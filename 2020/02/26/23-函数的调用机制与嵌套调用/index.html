<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;23&gt; 函数的调用机制与嵌套调用 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;23&gt; 函数的调用机制与嵌套调用</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;23&gt; 函数的调用机制与嵌套调用</h1><div class="post-meta"><a href="/2020/02/26/23-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8/#comments" class="comment-count"></a><p><span class="date">Feb 26, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-23-gt-函数的调用机制与嵌套调用"><a href="#Go语言从入门到放弃系列-lt-23-gt-函数的调用机制与嵌套调用" class="headerlink" title="Go语言从入门到放弃系列&lt;23&gt; 函数的调用机制与嵌套调用"></a>Go语言从入门到放弃系列&lt;23&gt; 函数的调用机制与嵌套调用</h2><p>&emsp;&emsp;在上一节中，我们讲解了函数的引入过程，并且也讲解了函数的最基础的定义方式与使用方法。同时也对模块化编程中的包的使用规则进行了阐述。在这一小节中，我们会简要地讲解Go语言中函数调用过程中的底层实现方式，进而通过对这个方式的讲解对函数的嵌套调用与递归调用进行解释说明。</p>
<h3 id="函数调用的底层实现"><a href="#函数调用的底层实现" class="headerlink" title="函数调用的底层实现"></a>函数调用的底层实现</h3><p>&emsp;&emsp;在讲解这个底层实现之前，我们先明确几个概念：大部分的数据存储等都发生在内存中，且计算都发生在运算器中。且在计算机在逻辑上将内存分为四个部分，分别是栈区，堆区，常量区，以及代码区。这一部分知识可以再计算机原理中得到深入的讲解，在这里我们只是简要地提一下其作用。 </p>
<p>&emsp;&emsp;栈的特点是先入后出，例如我们向一个杯子中倒入沙土，最先倒进去的沙土在最下面，因此当倒出的时候是最后才被倒出的（如果有机会我会在数据结构部分说起这个知识点）。当程序对基本数据进行创建时，即之前我们所提到的值类型进行创建时，创建的位置处在栈区。不仅是基本数据，函数类型的调用也会在栈区中发生。堆区一般存储的都是引用类型，例如我们后面会学到的切片等数据类型。代码区当然存储的就是可执行的机器码本身，常量区存储的是程序中定义的全局变量与静态变量等。但是这个分类并不是百分百准确的，在Go语言的底层中，存在着内存逃逸的现象，即基本数据类型的变量可能会逃逸到堆区，引用类型也可能会被创建在栈区等。 </p>
<p>&emsp;&emsp;当然上述的说法如果实在不懂也没有太大的问题，这个对于顶层程序的编写与理解代码的执行没有特别大的相关性，但是如果理解了可能会对日后程序的书写有所帮助。现在我们针对下述的代码进行内存上的分析（我们便只分析栈区，而不看代码区了）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMax</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="params">(max <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num1 &gt;= num2 &#123;</span><br><span class="line">        max = num1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max = num2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num1 <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> num2 <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">    fmt.Println(num1, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对于这一段程序相信不需要我过多的进行解释了，需要说明的是，我们定义了findMax函数，但是我们并没有调用这个函数。我们只是在主函数中定义了两个变量并将这个两个变量输出来。这时，栈区内存中与findMax函数是没有任何关系的，我们采用图解的方式来表示： </p>
<p><img src="/2020/02/26/23-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8/1.png" alt></p>
<p>&emsp;&emsp;从这个图解中我们可以发现，当程序开始执行的时候，计算机会在栈区内存中为main函数分配一段空间，在这段空间中又分配有两个变量，分别是num1和num2。接下来对这两个整数的输出也发生在main函数中，因此也相当于是在main栈区中提取数据。 </p>
<p>&emsp;&emsp;接下来我们上述的代码进行修改，在函数中我们将max输出，在main函数中调用findMax函数，修改后的代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMax</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="params">(max <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num1 &gt;= num2 &#123;</span><br><span class="line">        max = num1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max = num2</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"在函数中"</span>, max)</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num1 <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> num2 <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">    fmt.Println(<span class="string">"调用函数前"</span>)</span><br><span class="line">    findMax(num1, num2)</span><br><span class="line">    fmt.Println(<span class="string">"调用函数后"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这段代码中，我们可以发现，此时main函数调用到了findMax函数，那么程序在调用函数的时候内存就会与findMax函数相关了。当程序运行到fmt.Println(“调用函数前”)的时候，内存图依旧与上述的图是一致的，因为还没有调用到findMax函数。 </p>
<p>&emsp;&emsp;当程序运行到findMax函数的时候，内存中就需要关联这个函数了，在这个函数中存在三个变量，分别是num1、num2、以及max，当程序刚进入到函数的定义部分时，此时的栈区内存图如下所示： </p>
<p><img src="/2020/02/26/23-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8/2.png" alt></p>
<p>&emsp;&emsp;我们可以发现当调用到其他函数的时候，编译器会为这个函数分配一块独立的内存，且这段内存中存在着自己三个变量。从这个图中我们也可以发现，findMax栈区所定义的三个变量与main栈区定义的两个变量是没有任何关系的，只是说我们将main栈区的两个变量的值拷贝给了findMax栈区的两个变量。这两个栈区的变量在内存中的地址是不同的，读者可以通过分别输出&amp;num1的方式进行验证。 </p>
<p>&emsp;&emsp;程序继续向下执行，当执行到函数中的return的时候，此时findMax栈区中的max值已然被得到，且在控制台中也输出了相应的”在函数中 20”。此时程序将会从findMax函数中跳转回main函数，当跳转的时候，在栈区内存中又会发生一件事情：</p>
<p><img src="/2020/02/26/23-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8/3.png" alt></p>
<p>&emsp;&emsp;通过这个图我们可以得到一个结论，当一个函数被执行完的时候，分配给这个函数的栈区内存会被回收释放，被释放后的这段内存可以再被分配给其他的函数等。那么可以想到的是，当主函数执行结束后，main函数的栈区内存也会被释放掉。 </p>
<p>&emsp;&emsp;从这段过程中，我们也可以侧面理解栈的含义：在内存分配的过程中，先分配了main函数的栈区，然后再分配的findMax函数栈区；当函数执行结束进行内存释放的过程中，先是findMax函数内存被释放，然后才是main函数栈区内存被释放。这也体现了先入后出的栈的含义。</p>
<h3 id="函数的嵌套调用"><a href="#函数的嵌套调用" class="headerlink" title="函数的嵌套调用"></a>函数的嵌套调用</h3><p>&emsp;&emsp;明白了函数的调用的底层含义之后，我们可以对函数的嵌套调用进行讲解。我们依旧类比于分支结构和循环结构的嵌套使用，我们可以得出一个结论：函数的嵌套调用就是在一个函数的函数体中调用了另一个函数。其实话说回来，我们在main函数中调用了findMax函数其实就是一种嵌套调用。 </p>
<p>&emsp;&emsp;在嵌套调用的过程中（我们依旧以main函数调用findMax函数为例），当main函数执行到调用findMax函数的那条语句时，main函数的执行流程会被阻塞在那条语句上，程序指针跳转到findMax函数中进行顺序执行。当findMax函数的函数体被执行完之后，程序指针又跳回了刚才被阻塞的地方进行继续执行。我们通过上述程序的输出结果可知：</p>
<pre><code>输出：
    调用函数前
    在函数中 20
    调用函数后</code></pre><p>&emsp;&emsp;通过这个输出结果的顺序，我们可以发现：是先执行了”调用函数前”的那个部分， 然后main函数被阻塞，进入了findMax函数输出了”在函数中”，然后回到了阻塞地方输出了”调用函数后”，通过下述的一个图例可以更为直观地理解：</p>
<p><img src="/2020/02/26/23-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8/4.png" alt></p>
<p>&emsp;&emsp;根据对这个图的理解，我们继续向下联想：假如函数的嵌套并不只是这一层，而是呈现了多层，例如在findMax函数中我们又调用了另一个函数，这个图就会像在main函数中阻塞一样，在findMax函数中阻塞，进入另一个函数，当那个函数执行完后回到findMax函数继续执行，当findMax函数执行结束后回到main函数直到结束。 </p>
<p>&emsp;&emsp;接下来我们对这个概念进行延伸：假如我们在一个函数中调用的不是其他的函数，而是这个函数本身，例如findMax函数中调用findMax函数，这种调用方式就是递归调用。我们首先举一个例子说明：我们希望通过递归调用的方式求出1+2+3+…100的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getSum(index<span class="number">-1</span>) + index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(getSum(<span class="number">100</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上述的这段程序就是一个典型的递归调用，主函数中只是调用了getSum函数，并且将100这个整数传进去，此时程序指针进入了getSum函数中，进入getSum函数中首先判断index值是否为0，由于我们传入的是100，所以不为0。因此程序进入了getSum(99)，并且程序在这个地方阻塞，一旦getSum(99)执行完了，我们就将这个结果与index（此时为100）相加得到结果。 </p>
<p>&emsp;&emsp;我们继续向里面分析，当程序进入了getSum(99)的时候，首先判断index是否为0，由于输入的是99，因此不为0，所以进入了getSum(98)，且当getSum(98)执行结束后，将结果与index（此时为99）相加……上述过程往复循环直到出现了getSum(0)这个函数，当进入getSum函数且将0传入的时候，判断index是否为0，此时index刚好就是0，所以程序不会再进入到下一层的getSum函数了。 </p>
<p>&emsp;&emsp;这个getSum(0)函数结束，返回到getSum(1)函数的阻塞点继续执行，执行结束后返回到getSum(2)的阻塞点……重复上述循环直到返回getSum(100)这个函数的阻塞点。由于是main函数调用了getSum(100)，因此getSum(100)执行结束后就回到了main函数中进行输出，也就完成了整个的程序过程。整个程序的运行过程只是满足于一个公式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getSum(index) = getSum(index<span class="number">-1</span>)+index</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个公式完整地变现了整个递归的关系。我们再举一个例子，我们在三大流程总结的代码篇中实现了斐波那契数列的程序编写，其实这个数列也可以通过递归的方式进行。我们在那一小节中说明了斐波那契数列的数学表达式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fib(n)=Fib(n<span class="number">-1</span>)+Fib(n<span class="number">-2</span>)    (n&gt;=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们发现这个公式与求1到100求和的公式有异曲同工之妙，即想要求当前的值，必须要求前一个乃至于前两个值。那么对于这个数列我们进行程序的书写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fib</span><span class="params">(month <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> month == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> month == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Fib(month<span class="number">-1</span>) + Fib(month<span class="number">-2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(Fib(<span class="number">12</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这段程序似乎不难理解，当第一个月的时候只有1对兔子，当第二个月的时候有2对兔子，在这之后的月数中，当月的兔子对数等于前两个月的兔子对数之和。 </p>
<p>&emsp;&emsp;对于初学者来说，函数的递归调用是一个非常难以理解的知识点，有时候即便是懂了函数自己调用自己的模式，但是一旦跟踪代码执行情况就又会把自己绕进去，因此当初学者读到这个小节时候，一定要将上述的两个例子琢磨明白。不仅要明白其中的数学表达式，也要清楚在实现递归调用的时候栈区内存中到底发生了什么，这个结果是怎样出来的。 </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节的最后，我们将会留下一个经典的面试题作为本小节的一个练习，面试官是这样问的：在Go语言中，在不使用for关键字的前提下，让程序输出100句”Hello World”。当然如果回答了用goto关键字，这场面试可能就立刻有结果了，面试官可能更希望你回答的是利用递归来完成，那么这个需求的代码请自行练习写一下。如若这段程序能够独立地写出来，那么函数递归这个知识点就可以说初成了。    </p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/02/27/24-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%B8%80/" class="pre">Go语言从入门到放弃系列&lt;24&gt; 函数使用细节&lt;一&gt;</a><a href="/2020/02/25/22-%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E4%B8%8E%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/" class="next">Go语言从入门到放弃系列&lt;22&gt; 函数入门与包的使用</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-23-gt-函数的调用机制与嵌套调用"><span class="toc-text">Go语言从入门到放弃系列&lt;23&gt; 函数的调用机制与嵌套调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用的底层实现"><span class="toc-text">函数调用的底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数的嵌套调用"><span class="toc-text">函数的嵌套调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/26-init%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/">Go语言从入门到放弃系列<26> init函数与匿名函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/28/25-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%BA%8C/">Go语言从入门到放弃系列<25> 函数使用细节<二></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/27/24-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%B8%80/">Go语言从入门到放弃系列<24> 函数使用细节<一></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/26/23-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8/">Go语言从入门到放弃系列<23> 函数的调用机制与嵌套调用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/25/22-%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E4%B8%8E%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/">Go语言从入门到放弃系列<22> 函数入门与包的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/24/21-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B/">Go语言从入门到放弃系列<21> 流程控制代码举例</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/23/20-%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84break%E5%92%8Ccontinue/">Go语言从入门到放弃系列<20> 嵌套循环结构break和continue</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/22/19-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84goto%E3%80%81for%E7%9A%84%E4%BD%BF%E7%94%A8/">Go语言从入门到放弃系列<19> 循环结构goto、for的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/21/18-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-switch-case%E7%BB%93%E6%9E%84/">Go语言从入门到放弃系列<18> 分支结构-switch case结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/20/17-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-if%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/">Go语言从入门到放弃系列<17> 分支结构-if条件语句</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">26</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>