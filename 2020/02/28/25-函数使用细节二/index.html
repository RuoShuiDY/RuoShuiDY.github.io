<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;25&gt; 函数使用细节&lt;二&gt; | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;25&gt; 函数使用细节&lt;二&gt;</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;25&gt; 函数使用细节&lt;二&gt;</h1><div class="post-meta"><a href="/2020/02/28/25-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%BA%8C/#comments" class="comment-count"></a><p><span class="date">Feb 28, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-25-gt-函数使用细节-lt-二-gt"><a href="#Go语言从入门到放弃系列-lt-25-gt-函数使用细节-lt-二-gt" class="headerlink" title="Go语言从入门到放弃系列&lt;25&gt; 函数使用细节&lt;二&gt;"></a>Go语言从入门到放弃系列&lt;25&gt; 函数使用细节&lt;二&gt;</h2><p>&emsp;&emsp;在上一小节中，我们讲解了函数的底层调用机制以及函数的嵌套调用、递归调用等知识点，同时也对Go语言中函数的使用细节做了初步的介绍。在这一小节中，我们将承接上一小节未能完全讲解完的使用细节进行相对深入的讲解。在本小节中讲解到的各个知识点在日常开发中也会经常使用到。</p>
<h5 id="1-基本数据类型和数组在函数参数传递中是以值形式传递，因此普通传递方式不能改变调用者栈区内的值。"><a href="#1-基本数据类型和数组在函数参数传递中是以值形式传递，因此普通传递方式不能改变调用者栈区内的值。" class="headerlink" title="1. 基本数据类型和数组在函数参数传递中是以值形式传递，因此普通传递方式不能改变调用者栈区内的值。"></a>1. 基本数据类型和数组在函数参数传递中是以值形式传递，因此普通传递方式不能改变调用者栈区内的值。</h5><p>&emsp;&emsp;根据底层调用的图解，我们可以得知在函数调用的过程中，栈区会开辟一段新的内存用来处理函数的各个操作。同时调用者传入的参数也是通过数值的拷贝进入到被调用者的，因此调用者内部的变量与函数中的变量是相互独立且不相互影响的。我们通过程序举一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temp <span class="keyword">int</span> = num1</span><br><span class="line">    num1 = num2</span><br><span class="line">    num2 = temp</span><br><span class="line">    fmt.Println(<span class="string">"In the swap function, num1 is"</span>, num1, <span class="string">"num2 is"</span>, num2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">20</span></span><br><span class="line">    swap(num1, num2)</span><br><span class="line">    fmt.Println(<span class="string">"In the main function, num1 is"</span>, num1, <span class="string">"num2 is"</span>, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述的这段程序中，我们在主函数中定义了两个整数变量并传入到swap函数中，swap函数的函数体将传入的两个参数值相互交换，并且将交换后的值输出。在swap函数执行过后返回主函数，我们再次输出主函数中的两个变量，我们的到的执行结果为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In the swap function, num1 is <span class="number">20</span> num2 is <span class="number">10</span></span><br><span class="line">In the main function, num1 is <span class="number">10</span> num2 is <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过上述结果可以发现主函数中定义的变量并没有因为函数中的交换操作而受到任何的影响，因此值类型通过参数直接进行传递时，调用者是不会受到任何影响的。</p>
<h5 id="2-如果希望在函数中改变值类型，可以通过指针形式进行传递。（类似于引用）"><a href="#2-如果希望在函数中改变值类型，可以通过指针形式进行传递。（类似于引用）" class="headerlink" title="2. 如果希望在函数中改变值类型，可以通过指针形式进行传递。（类似于引用）"></a>2. 如果希望在函数中改变值类型，可以通过指针形式进行传递。（类似于引用）</h5><p>&emsp;&emsp;在这里，我们首先简要回顾一下指针的几个相关知识点：首先，指针本质就是内存地址，可以指代的是变量在内存中的物理地址，第二，*在变量定义的过程中代表该变量为指针变量，在变量的使用过程中代表取出该地址中的值，第三，&amp;符号在使用过程中代表取出该变量的物理地址。如果这三个概念没有完全想起来，可以返回到对应小节进行一些了解。 </p>
<p>&emsp;&emsp;现在我们可以通过这几个运算符进行指针传递了，我们依旧采用上述的代码段进行演示，同时需要注意一下下面的这段程序与值传递时所用到的程序的几个细微的差别：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(num1, num2 *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temp <span class="keyword">int</span> = *num1</span><br><span class="line">    *num1 = *num2</span><br><span class="line">    *num2 = temp</span><br><span class="line">    fmt.Println(<span class="string">"In the swap function, num1 is"</span>, *num1, <span class="string">"num2 is"</span>, *num2)</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">20</span></span><br><span class="line">    swap(&amp;num1, &amp;num2)</span><br><span class="line">    fmt.Println(<span class="string">"In the main function, num1 is"</span>, num1, <span class="string">"num2 is"</span>, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们集中说明一下差别：首先在swap函数定义中，我们定义的两个形式参数为整数类型的<strong>指针</strong>，在函数体中对num1和num2的使用是通过获取指针所指向的值的方式进行的。在主函数中，调用swap函数的时候传入的实际参数是主函数中定义的num1和num2的物理地址。这段程序的运行结果为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In the swap function, num1 is <span class="number">20</span> num2 is <span class="number">10</span></span><br><span class="line">In the main function, num1 is <span class="number">20</span> num2 is <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这里我们可以发现，函数中的交换数据的行为直接影响到了主函数中变量的值，这是因为参数传递的是地址而不是值。我们举一个易于理解的例子，我们将参数看作为一台电视机，值传递的意思就是我们保持这台电视机不动，买了另外一台同样型号电视机送给其他人，遥控器不同，两台电视机互相不影响。传递指针的时候，相当于电视机不同，我们又额外配了一个遥控器，并把这个新配的遥控器送给了其他人。当其他人通过遥控器变换频道的时候，唯一的电视机会进行响应。我们通过一个图解进行解释：<br> <img src="/2020/02/28/25-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%BA%8C/1.png" alt></p>
<h5 id="3-函数可以作为一种数据类型，也可以作为参数进行传递"><a href="#3-函数可以作为一种数据类型，也可以作为参数进行传递" class="headerlink" title="3. 函数可以作为一种数据类型，也可以作为参数进行传递"></a>3. 函数可以作为一种数据类型，也可以作为参数进行传递</h5><p>&emsp;&emsp;这个特性看起来似乎比较难以理解，因为这个点不论是在Go语言中还是在其他语言中都不是十分常用。我在这里也就是介绍一下函数作为一种数据类型的使用方式，当然这个知识点在后面讲解闭包的概念的时候还会被提及，因此在这个小节中需要对这个特性有所了解。我们首先看一段程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">20</span></span><br><span class="line">    funcVar := getSum</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, funcVar)</span><br><span class="line">    fmt.Println(funcVar(num1, num2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述的程序中，getSum函数与之前的代码是相同的，不同点在于主函数中funcVar := getSum这里，这条语句的意思便是将getSum函数交个了一个名为funcVar的函数型变量。并且在后面的函数调用时就直接使用funcVar变量即可。我们可以简单地将其认为把一个函数的调用过程拆分成了两个：为函数变量赋值、通过该变量调用。程序的结果如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;讲解完了函数作为数据类型后，我们接下来讲解函数作为参数进行传递的过程。正如我们所知，在函数定义过程中，我们需要提供输入参数数数量和数据类型，因此当函数作为参数的时候也是需要指明参数类型的。对于一类函数而言，函数的签名（参数列表和返回值列表）可以唯一确定这一类的函数，因此当函数作为参数时，所需要提供的类型就是这样。我们看一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testGetSum</span><span class="params">(testVar <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">num1</span> <span class="title">int</span>, <span class="title">num2</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> testVar(num1, num2)</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">20</span></span><br><span class="line">    fmt.Println(testGetSum(getSum, num1, num2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上面的这段程序中，我们在主函数中调用了testGetSum函数，同时testGetSum函数的形式参数中就存在着一个func类型的参数。当调用的时候，我们传入的实际参数就是getSum函数的函数名，这也验证了函数是可以作为参数的。同时我们也可以向下联想到：但凡满足于两个整数参数且返回值为整数的所有函数均可以传入到testGetSum函数中，因为形式参数并没有指定调用哪个函数，而是根据输入的函数名而定的。</p>
<h5 id="4-Go语言中函数支持可变参数列表"><a href="#4-Go语言中函数支持可变参数列表" class="headerlink" title="4. Go语言中函数支持可变参数列表"></a>4. Go语言中函数支持可变参数列表</h5><p>&emsp;&emsp;由于Go语言中不支持函数的重载，因此当出现希望用同一个函数名来但具备不同参数列表的需求时候，就会比较困难。因此我们在这里引出对可变参数的讲解。首先我们看一个需求：写出一个名为getSum的函数，要求传入几个值就计算几个值的和。如果采用原来的方式，我们可能需要写多个函数，且函数名还不可以一致。当然这个需求可以通过传入切片来完成，但是目前我们还没有介绍到切片，就先介绍可变参数了。我们先看如下的一段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(nums ...<span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        result += nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(getSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们从上述程序中可以发现，在getSum函数的参数列表中，我们使用了”…”的方式来定义可变参数。其使用规则为：变量名会被视为一个切片（这个我们会和数组一起讲解），且被”…”所修饰的类型为该切片中所具有数据的类型，在使用的时候可以通过nums[i]来表示传入的参数中的第i个值。通过解释后这个函数的意思就显而易见了：即遍历每一个传入的参数，将该参数累加到result中，最后返回。在主函数调用的过程中，我们传入了5个参数作为测试，当然也可以传入任意个数的参数。 </p>
<p>&emsp;&emsp;在使用可变参数的时候，我们需要注意以下几个问题： </p>
<ol>
<li>一个函数中只能出现一个可变参数，不可以出现多个，例如：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(nums ...<span class="keyword">int</span>, strs ...<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        fmt.Println(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(strs); j++ &#123;</span><br><span class="line">        fmt.Println(strs[j])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们定义getSum函数的参数列表时定义了两个可变参数，分别遍历输出，但是这段程序在编译时会发生错误，其错误类型为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">can only use ... with final parameter in list</span><br><span class="line">cannot use <span class="string">"Hello"</span> (<span class="keyword">type</span> <span class="keyword">string</span>) as <span class="keyword">type</span> <span class="keyword">int</span> in argument to getSum</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>参数列表中可以出现正常参数与可变参数混用的情况，但是可变参数必须要放在参数列表的最后面。 </p>
<p>&emsp;&emsp;编译器当看到可变参数后，会将在这之后的所有的参数均看做为可变参数的一部分，所以可变参数必须在最后，其前面有任何的普通参数均没有任何问题，我们举几个例子：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(nums ...<span class="keyword">int</span>, extra <span class="keyword">int</span>)</span>    //错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(extra <span class="keyword">int</span>, nums ...<span class="keyword">int</span>)</span>    //正确</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(extra <span class="keyword">int</span>, str <span class="keyword">string</span>, nums ...<span class="keyword">int</span>)</span>    //正确</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(extra <span class="keyword">int</span>, nums ...<span class="keyword">int</span>, str <span class="keyword">string</span>)</span>    //错误</span></span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们继续讲解了Go语言中函数的四个使用细节，分别为函数的两种参数传递方式，可变参数列表，和函数作为变量与参数。在下一小节中，我们将会针对init函数、匿名函数、闭包特点以及defer的使用进行详细的讲解，也会部分运用到这个小节的知识点。</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/02/29/26-init%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/" class="pre">Go语言从入门到放弃系列&lt;26&gt; init函数与匿名函数</a><a href="/2020/02/27/24-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%B8%80/" class="next">Go语言从入门到放弃系列&lt;24&gt; 函数使用细节&lt;一&gt;</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-25-gt-函数使用细节-lt-二-gt"><span class="toc-text">Go语言从入门到放弃系列&lt;25&gt; 函数使用细节&lt;二&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-基本数据类型和数组在函数参数传递中是以值形式传递，因此普通传递方式不能改变调用者栈区内的值。"><span class="toc-text">1. 基本数据类型和数组在函数参数传递中是以值形式传递，因此普通传递方式不能改变调用者栈区内的值。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-如果希望在函数中改变值类型，可以通过指针形式进行传递。（类似于引用）"><span class="toc-text">2. 如果希望在函数中改变值类型，可以通过指针形式进行传递。（类似于引用）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-函数可以作为一种数据类型，也可以作为参数进行传递"><span class="toc-text">3. 函数可以作为一种数据类型，也可以作为参数进行传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Go语言中函数支持可变参数列表"><span class="toc-text">4. Go语言中函数支持可变参数列表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/26-init%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/">Go语言从入门到放弃系列<26> init函数与匿名函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/28/25-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%BA%8C/">Go语言从入门到放弃系列<25> 函数使用细节<二></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/27/24-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%B8%80/">Go语言从入门到放弃系列<24> 函数使用细节<一></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/26/23-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8/">Go语言从入门到放弃系列<23> 函数的调用机制与嵌套调用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/25/22-%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E4%B8%8E%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/">Go语言从入门到放弃系列<22> 函数入门与包的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/24/21-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B/">Go语言从入门到放弃系列<21> 流程控制代码举例</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/23/20-%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84break%E5%92%8Ccontinue/">Go语言从入门到放弃系列<20> 嵌套循环结构break和continue</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/22/19-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84goto%E3%80%81for%E7%9A%84%E4%BD%BF%E7%94%A8/">Go语言从入门到放弃系列<19> 循环结构goto、for的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/21/18-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-switch-case%E7%BB%93%E6%9E%84/">Go语言从入门到放弃系列<18> 分支结构-switch case结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/20/17-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-if%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/">Go语言从入门到放弃系列<17> 分支结构-if条件语句</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">26</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>