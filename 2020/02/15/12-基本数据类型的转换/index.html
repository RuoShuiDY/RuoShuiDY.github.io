<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;12&gt; 基本数据类型的转换 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;12&gt; 基本数据类型的转换</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;12&gt; 基本数据类型的转换</h1><div class="post-meta"><a href="/2020/02/15/12-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/#comments" class="comment-count"></a><p><span class="date">Feb 15, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-12-gt-基本数据类型的转换"><a href="#Go语言从入门到放弃系列-lt-12-gt-基本数据类型的转换" class="headerlink" title="Go语言从入门到放弃系列&lt;12&gt; 基本数据类型的转换"></a>Go语言从入门到放弃系列&lt;12&gt; 基本数据类型的转换</h2><p>&emsp;&emsp;在上几个小节中，我们针对Go语言中的基本数据类型进行简要的描述，以及对各个基本数据类型在使用过程中可能出现的问题以及需要注意的点进行了详细的说明。在这一节中，我们将继续集中讲解Go语言中基本数据类型的互相转换方式，以及所用到的相关的函数等。</p>
<h3 id="不同数据类型的转换"><a href="#不同数据类型的转换" class="headerlink" title="不同数据类型的转换"></a>不同数据类型的转换</h3><p>&emsp;&emsp;我们首先介绍同类型的相互转换方式，例如int8转换为int32、float64转换为float32等。Go语言在这点上与C语言、Java语言等不同，Go语言在不同类型的变量之间赋值时需要进行显式转换，而不能自动转换。例如在Java语言中，我们完全可以将byte类型的数据直接赋值给int类型的数据完成自动转换，因为变量可容纳的空间是由小到大，因此不会出现数据溢出的问题，但是在Go语言中，我们需要明确地显式转换。 </p>
<p>&emsp;&emsp;大致上来说，Go语言中的类型转换都可以遵循一个语法：T(V)，其含义为将V的数据类型转换成T的数据类型。T是转换后的类型，如int32、float32等等，V是需要转换的变量，我们先写一段程序举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float32</span> = <span class="keyword">float32</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="keyword">uint8</span> = <span class="keyword">uint</span>(i)</span><br><span class="line">fmt.Println(i,f,u)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;从以上程序中我们可以看出，我们首先定义了一个int类型的变量，并初始化为10，接着我们希望将这个int变量中的值赋给一个float32和uint8类型的变量，然后再输出，其输出结果为三个10，也就是说在这个类型转换过程中是成功的。接下来我们验证一下Go语言中数据类型不可以自动转换的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int8</span> = <span class="number">127</span></span><br><span class="line"><span class="keyword">var</span> bi <span class="keyword">int64</span> = i</span><br><span class="line">fmt.Println(bi)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在编译这段代码的时候，系统就会报出错误，其错误类型是：cannot use i (type int8) as type int64 in assignment。也就是int8类型的数据不能直接赋值给int64类型的数据，尽管理论上不会出现数据溢出的现象，也不会有任何的数据方面的问题。所以说Go语言对于数据类型的定义以及赋值限制是十分严格的。</p>
<h3 id="类型转换过程中的数据精度问题"><a href="#类型转换过程中的数据精度问题" class="headerlink" title="类型转换过程中的数据精度问题"></a>类型转换过程中的数据精度问题</h3><p>&emsp;&emsp;既然数据类型可以相互转换，则势必会出现数据精度丢失的问题，以及数据溢出的问题，例如我们将多字节的整数的值赋给一个少字节的整数，则可能会出现数据溢出，将浮点型数据向整数转换时小数的值会丢失。接下来我们写程序验证一下这两种事情发生时的情况。</p>
<h4 id="整数数据溢出"><a href="#整数数据溢出" class="headerlink" title="整数数据溢出"></a>整数数据溢出</h4><p>&emsp;&emsp;这个问题我们其实在整数精讲的部分时候已经提及过数据溢出的现象以及成因了，在这里我们只是通过程序验证一下这个现象并且通过例子更为深入地了解一下这个问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i32 <span class="keyword">int32</span> = <span class="number">456</span></span><br><span class="line"><span class="keyword">var</span> i8 <span class="keyword">int8</span> = <span class="keyword">int8</span>(i32)</span><br><span class="line">fmt.Println(i8)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;输出结果为-56，从程序中，我们可以明显地看出来456这个数值已经超出了int8所能表示的数据范围，如果强行将其赋给int8，我们会发现编译过程中是不报错的，同时也是可以正确输出结果的。下面我们就解释一下-56这个数字的由来，也顺便复习一下二进制与码制的知识点。</p>
<p>&emsp;&emsp;首先我们看到456是一个正数，因此其补码与原码相同，我们将其转换为二进制后可以得到如下的结果（除模取余，倒序输出）:0111001000，然后由于int8数据类型只分配到了8个二进制位的空间，因此超出8个二进制位的部分被全部舍弃，其结果变为11001000（第一个1溢出舍弃）。现在我们观察一下当前的结果，我们发现符号位为1，因此得到的这个数字是个负数，我们再根据补码规则，将其还原为原码：10111000（符号位不变，从右向左从第一个1以后所有位取反），根据二进制向十进制的转换关系为-56。</p>
<h4 id="浮点型向整数转换"><a href="#浮点型向整数转换" class="headerlink" title="浮点型向整数转换"></a>浮点型向整数转换</h4><p>&emsp;&emsp;由于整数是无法显示小数的，且整数与浮点型的表示方式也不甚一致，因此我们通过下面的一段程序来探究浮点型向整数转换时的小数问题，以及依旧可能出现的精度丢失问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">float32</span> = <span class="number">456.5</span></span><br><span class="line"><span class="keyword">var</span> i8 <span class="keyword">int8</span> = <span class="keyword">int8</span>(f)</span><br><span class="line">fmt.Println(i8)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;根据输出结果，我们会发现输出结果依旧是-56，也就是说，在浮点型数据向整型数据转换的时候，其小数位全部丢失，整数位根据整数之间的转换的原则进行数据溢出判断。所以相当于依旧是456向int8进行转换，根据上述的分析过程，我们依旧可以得到结果为-56。</p>
<h4 id="其他转换细节"><a href="#其他转换细节" class="headerlink" title="其他转换细节"></a>其他转换细节</h4><p>&emsp;&emsp;在大型的程序开发，或者说在多人的合作开发中，每个人完成特定的函数编写，因此可能存在数据类型不一致的情况，因此在计算过程中也可能会出现数据类型的转换，接下来我们举两个例子来完成类型转换的细节讲解。</p>
<p>&emsp;&emsp;首先我们看如下的一段程序，判断这段程序能否通过编译：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1 <span class="keyword">int32</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> n3 <span class="keyword">int8</span></span><br><span class="line">n2 = n1 + <span class="number">20</span></span><br><span class="line">n3 = n1 + <span class="number">20</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;答案是不能通过编译，因为数据类型不匹配，第一个错误类型依旧为：cannot use n1+20 (type int32) as type int64 in assignment。因此一个数据类型加一个常数，所得到的数据类型依旧是当前的数据类型。所以int32加20之后依旧是int32。接下来我们下面的一段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1 <span class="keyword">int32</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="keyword">int64</span> = <span class="number">20</span></span><br><span class="line">n3 := n1 + n2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这段程序中我们分别定义了int32和int64的值，并将两个值相加赋值给n3，我们利用类型推导来完成赋值，现在我们猜n3是什么数据类型。接触过C或者Java的人可能会回答n3的类型为int64，实则不然，因为这段程序根本无法编译，错误类型为：invalid operation: n1 + n2 (mismatched types int32 and int64)。因此不仅仅是赋值过程中不能隐式转换，就是运算过程中也不可以。如果我们将n2显式转换为int32后，编译通过，n3当然也就是int32类型。</p>
<p>&emsp;&emsp;第二个细节，是程序运算过程中的数据溢出判定，我们先看下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1 <span class="keyword">int32</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="keyword">int8</span></span><br><span class="line"><span class="keyword">var</span> n3 <span class="keyword">int8</span></span><br><span class="line">n2 = <span class="keyword">int8</span>(n1) + <span class="number">127</span></span><br><span class="line">n3 = <span class="keyword">int8</span>(n1) + <span class="number">128</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在上述程序中，是否能通过编译呢，答案依旧是不能，其错误的语句在于n3 = int8(n1) + 128，报出的错误为128溢出了int8数据类型，因此我们说，即便是’+’号两边的数据类型一致了，编译器也会检查两边的数据是否出现溢出的现象。对于加127那行语句，我们逻辑上可以看出数据溢出了，但是不会报错，程序运行也不受影响，但是128那一行会报错，因此在实际开发中需要注意。</p>
<h3 id="其他类型与string相互转化"><a href="#其他类型与string相互转化" class="headerlink" title="其他类型与string相互转化"></a>其他类型与string相互转化</h3><p>&emsp;&emsp;在实际开发中，我们常常会将其他基本数据类型与string类型相互转换，例如在网络传输过程中，我们会将实体类的各个属性转换成为一个字符串进行传输，在另一端收到字符串后会将其反序列化为实体类，其中的过程就是类型之间的互相转换。</p>
<h4 id="其他类型转string"><a href="#其他类型转string" class="headerlink" title="其他类型转string"></a>其他类型转string</h4><p>&emsp;&emsp;总体来说，其他数据类型向string类型转换时有两个常用的方法，分别是fmt包中的Sprintf函数以及strconv包中的几个函数，我们分别举例讲解：</p>
<ol>
<li>Sprintf函数，这个函数的签名为：fmt.Sprintf(“%参数”,表达式)，这个类型与fmt包中Printf输出函数十分的类似，如果我们使用Printf函数十分熟练的话，这种方式就非常简单了。无非就是将数据转成字符换和将数据转换成字符串后打印到屏幕上的区别，我们举一个例子：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"Devin"</span></span><br><span class="line"><span class="keyword">var</span> isAdult <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> info <span class="keyword">string</span></span><br><span class="line">info = fmt.Sprintf(<span class="string">"Name is %s age is %d isAdult is %t"</span>, name, age, isAdult)</span><br><span class="line">fmt.Println(info)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上述的程序的含义为：定义了几种数据类型的变量，并通过Sprintf方式将其格式化形成一个字符串，最后将这个字符串打印到屏幕上。经过运行后，我们会发现屏幕上输出了：Name is Devin age is 25 isAdult is true。也就是说，我们成功地将属性转换成了字符串，格式中的%d之类的表示方法与输出函数相同，可以参考前几节中我们讲到的知识点。</p>
<ol start="2">
<li>strconv包中函数，这个包中的函数在转换过程中主要会用到以下4个函数，分别为：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatBool</span><span class="params">(b <span class="keyword">bool</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="keyword">float64</span>, fmt <span class="keyword">byte</span>, prec,bitSize <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="keyword">int64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatUint</span><span class="params">(i <span class="keyword">uint64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这些函数我们直接就在代码实践中以注释形式解释参数的含义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num1 <span class="keyword">int32</span> = <span class="number">100</span></span><br><span class="line">	<span class="keyword">var</span> num2 <span class="keyword">float64</span> = <span class="number">12.345</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">bool</span> = <span class="literal">true</span>		</span><br><span class="line">	str1 := strconv.FormatInt(<span class="keyword">int64</span>(num1), <span class="number">8</span>)</span><br><span class="line">	<span class="comment">//注意输入参数的数据类型，参数是int64，因此要强转，8为基数，即以8进制形式转换，可选为2,8,10,16</span></span><br><span class="line">	str2 := strconv.FormatFloat(num2, <span class="string">'f'</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">	<span class="comment">//参数为float64，fmt表示格式: 'f':ddd.dd ,'b':dddp(+-)ddd(二进制科学计数法),'e':ddde(+-)ddd(十进制科学计数法)...</span></span><br><span class="line">	<span class="comment">//10为保留10位小数，64指代传入的是float64，可选值为64和32</span></span><br><span class="line">	str3 := strconv.FormatBool(b)</span><br><span class="line">	<span class="comment">//传入布尔值，将其转换成字符串</span></span><br><span class="line">	fmt.Println(str1)</span><br><span class="line">	fmt.Println(str2)</span><br><span class="line">	fmt.Println(str3)		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其输出结果如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">144</span></span><br><span class="line"><span class="number">12.3450000000</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其中FormatInt函数和FormatUint函数参数相同，也不做过多介绍了。</p>
<h4 id="string转其他基本类型"><a href="#string转其他基本类型" class="headerlink" title="string转其他基本类型"></a>string转其他基本类型</h4><p>&emsp;&emsp;string转向其他基本数据类型依旧使用的是strconv包中的函数，我们将其列出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="keyword">string</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(f <span class="keyword">float64</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(i <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseUint</span><span class="params">()</span><span class="title">s</span> <span class="title">string</span>, <span class="title">base</span> <span class="title">int</span>, <span class="title">bitSize</span> <span class="title">int</span>) <span class="params">(n <span class="keyword">uint64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;从上述的函数描述中，我们首次看到了两个返回值的函数，即bool值和error值，因此我们在调用的时候需要两个变量进行承接。我们依旧采用程序例子的方式进行说明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str1 := <span class="string">"true"</span></span><br><span class="line">	str2 := <span class="string">"100"</span></span><br><span class="line">	str3 := <span class="string">"12.345"</span></span><br><span class="line">	v1, _ := strconv.ParseBool(str1)</span><br><span class="line">	<span class="comment">//暂时不关心error，所以采用_标识符进行接收</span></span><br><span class="line">	v2, _ := strconv.ParseInt(str2, <span class="number">10</span>, <span class="number">32</span>)</span><br><span class="line">	<span class="comment">//10表示以10进制形式转换，如果该值为0则根据字符串判断，出现0x为16进制，以0开头为8进制，否则10进制</span></span><br><span class="line">	<span class="comment">//32表示结果可以赋值给int32，该值可选为0,8,16，32,64，分别对应int，int8，int16，int32，int64</span></span><br><span class="line">	<span class="comment">//要求该数值指定结果必须能够无溢出地赋值</span></span><br><span class="line">	v3, _ := strconv.ParseFloat(str3, <span class="number">32</span>)</span><br><span class="line">	<span class="comment">//32表示：结果可以不改变精确值地赋给float32，可选值为32和64</span></span><br><span class="line">	fmt.Printf(<span class="string">"v1的类型为%T,v1的值为%t\n"</span>, v1, v1)</span><br><span class="line">	fmt.Printf(<span class="string">"v2的类型为%T,v2的值为%d\n"</span>, v2, v2)</span><br><span class="line">	fmt.Printf(<span class="string">"v3的类型为%T,v3的值为%f\n"</span>, v3, v3)		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其输出结果为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v1的类型为<span class="keyword">bool</span>,v1的值为<span class="literal">true</span></span><br><span class="line">v2的类型为<span class="keyword">int64</span>,v2的值为<span class="number">100</span></span><br><span class="line">v3的类型为<span class="keyword">float64</span>,v3的值为<span class="number">12.345000</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;根据输出结果，我们可以看出其转换过程是成功的，且返回值分别是bool，int64，以及float64，当我们得到结果并且向转换成其他数据类型如int32时，可以再行显式转换。</p>
<p>&emsp;&emsp;值得注意的问题是，假如类型转换失败会发生什么现象，例如我们将”true”转换为整数，这时就需要用到error的值了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"true"</span></span><br><span class="line">v1, err := strconv.ParseInt(str, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">fmt.Println(v1)</span><br><span class="line">fmt.Println(err)</span><br><span class="line">v2, err := strconv.ParseBool(str)</span><br><span class="line">fmt.Println(v2)</span><br><span class="line">fmt.Println(err)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;结果为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">strconv.ParseInt: parsing <span class="string">"true"</span>: invalid syntax</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们可以发现当数据转换成功的时候，是可以输出正确的值的，并且error的类型为nil，当数据转换不成功的时候，得到的值为该数据类型的<strong>零值</strong>，且error的类型是invalid syntax，因此在做数据类型转换的时候我们往往会根据err是否为nil来判断转换是否成功，所以我们一般会如下去写（使用到分支结构后续会详细讲解）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"Hello"</span></span><br><span class="line">v, err := strconv.ParseInt(str, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"类型转换出错"</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在本小结中，我们集中讲解了Go语言的基本数据类型之间的互相转化，讨论了由高精度到低精度，高容量到低容量的转换过程中出现的问题，以及string类型与其他基本类型转换过程中使用到的函数与注意事项。整体来说，本节讲的知识点偏细，且比较杂，但难度不大。读者可以不必现在完全记住这些，当使用的时候，再回来仔细看即可。</p>
<p>&emsp;&emsp;在下一节中我们将集中介绍另一个数据类型：指针，并对指针数据类型的定义、使用、注意事项等进行详细地说明。</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/" class="pre">Go语言从入门到放弃系列&lt;13&gt; 指针类型简明讲述</a><a href="/2020/02/14/11-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="next">Go语言从入门到放弃系列&lt;11&gt; 基本数据类型精讲-字符和字符串</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-12-gt-基本数据类型的转换"><span class="toc-text">Go语言从入门到放弃系列&lt;12&gt; 基本数据类型的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不同数据类型的转换"><span class="toc-text">不同数据类型的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型转换过程中的数据精度问题"><span class="toc-text">类型转换过程中的数据精度问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#整数数据溢出"><span class="toc-text">整数数据溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#浮点型向整数转换"><span class="toc-text">浮点型向整数转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他转换细节"><span class="toc-text">其他转换细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他类型与string相互转化"><span class="toc-text">其他类型与string相互转化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#其他类型转string"><span class="toc-text">其他类型转string</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string转其他基本类型"><span class="toc-text">string转其他基本类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/22/46-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%B8%80/">Go语言从入门到放弃系列<46> 文件与IO<一></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/21/45-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/">Go语言从入门到放弃系列<45> 面向对象-多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/44-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<44> 面向对象-接口细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/17/43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/">Go语言从入门到放弃系列<43> 面向对象-接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<42> 面向对象-继承细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/">Go语言从入门到放弃系列<41> 面向对象-继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/14/40-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/">Go语言从入门到放弃系列<40> 面向对象-封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/39-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">Go语言从入门到放弃系列<39> 面向对象-方法细节与工厂模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/12/38-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95/">Go语言从入门到放弃系列<38> 面向对象-方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/11/37-%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<37> 结构体细节讨论</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">46</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>