<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;10&gt; 基本数据类型精讲-整型和浮点型 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;10&gt; 基本数据类型精讲-整型和浮点型</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;10&gt; 基本数据类型精讲-整型和浮点型</h1><div class="post-meta"><a href="/2020/02/13/10-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E6%95%B4%E5%9E%8B%E5%92%8C%E6%B5%AE%E7%82%B9%E5%9E%8B/#comments" class="comment-count"></a><p><span class="date">Feb 13, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-10-gt-基本数据类型精讲-整型和浮点型"><a href="#Go语言从入门到放弃系列-lt-10-gt-基本数据类型精讲-整型和浮点型" class="headerlink" title="Go语言从入门到放弃系列&lt;10&gt; 基本数据类型精讲-整型和浮点型"></a>Go语言从入门到放弃系列&lt;10&gt; 基本数据类型精讲-整型和浮点型</h2><p>&emsp;&emsp;在前几节中我们详细地讲述了Go语言中二进制的基础，基本数据类型和Go语言中标识符的规定及使用。在接下来的几节中，我们将针对之前提到的几种基本数据类型进行详细地讲解，并对程序开发中可能出现的问题进行讲解和原因的解释。</p>
<h3 id="整型变量的细节讨论"><a href="#整型变量的细节讨论" class="headerlink" title="整型变量的细节讨论"></a>整型变量的细节讨论</h3><p>&emsp;&emsp;首先，我们先复习一下之前所讲的基本数据类型中的整型变量，整型变量的定义按是否有符号可以分为有符号整数和无符号整数。有符号整数的最高位表示符号位，且0代表正数，1代表负数，无符号整数的最高位参与数字的表示，即只能表示正数。在intN类型中的N代表计算机系统为该类型分配多少个二进制位数，即int8为8位，int16为16位。不同的整数类型对于数值的表示大小是不相同的，我们在接下来的讲解中会以int8为例。</p>
<p>&emsp;&emsp;既然每种整数类型可以表示的数值范围大小是一定的，那么一旦其中存储的数据超出了其可以表示的最大的范围会发生什么呢，我们将以以下的几个例子进行详细地说明：</p>
<h4 id="赋值时越界"><a href="#赋值时越界" class="headerlink" title="赋值时越界"></a>赋值时越界</h4><p>&emsp;&emsp;首先我们知道，int8可以表示的范围为-128到127，我们看下面的一段代码（只写main函数中的代码了）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="keyword">int8</span> = <span class="number">128</span></span><br><span class="line">fmt.Println(num)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;通过对上述程序的分析，我们知道，将128赋值给int8是会出现数值越界的情况的，因为其可表示的最大的数值只为127。在开发阶段出现了这类数值越界的代码时，编译器会帮助我们进行检查，因此这段代码是无法编译通过的，而且其错误类型显示为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constant <span class="number">128</span> overflows <span class="keyword">int8</span></span><br><span class="line">即常量<span class="number">128</span>溢出了<span class="keyword">int8</span>所能表示的范围</span><br></pre></td></tr></table></figure>

<h4 id="运行时越界"><a href="#运行时越界" class="headerlink" title="运行时越界"></a>运行时越界</h4><p>&emsp;&emsp;既然在变量的赋值过程中是不会出现数据溢出的（否则编译不通过），那么在运行时是否会出现数据越界呢，一旦出现的数据越界程序是否会做出相应的响应，例如程序停止运行等行为。现在我们进行验证一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="keyword">int8</span> = <span class="number">127</span></span><br><span class="line">num = num + <span class="number">1</span></span><br><span class="line">fmt.Println(num)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;程序中出现的num=num+1的意思是，取出num所代表的值，进行加1运算后将结果再赋值给num。在这个过程中，我们会预见在做完加1运算后就又出现了数值溢出现象，经过编译运行后，我们会发现编译过程是不报错误的，同时运行过程中也没有任何的错误消息产生的，当我们看到输出结果时，我们会发现其结果为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-128</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在我们可以考虑一下为什么会是这个结果，在介绍原码、反码与补码的章节中，我们提到了正0和负0的问题，即00000000和10000000的问题，我们人为地将10000000所代表的数定为-128。首先我们将127转换为2进制表示方法，其结果为01111111，现在我们在此基础上加1，我们会发现通过进位后其结果成为10000000，而这个数字刚好是-128。</p>
<p>&emsp;&emsp;反过来思考，如果我们首先将num赋值为-128，然后在此基础上减1，其结果会显示为127，也正如当初举的时钟的例子一般，正数最大值和负数最小值是相连的。分析过程是相似的，读者可以自行思考。</p>
<p>&emsp;&emsp;接下来我们将目光放置在无符号整数上，例如uint8，之前我们曾经介绍过，uint8的表示范围为0到255，那么同样在开发过程中赋越界的值时会编译错误，所以我们依旧关注的是运行过程中数据越界的问题，看如下的程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="keyword">uint8</span> = <span class="number">255</span></span><br><span class="line">num = num + <span class="number">1</span></span><br><span class="line">fmt.Println(num)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以分析得，按照上述最大值和最小值相连的规律，其输出结果为0，由于该整数是一个无符号整数，因此最高位参与了计数，所以255用二进制表示为11111111（8个1），我们在其基础上加1后，经过一系列的进位运算，其结果应该是100000000（1后面有8个0），但是uint8数据类型只得到了8个二进制位的空间，因此最高位（第9位）的数据溢出并舍弃，所以计算结果为： 00000000（8个0）也就是0。逆过程可以自行思考。</p>
<p>&emsp;&emsp;在应用过程中有一个十分常见的例子，便是字符的表示方式。如果表示ASCII码，byte型就可以完全存储了，但是如果想存储汉字，那么byte就会出现越界，需要用rune类型数据进行存储。当然，用rune类型来存储ASCII字符也是没有问题的，程序验证如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">byte</span> = <span class="string">'中'</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其编译过程中会出现错误，异常信息为：const 20013 overflows byte，由此看出，’中’这个字符在UTF-8编码中的数值为20013，这个数值明显超出了byte所存储的范围，因此会报错。</p>
<p>&emsp;&emsp;所以，在整数的定义与表示过程中，无论定义了空间多大的整数，都会出现数据溢出的可能，因为每个整数都有确定的数据表示范围。因此针对不同的数据范围需求来选择对应的数据类型是十分重要的，否则在程序运行中会出现意想不到的问题，而这个问题并不涉及任何的逻辑上的错误。比如说我们定义一个变量，令该变量每次都加1，一直加到该变量为500为止，如果我们使用了uint8类型，那么这个程序就永远也停不下来了，因为255后的值又回归到0了。当然我们也可以采用int64来存储，但是针对这个需求而言，int64又有些内存的浪费了（虽说现在基本上不缺这点内存），所以选择适合的数据类型来完成特定的工作是一件需要考虑乃至于优化的事情。</p>
<h3 id="浮点型变量的细节讨论"><a href="#浮点型变量的细节讨论" class="headerlink" title="浮点型变量的细节讨论"></a>浮点型变量的细节讨论</h3><p>&emsp;&emsp;浮点型的存储过程中精度丢失一直都是一个无法回避的问题，这个问题在大规模的精确计算过程中十分的常见，精度丢失的问题甚至可能会导致逻辑上的问题。根据我们之前对数据类型的介绍，不论是float32还是float64类型的变量，其可表示范围都十分的广阔，同时我们也讲解了浮点型数据在内存中的存储方法，因此一般来说float32所能精确地表示小数位数为6<del>7位，而float64能表示为15</del>16位，超出的精度部分往往就会丢失了，我们来看下面的一段程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">1.00000001</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span> = <span class="number">1.0000001</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(b)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在上述的一段程序中，我们为a和b两个变量分别赋值，并且在程序的最后输出这两个值。根据我们刚提及的精度丢失问题以及小数保留位数，我们会发现：最终的结果为a=1，b=1.0000001。可以说b的值的输出是正常的，但是a的值却产生了错误。其原因便是超出精度范围的数值被忽略了。如果我们依旧对于精度丢失所产生的问题不甚理解的话，那么我们可以再看一段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">3.3333333</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span> = <span class="number">6.6666666</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">float32</span> = a + b</span><br><span class="line">fmt.Println(c)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可能令人大跌眼镜的是，这个运算结果也就是c的值为10，第一个例子中超出精度的部分被舍弃了，而在第二个例子中超出精度的部分就进了1位。这种问题既不可以被归结为编译的错误，也不可以归结为逻辑的错误，而是说这个错误出现的原因是由语言本身和机器本身所导致的。更确切地说是由浮点型数据的存储方法和二进制十进制对应关系所导致的。接下来我们从两个角度简要说明一下精度丢失的成因。</p>
<p>&emsp;&emsp;第一个成因便是<strong>进制转换时的精度丢失</strong>，在进制转换的那一小节中，我们抛出了一个问题，是否每一个有限的十进制数都有一个有限位数的二进制数相对应，我们对这个问题的解答是否定的。也就是说我们在用十进制数编程时，再用计算机转换成二进制码的时候，精度就已经丢失了一次了，这个丢失是内部原因导致的，也是基本无法避免的。</p>
<p>&emsp;&emsp;第二个成因便是<strong>浮点数的表示方法</strong>，按常理来说，一个有限位数的浮点型变量居然能表示那么大的范围，其精度必然是不会非常高的。我们在前几节介绍了浮点数的存储方式，即符号位、指数部分、和尾数部分。指数部分代表了科学计数法中的幂次，剩余的部分则表示在尾数部分，由于尾数部分也是有位数限制的，因此也会出现类似于整数一样的数据溢出问题的。因此太多的小数位数将溢出尾数部分，而保留的就是前几位未溢出的部分，因此在浮点数的存储方法中，会出现二次的精度损失。</p>
<p>&emsp;&emsp;那么一旦真的需要精度十分高的浮点型乃至于数值极为庞大的整数运算时，有一种解决办法便是利用字符串，字符串中的每一个字符值都是一个精确的数字。换句话说，利用字符串，在内存中所保存的是一系列的int8类型，每个int8对应于真值的每一位。同时Go语言开发者也向用户封装了基于字符串所表示的数据的数学运算函数，在需要时可以调用。详细源码可以研读Go语言中的math/big包。</p>
<p>&emsp;&emsp;利用字符串表示数据虽解决了数据存储与表示的问题，但是这种方式也有其特定的弊端。当我们利用int、float32等提供的数据类型进行运算操作时，系统在计算机底层予以其特殊的优化手段，使之计算速度有极大的提升。而利用字符串进行运算，则会拖慢运行速度，在一些已定义的函数中无法作为参数而不得已只好自行包装、改写函数。</p>
<p>&emsp;&emsp;不过话说来，浮点数精度丢失的问题一般不会影响到我们程序开发，在应用级的开发中往往不会用到8位小数之后，而且float64所提供的有效精度也足够使用了。但是在科学计算中，或在大规模的银行系统中，精度就会成为一个不得不慎重考虑的问题。曾经有一个生物信息专业的同学给我讲述过一个事情，在做DNA匹配计算过程中需要将各种的变异均考虑进去，并且得到的匹配结果十分的相似。此时问题就是，究竟是这两个DNA相同但是因为计算精度问题而显示成不同，还是说两种DNA真的是不同只是不同点比较少但是比较重要。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们主要讲述了Go语言中整数和浮点数使用注意事项，集中说明了整数中的数据溢出问题和浮点型数据中的精度丢失问题。这两个问题在计算机语言中是普遍存在的问题，不仅仅是Go语言中单独的问题。这两种问题在日常开发中几乎不会遇到，但是在实际工作中一旦出现了某种周期性问题或没有明显逻辑错误的问题时，这两个原因不失为一种考虑方向。</p>
<p>&emsp;&emsp;在下一节中，我们将针对于剩下的几种基本数据类型进行精讲，同时也将讲解在开发过程中可能出现的问题及原因。</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/02/14/11-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="pre">Go语言从入门到放弃系列&lt;11&gt; 基本数据类型精讲-字符和字符串</a><a href="/2020/02/12/9-%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%8C%E8%BE%93%E5%87%BA%E5%8F%8A%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/" class="next">Go语言从入门到放弃系列&lt;9&gt; 标识符、输出及转义字符</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-10-gt-基本数据类型精讲-整型和浮点型"><span class="toc-text">Go语言从入门到放弃系列&lt;10&gt; 基本数据类型精讲-整型和浮点型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#整型变量的细节讨论"><span class="toc-text">整型变量的细节讨论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#赋值时越界"><span class="toc-text">赋值时越界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行时越界"><span class="toc-text">运行时越界</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浮点型变量的细节讨论"><span class="toc-text">浮点型变量的细节讨论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/39-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">Go语言从入门到放弃系列<39> 面向对象-方法细节与工厂模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/12/38-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95/">Go语言从入门到放弃系列<38> 面向对象-方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/11/37-%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<37> 结构体细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/36-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%93%E6%9E%84%E4%BD%93/">Go语言从入门到放弃系列<36> 面向对象-结构体</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/09/35-map%E6%98%A0%E5%B0%84%E7%9A%84%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<35> map映射的细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/08/34-map%E6%98%A0%E5%B0%84/">Go语言从入门到放弃系列<34> map映射</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/07/33-%E5%88%87%E7%89%87%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/">Go语言从入门到放弃系列<33> 切片使用细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/32-%E5%88%87%E7%89%87%E5%BC%95%E5%85%A5/">Go语言从入门到放弃系列<32> 切片引入</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/05/31-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/">Go语言从入门到放弃系列<31> 二维数组与多维数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/04/30-%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81%E7%AF%87-%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/">Go语言从入门到放弃系列<30> 数组代码篇-几种排序方式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">39</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>