<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;52&gt; channel管道入门 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;52&gt; channel管道入门</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;52&gt; channel管道入门</h1><div class="post-meta"><a href="/2020/03/30/52-channel%E7%AE%A1%E9%81%93%E5%85%A5%E9%97%A8/#comments" class="comment-count"></a><p><span class="date">Mar 30, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-52-gt-channel管道入门"><a href="#Go语言从入门到放弃系列-lt-52-gt-channel管道入门" class="headerlink" title="Go语言从入门到放弃系列&lt;52&gt; channel管道入门"></a>Go语言从入门到放弃系列&lt;52&gt; channel管道入门</h2><p>&emsp;&emsp;在上个小节中，我们通过资源竞争问题简要地介绍了Go语言中的全局互斥锁的使用方式，以及引出了channel的快速入门案例。在这个小节中，我们将针对Go语言中的channel变量进行更多的介绍，并相应地配合入门案例完成对应的讲解。</p>
<h3 id="channel基本介绍"><a href="#channel基本介绍" class="headerlink" title="channel基本介绍"></a>channel基本介绍</h3><p>&emsp;&emsp;相比于之前我们介绍的简单的或者复合的变量，channel形式的变量又显得比较特殊。channel其本质是一种队列的数据结构。在上个小节我们举了一个ATM取款的例子，当有人使用提款机时，后面的其他人需要排队等待，这种数据结构经过抽象后就是队列。 </p>
<p>&emsp;&emsp;再次类比上面的例子，当一个人最先到达，他会排在队列的前面，同时他也将会成为候补人选的第一个人。因此队列的逻辑形式是先入先出FIFO（first in first out）。队列中还有两个属性：长度与容量。容量是一个队列可以容纳的最多数据的个数，而长度则是指当前队列中究竟有几个元素。我们举一个例子：我们首先定义一个容量为10的队列，将1,3,5,2,4按顺序插入队列中，此时的队列为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">2</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;队列的容量是10，队列的长度为5。此时我们从队列中提取一个元素，因为队列是先入先出，因此提取出来的值是队列中的第一个值：1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>  <span class="number">5</span>  <span class="number">2</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此时队列的容量依旧为10，但是长度变为了4。假如此时我们再向队列中插入一个值10，因为后出入的值会排在最后面，因此此时的队列为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>  <span class="number">5</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;channel的本质是一个队列，因此channel中的数据也满足先入先出的思想，同时channel是线程（协程）安全的，当多个goroutine访问同一个channel时不需要加锁，也不会出现读写的资源竞争问题。接下来我们将通过代码案例完成channel的各个知识点的讲解。</p>
<h3 id="channel的定义与声明"><a href="#channel的定义与声明" class="headerlink" title="channel的定义与声明"></a>channel的定义与声明</h3><p>&emsp;&emsp;在Go语言中使用变量之前往往需要定义与声明，channel也需要先定义才可以继续向下使用。而channel的基本定义方式为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 <span class="keyword">chan</span> 数据类型</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过上述的声明结构，我们可以发现channel的声明由三部分构成：变量名，chan（指定变量为channel），以及channel中装载的数据类型。我们举几个案例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> stringChan <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> mapChan <span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> classChan <span class="keyword">chan</span> StuInfo</span><br><span class="line"><span class="keyword">var</span> pointerChan <span class="keyword">chan</span> *StuInfo</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;解释一下上面的定义方式：第一个channel名为intChan，且channel中只能存放int类型的整数。同理其他的几个定义中channel只可以存放string，map[int]int，StuInfo类，StuInfo对象指针。 </p>
<p>&emsp;&emsp;channel在定义过后还需要注意的几点是：channel自身是一个引用类型，因此在函数或方法传递过程中会受到函数方法内的改变的影响。同时正因为其引用类型的特性，channel是需要初始化才可以写入数据的，即make操作过后才可以使用。还有一个特性是：channel是有数据类型的，一旦channel定义中出现int，那么该channel中只能写入整数int。当然我们已经介绍过了面向对象的多态与接口，因此在一定意义上可以用空接口解决多个类型存入的问题。</p>
<h3 id="Channel初始化与数据操作"><a href="#Channel初始化与数据操作" class="headerlink" title="Channel初始化与数据操作"></a>Channel初始化与数据操作</h3><p>&emsp;&emsp;在上个部分中我们提到，Go语言中channel变量需要make过后才可以使用。对于channel变量的make函数而言需要两个参数。分别为channel变量及存储的数据类型以及channal管道的容量。与切片slice和映射map不同的是，channel的容量是固定的，一经定义好，就不可以改变了。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过上述的初始化过后，内存中就已然分配了一个容量为5，长度为0的管道，其本质就是一个容量为5的队列。经过初始化后，就可以向管道内插入和提取数据了。Go语言中向管道内插入数据与提取数据采用的是”&lt;-“符号（小于号和一个减号）。我们通过下面的案例来说明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    intChan &lt;- <span class="number">1</span></span><br><span class="line">    intChan &lt;- <span class="number">2</span></span><br><span class="line">    intChan &lt;- <span class="number">3</span></span><br><span class="line">    intChan &lt;- <span class="number">4</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(intChan))</span><br><span class="line">    num1 := &lt;-intChan</span><br><span class="line">    num2 := &lt;-intChan</span><br><span class="line">    fmt.Println(num1, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述的代码中，我们初始化了一个容量为5的管道，并向管道中依次插入四个整数。然后我们输出了该管道当前的长度。之后我们再将管道中的前两个整数提取出来，最后将这两个整数输出到控制台终端。上述代码的输出结果为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来我们再测试一下当插入数据超出了channel所规定的容量时发生的情况。我们依旧初始化一个容量为5的channel，并依次向里面插入6个数，最后再使用输出channel的长度：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    intChan &lt;- <span class="number">1</span></span><br><span class="line">    intChan &lt;- <span class="number">2</span></span><br><span class="line">    intChan &lt;- <span class="number">3</span></span><br><span class="line">    intChan &lt;- <span class="number">4</span></span><br><span class="line">    intChan &lt;- <span class="number">5</span></span><br><span class="line">    intChan &lt;- <span class="number">6</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(intChan))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当程序执行到intChan&lt;-6这条语句时，插入数据已然超出了规定的最大的容量了。<strong>在单协程的情况下</strong>，程序会报出运行时错误。因为此时只有一个主协程，而主协程中管道已然满了而添加不进去新的数据，因此主协程被阻塞了。同时没有其他的协程从管道中提取数据，主协程将会一直阻塞，因此出现了致命错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;同理，我们再测试当channel中暂时为空，而没有数据的前提下，我们从channel中提取数据。我们依旧初始化一个channel，不向其中插入数据，直接提取数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    num := &lt;-intChan</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上述的这段程序依旧会出现死锁的问题，其原因也是十分类似的：此时只有一个主协程，主协程中等待着其他协程向channel中插入数据，只有channel中有数据才可以提取出来。因此主协程被阻塞在提取的步骤上了，而没有其他的协程插入，因此编译器发现所有的协程都处于阻塞状态（虽然只有一个主协程），就报出了致命错误。错误类型是相同的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;因此可以讲，channel的作用是在不同的协程中起到通信的作用，而且channel中的数据是一种动态的数据。如同水管一般，水是在水管中是流动的，正如数据在channel中流动。在一个协程中单独使用channel，或者channel中数据不流动往往是不合适的。 </p>
<h3 id="主协程等待子协程方式"><a href="#主协程等待子协程方式" class="headerlink" title="主协程等待子协程方式"></a>主协程等待子协程方式</h3><h4 id="channel阻塞机制"><a href="#channel阻塞机制" class="headerlink" title="channel阻塞机制"></a>channel阻塞机制</h4><p>&emsp;&emsp;既然channel在多协程的情况下提取空数据或者添加满数据时会发生阻塞，我们就可以利用这个特性让主协程等待所有的子协程执行结束后再退出了。假如程序将启动8个协程，每个协程在结束的时候向channel中写入一个true，主协程中循环8次提取channel中的bool值。当提取不满8次时，主协程阻塞；当第八次提取到了true时，说明所有子协程都结束了，主协程可以继续向下执行。 </p>
<p>&emsp;&emsp;现在我们通过案例来说明上述的场景，我们启动8个协程，在每个协程中0到10随机Sleep一段时间，当所有协程均结束后，主协程结束：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomDelay</span><span class="params">(channel <span class="keyword">chan</span> <span class="keyword">bool</span>, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s := rand.Intn(<span class="number">10</span>)</span><br><span class="line">    time.Sleep(time.Duration(s) * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"协程"</span>, i, <span class="string">"等待"</span>, s, <span class="string">"秒"</span>)</span><br><span class="line">    channel &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> randomDelay(channel, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">        &lt;-channel</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"主协程结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上面的代码中，我们首先在主协程中确定了随机种子的值，然后初始化了容量为8的管道。在randomDelay中，我们随机生成一个0到10的整数，并让该函数阻塞对应长的时间，阻塞过后输出结果。同时在主协程中我们逐个将channel中的数据取出。由于channel中的数据只起到标志位的作用，因此能够取出数据就是我们希望的结果，而对于取出来的数据我们并不关心，因此可以不赋值给其他变量。最终，取出8次数据之后，主协程结束。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">协程 <span class="number">1</span> 等待 <span class="number">0</span> 秒</span><br><span class="line">协程 <span class="number">7</span> 等待 <span class="number">2</span> 秒</span><br><span class="line">协程 <span class="number">6</span> 等待 <span class="number">2</span> 秒</span><br><span class="line">协程 <span class="number">3</span> 等待 <span class="number">2</span> 秒</span><br><span class="line">协程 <span class="number">5</span> 等待 <span class="number">4</span> 秒</span><br><span class="line">协程 <span class="number">4</span> 等待 <span class="number">5</span> 秒</span><br><span class="line">协程 <span class="number">0</span> 等待 <span class="number">7</span> 秒</span><br><span class="line">协程 <span class="number">2</span> 等待 <span class="number">8</span> 秒</span><br><span class="line">主协程结束</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过这种方式，我们可以利用channel在多协程中的阻塞机制，让主协程强行等待最后一个子协程的结束后自己再结束。同时，channel变量自身就是线程（协程）安全的，不会出现资源共享时的竞争问题，因此在多协程通讯的时候，channel的作用可以说是十分重要的。 </p>
<p>&emsp;&emsp;除了这种方式之外，还有一种方式是利用管道关闭的性质完成主协程等待子协程的操作，具体的方法及细节我们将在下个小节中详细讲解。</p>
<h4 id="计数器模式"><a href="#计数器模式" class="headerlink" title="计数器模式"></a>计数器模式</h4><p>&emsp;&emsp;除了上述channel阻塞模式之外，我们还可以利用sync包中的WaitGroup类来完成该需求。其本质即是一个计数器：当我们开启一个协程时让计数器增加1，当某个协程结束时令计数器减少1，在计数器归零之前程序处于阻塞的状态，当计数器归零，程序就可以继续向下执行了。</p>
<p>&emsp;&emsp;在WaitGroup类中，主要被用到的只有三个方法：Add方法，Done方法和Wait方法。当我们希望在程序运行过程中对计数器进行增加操作时，我们就调用Add方法。Done方法与Add方法相反，程序每次调用Done方法都会令计数器自减。而Wait方法则是程序在调用其位置进行阻塞，直到计数器归零。  </p>
<p>&emsp;&emsp;在这里需要明确的是：WaitGroup既然是一个类，那么其对象即满足值类型的本质，当WaitGroup对象作为函数参数传递时，是需要复制一份副本进行传递，这样在函数方法内部就无法对计数器本身进行修改。因此在函数参数的传递过程中大多数还是要传递WaitGroup<strong>指针</strong>，否则计数器不归零程序将持续阻塞。我们举例完成上述同样的需求：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomDelay</span><span class="params">(wg *sync.WaitGroup, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s := rand.Intn(<span class="number">10</span>)</span><br><span class="line">	time.Sleep(time.Duration(s) * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"协程"</span>, i, <span class="string">"等待"</span>, s, <span class="string">"秒"</span>)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> randomDelay(wg, i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">"主协程结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在程序中，我们每启动一个goroutine，都令WaitGroup对象（wg）自增1，当每个goroutine结束的时候，我们都让计数器减1（Done方法），最后我们在程序的结尾处调用Wait方法，使得主协程开始阻塞等待所有协程的结束。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们首先介绍了队列数据结构的基本思路，进而说明了channel的核心就是一个队列。然后我们又简要介绍了Go语言中channel的定义方式以及channel中数据类型的多样性。随后我们又初始化channel，并说明了向管道写入以及从管道内取出数据的方法以及异常情况的阻塞机制。最后我们通过这种阻塞机制说明了主协程等待子协程的方法。 </p>
<p>&emsp;&emsp;在下个小节中，我们将集中针对channel数据类型讲解其各个细节，并通过一段代码综合地讲解goroutine和channel的配合。在这之后，读者应该可以完成一定的多协程开发与协程交互的任务。</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/03/31/53-channel%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/" class="pre">Go语言从入门到放弃系列&lt;53&gt; channel细节讨论</a><a href="/2020/03/29/51-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E4%B8%8E%E7%AE%A1%E9%81%93/" class="next">Go语言从入门到放弃系列&lt;51&gt; 资源竞争与管道</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-52-gt-channel管道入门"><span class="toc-text">Go语言从入门到放弃系列&lt;52&gt; channel管道入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#channel基本介绍"><span class="toc-text">channel基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#channel的定义与声明"><span class="toc-text">channel的定义与声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel初始化与数据操作"><span class="toc-text">Channel初始化与数据操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主协程等待子协程方式"><span class="toc-text">主协程等待子协程方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#channel阻塞机制"><span class="toc-text">channel阻塞机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#计数器模式"><span class="toc-text">计数器模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/31/53-channel%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<53> channel细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/30/52-channel%E7%AE%A1%E9%81%93%E5%85%A5%E9%97%A8/">Go语言从入门到放弃系列<52> channel管道入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/51-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E4%B8%8E%E7%AE%A1%E9%81%93/">Go语言从入门到放弃系列<51> 资源竞争与管道</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/27/50-Goroutine%E5%85%A5%E9%97%A8/">Go语言从入门到放弃系列<50> Goroutine入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/49-Goroutine%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/">Go语言从入门到放弃系列<49> Goroutine概念简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/25/48-JSON%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/">Go语言从入门到放弃系列<48> JSON与序列化</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/24/47-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%BA%8C/">Go语言从入门到放弃系列<47> 文件与IO<二></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/22/46-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%B8%80/">Go语言从入门到放弃系列<46> 文件与IO<一></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/21/45-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/">Go语言从入门到放弃系列<45> 面向对象-多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/44-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<44> 面向对象-接口细节讨论</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">53</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>