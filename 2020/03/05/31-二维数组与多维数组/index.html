<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;31&gt; 二维数组与多维数组 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;31&gt; 二维数组与多维数组</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;31&gt; 二维数组与多维数组</h1><div class="post-meta"><a href="/2020/03/05/31-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/#comments" class="comment-count"></a><p><span class="date">Mar 05, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-31-gt-二维数组与多维数组"><a href="#Go语言从入门到放弃系列-lt-31-gt-二维数组与多维数组" class="headerlink" title="Go语言从入门到放弃系列&lt;31&gt; 二维数组与多维数组"></a>Go语言从入门到放弃系列&lt;31&gt; 二维数组与多维数组</h2><p>&emsp;&emsp;在之前的章节中，我们已经讲解了一维数组的定义方式、使用方式以及需要注意的几个点，同时也针对数组排序的需求对数组这个知识点进行了代码的书写与讲解。在这个小节中，我们将基于一维数组的概念推广到二维数组乃至于多维数组。对二维数组的定义方式、使用方式等做出讲解，并在最后通过二维数组走迷宫的案例进行代码讲解。</p>
<h3 id="二维数组的引入"><a href="#二维数组的引入" class="headerlink" title="二维数组的引入"></a>二维数组的引入</h3><p>&emsp;&emsp;在一维数组的讲解中，我们介绍了一维数组的概念，如果我们将一维数组比作为一个线性的数据存储格式，那么二维数组就是一个平面向的存储方式，同理推广到高维数组就可以理解为数组存储的多维空间。我们首先提出一个需求：通过Go语言完成一个课程表的显示，假设每周除去双休日需要学习五天，每天只有八节课，没有课的地方用“-”来表示。 </p>
<p>&emsp;&emsp;针对这个需求，如果我们采用之前学到的知识来完成，我们可能会定义五个一维数组来完成。每个一维数组存储当天的课程信息。假设不同周的课程是相同的，那么可能会写出如下的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> monday [<span class="number">8</span>]<span class="keyword">string</span> = [<span class="number">8</span>]<span class="keyword">string</span>&#123;<span class="string">"Math"</span>,<span class="string">"Physics"</span>,...&#125;</span><br><span class="line"><span class="keyword">var</span> tuesday [<span class="number">8</span>]<span class="keyword">string</span> = [<span class="number">8</span>]<span class="keyword">string</span>&#123;<span class="string">"Math"</span>,<span class="string">"Physics"</span>,...&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这种写法是可以满足需求的，但是如果联想到我们介绍一维数组时所举的例子，我们会发现程序需要改进的地方是基本相同的，我们依旧定义了太多的变量，尽管每个变量都是一维数组，所以我们希望存在这样一个一维数组，这个一维数组中的每一个元素都是一维数组。在一维的前提下再添一维，就引出了二维数组。 </p>
<p>&emsp;&emsp;我们再次回忆一维数组的定义方式：var num [3]int，通过这个定义方式我们可以知道num是一个具有3个元素的数组，且每个元素都是int。现在假如我们定义是 var num [3][4]int，依旧采用刚刚的分析方式，我们可以知道num是一个具有3个元素的数组，且每个元素都是具备4个int元素的数组，换句话说即申请了一个三行四列的二维数组。二维数组的定义方式就是如此。</p>
<h3 id="二维数组的内存构成"><a href="#二维数组的内存构成" class="headerlink" title="二维数组的内存构成"></a>二维数组的内存构成</h3><p>&emsp;&emsp;介绍这个问题的原因是：我们计算机中的硬件内存是一个线性内存，因此通过一维的线性内存来反映二维的乃至于多维的数组是需要通过一些方式的。而不同的计算机语言对于这个一维到二维的映射方式也是不同的。主流思想有两个：按行存储（例如C语言），按列存储（例如Fortran语言），因此明白数组在内存中的结构是需要的，它会决定数组定义的简化方式以及快速查找的计算模型。首先我们通过一个案例来说明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;nums)</span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;nums[<span class="number">0</span>])</span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;nums[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这段程序构成十分简单，我们单纯地定义了一个2行3列的整数型的数组，由于我们未对其进行初始化或赋值，因此数组中的每一个值都是0，即该数据类型的零值。接下来，我们输出了数组的首地址、第0行的地址、以及第1行的地址，我们可以发现其结果为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xc000080060</span></span><br><span class="line"><span class="number">0xc000080060</span></span><br><span class="line"><span class="number">0xc000080078</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过程序的输出结果，我们可以发现数组的地址就是第0行数组的地址，这个似乎不需要解释。其次我们可以发现，nums[0]的物理地址与nums[1]的物理地址相差了18个字节（十六进制），换算成十进制则是相差了24个字节。由于笔者的计算机是64位操作系统，因此一个int类型占据了8个字节，这样看来相差的24个字节刚好满足了存储3个int类型数据。用一个图解来表示则为：<br> <img src="/2020/03/05/31-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/1.png" alt></p>
<p>&emsp;&emsp;现在我们通过二维数组的内存构成来推导出高维数组的表示方式，同样地，计算机内存是线性的因此需要通过映射来完成。例如我们定义了一个三维数组：var nums [2][3][4]int，我们可以推断出：nums[0]的地址与nums[1]的地址相差：3*4*8=96个字节，nums[0][0]与nums[0][1]的地址相差：4*8=32个字节，nums[0][0][0]与nums[0][0][1]的地址相差8个字节。 </p>
<p>&emsp;&emsp;因此我们可以推断出：在Go语言中，数组的存储形式是按行存储，否则连续的两个元素之间的地址差将会是该数据类型的整数倍，而不是单独的一个数据空间。</p>
<h3 id="二维数组的定义与初始化"><a href="#二维数组的定义与初始化" class="headerlink" title="二维数组的定义与初始化"></a>二维数组的定义与初始化</h3><p>&emsp;&emsp;参照于一维数组的定义与初始化形式，二维数组也有四种基本的初始化方式，接下来我们逐一地进行讲解。首先二维数组的定义方式我们在入门案例中已经提及了，这里就不过多的讲解了。我们着重说明初始化的方式。 </p>
<h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>&emsp;&emsp;第一种方式就是将所有需要的信息完全写在初始化过程中，不省略任何一个元素，其初始化方式为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 [大小][大小]数据类型 = [大小][大小]数据类型&#123;&#123;数据，...&#125;,&#123;数据，...&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们举一个例子，定义一个两行三列的数组，且初始化其值为1到6：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line">fmt.Println(nums)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这段程序中，我们可以发现，由于1,2,3处在同一行，4,5,6处在同一行，因此，将同一行所对应的元素用大括号包裹起来，这样也有助于编译器分别对不同的值进行初始化。同时，每一行只有三个元素，因此每行最多只能初始化三个值，一旦当前行中初始化的值不够定义的个数，则用零值来补全，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此时由于我们在第0行中只初始化了两个值，因此这个数组的初始化结果其实为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>&emsp;&emsp;由于我们在初始化过程中用大括号对每行数据进行了指定，因此，程序在编译过程中就可以知道这个数组究竟有几行，因此行数的大小是可以不指定的，通过三个点号来代替，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums [<span class="number">2</span>][<span class="number">3</span>] = [...][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这种初始化的方式相对来说比较鸡肋，因为在数据定义的时候已经指定了数组的行数和列数，那在后面通过三个点号来表示就完全没有意义了。其实这个特性主要是用在数据类型的自动推导中，在这里暂时不做讲解。</p>
<h4 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h4><p>&emsp;&emsp;基本数据类型可以通过自动推导得到，那二维数组当然也具备这个特性，因此，我们介绍的第三个初始化方式就是数组的自动推导，根据初始化过程完成数据类型的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 = [大小][大小]数据类型&#123;&#123;初值,...&#125;,&#123;初值,...&#125;...&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这种方式与之前提及的各种数据类型的自动推导完全一致，如果明白了方式一的定义方式，这个就迎刃而解了。当然，我们也可以通过:=的方式来完成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名 := [大小][大小]数据类型&#123;&#123;初值,...&#125;,&#123;初值,...&#125;...&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a>方式四</h4><p>&emsp;&emsp;第四种方式其实就是省略行数的自动推导类型方式，这个方式与我们提及的方式二有所不同，具体不同点我们会进行讲解。首先我们先列出方式四的初始化格式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 = [...][大小]数据类型&#123;&#123;初值,...&#125;,&#123;初值,...&#125;...&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过大括号定义了具体的行元素，那么有几行就可以知晓了，因此省略行数的自动推导所得到的数据类型与初始化中的大括号对数相关。这点与方式二不同，方式二得到的数据行数是通过定义指明了的，而方式四的数据行数是推导的，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span> = [...][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(nums))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上述的这段通过方式二初始化的程序是编译不通过的，其报错的原因是：自动推导出[1][3]int的数组而赋值给[2][3]int的数组，出现了数据类型不匹配的错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [...][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(nums))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;而这一段程序是不会出现错误的，输出的结果即二维数组的行数为1，此时的nums数组为一行三列。</p>
<h3 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h3><p>&emsp;&emsp;在介绍二维数组的定义过后，我们继续讲解二维数组的使用方式，而众多的使用方式中，遍历是最为常见之一，因此二维数组的遍历我们在这里简单地提及。</p>
<h4 id="双层for循环遍历"><a href="#双层for循环遍历" class="headerlink" title="双层for循环遍历"></a>双层for循环遍历</h4><p>&emsp;&emsp;在二维数组引入的过程中，我们将二维数组看作成元素为数组的数组，因此通过这个理解方式，我们可以发现：对外层的大数组取其长度，（即得到多少个一维数组）就是该二维数组的行数，同理进入到大数组中的元素（小数组）后，该长度就是二维数组的列数，因此二维数组的遍历方式可以为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i&lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j&lt; <span class="built_in">len</span>(nums[<span class="number">0</span>]); j++ &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//取元素时通过nums[i][j]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="for-range方式遍历"><a href="#for-range方式遍历" class="headerlink" title="for-range方式遍历"></a>for-range方式遍历</h4><p>&emsp;&emsp;for-range遍历方式与上述双重循环类似，因为for-range其本质也就是一个循环。在for-range结构中，我们通过传入的数组可以得到该数组中每个元素的位置以及值，而对于二维数组而言，通过for-range得到其元素其实就是得到了一个一维数组，再对该一维数组进行for-range操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, valuei := <span class="keyword">range</span> nums &#123;</span><br><span class="line">    <span class="keyword">for</span> j, valuej := <span class="keyword">range</span> valuei &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//此时valuej就是遍历到的元素，i，j就是该元素的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;介绍了以上两种二维数组的遍历方式之后，对于高维数组的扩展就不必多说了，无非就是多个for循环的嵌套，或者for-range结构的嵌套，当然for循环与for-range结构混用也是没有问题的。</p>
<h3 id="二维数组代码举例"><a href="#二维数组代码举例" class="headerlink" title="二维数组代码举例"></a>二维数组代码举例</h3><p>&emsp;&emsp;在这个部分中，我们将针对一个走迷宫的初级问题来对二维数组的使用进行举例，需求如下：假设有一个N乘以N的数组，在数组中0代表空地，1代表墙，2代表目的地，问给定一个数组和一个起点，是否存在一条路径使得从起点到终点有一条通路。 </p>
<p>&emsp;&emsp;例如，我们使用如下的一个迷宫矩阵，且设定起始位置为（1,1）点：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这里我们采用递归的方式进行深度优先搜索，当然这个方式不是一个非常合适的方法，只是说其中涉及到递归的技术，以及逻辑表达式的一些问题，可以复习一下前面的知识，就用这种方式举例。当然，实现方式可以不同，面对一个问题多个人就有多个解法。解法之一的思想如下： </p>
<p>&emsp;&emsp;我们可以将数组中的点分为三类，第一类是可继续行动的点，第二类是不可行动的点，第三类就是终点。针对于这三种不同的点逻辑是不同的。假设我们有一个返回值是布尔变量的函数，参数是当前的x、y值，当当前的点为不可行动的点（如数组中的1）时，返回false，当这个点是终点的时候，返回值是true，当这个点是一个空地，那么就需要判断它的上下左右的点能否到达终点。且上下左右能到终点的逻辑呈现或的关系，即一旦有一个方向能到终点，该点就可以通向终点。回溯回去，就可以证明从起点出发可以到达终点。函数逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CanGetToDes</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> maze[x][y] == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> maze[x][y] == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> maze[x][y] == <span class="number">0</span> &#123;</span><br><span class="line">        maze[x][y] = <span class="number">1</span></span><br><span class="line">        <span class="comment">//在这里我们将其设定为1，代表这个点已经搜索过了，以后不要再搜索了，否则会出现无限循环。</span></span><br><span class="line">        <span class="keyword">return</span> CanGetToDes(x<span class="number">-1</span>, y) || CanGetToDes(x+<span class="number">1</span>, y) || CanGetToDes(x, y<span class="number">-1</span>) || CanGetToDes(x, y+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;主函数就负责调用该函数即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(CanGetToDes(<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后将maze数组定义为全局变量，使得各个函数都可以调用该变量，当然这只是为了简便，也可以通过函数参数将maze数组进行传递而不需要全局变量。全部的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maze [<span class="number">6</span>][<span class="number">6</span>]<span class="keyword">int</span> = [<span class="number">6</span>][<span class="number">6</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(CanGetToDes(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CanGetToDes</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> maze[x][y] == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> maze[x][y] == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> maze[x][y] == <span class="number">0</span> &#123;</span><br><span class="line">        maze[x][y] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> CanGetToDes(x<span class="number">-1</span>, y) || CanGetToDes(x+<span class="number">1</span>, y) || CanGetToDes(x, y<span class="number">-1</span>) || CanGetToDes(x, y+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据输出结果，我们可以发现输出为true，即存在一条通路使得起点到达终点，如果我们修改了maze数组，例如将maze[3][4]的值修改为1，则输出结果会成为false。当然，我们可以根据这个需求和方法进行加深，例如：求取从起点到终点的最短路径，如果无法到达则输入-1。程序实现也是可以基于当前的这个代码进行扩展的，如果读者有兴趣，可以自行探索并完成代码的书写。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们集中讲解了二维数组的定义以及使用方式，进而对多维数组进行引出和拓展。我们讲解了二维数组的内存构成、四种初始化方式以及常用的遍历方式。最后我们通过走迷宫这个小案例来完成二维数组的代码案例。在下一小节中，我们将会介绍到切片数据类型，这种数据类型与数组十分相似，在看下一小节之前一定明白数组的定义方式，否则容易相互混淆。</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/03/06/32-%E5%88%87%E7%89%87%E5%BC%95%E5%85%A5/" class="pre">Go语言从入门到放弃系列&lt;32&gt; 切片引入</a><a href="/2020/03/04/30-%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81%E7%AF%87-%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/" class="next">Go语言从入门到放弃系列&lt;30&gt; 数组代码篇-几种排序方式</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-31-gt-二维数组与多维数组"><span class="toc-text">Go语言从入门到放弃系列&lt;31&gt; 二维数组与多维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二维数组的引入"><span class="toc-text">二维数组的引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二维数组的内存构成"><span class="toc-text">二维数组的内存构成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二维数组的定义与初始化"><span class="toc-text">二维数组的定义与初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方式一"><span class="toc-text">方式一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方式二"><span class="toc-text">方式二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方式三"><span class="toc-text">方式三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方式四"><span class="toc-text">方式四</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二维数组的遍历"><span class="toc-text">二维数组的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#双层for循环遍历"><span class="toc-text">双层for循环遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-range方式遍历"><span class="toc-text">for-range方式遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二维数组代码举例"><span class="toc-text">二维数组代码举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/07/33-%E5%88%87%E7%89%87%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/">Go语言从入门到放弃系列<33> 切片使用细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/32-%E5%88%87%E7%89%87%E5%BC%95%E5%85%A5/">Go语言从入门到放弃系列<32> 切片引入</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/05/31-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/">Go语言从入门到放弃系列<31> 二维数组与多维数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/04/30-%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81%E7%AF%87-%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/">Go语言从入门到放弃系列<30> 数组代码篇-几种排序方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/03/29-%E6%95%B0%E7%BB%84%E7%BB%86%E8%8A%82%E8%AE%B2%E8%A7%A3/">Go语言从入门到放弃系列<29> 数组细节讲解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/02/28-%E6%95%B0%E7%BB%84%E5%BC%95%E5%85%A5/">Go语言从入门到放弃系列<28> 数组引入</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/01/27-%E9%97%AD%E5%8C%85%E3%80%81defer%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/">Go语言从入门到放弃系列<27> 闭包、defer与作用域</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/26-init%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/">Go语言从入门到放弃系列<26> init函数与匿名函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/28/25-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%BA%8C/">Go语言从入门到放弃系列<25> 函数使用细节<二></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/27/24-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%B8%80/">Go语言从入门到放弃系列<24> 函数使用细节<一></a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">33</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>