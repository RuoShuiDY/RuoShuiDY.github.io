<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;35&gt; map映射的细节讨论 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;35&gt; map映射的细节讨论</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;35&gt; map映射的细节讨论</h1><div class="post-meta"><a href="/2020/03/09/35-map%E6%98%A0%E5%B0%84%E7%9A%84%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/#comments" class="comment-count"></a><p><span class="date">Mar 09, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-35-gt-map映射的细节讨论"><a href="#Go语言从入门到放弃系列-lt-35-gt-map映射的细节讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;35&gt; map映射的细节讨论"></a>Go语言从入门到放弃系列&lt;35&gt; map映射的细节讨论</h2><p>&emsp;&emsp;在上一小节中，我们对Go语言中的map映射进行了引入，同时也讲解了map的定义初始化方式以及对其中数据的增删改查操作的方式。在这个小节中，我们依旧针对map映射的其他特性进行相对深入的讲解，以及在程序编写过程中需要注意的几个问题进行提及。 </p>
<h3 id="键值对类型"><a href="#键值对类型" class="headerlink" title="键值对类型"></a>键值对类型</h3><p>&emsp;&emsp;在上一个小节中，我们提到map映射中数据的存储方式是以键-值的方式存储的，同时每一个键都对应于一个值。在上一节的入门案例中，我们只使用了整数类型以及字符串类型作为map的键值，在这一部分中我们将介绍其他的可以作为键值的数据类型。 </p>
<p>&emsp;&emsp;到目前为止，我们已经讲解过的数据类型有：整数类型、浮点类型、布尔类型、字符串类型、数组、切片、函数类型、以及正在讲解的映射类型。那么这些数据类型是否全部都可以作为map的键值类型呢，答案是否定的。在Go语言中切片、映射、和函数是不可以作为map的键的类型的。 </p>
<p>&emsp;&emsp;对于这个规定的理解，我们可以想象一下如下的过程，当我们希望通过一个键来查找值的时候，map中是维护了一个键的列表的。当在这个列表中存在着当前键的时候，才将值进行输出，同时判断两个键值是否相同的方式只有通过==的方式。到目前为止我们所演示的所有案例中，均没有出现过判断两个切片是否相等、两个映射是否相等、以及两个函数是否相等。从某种意义上来说可以判断是否相等的两个值大小需要是固定的，而slice以及map刚好不满足，而function作为一个map的键一般来说也是没有意义的。 </p>
<p>&emsp;&emsp;那么对于map的值类型是否也存在着某些限制，理论上来说，map映射对于value的数据类型是没有限制的，即slice等不可以作为key的类型但是是可以作为value的类型的。不论某个数据类型是值类型还是引用类型，它在内存中都是可以被另一个指针所指向的，因此value的类型是可以任意的。我们通过两小段程序来说明这个问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sys <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">sys[<span class="string">"1"</span>] = slice</span><br><span class="line">fmt.Println(sys)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;第一段程序是可以成功编译运行的，这个map映射的key类型为string字符串，value类型为一个int切片。我们接下来为这个切片赋值，再添加到map中，最终的结果可以成功输出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sys <span class="keyword">map</span>[[]<span class="keyword">int</span>]<span class="keyword">string</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[[]<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">sys2[slice] = <span class="string">"1"</span></span><br><span class="line">fmt.Println(sys)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;第二段程序就无法编译通过了，因为他的key类型是一个int切片，由于int切片是无法通过==或!=来判断的，因此这个map是无法构成的。在编译过程中，会报出：invalid map key type []int的错误。</p>
<h3 id="map的无序性"><a href="#map的无序性" class="headerlink" title="map的无序性"></a>map的无序性</h3><p>&emsp;&emsp;在我们之前所接触到的多数据集合的类型中，例如数组切片等都是有序的集合，即先输入的数据排在前方而后输入的数据排在后方。我们也可以采用某些数据结构或独特的排序方式使之成为有序的状态，例如插入排序、堆排序等。而在Golang的map映射中，这两种特性均不存在，也就是说当遍历map中的数据时，往往不会遵循数据的大小规律以及输入的先后规律。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sys := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="string">"one"</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">"two"</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="string">"three"</span>,</span><br><span class="line">    <span class="number">4</span>: <span class="string">"four"</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">"five"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(sys)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这段程序中我们输出了10次map映射，在这里我就不将执行结果写出来了，因为不同的人在执行这样同一段代码的时候，其结果可能完全不同。但是可以保证的是：map映射中会存在5个数据，且这5个数据均是正确显示的，只是输出的顺序是不同的。 </p>
<p>&emsp;&emsp;出现这个效果的原因是每一次key的遍历顺序不同，而这个不同则是Go语言的设计者的有意为之（虽说我不太理解这个做法）。在其他语言中程序员对于map的遍历时往往依赖于其key的稳定输出顺序，在Go语言中是完全不可以的。不过奇怪的是：在早版本的golang中，输出的key并非是随机化的，无序这个特性是设计者在后续版本中加入的一个特性。 </p>
<p>&emsp;&emsp;再需要提及的一个问题是：map中的值的存储是不连续的，即不像是数组那样两个元素是相连的。在Go语言中键与值的对应关系满足哈希算法，即通过键的值经过某种计算直接得到值的物理地址，从而可以快速查找。因此值的存储是不连续的，不仅如此，value的访问是不可以通过指针访问的，即便是我们知道了value的物理地址，也不能通过*运算来访问。因为当map扩容时，所有的数据可能会采用新的hash算法进行计算，之前的物理地址可能就不再指向原来的数据了。</p>
<h3 id="map的排序"><a href="#map的排序" class="headerlink" title="map的排序"></a>map的排序</h3><p>&emsp;&emsp;既然map的key的遍历是无序的，value的输出也是无序的，当遇到了对map排序的需求时就需要对其做一些变通。此时我们需要用一个数组或切片进行辅助排序。我们就首先遍历map中的键，并将每一个遍历到的键加入到一个切片中。然后对这个切片进行排序，最后按排序后的key进行对应值的查找，进而完成按key的大小排序，程序如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sort"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sys := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="number">1</span>: <span class="string">"one"</span>,</span><br><span class="line">        <span class="number">2</span>: <span class="string">"two"</span>,</span><br><span class="line">        <span class="number">3</span>: <span class="string">"three"</span>,</span><br><span class="line">        <span class="number">4</span>: <span class="string">"four"</span>,</span><br><span class="line">        <span class="number">5</span>: <span class="string">"five"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> keys []<span class="keyword">int</span> = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> key, _ := <span class="keyword">range</span> sys &#123;</span><br><span class="line">        keys = <span class="built_in">append</span>(keys, key)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(keys)</span><br><span class="line">    <span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        fmt.Println(sys[key])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="键的唯一性"><a href="#键的唯一性" class="headerlink" title="键的唯一性"></a>键的唯一性</h3><p>&emsp;&emsp;这个特性是相对好理解的，因为在日常生活中处处存在类似的例子。例如，在一所学校中不会出现两个相同学号的学生，不会出现两个相同身份证号的人。因此这个特性就决定了map映射中每一个key都需要是不同的，而对于value则完全没有要求。例如“信用卡-用户”这个键值对，每个信用卡都可以独特地对应一个人，但是一个人可能对应的不止一个信用卡。对于键的唯一性我们通过代码举例说明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">stu[<span class="number">1</span>] = <span class="string">"Devin"</span></span><br><span class="line">stu[<span class="number">2</span>] = <span class="string">"RuoShui"</span></span><br><span class="line">stu[<span class="number">3</span>] = <span class="string">"RuoShui"</span></span><br><span class="line">stu[<span class="number">1</span>] = <span class="string">"Evelyn"</span></span><br><span class="line">fmt.Println(stu)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在上述的代码中，我们声明了一个map映射，并向其中插入了四条数据，在这四条数据中，我们验证了在Go语言中map的键、值是否可以重复。stu2和stu3的值是相同的，而Devin和Evelyn的键是相同的。通过结果我们可以发现：stu2和stu3是可以共存的，而stu1的Devin值是被Evelyn所覆盖了，因为根据哈希算法，通过一个键值的计算所得到的物理地址是一定的，因此对应于同一个键，只能存在一个值，也就是最后覆盖的那个值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="number">3</span>:RuoShui <span class="number">1</span>:Devin <span class="number">2</span>:Evelyn]</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们针对Go语言中的map映射进行了相对具体的讲解，并介绍了map的键类型与值类型的限制，以及map内key的遍历的无序性和对应的排序方式，最后我们也提及了map映射中键的唯一性。 </p>
<p>&emsp;&emsp;从下个小节开始，我们将开始进入面向对象的部分，讲解Go语言中面向对象的特性以及实现方式，同时也将针对Go语言对面向对象的几大特性的独特的设计理念进行讲解。</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/03/10/36-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%93%E6%9E%84%E4%BD%93/" class="pre">Go语言从入门到放弃系列&lt;36&gt; 面向对象-结构体</a><a href="/2020/03/08/34-map%E6%98%A0%E5%B0%84/" class="next">Go语言从入门到放弃系列&lt;34&gt; map映射</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-35-gt-map映射的细节讨论"><span class="toc-text">Go语言从入门到放弃系列&lt;35&gt; map映射的细节讨论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#键值对类型"><span class="toc-text">键值对类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map的无序性"><span class="toc-text">map的无序性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map的排序"><span class="toc-text">map的排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#键的唯一性"><span class="toc-text">键的唯一性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/21/45-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/">Go语言从入门到放弃系列<45> 面向对象-多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/44-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<44> 面向对象-接口细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/17/43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/">Go语言从入门到放弃系列<43> 面向对象-接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<42> 面向对象-继承细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/">Go语言从入门到放弃系列<41> 面向对象-继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/14/40-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/">Go语言从入门到放弃系列<40> 面向对象-封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/39-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">Go语言从入门到放弃系列<39> 面向对象-方法细节与工厂模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/12/38-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95/">Go语言从入门到放弃系列<38> 面向对象-方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/11/37-%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<37> 结构体细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/36-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%93%E6%9E%84%E4%BD%93/">Go语言从入门到放弃系列<36> 面向对象-结构体</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">45</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>