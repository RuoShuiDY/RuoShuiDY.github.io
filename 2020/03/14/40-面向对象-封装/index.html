<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;40&gt; 面向对象-封装 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;40&gt; 面向对象-封装</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;40&gt; 面向对象-封装</h1><div class="post-meta"><a href="/2020/03/14/40-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/#comments" class="comment-count"></a><p><span class="date">Mar 14, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-40-gt-面向对象-封装"><a href="#Go语言从入门到放弃系列-lt-40-gt-面向对象-封装" class="headerlink" title="Go语言从入门到放弃系列&lt;40&gt; 面向对象-封装"></a>Go语言从入门到放弃系列&lt;40&gt; 面向对象-封装</h2><p>&emsp;&emsp;在面向对象部分的介绍中，我们自始至终地都在强化一种思想，即是抽象的思想。我们在定义一个结构体(类)的时候，实际上就是将一类事物所共有的属性和行为提取出来，建立一个物理模型，就成为了一个类。在这其中,             共有的属性以字段的形式存在，行为以方法的形式存在。这个提取的过程就是抽象的思想，因此我们所说的抽象并不涉及技术上的实现，而是贯穿整个面向对象的一种解决问题的方法。 </p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>&emsp;&emsp;作为面向对象的特性之一，封装的概念在Go语言中也有所体现。封装就是将抽象出来的字段和对字段的操作封装在一起，将数据在内部保护起来，其他的程序只可以通过放出的方法接口来对属性字段进行操作。就如同我们在讲解工厂模式的时候举的例子：学生的年龄只可以读取而不可以在其他包中修改。我们说在这个例子中，我们将年龄这个属性与读取的方法封装在了一起。 </p>
<p>&emsp;&emsp;通过封装的概念，使得程序员在基于他人的代码进行二次开发过程中不需要完全了解其代码实现，只需要了解一个方法应当如何输入，其返回值是什么，对于程序中其他的属性是否存在关联的变动。而这三个方面往往都会在用户的开发文档中或代码注释中标明。 </p>
<p>&emsp;&emsp;举一个很典型的例子：我们普通用户并不需要知道电视机的成像原理，不需要知道其内部的集成电路是如何工作的，也不需要知道红外线控制器的协议过程。我们只需要知道对于一个电视机，哪些按键是开关，哪些按键控制频道，哪些按键控制音量。而一旦电视机出现问题，我们只需要联系维修人员即可。同理，对于其他人的代码，我们只需要知道输入格式，输出格式，而代码中出现bug，则需要联系开发人员，或通过其他途径完成自己的开发需求。</p>
<h3 id="案例讲解"><a href="#案例讲解" class="headerlink" title="案例讲解"></a>案例讲解</h3><p>&emsp;&emsp;假设一个银行在写管理系统，并且我们负责系统中个人账户的部分，要求用户可以查询余额，存钱取钱，且单次取钱额度不超过10k，以及用户之间互相转账的功能，单次转账也不超过50k。我们通过这个小案例进行封装的入门。当然真实的开发操作要比这个复杂地多得多，而且还需要进行加锁操作，数据库操作等等，我们在这里只是针对这个案例进行一个简单的分析和实现而已，只是介绍一下封装的使用方式，对于实现方式就当做一个代码篇来看吧。 </p>
<h3 id="1-属性行为分析"><a href="#1-属性行为分析" class="headerlink" title="1. 属性行为分析"></a>1. 属性行为分析</h3><p>&emsp;&emsp;在代码编写之前，我们往往需要首先分析一下一个类的构成。在这个案例中，我们可以清楚地知道：转账过程需要对方的用户名和本人的密码，查询余额和存钱取钱需要余额的显示，其他的暂时先不需要了。因此我们可以将在Account类中包含三个属性，分别为用户名，密码，和余额。 </p>
<p>&emsp;&emsp;接下来，我们继续分析这个类的行为。根据需求描述，我们可以知道需求中存在着如下的几个行为：查询，存储，取出，转账这四个行为，且这四个行为均是账户管理中的行为。因此对于类的设计中我们可以采用如下的类定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">    UserName <span class="keyword">string</span></span><br><span class="line">    Password <span class="keyword">string</span></span><br><span class="line">    Balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">QueryAccount</span><span class="params">(password <span class="keyword">string</span>)</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">Transfer</span><span class="params">(to *Account, money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-权限控制修改"><a href="#2-权限控制修改" class="headerlink" title="2. 权限控制修改"></a>2. 权限控制修改</h4><p>&emsp;&emsp;在对工厂模式的讲解中，我们介绍到了私有类的访问方式，以及私有属性的访问方式。在大多数情况下，我们将类名以及属性名的首字母小写，使之成为私有，可见性只针对于本包。此时我们需要为之添加一个公有类型的工厂函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> account <span class="keyword">struct</span> &#123;</span><br><span class="line">    userName <span class="keyword">string</span></span><br><span class="line">    password <span class="keyword">string</span></span><br><span class="line">    balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAccount</span><span class="params">(userName <span class="keyword">string</span>, password <span class="keyword">string</span>)</span> *<span class="title">account</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;account&#123;</span><br><span class="line">        userName: userName,</span><br><span class="line">        password: password,</span><br><span class="line">        balance: <span class="number">0.0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述程序中，我们添加了NewAccount函数，且需要两个入参分别为用户名和密码，在函数中为本类中的userName和password赋值，同时我们设定balance的初始值为0。</p>
<h4 id="3-方法的实现"><a href="#3-方法的实现" class="headerlink" title="3. 方法的实现"></a>3. 方法的实现</h4><p>&emsp;&emsp;我们首先完成余额查询的功能。在这个功能中我们需要首先判断输入的密码是否与account中的密码相匹配，如果匹配则输出对应的balance属性的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *account)</span> <span class="title">QueryAccount</span><span class="params">(password <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> password == a.password &#123;</span><br><span class="line">        fmt.Println(a.balance)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"密码错误！"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来我们完成存款的实现，首先依旧是判断输入密码是否与account中密码相同，如果相同则将balance加上对应的金额：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *account)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> password == a.password &#123;</span><br><span class="line">        a.balance += money</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"密码错误！"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来是取钱的操作，它与存钱的区别便是一次性取钱不能超过10k，且余额不能小于0。 在密码得以匹配和上述条件均满足的情况下，balance的值减少对应的money金额：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *account)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> password == a.password &#123;</span><br><span class="line">        <span class="keyword">if</span> money &gt;= <span class="number">10000</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"超出额度"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> money &gt; a.balance &#123;</span><br><span class="line">            fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        a.balance -= money</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"密码错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后是转账操作的实现，一次转账操作可以相当于两个行为：一方的取出操作和另一方的存入操作。取出操作依旧遵循上述的判断过程，存入操作不需要什么其他的限制：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *account)</span> <span class="title">Transfer</span><span class="params">(to *account, money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> password == a.password &#123;</span><br><span class="line">        <span class="keyword">if</span> money &gt;= <span class="number">50000</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"超出额度"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> money &gt; a.balance &#123;</span><br><span class="line">            fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        a.balance -= money</span><br><span class="line">        to.balance += money</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"密码错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> acc1 = test.NewAccount(<span class="string">"DENG"</span>, <span class="string">"123456"</span>)</span><br><span class="line">    <span class="keyword">var</span> acc2 = test.NewAccount(<span class="string">"YANG"</span>, <span class="string">"654321"</span>)</span><br><span class="line">    acc1.SaveAccount(<span class="number">5000</span>, <span class="string">"123456"</span>)</span><br><span class="line">    acc1.WithdrawAccount(<span class="number">2000</span>, <span class="string">"123456"</span>)</span><br><span class="line">    acc1.Transfer(acc2, <span class="number">1000</span>, <span class="string">"123456"</span>)</span><br><span class="line">    acc1.QueryAccount(<span class="string">"123456"</span>)</span><br><span class="line">    acc2.QueryAccount(<span class="string">"654321"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最终我们在demo文件下的main包中进行功能的测试，我们只写了简单的几个过程，并没有将所有的功能全部都测试完全，代码也只是作为demo说明而已。其结果为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2000</span></span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这两个数值的输出也一定程度上证实了主要功能的正确，对于其他的错误的输出没有做任何的测试。</p>
<h3 id="封装规则"><a href="#封装规则" class="headerlink" title="封装规则"></a>封装规则</h3><p>&emsp;&emsp;在Go语言的开发过程中，其实并没有特别强调封装的概念。Go语言说起来并没有对面向过程或面向对象有着明显的倾向性，它对于面向对象的实现也有着自己一套的灵活的实现方式。它与Java语言，C/C++语言不同，不能以传统的面向对象的语法特性看待Go语言。Go语言本身而言对面向对象的概念是做了一定的简化的。 </p>
<p>&emsp;&emsp;相较于传统面向对象的开发习惯，Go语言的封装规则可以总结为一下的几个步骤： </p>
<p>&emsp;&emsp;1. 将结构体和属性字段的首字母小写，将其变为私有属性，在其他包中不可导出，类似于传统面向对象中的private属性。 </p>
<p>&emsp;&emsp;2. 为结构体所在包提供一个工厂函数，函数的首字母大写，该函数可以在其他包中被调用，导出结构体实例指针。 </p>
<p>&emsp;&emsp;3. 为私有属性提供首字母大写的SetXXX方法，在该方法中对属性进行判断与赋值。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *XXX)</span> <span class="title">SetYYY</span> <span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line">    ...  <span class="comment">//数据验证等操作</span></span><br><span class="line">    x.YYY = 参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;4. 为私有属性提供首字母大学的GetXXX方法，在该方法中返回该属性的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *XXX)</span> <span class="title">GetYYY</span> <span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.YYY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们讲解了Go语言中面向对象概念中的封装，并通过一个案例讲解了封装思路。可以说，封装是一种思想而不是一种技术，因此开发人员需要在日常开发中多多积累相应经验。由于它是思想，因此不同的人对这个思想的理解倾向性不同，因此很难辨明孰是孰非。针对于同一个需求，开发的思路也不同。笔者开发经验也不多，在一些问题上考虑地也并不完善，说的不到的地方希望见谅。 </p>
<p>&emsp;&emsp;在下一个小节中，我们将开始讲解面向对象特性中的另一个概念，继承。继承与封装不太相似，继承是一个技术点，因此具备一定的语法规则，我们会在下几节中详细地说明。</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/03/15/41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/" class="pre">Go语言从入门到放弃系列&lt;41&gt; 面向对象-继承</a><a href="/2020/03/13/39-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="next">Go语言从入门到放弃系列&lt;39&gt; 面向对象-方法细节与工厂模式</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-40-gt-面向对象-封装"><span class="toc-text">Go语言从入门到放弃系列&lt;40&gt; 面向对象-封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#封装"><span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#案例讲解"><span class="toc-text">案例讲解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-属性行为分析"><span class="toc-text">1. 属性行为分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-权限控制修改"><span class="toc-text">2. 权限控制修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-方法的实现"><span class="toc-text">3. 方法的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-测试"><span class="toc-text">4.测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#封装规则"><span class="toc-text">封装规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/24/47-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%BA%8C/">Go语言从入门到放弃系列<47> 文件与IO<二></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/22/46-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%B8%80/">Go语言从入门到放弃系列<46> 文件与IO<一></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/21/45-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/">Go语言从入门到放弃系列<45> 面向对象-多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/44-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<44> 面向对象-接口细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/17/43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/">Go语言从入门到放弃系列<43> 面向对象-接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<42> 面向对象-继承细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/">Go语言从入门到放弃系列<41> 面向对象-继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/14/40-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/">Go语言从入门到放弃系列<40> 面向对象-封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/39-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">Go语言从入门到放弃系列<39> 面向对象-方法细节与工厂模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/12/38-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95/">Go语言从入门到放弃系列<38> 面向对象-方法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">47</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>