<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;48&gt; JSON与序列化 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;48&gt; JSON与序列化</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;48&gt; JSON与序列化</h1><div class="post-meta"><a href="/2020/03/25/48-JSON%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/#comments" class="comment-count"></a><p><span class="date">Mar 25, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-48-gt-JSON与序列化"><a href="#Go语言从入门到放弃系列-lt-48-gt-JSON与序列化" class="headerlink" title="Go语言从入门到放弃系列&lt;48&gt; JSON与序列化"></a>Go语言从入门到放弃系列&lt;48&gt; JSON与序列化</h2><p>&emsp;&emsp;在上个小节中，我们讲解了Go语言中文件的各个基本操作。在这个小节中，我们将对Go语言中的序列化与反序列化的方式进行讲解，同时也对JSON数据格式进行提及。这个小节的核心其实就是两个函数的使用，其他的基本都是针对这两个函数进行细节的讲解。首先我们先简要介绍JSON的数据格式。</p>
<h3 id="JSON数据格式"><a href="#JSON数据格式" class="headerlink" title="JSON数据格式"></a>JSON数据格式</h3><p>&emsp;&emsp;JSON是一种轻量级的数据交换格式，易于人的阅读与机器的解析和生成。JSON是JavaScript Object Notation的简写。其层次结构简洁清晰，因此迅速成为了一种流行且理想的数据交换语言。在JS语言中一切均是对象，所以任何对象都可以通过JSON来表示，字符串、数组、数字、对象等均可以表示。在这里我们并不需要掌握JS语言，也不需要理解JS与JSON到底有什么关系，我们目前所关心的只是这种交互数据格式。 </p>
<p>&emsp;&emsp;我们举一个数据交互的例子：假如我们用Go语言写出了即时通讯的客户端与服务器（类比于QQ），当用户之间进行通信时，就需要一个客户端将信息发送给服务器，服务器将信息转交给另一个客户端。那么客户端到底发出了什么消息，这个就是交互数据。同理假如我们通过网页访问服务器，例如CRM系统后台，我们依旧需要从浏览器发出一个HTTP请求，请求中带有需要交互的数据。 </p>
<p>&emsp;&emsp;可以说交互数据就是双方的一种协议，双方规定好数据如何传输，某一个键到底对应了什么值。一旦这些规定都完成后，前后台就可以基本完全地分离，甚至双方所用的技术语言都可以不同，只要他们按规定传输数据、按规定解析数据即可。 </p>
<p>&emsp;&emsp;既然是规定协议，那么JSON就需要遵循几个规则，其规则如下：</p>
<h4 id="1-大括号保存对象"><a href="#1-大括号保存对象" class="headerlink" title="1.大括号保存对象"></a>1.大括号保存对象</h4><p>&emsp;&emsp;所有JSON对象都是存在于一对大括号之间的，大括号可以进行嵌套。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-键值对表示对象"><a href="#2-键值对表示对象" class="headerlink" title="2.键值对表示对象"></a>2.键值对表示对象</h4><p>&emsp;&emsp;键值对的概念我们曾经在map映射部分进行过提及，因此这里不对键值对的概念再做什么说明。键与值之间用冒号进行连接，不同数据之间用逗号分隔。例如我们想传输某个学生的信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Devin"</span>,<span class="string">"age"</span>:<span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-中括号保存数组"><a href="#3-中括号保存数组" class="headerlink" title="3.中括号保存数组"></a>3.中括号保存数组</h4><p>&emsp;&emsp;一旦一个JSON对象需要传输多组数据，那么就需要用中括号来保存数组。数组中的每一个元素均遵循大括号保存对象与键值对表示对象的原则，例如我们希望传输两个学生的信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="string">"name"</span>:<span class="string">"DENG"</span>,<span class="string">"age"</span>:<span class="number">25</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"YANG"</span>,<span class="string">"age"</span>:<span class="number">24</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这个JSON字符串中，我们可以发现，中括号中具有两个部分，每个部分都是一个对象，即分别由大括号包裹，每个大括号中又分别有name和age两个属性。 </p>
<p>&emsp;&emsp;不仅如此，JSON字符串中还可以保存普通的数组，甚至普通的基本数据，可以讲JSON确实是便于传输的数据格式，在AJAX框架中，JSON就是其专门的传输格式。当然上面说的这些也不重要，只需要能够看懂即可（相信大多数人一下子就都能看懂），同时我们也基本不会要求手写JSON数据，因为这种数据的生成往往是靠程序完成的。因此接下来我们将介绍在Go语言中JSON字符串的生成与解析。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>&emsp;&emsp;理论上来说，序列化与JSON是没有关系的，只是说在Go语言中JSON是序列化的一个良好的形式。序列化是将对象的状态信息转换成可以存储或可以传输的形式的过程。我们举一个例子，假如我们的程序中有Student类，类中有Name和Age属性，在main函数中我们定义了一个数组，数组中包含5个Student对象，现在我们希望将这5个学生对象存在硬盘中，以备在程序关闭后下次执行的时候读取它，也就是一个保存的过程。 </p>
<p>&emsp;&emsp;面对这个需求，我们可能会想出如下的一个保存方式：将5个学生的信息整合成为一个字符串，属性之间用空格隔开，不同的对象之间用回车隔开，然后用IO存在本地的记事本中。这个过程其实包含了两个步骤，一个时Student对象的序列化，一个是序列化后的持久化。我们按时不看持久化过程，只看序列化过程，我们将信息整合成为一个字符串之后，就可以存储在本地，或者将这个字符串发送给其他客户端或服务器。而如果不进行序列化，对象只是在内存中的一段空间而已，是无法存储或传输的。 </p>
<p>&emsp;&emsp;当然，序列化不仅仅是整合成为一个字符串那么简单，它还可以整合成为其他的形式，有其他的协议规定。因此我们说JSON是一个序列化的一种合适的形式，xml文件也可以成为一种序列化的形式，我们这里只介绍JSON。 </p>
<h4 id="1-类的序列化"><a href="#1-类的序列化" class="headerlink" title="1.类的序列化"></a>1.类的序列化</h4><p>&emsp;&emsp;由于JSON数据的基本格式是键值对，因此类属性的定义刚好就天然地满足了键值对的格式，因此我们就先从类的序列化开始。首先我们定义一个Student类，包含Name属性和Age属性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后我们在main函数中实例化一个Student类，并为之赋值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s Student = Student&#123;<span class="string">"DENG"</span>, <span class="number">25</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;现在数据已经准备好了，我们接下来就开始对s进行序列化，我们首先需要引入一个包：encoding/json，然后使用该包中的Marshal()函数，我们将s对象传入，并得到两个返回值，分别为序列化后的数据data和error对象。得到的data数据是是个byte切片，我们在输出时将其转换为string类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s Student = Student&#123;<span class="string">"DENG"</span>, <span class="number">25</span>&#125;</span><br><span class="line">    data, err := json.Marshal(s)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"序列化失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;执行了上述程序之后，我们将会发现其结果为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"Name"</span>:<span class="string">"DENG"</span>,<span class="string">"Age"</span>:<span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们发现这个JSON字符串中的key值刚好就是Student类中的两个属性名，字符串中的value值则是我们为之赋值的数据。 </p>
<p>&emsp;&emsp;在这段程序中，我们会发现一个问题，在多人协作开发的过程中，往往需要key值都是小写的，如果我们将属性名的首字母变为小写，序列化的结果就是空的。这是因为我们是使用其他包中的函数，如果我们定义的属性是小写，则属性对于其他包是不可导出的，那么json包中当然就读不到对应的属性了，这个解决办法就是为属性添加tag利用反射的方式完成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">    Age <span class="keyword">int</span>  <span class="string">`json:"age"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们加入了tag之后（数字1的左面的键，tab的上面的键），相当于告诉了json包，在序列化的过程中，将Name的key变为name，将Age这个key变为age，就完成了对应的功能。具体实现原理暂时不做解释，我们将会在反射的章节中详细说明。</p>
<h4 id="2-map映射的序列化"><a href="#2-map映射的序列化" class="headerlink" title="2.map映射的序列化"></a>2.map映射的序列化</h4><p>&emsp;&emsp;在Go语言中，不仅类属性满足于键值对的形式，map映射依旧满足于这个形式，在这个部分中，我们将举例讲解map的序列化的方式。 </p>
<p>&emsp;&emsp;我们首先定义一个map映射，map中的key是字符串类型，map中的value是空接口类型(interface{})，（回忆一下接口的实现原理：一个数据类型实现了接口中定义的方式则认为实现了该接口，同时该数据可以将指针赋值给接口实例）因为接口是空的，没有定义任何的方法，因此也可以说一切都实现了空接口，也就是一切都能作为map的值。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    m[<span class="string">"name"</span>] = <span class="string">"DENG"</span></span><br><span class="line">    m[<span class="string">"age"</span>] = <span class="number">25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此时name所对应的value是字符串”DENG”，age所对应的value是整数25，现在我们将map映射进行序列化操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    m[<span class="string">"name"</span>] = <span class="string">"DENG"</span></span><br><span class="line">    m[<span class="string">"age"</span>] = <span class="number">25</span></span><br><span class="line">    data, err := json.Marshal(m)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"序列化错误"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们会发现，其结果是类似的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"age"</span>:<span class="number">25</span>,<span class="string">"name"</span>:<span class="string">"DENG"</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-切片的序列化"><a href="#3-切片的序列化" class="headerlink" title="3.切片的序列化"></a>3.切片的序列化</h4><p>&emsp;&emsp;根据之前的理解，切片中存储这多个同类型的数据，因此其序列化的结果应当是一个数组结合，在接下来的案例中，我们将实例化两个Student对象，并将对象放入切片中，最后序列化该切片，切片技术等都已然讲解过，因此直接通过代码体现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]Student, <span class="number">0</span>)</span><br><span class="line">    stu1 := Student&#123;<span class="string">"DENG"</span>, <span class="number">25</span>&#125;</span><br><span class="line">    stu2 := Student&#123;<span class="string">"YANG"</span>, <span class="number">24</span>&#125;</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">append</span>(s, stu1)</span><br><span class="line">    s = <span class="built_in">append</span>(s, stu2)</span><br><span class="line"></span><br><span class="line">    data, err := json.Marshal(s)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"序列化错误"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们会发现，其结果为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="string">"name"</span>:<span class="string">"DENG"</span>,<span class="string">"age"</span>:<span class="number">25</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"YANG"</span>,<span class="string">"age"</span>:<span class="number">24</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;同理，假如我们切片中存储的是map映射，其结果依旧类似，我们就不在这里赘述了。</p>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>&emsp;&emsp;作为序列化的逆过程，反序列化似乎就不难理解了。假如当我们从网络或者从文本文件中读取到了一个JSON字符串，我们想将其反过来赋值给一个map，一个类，或者一个切片，所用到的技术就是就反序列化技术。</p>
<h4 id="1-反序列化为类对象"><a href="#1-反序列化为类对象" class="headerlink" title="1. 反序列化为类对象"></a>1. 反序列化为类对象</h4><p>&emsp;&emsp;作为类的序列化的逆过程，我们需要首先具备JSON字符串，以及需要类的定义，然后才能通过该技术获取对象，我们通过案例来说明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">`&#123;"name":"DENG","age":25&#125;`</span></span><br><span class="line">    <span class="keyword">var</span> s Student</span><br><span class="line">    err := json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;s)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"反序列化失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在代码中，首先需要说明的一点是：我们在定义字符串的过程中采用了反引号（`），这是因为我们希望在字符串中保留双引号，否则我们需要通过转义的形式保留双引号。反引号的使用可以使其原样保存。 </p>
<p>&emsp;&emsp;第二点需要说明的是，我们传入Unmarshal函数的是Student对象指针，因为我们需要在Unmarshal函数中改变s内的值（直接传入s对象是错误的）。这段代码的结果为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;DENG <span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里还需要注意的一点是：假如此时我们的Student类中的Age属性（加了tag）的数据类型改为int8，反序列化依旧能够成功，因为在类型转换的时候没有出现问题。现在假如我们将25变为225，并将Age的类型改为int8，由于类型转换有误，所以输出结果为：反序列化失败。通过这个问题我们可以发现：JSON反序列化的本质就是字符串转换为其他类型而已，与生成JSON字符串的原类型无关。</p>
<h4 id="2-反序列化为map"><a href="#2-反序列化为map" class="headerlink" title="2. 反序列化为map"></a>2. 反序列化为map</h4><p>&emsp;&emsp;如果我们将Student类定义看成一个模板，将JSON字符串看做为内容，反序列化的工作就是将内容向模板上填充。反序列化为map也是一样的，我们定义一个map作为数据模板，然后将内容填充进去：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">`&#123;"name":"DENG","age":25&#125;`</span></span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    err := json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;m)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"反序列化失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, m[<span class="string">"age"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述程序中，我们定义了一个map，map的key是string类型，值是空接口，然后我们将str对应的byte切片和m指针传入。同时，我们又数据了m[“age”]所对应的数据类型:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[name:DENG age:<span class="number">25</span>]</span><br><span class="line"><span class="keyword">float64</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过结果我们可以发现：反序列化的结果是正确的，且JSON中的key值成为了map中的key，JSON中的键值变为了map中的value。同时我们还可以发现的是，在Unmarshal函数中对数字空接口类型的解读统一为float64。</p>
<h4 id="3-反序列化为切片"><a href="#3-反序列化为切片" class="headerlink" title="3. 反序列化为切片"></a>3. 反序列化为切片</h4><p>&emsp;&emsp;同理，我们定义一个切片，切片中保存的是Student类，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">`[&#123;"name":"DENG","age":25&#125;,&#123;"name":"YANG","age":24&#125;]`</span></span><br><span class="line">    <span class="keyword">var</span> s []Student</span><br><span class="line">    err := json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;s)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"反序列化失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此处我们依旧可以发现，切片s在程序中是不需要make函数的，因为在Unmarshal函数中已然帮我们make过了，上述的程序的输出结果为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;DENG <span class="number">25</span>&#125; &#123;YANG <span class="number">24</span>&#125;]</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p> &emsp;&emsp;在这个小节中，我们讲解了JSON数据类型的构成及其遵循的格式。同时，我们也讲解了Go语言中序列化与反序列化的方式方法，同时也简单说明了在这两个过程中需要注意的几个小点。序列化与反序列化在文件开发与网络开发中起着十分重要的作用，现在xml格式与json格式是传输数据中最为常用的两种模式，xml的序列化方式在encoding/xml包中，读者如果有兴趣可以自行自学尝试一下。</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/03/26/49-Goroutine%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/" class="pre">Go语言从入门到放弃系列&lt;49&gt; Goroutine概念简介</a><a href="/2020/03/24/47-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%BA%8C/" class="next">Go语言从入门到放弃系列&lt;47&gt; 文件与IO&lt;二&gt;</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-48-gt-JSON与序列化"><span class="toc-text">Go语言从入门到放弃系列&lt;48&gt; JSON与序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON数据格式"><span class="toc-text">JSON数据格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-大括号保存对象"><span class="toc-text">1.大括号保存对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-键值对表示对象"><span class="toc-text">2.键值对表示对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-中括号保存数组"><span class="toc-text">3.中括号保存数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#序列化"><span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-类的序列化"><span class="toc-text">1.类的序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-map映射的序列化"><span class="toc-text">2.map映射的序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-切片的序列化"><span class="toc-text">3.切片的序列化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反序列化"><span class="toc-text">反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-反序列化为类对象"><span class="toc-text">1. 反序列化为类对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-反序列化为map"><span class="toc-text">2. 反序列化为map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-反序列化为切片"><span class="toc-text">3. 反序列化为切片</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/49-Goroutine%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/">Go语言从入门到放弃系列<49> Goroutine概念简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/25/48-JSON%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/">Go语言从入门到放弃系列<48> JSON与序列化</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/24/47-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%BA%8C/">Go语言从入门到放弃系列<47> 文件与IO<二></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/22/46-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%B8%80/">Go语言从入门到放弃系列<46> 文件与IO<一></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/21/45-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/">Go语言从入门到放弃系列<45> 面向对象-多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/44-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<44> 面向对象-接口细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/17/43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/">Go语言从入门到放弃系列<43> 面向对象-接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<42> 面向对象-继承细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/">Go语言从入门到放弃系列<41> 面向对象-继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/14/40-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/">Go语言从入门到放弃系列<40> 面向对象-封装</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">49</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>