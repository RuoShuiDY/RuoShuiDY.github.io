<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;28&gt; 数组引入 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;28&gt; 数组引入</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;28&gt; 数组引入</h1><div class="post-meta"><a href="/2020/03/02/28-%E6%95%B0%E7%BB%84%E5%BC%95%E5%85%A5/#comments" class="comment-count"></a><p><span class="date">Mar 02, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-28-gt-数组引入"><a href="#Go语言从入门到放弃系列-lt-28-gt-数组引入" class="headerlink" title="Go语言从入门到放弃系列&lt;28&gt; 数组引入"></a>Go语言从入门到放弃系列&lt;28&gt; 数组引入</h2><p>&emsp;&emsp;在这之前的各个小节中，我们所接触到的都是简单的数据类型。包括指针类型在内，每一个变量都只可以表示一个值，且这个值的类型一旦确定就不可以改变。在这几个小节中，我们将会接触到Go语言中的一个复杂数据类型，数组。且在这一小节中，我们将引出数组的定义与使用场景，并对其基础操作进行简要的说明。</p>
<h3 id="数组的引入"><a href="#数组的引入" class="headerlink" title="数组的引入"></a>数组的引入</h3><p>&emsp;&emsp;现在我们依旧通过一个案例来完成数组的引入，我们现在有这样一个需求：假设一个小班级里面有五个人，要求输入每一个人的成绩，最后输出其平均成绩。这个需求我们如果使用之前的方式来完成也是没有难度的，我们可以定义五个变量，分别输入后再取平均值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> grade1, grade2, grade3, grade4, grade5 <span class="keyword">float32</span></span><br><span class="line">    fmt.Scanln(&amp;grade1)</span><br><span class="line">    fmt.Scanln(&amp;grade2)</span><br><span class="line">    fmt.Scanln(&amp;grade3)</span><br><span class="line">    fmt.Scanln(&amp;grade4)</span><br><span class="line">    fmt.Scanln(&amp;grade5)</span><br><span class="line">    <span class="keyword">var</span> average <span class="keyword">float32</span> = (grade1 + grade2 + grade3 + grade4 + grade5) / <span class="number">5</span></span><br><span class="line">    fmt.Printf(<span class="string">"平均成绩是:%.2f\n"</span>, average)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上述的代码显然可以正确地完成我们提及的需求，但是这种实现方式似乎不是很美观。首先定义五个变量的写法有些过于臃肿，然后输入成绩的操作显然是重复操作因此最好使用循环完成，再有求平均成绩的时候需要将所有的变量相加也是比较臃肿。同时还有一个最大的问题：一旦数据量变大，例如一个专业里面有300个学生，这样不论是变量定义还是代码书写，就都会是一个极大的挑战。 </p>
<p>&emsp;&emsp;因此在这里我们引出数组的概念：数组即有序的元素序列，是若干个连续的有限个数的相同类型的变量的集合。集合的名称我们称之为数组名，其中的变量称为数组的元素。我们先使用数组的方式将上述代码改写，然后再针对数组的基础知识进行讲解：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> grades [<span class="number">5</span>]<span class="keyword">float32</span></span><br><span class="line">    <span class="keyword">var</span> average <span class="keyword">float32</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(grades); i++ &#123;</span><br><span class="line">        fmt.Scanln(&amp;grades[i])</span><br><span class="line">        average += grades[i]</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"平均成绩为:%.2f\n"</span>, average/<span class="keyword">float32</span>(<span class="built_in">len</span>(grades)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过数组的写法我们就弥补了我们所提及的几个缺点，我们不用定义五个变量，而是定义一个可以代表五个变量的变量。同时赋值操作与加和操作在循环中进行，不需要手动完成多个重复代码的书写。</p>
<h3 id="数组的定义与初始化"><a href="#数组的定义与初始化" class="headerlink" title="数组的定义与初始化"></a>数组的定义与初始化</h3><p>&emsp;&emsp;现在我们想，如果我们希望用一个变量来代表多个变量的集合，我们需要明确存储的变量的数据类型、以及需要存储的变量的个数，因此在数组的定义过程中，这两个要素是必不可少的。其定义方式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 [数组大小]数据类型</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;例如，我们希望在数组中存储10个整数，我们可以定义为：var name [10]int,同理存储5个字符串可以定义为：var name [5]string，其他的例子我们就不过多地列举了。 </p>
<p>&emsp;&emsp;数组的定义可以通过上述的方式进行，接下来我们讲数组的初始化操作。初始化就是在定义的时候进行赋值，在Go语言中，数组的初始化可以有以下的五种表示方式，我们通过三个整数的数组举例： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">var</span> nums [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在第一种初始化的操作中，可以说十分的中规中矩，赋值号前面的部分是数组的定义部分，赋值号后的部分则指定了数组中三个元素分别对应的值。那么既然在赋值号前后都有[3]int的书写，这样完全重复了，因此我们也可以将定义部分的类型省略，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span> <span class="keyword">var</span> nums = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果继续向下说，其实在初始化的时候，甚至连数组的大小都不需要提供，编译器可以根据大括号里面的值的个数来确定其数组的大小。但是这只局限于数组中每一个数据都被初始化的前提下，一旦假如我们只初始化三个值而数组大小为四个值时就不适用了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span> <span class="keyword">var</span> nums = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述的初始化形式中，我们可以使用…来代表数组的大小，其真实大小根据大括号中的个数而定。在有些情况下，我们需要分别对数组中的某个或某几个值进行初始化，且明确表明了这几个数的下标，也是可以的，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span> <span class="keyword">var</span> nums [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>: <span class="number">100</span>, <span class="number">1</span>: <span class="number">200</span>, <span class="number">2</span>: <span class="number">300</span>&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这种状态下，我们通过冒号的方式，来完成对某些特定值的初始化，例如对第0个值初始化为100，第1个值初始化为200，第2个值初始化为300（数组中下标是从0开始）。当然，数组的初始化过程是支持类型推导的，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.</span> nums := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组在内存中的形式"><a href="#数组在内存中的形式" class="headerlink" title="数组在内存中的形式"></a>数组在内存中的形式</h3><p>&emsp;&emsp;在数组的定义中，我们说数组是一段连续的同样数据类型的数据结构。换句话说，数组中每一个元素在内存中都是相连的。在之前的变量定义中，每一个变量所分配的内存空间可能是随机的，甚至说之间几乎没有任何的关系，而数组是不相同的。我们采用一个图片来表示（本次数组的首地址是0x0000580e0，不同的机器可能会不同）：<br> <img src="/2020/03/02/28-%E6%95%B0%E7%BB%84%E5%BC%95%E5%85%A5/1.png" alt></p>
<p>&emsp;&emsp;在上图中，我们可以发现，数组中的数据存储确实是连续的。同时，两个数之间的内存地址的差为8（十六进制），这个内存地址的差其实就是定义的数据类型所占据的内存空间。因此在数组定义的过程中，存放的数据类型是需要明确指明的，否则在空间的分配上会出现问题。我们举一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">3</span>]<span class="keyword">int8</span> = [<span class="number">3</span>]<span class="keyword">int8</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%p,%p,%p"</span>, &amp;nums[<span class="number">0</span>], &amp;nums[<span class="number">1</span>], &amp;nums[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述的程序中，我们在数组中定义了三个int8类型的变量，且在输出语句中我们将这三个变量的物理地址输出，得到的结果如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xc00005a080</span>,<span class="number">0xc00005a081</span>,<span class="number">0xc00005a082</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从上述输出，我们可以看出：由于int8整数在内存中占据了8个二进制位，即一个字节，因此两个元素所在的物理地址的差值为1。再换句话说，只要我们知道了数组的首地址和数据类型，我们就可以根据地址直接取出指定位置的数据，这也正是数组在做二分查找等算法优化时的一大优点。同时在Go语言中，对数组名进行取地址的运算，就相当于对数组的第一个元素（下标为0）进行取地址的运算：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%p,%p"</span>,&amp;nums, &amp;nums[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述的程序语句中，其输出的结果是相同的。当进行数组作为函数参数进行传递时，数组名可以直接传入以代表整个数组，这个特性在使用过程中是十分常见的。</p>
<h3 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h3><p>&emsp;&emsp;在上述我们所举的各个案例中，我们可以发现<strong>数组的元素下标是从0开始的</strong>，不同的语言对这个特性的支持是不相同的。例如我们定义的var names [3]int，其取值范围为names[0],names[1],names[2]，而不会出现names[3]，一旦出现了这个问题，编译器会报出数组越界的错误。因此在数组的遍历过程中，我们往往会使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; <span class="built_in">len</span>(names); i++ &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;也就是说，局部变量i的值是从0开始，一直取到数组长度-1位置，如果不小心将条件写为i&lt;=len(names)则一定会报出数组越界的错误。这个错误一般在实际开发中很少会出现，但是在认证考试中可能会成为一个迷惑考试的一个考点。 </p>
<p>&emsp;&emsp;在对数组遍历的时候，我们可以采用上述方式进行逐个遍历，其实在数组中还可以采用我们在讲解循环结构时讲到的for-range结构进行遍历。for关键字后跟随两个变量，分别代表当前遍历到的下标值和该下标值所对应的变量，range关键字后跟随的是需要被遍历的数组，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> names &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里需要说明的是，index和value两个变量是在for循环内部可见的局部变量，换句话说，其作用域只在for结构之中。同时，此处的index所表示的内容与上一段程序中i所表示的内容是相同的，因此我们依旧可以不使用value这个关键字而依旧使用names[index]来表示内容，但是Go语言中变量定义后不可以不使用，因此在value处需要用下划线(‘_’)来接收。这种用法一般不会有人这样使用。 </p>
<p>&emsp;&emsp;同理，当用户只需要关注遍历到的各个值而不需要关注这个值所在的位置序号时，index的值就可以被省略了，同时，index处需要用下划线所表示（下划线的含义在标识符小节中有提到）。</p>
<h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>&emsp;&emsp;在这个小节中，我们通过输入多个学生成绩的问题简述了之前的解决方式存在的问题，从而引出了Go语言中的数组的概念，同时也讲解了数组的定义方式以及几种初始化的方式。我们也介绍了数组在内存中的存储方式以及遍历数组时采用的两种循环方式。 </p>
<p>&emsp;&emsp;在下一小节中，我们将针对数组的使用的细节做出相对深入的讨论和讲解，并与之前所讲解到的值类型等知识相互关联对数组进行更为深刻的解释。</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/03/03/29-%E6%95%B0%E7%BB%84%E7%BB%86%E8%8A%82%E8%AE%B2%E8%A7%A3/" class="pre">Go语言从入门到放弃系列&lt;29&gt; 数组细节讲解</a><a href="/2020/03/01/27-%E9%97%AD%E5%8C%85%E3%80%81defer%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/" class="next">Go语言从入门到放弃系列&lt;27&gt; 闭包、defer与作用域</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-28-gt-数组引入"><span class="toc-text">Go语言从入门到放弃系列&lt;28&gt; 数组引入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数组的引入"><span class="toc-text">数组的引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组的定义与初始化"><span class="toc-text">数组的定义与初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组在内存中的形式"><span class="toc-text">数组在内存中的形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组的使用"><span class="toc-text">数组的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小节"><span class="toc-text">小节</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/21/45-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/">Go语言从入门到放弃系列<45> 面向对象-多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/44-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<44> 面向对象-接口细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/17/43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/">Go语言从入门到放弃系列<43> 面向对象-接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<42> 面向对象-继承细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/">Go语言从入门到放弃系列<41> 面向对象-继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/14/40-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/">Go语言从入门到放弃系列<40> 面向对象-封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/39-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">Go语言从入门到放弃系列<39> 面向对象-方法细节与工厂模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/12/38-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95/">Go语言从入门到放弃系列<38> 面向对象-方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/11/37-%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<37> 结构体细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/36-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%93%E6%9E%84%E4%BD%93/">Go语言从入门到放弃系列<36> 面向对象-结构体</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">45</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>