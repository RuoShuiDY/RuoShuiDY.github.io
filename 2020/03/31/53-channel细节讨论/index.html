<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;53&gt; channel细节讨论 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;53&gt; channel细节讨论</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;53&gt; channel细节讨论</h1><div class="post-meta"><a href="/2020/03/31/53-channel%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/#comments" class="comment-count"></a><p><span class="date">Mar 31, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-53-gt-channel细节讨论"><a href="#Go语言从入门到放弃系列-lt-53-gt-channel细节讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;53&gt; channel细节讨论"></a>Go语言从入门到放弃系列&lt;53&gt; channel细节讨论</h2><p>&emsp;&emsp;在上个小节中，我们讲解了Go语言中channel的定义与初始化方式，数据插入提取操作，以及主线程等待子协程运行结束的方式。在这个小节中，我们将针对channel的其他几个细节进行讲解。我们将提及管道的关闭，遍历，阻塞机制，以及只读只写的管道定义。最后我们还将针对子协程中异常捕获的方式作出简要的介绍。</p>
<h3 id="管道的关闭"><a href="#管道的关闭" class="headerlink" title="管道的关闭"></a>管道的关闭</h3><p>&emsp;&emsp;在之前的小节中，我们只讲解到了channel的定义，相当于channel的打开，但没有讲解到channel变量的关闭。在很多情况下channel的关闭是具备一些作用的，同时channel的关闭操作也影响channel的遍历阻塞情况。我们一一来讲解以上的内容。 </p>
<p>&emsp;&emsp;对于channel变量的关闭操作，Go语言提供了一个内置函数close，其参数就是任意类型的channel变量。换句话说，close函数所在的包就是Go语言中的builtin包，因此无需要引入任何其他的包。我们通过入门案例来说明其用法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    channel &lt;- <span class="number">1</span></span><br><span class="line">    channel &lt;- <span class="number">2</span></span><br><span class="line">    channel &lt;- <span class="number">3</span></span><br><span class="line">    num := &lt;-channel</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">    <span class="built_in">close</span>(channel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们只需要close(channel)就可以关闭我们希望关闭的管道了。关闭在关闭过后将会有以下的几个性质：</p>
<p>&emsp;&emsp;1. 不可以继续向管道内写入数据，否则将出现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: send on closed channel</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. 可以继续从管道内读取数据，且当管道已然空了之后再读取不会出现panic，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    channel &lt;- <span class="number">1</span></span><br><span class="line">    channel &lt;- <span class="number">2</span></span><br><span class="line">    <span class="built_in">close</span>(channel)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        fmt.Println(&lt;-channel)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们在这段程序中初始化了一个容量为3的管道，向管道中插入2个数据，但是我们希望从管道中取出5个数据，此时输出结果为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们可以发现，当管道关闭过后且管道内无数据，取出的值，即管道内数据（整数数据）的零值为0。但是更多的情况下，我们并不想取出那些多余的数据，我们可以根据取出数据时带有的标志位来判别：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">    num, flag := &lt;-channel</span><br><span class="line">    <span class="keyword">if</span> flag &#123;</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此时的输出就不会带有后面的三个0了。</p>
<h3 id="管道的遍历"><a href="#管道的遍历" class="headerlink" title="管道的遍历"></a>管道的遍历</h3><p>&emsp;&emsp;其实在上一个小节中我们已经说到了管道的遍历了，只不过我们暂时并不知道管道的长度是多少，循环n次提取数据，如果提取超出限制就会返回0。同时我们也通过取出数据时的标志位来确定提取是否成功，一旦不成功我们就停止循环。 </p>
<p>&emsp;&emsp;但是就因为长度是无法确定的，所以在提取的时候循环次数是无法确定的。虽然我们可以通过len的方式来确定当前channel中有多少个数据再进行循环，但是我们也说了，channel是一种流动的数据类型，多个协程可以同时操作一个channel不出资源竞争。所以通过len函数得到的值在下一时刻可能就不再适用了，因此我们依旧介绍一种之前见过的遍历方式，range：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    channel &lt;- <span class="number">1</span></span><br><span class="line">    channel &lt;- <span class="number">2</span></span><br><span class="line">    <span class="built_in">close</span>(channel)</span><br><span class="line">    <span class="keyword">for</span> num := <span class="keyword">range</span> channel &#123;</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在for-range结构中，我们不需要在提取数据时判断标志位，具体channel中有多少数据，什么时候channel被关闭了，在for-range结构中都可以不需要进行考虑，编译器都如数帮助我们完成了判断。 </p>
<p>&emsp;&emsp;但是这里需要说明的一点是：不论是传统for结构，还是for-range结构，<strong>当channel没有被关闭的情况下</strong>，无限制地读取数据还是会出现阻塞且死锁现象。因此可以讲：channel的遍历是以channel被关闭为基础的。如果channel没有被关闭，就不能无限制地遍历。 </p>
<p>&emsp;&emsp;但是实际上是，channel并不能随随便便地关闭，且channel是引用类型，一旦某一个协程关闭了channel，其他的协程都无法再向该channel中写入数据了。换句话说，当遍历channel时率先关闭channel是不现实的，因为无法保证其他协程没有在用这个channel了；同时不关闭就无法遍历，这似乎成了一个死循环。因此我们将介绍一种其他的遍历方式：select，在这种前提下即便不关闭channel，也可以完成遍历操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    channel &lt;- <span class="number">1</span></span><br><span class="line">    channel &lt;- <span class="number">2</span></span><br><span class="line">    channel &lt;- <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> v := &lt;-channel:</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"No other data"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上面的代码中，我们初始化了一个管道，并向其中插入三个数据，在后面的循环中，我们通过select块完成管道数据的提取。一旦数据成功被提取了，程序将会进入case部分，如若取不出来数据，就会继续向后匹配其他的case块，如若全都没有匹配，则会进入default部分。之后我们再次进入下一次的循环依旧提取数据。我在这里通过time.Sleep是为了让程序人为地减慢，否则程序将会一直输出”No other data”，此时由于我们没有设定跳出的操作，因此会无限循环，需要通过”ctrl+c”的方式（不同系统不一样）来强制退出。 </p>
<p>&emsp;&emsp;如果我们在程序中定义多个管道，且在同一个select块中提取数据，其执行顺序也是不可预见的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    intChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    intChannel &lt;- <span class="number">1</span></span><br><span class="line">    intChannel &lt;- <span class="number">2</span></span><br><span class="line">    intChannel &lt;- <span class="number">3</span></span><br><span class="line">    stringChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">    stringChannel &lt;- <span class="string">"Hello"</span></span><br><span class="line">    stringChannel &lt;- <span class="string">"World"</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> v := &lt;-intChannel:</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">            <span class="keyword">case</span> v := &lt;-stringChannel:</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"No other data"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="管道的只读只写"><a href="#管道的只读只写" class="headerlink" title="管道的只读只写"></a>管道的只读只写</h3><p>&emsp;&emsp;在之前我们所定义的channel中，我们定义的都是双向的管道，即既可以向管道中写入数据也可以从管道中读取数据。其实在Go语言中，我们可以定义只读或者只写的管道：只读的管道只可以从管道中读取数据而不可以写入，只写管道只可以向管道中写入数据而不可以读。我们举个例子来说明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> channel &lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> channel <span class="keyword">chan</span>&lt;- <span class="keyword">int</span></span><br><span class="line">readChannel := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">writeChannel := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其定义或初始化方式就是在chan关键字前或后面添加指向的符号，以确定值只可以从管道取还是只可以向管道内写。如果操作没能满足只读只写的性质，会出现如下的运行时错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invalid operation: readChannel &lt;- <span class="number">1</span> (send to receive-only <span class="keyword">type</span> &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">invalid operation: &lt;-writeChannel (receive from send-only <span class="keyword">type</span> <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;经过上述的介绍，我们可能会考虑一个问题，我们在之前说管道内的数据是需要流动的，那么只读和只写着两个种性质岂不是直接地违背了管道数据的流动性。这个问题我们需要以多协程的形式来考虑，我们可以将只读和只写看做管道变量给予其他函数的权限。在某些协程中专门负责向管道中写入数据，某些协程中专门处理数据，管道内数据是不同协程之间流动的，而不是在一个协程之中流动。因此可以说，限定了管道权限可以一定意义上防止协程对管道的误操作。 </p>
<p>&emsp;&emsp;为了更详细说明一下，我们举一个例子，开启两个协程，一个协程向管道中写入50个数据，另一个协程从管道中取出数据，取出数据结束后主协程结束：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inputData</span><span class="params">(channel <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++ &#123;</span><br><span class="line">        channel &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(channel)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outputData</span><span class="params">(channel &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, exit <span class="keyword">chan</span>&lt;- <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> data := <span class="keyword">range</span> channel &#123;</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(exit)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">go</span> inputData(channel)</span><br><span class="line">    <span class="keyword">go</span> outputData(channel, exit)</span><br><span class="line">    &lt;-exit</span><br><span class="line">    fmt.Println(<span class="string">"主协程结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述代码中，我们在函数的形参中指定了channel的只读只写属性，而在主函数中调用协程时传入的实参是没有只读只写定义的。对于这个现象我们可以一定程度上理解为向下转型，即channel还是同一个channel，只是在参数传递的过程中赋给了一定的权限。因此只读或只写管道并不是两个独特的数据类型，其本质都是双向的管道，只是在定义初始化或使用过程中人为地添加了一个额外的属性。</p>
<h3 id="协程中处理错误"><a href="#协程中处理错误" class="headerlink" title="协程中处理错误"></a>协程中处理错误</h3><p>&emsp;&emsp;在Go语言中如果出现了运行时错误，整个程序就会完全崩溃停止。但在一些情况下，我们并不希望这样，因为每一个协程都可以说自已执行自己的代码。一个协程出了问题，不应该影响到其他的协程。比如说游戏逻辑出了一点问题不应该影响好友逻辑，因此结合之前我们所提到的defer+recover关键字，我们可以解决上述的问题。 </p>
<p>&emsp;&emsp;我们首先写一个没有做错误处理的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makePanic</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> myMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">    myMap[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> makePanic()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"主协程结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这段程序中，我们可以发现：在makePanic函数中我们定义了一个map，但是没有初始化，而直接向map中写入数据，这个行为会造成panic，执行结果如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: assignment to entry in <span class="literal">nil</span> <span class="keyword">map</span>  </span><br><span class="line">goroutine <span class="number">19</span> [running]:</span><br><span class="line">main.makePanic()</span><br><span class="line">E:/GoProject/src/demo/demo.<span class="keyword">go</span>:<span class="number">10</span> +<span class="number">0x3c</span></span><br><span class="line">created by main.main</span><br><span class="line">E:/GoProject/src/demo/demo.<span class="keyword">go</span>:<span class="number">15</span> +<span class="number">0x40</span></span><br><span class="line">错误: 进程退出代码 <span class="number">2.</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们可以发现整个程序都停止了，现在我们希望协程中出现panic后并不影响主协程，我们可以采用以下的办法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makePanic</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        err := <span class="built_in">recover</span>()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Error happen:"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">var</span> myMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">    myMap[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> makePanic()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"主协程结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在makePanic函数中defer一个匿名函数，在函数中捕获函数中出现的异常，最后将异常打印出来，代码结果为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error happen: assignment to entry in <span class="literal">nil</span> <span class="keyword">map</span></span><br><span class="line">主协程结束</span><br><span class="line">成功: 进程退出代码 <span class="number">0.</span></span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们集中讲解了管道的关闭以及管道关闭的作用、以关闭管道为基础的管道的遍历方式，以及不需要关闭管道的遍历方式。同时，我们也讲解了管道的只读只写属性，以及在协程参数传递中的使用方式。最后我们讲解了多协程编程过程中子协程panic的捕获方式，当子协程出现panic时，其他协程会正常工作。 </p>
<p>&emsp;&emsp;在下个小节中，我们将开始一个新的技术难点：反射。反射可以说是Go语言更底层的一种实现，在大多数的框架开发中使用十分频繁，下个小节也将会概念性地笼统地讲解一下其用法，深度应该不会太高。因为反射这个知识点对于初学者来说并不是十分的友好。</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/04/02/54-%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/" class="pre">Go语言从入门到放弃系列&lt;54&gt; 反射入门</a><a href="/2020/03/30/52-channel%E7%AE%A1%E9%81%93%E5%85%A5%E9%97%A8/" class="next">Go语言从入门到放弃系列&lt;52&gt; channel管道入门</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-53-gt-channel细节讨论"><span class="toc-text">Go语言从入门到放弃系列&lt;53&gt; channel细节讨论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#管道的关闭"><span class="toc-text">管道的关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#管道的遍历"><span class="toc-text">管道的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#管道的只读只写"><span class="toc-text">管道的只读只写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协程中处理错误"><span class="toc-text">协程中处理错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/02/54-%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/">Go语言从入门到放弃系列<54> 反射入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/31/53-channel%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<53> channel细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/30/52-channel%E7%AE%A1%E9%81%93%E5%85%A5%E9%97%A8/">Go语言从入门到放弃系列<52> channel管道入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/51-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E4%B8%8E%E7%AE%A1%E9%81%93/">Go语言从入门到放弃系列<51> 资源竞争与管道</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/27/50-Goroutine%E5%85%A5%E9%97%A8/">Go语言从入门到放弃系列<50> Goroutine入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/49-Goroutine%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/">Go语言从入门到放弃系列<49> Goroutine概念简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/25/48-JSON%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/">Go语言从入门到放弃系列<48> JSON与序列化</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/24/47-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%BA%8C/">Go语言从入门到放弃系列<47> 文件与IO<二></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/22/46-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%B8%80/">Go语言从入门到放弃系列<46> 文件与IO<一></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/21/45-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/">Go语言从入门到放弃系列<45> 面向对象-多态</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">54</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>