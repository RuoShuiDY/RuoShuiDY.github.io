<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;43&gt; 面向对象-接口 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;43&gt; 面向对象-接口</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;43&gt; 面向对象-接口</h1><div class="post-meta"><a href="/2020/03/17/43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/#comments" class="comment-count"></a><p><span class="date">Mar 17, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-43-gt-面向对象-接口"><a href="#Go语言从入门到放弃系列-lt-43-gt-面向对象-接口" class="headerlink" title="Go语言从入门到放弃系列&lt;43&gt; 面向对象-接口"></a>Go语言从入门到放弃系列&lt;43&gt; 面向对象-接口</h2><p>&emsp;&emsp;在这之前，我们已然介绍了面向对象编程部分的抽象思想，封装思想，和继承技术。在接下来的几个小节中我们将开始介绍面向对象的另一个特性-多态。然而就目前而言，直接介绍多态相对复杂，因此我们先介绍接口的技术，然后通过接口和继承的技术来说明多态的特性。在这个小节中，我们将通过案例引入接口的概念以进行快速入门程序的书写。</p>
<h3 id="接口引入"><a href="#接口引入" class="headerlink" title="接口引入"></a>接口引入</h3><p>&emsp;&emsp;在日常生活中，接口的概念十分广泛。比如我们都十分熟悉的USB接口，TypeC接口，HDMI接口，VGA接口等。在面向对象语言中，也存在接口的概念。我们通过物理的接口为例来了解Go语言的接口：现在我们的计算机基本都有USB接口，手机可以通过USB接口连入计算机，打印机可以通过USB接口连入计算机。不同的设备通过同一种接口连入计算机，却能够拥有不同的响应，换句话说：接口可以根据连入的设备不同自动判断对应的执行结果。 </p>
<p>&emsp;&emsp;在好多年前的计算机中，鼠标和键盘与计算机的连接都不是通过USB接口的，而是有各自的具体的接口，且不同的接口是连不上的。这也意味着曾经计算机需要为不同的硬件专门设计不同的接口。我们通过简化的代码来模拟这个问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mouse <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Mouse)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"鼠标开始工作"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Keyboard <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k Keyboard)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"键盘开始工作"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们定义了两个类分别为鼠标类和键盘类，且类中没有属性只有方法。向鼠标和键盘类分别绑定各自的不同的Start方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Computer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Computer)</span> <span class="title">MouseWork</span><span class="params">(m *Mouse)</span></span> &#123;</span><br><span class="line">    m.Start()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Computer)</span> <span class="title">KeyboardWork</span><span class="params">(k *Keyboard)</span></span> &#123;</span><br><span class="line">    k.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们接下来又定义了一个计算机类，在计算机类中依旧没有任何的属性，且计算机类需要分别为鼠标和键盘绑定一个方法。此时我们调用不同的方法以将鼠标或键盘连接到计算机上，我们用主函数模拟：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Computer</span><br><span class="line">    <span class="keyword">var</span> m Mouse</span><br><span class="line">    <span class="keyword">var</span> k Keyboard</span><br><span class="line">    c.MouseWork(&amp;m)</span><br><span class="line">    c.KeyboardWork(&amp;k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在主函数中，我们声明了一个计算机实例，鼠标实例，和键盘实例，并通过计算机实例的两个不同的接口完成设备的连入。此时程序的输出结果为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">鼠标开始工作</span><br><span class="line">键盘开始工作</span><br></pre></td></tr></table></figure>
<h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>&emsp;&emsp;在这种当前的解决方案下，即使程序可以正常执行，结果可以正确输出，但是这种做法的扩展性相对较低。例如我们再定义一个打印机类，打印机类具备自己的驱动方法，自己的执行方式。同时我们需要修改计算机类，让计算机类为打印机留出一个接口。程序修改为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Printer <span class="keyword">struct</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Printer)</span> <span class="title">Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Computer)</span> <span class="title">PrinterWork</span><span class="params">(p *Printer)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这种修改方式实在过于繁琐，且随着硬件的增多，程序会变得非常的大，而且代码十分重复。不仅如此，假如不同的硬件厂商的设计理念不同，生产出的硬件不兼容，计算机只好为不同厂商的同一种硬件做不同的适配，这无疑会增加更多的工作量。 </p>
<p>&emsp;&emsp;除此之外，即便是我们可以为所有的不同种类的硬件都预留出对应的接口，还是会出现一定的问题。一般情况下，计算机外设只有鼠标和键盘，但对于一些人来说可能需要打印机，对于开发人员来说，需要各种手机的连入接口。换句话说，不同的使用者更倾向于不同的特定的功能，而其他的预留接口都被浪费了。 </p>
<p>&emsp;&emsp;因此，如果存在着一种规定，不同的硬件厂商在生产的时候都遵循这个规定，计算机只接受实现了这个规定的硬件。这样的话，计算机只需要预留出几个接口就可以了，需要什么功能的硬件直接插入即可。因为规定都是相同的，协议都是一致的，在Go语言中，接口就可以起到这个功能。</p>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>&emsp;&emsp;对于上述问题的解决方式可以分为以下几个步骤：<br>&emsp;&emsp;1. 制定一种规定，设计一种接口；<br>&emsp;&emsp;2. 让鼠标和键盘实现这种规定；<br>&emsp;&emsp;3. 让计算机拥有这个接口。<br>&emsp;&emsp;因此，我们首先定义一个接口，这个接口中有一个抽象方法，即只有实现了这个方法，才算是实现了这个接口，然后我们让鼠标和键盘分别实现这两个方法，最后在计算机类的方法中注入这个接口实例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span>&#123;</span><br><span class="line">    Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;由于我们在之前的代码中已然为Mouse和Keyboard类绑定了Start方法，因此这两个类不需要做出改动。如果之前写的方法名不是Start的话，则需要改为Start方法。 </p>
<p>&emsp;&emsp;接下来我们修改Computer类，这个类不再需要为每一个硬件都预留方法，因此将其他方法删除，而是需要把USB接口传入：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Computer)</span> <span class="title">Work</span><span class="params">(usb USB)</span></span> &#123;</span><br><span class="line">    usb.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后在main函数中定义一个Computer类，Mouse类，和Keyboard类。并将Mouse和Keyboard传入到Computer类中的Work方法中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Computer</span><br><span class="line">    <span class="keyword">var</span> m Mouse</span><br><span class="line">    <span class="keyword">var</span> k Keyboard</span><br><span class="line">    c.Work(&amp;m)</span><br><span class="line">    c.Work(&amp;k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上述的代码中，我们可以发现，在定义Work方法的时候定义的参数是USB实例，但是我们传入的是Mouse和Keyboard对象指针。即便如此，并没有出现参数不匹配的现象，反而根据传入对象的不同输出结果不同，这就是一种多态的体现。 </p>
<p>&emsp;&emsp;现在假设我们又添加了一个新的打印机类，只要这个类实现了Start方法，它就可以被传入到Work方法中，并完成程序的调用。对于Computer类而言，则完全不需要进行修改。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们主要通过USB接口的案例来说明Go语言中的接口的概念，并通过该案例引入了Go语言接口实现的方式。在一些面向对象的语言中，接口的实现是通过implements关键字完成的，并且直接指明了实现关系。但是在Go语言中并没有这个关键字，接口的实现完全是靠实现接口定义的方法完成的。假如程序中定义了两个接口，且接口中定义的抽象方法是相同的，那么一个类实现其中一个接口的同时也就实现了另一个接口。 </p>
<p>&emsp;&emsp;在下个小节中，我们将针对Go语言中接口的使用方式和需要注意的细节进行相对深入的讨论。在讨论过程中也会通过代码案例来完成相应的说明。</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/03/19/44-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/" class="pre">Go语言从入门到放弃系列&lt;44&gt; 面向对象-接口细节讨论</a><a href="/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/" class="next">Go语言从入门到放弃系列&lt;42&gt; 面向对象-继承细节讨论</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-43-gt-面向对象-接口"><span class="toc-text">Go语言从入门到放弃系列&lt;43&gt; 面向对象-接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#接口引入"><span class="toc-text">接口引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题提出"><span class="toc-text">问题提出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决方式"><span class="toc-text">解决方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/25/48-JSON%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/">Go语言从入门到放弃系列<48> JSON与序列化</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/24/47-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%BA%8C/">Go语言从入门到放弃系列<47> 文件与IO<二></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/22/46-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%B8%80/">Go语言从入门到放弃系列<46> 文件与IO<一></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/21/45-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/">Go语言从入门到放弃系列<45> 面向对象-多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/44-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<44> 面向对象-接口细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/17/43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/">Go语言从入门到放弃系列<43> 面向对象-接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<42> 面向对象-继承细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/">Go语言从入门到放弃系列<41> 面向对象-继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/14/40-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/">Go语言从入门到放弃系列<40> 面向对象-封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/39-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">Go语言从入门到放弃系列<39> 面向对象-方法细节与工厂模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">48</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>