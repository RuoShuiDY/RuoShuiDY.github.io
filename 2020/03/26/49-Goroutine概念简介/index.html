<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;49&gt; Goroutine概念简介 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;49&gt; Goroutine概念简介</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;49&gt; Goroutine概念简介</h1><div class="post-meta"><a href="/2020/03/26/49-Goroutine%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/#comments" class="comment-count"></a><p><span class="date">Mar 26, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-49-gt-Goroutine概念简介"><a href="#Go语言从入门到放弃系列-lt-49-gt-Goroutine概念简介" class="headerlink" title="Go语言从入门到放弃系列&lt;49&gt; Goroutine概念简介"></a>Go语言从入门到放弃系列&lt;49&gt; Goroutine概念简介</h2><p>&emsp;&emsp;在之前的所有章节中，我们讲解的技术都是基于单线程的，换句话说我们的所有的操作都是在一条时间线上按规定的顺序执行。然而现如今，我们大多数人的机器都不是单核的，而是四核、八核乃至于更多，那么将所有的函数功能全部都集中在一个核上运行不仅浪费时间，还浪费了计算能力。 </p>
<p>&emsp;&emsp;因此从这个小节开始，我们将开始讲解Go语言中的多线程（协程）编程，尽最大的可能充分利用计算机的有限的资源。同时我们也将讲解到Go语言中管道（channel）的用法，讲解协程之间的通讯方式。在这之前，我们需要说明并区分几个概念，分别是：进程、线程、与协程；以及并行和并发的操作。最后我们还会基于线程协程的使用的几点讨论。 </p>
<h3 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h3><p>&emsp;&emsp;这三个概念和操作系统底层具备一定的关系，在这里我们并不希望通过硬件的讲解来说明这几个概念，只是大致通过具象的案例来说明。在大多数的计算机语言中，我们可能接触到的更多的是进程与线程的概念，而协程这个概念相对较少。协程并不是Go语言所独有的，但是Go语言对协程的实现也是这个语言的一大亮点。 </p>
<h4 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h4><p>&emsp;&emsp;进程这个概念也是由来已久了，这个概念在60年代初就已然出现了。狭义上讲，进程就是正在运行的程序实例，举个最简单的例子就是：当我们在Windows上打开了一个exe文件，那么系统中就会多一个程序实例，也就是多了一个进程。再比如说，当我们切出任务管理器，进入到进程的这个栏目中，我们所能看到的所有的都是进程，当我们将一个程序关闭时，在任务管理器中这个进程也就消失了，当我们通过任务管理器结束某个进程时，对应的程序也同样结束。 </p>
<p>&emsp;&emsp;在任务管理器中不是所有的进程都能够在桌面（控制台）可见，因为有许多的进程都是后台进程。比如系统的更新服务，各个硬件的驱动程序，系统中断服务等。 </p>
<p>&emsp;&emsp;广义上来说，进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动（源自百科）。在传统的操作系统中，进程是一个基本的分配单元，也是一个一个基本的执行单元。每一个进程都有自己的地址空间，一般情况下地址空间中包含代码段、数据段、和堆栈段。代码段存储处理器执行的代码、数据段存储变量和执行期间使用的内存、堆栈段则维护活动过程中的指令和本地变量。 </p>
<p>&emsp;&emsp;简而言之，进程可以被理解为一个在操作系统中正在运行的程序，每打开一个程序，系统中就会多一个（甚至几个）进程。一个操作系统中可以包含多个进程，进程之间相互独立，其可以同时运行。</p>
<h4 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h4><p>&emsp;&emsp;在上面说进程是操作系统中最小的资源管理单元，那么线程就是操作系统中最小的执行单元。不论是进程还是线程，都是由操作系统底层所管理的。线程是被包含在进程之中，是进程的实际运作单位，一个线程就是进程中的一个单一顺序的控制流，一个进程可以并发多个线程。 </p>
<p>&emsp;&emsp;线程是独立调度和分派的基本单位，线程可以分为操作系统内核所调度的线程，以及用户进程自行调度的用户线程。在多核或多CPU中使用多线程程序设计的好处是显而易见的：多线程提高了程序的执行吞吐率， 在单核CPU上使用多线程可以将I/O处理、人机交互等延时操作与计算分开执行。例如在一些网络游戏中，往往会分出一个线程用来做网络交互、一个线程做游戏控制、一个线程做界面输出。 </p>
<p>&emsp;&emsp;一个进程可以具备多个线程，如果将进程理解为操作系统，那么线程的地位就是相当于操作系统的进程。因此线程可以被理解为一个轻量级的进程，它也是独立调度和分配的基本单元。同时线程可以并发执行且共享进程资源。 </p>
<p>&emsp;&emsp;那么既然说起共享资源，那就不得不提出多线程的一个主要难题：资源冲突，即多个线程公用一个资源时就很容易出现这个问题，例如两个并发线程中，一个线程读取一个文件，另一个线程写入这个文件，那么此时就出现了资源问题。那么其解决方式就是添加同步锁等，这个行为是比较消耗计算资源的，同时在线程之间的互相切换过程中，也是消耗系统资源的。不仅如此，因为线程是由操作系统所调度的，所以就如同打开软件多了系统会卡顿一样，当一个程序启动的线程多了，操作系统和该软件也会卡顿。因此，即便线程是轻量级的进程，但是对于一些应用来说，它还是相对重一点。</p>
<h4 id="3-协程"><a href="#3-协程" class="headerlink" title="3. 协程"></a>3. 协程</h4><p>&emsp;&emsp;协程相比于线程，就如线程相比于进程。协程可以理解为更为轻量级的线程，只是协程不由操作系统所接管，而是由程序进行控制其挂起和运行等操作的。因此，可以将协程理解为一个特殊的函数，这种函数可以在某个地方挂起，也可以在挂起处继续运行。一个线程可以具备多个协程，换句话说，一个线程内可以具备多个类似的特殊的函数。 </p>
<p>&emsp;&emsp;协程具备自己的寄存器以及上下文，协程在调度切换时，是将寄存器等保存在其他地方，当从挂起的地方继续执行时，会将保存下来的资源恢复。协程相比于线程有一个本质上的区别，线程是操作系统中最小的执行单元，归根结底线程还是在操作系统的控制之中的，其并发调度运行是物理级别的。而协程看作为一种特殊的函数，是通过线程的程序所调度的，因此此时的并发操作是逻辑上的，内存级别的，没有像线程调度一般需要系统资源。 </p>
<p>&emsp;&emsp;一个线程可以具备多个协程，反过来说多个协程是存在于一个线程中的。由于只有一个线程，因此它不存在同时写变量的冲突。在协程中控制共享资源不加锁，只需要判断状态即可（但会出现资源竞争问题），因此其执行效率比多线程效率高。那么既然协程是在一个线程中执行，多核CPU并行操作则是采用进程+协程的方式完成的，这既充分利用了多核操作，又充分发挥了协程的高效率，性能会有较大的提升。</p>
<h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>&emsp;&emsp;这两个概念也比较容易混淆，也确实有时候比较难以分辨两个词的区别。本质上来说，这两个词都代表了多个任务”同时”完成的情况，但具体区别则是单核与多核的区别。 </p>
<h4 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h4><p>&emsp;&emsp;并发在操作系统中是指某一个时间段中，有几个程序都处于启动的状态下。这几个程序都是在同一个计算单元上运行，但是任何一个时间点上其实只有一个程序在计算单元上运行。CPU分配时间片给每个程序，让每一个程序都有机会快速地运行，在视觉效果上，就像是多个程序同时执行。 </p>
<p>&emsp;&emsp;用一个比较具象化的例子来说就是写作业的过程：假设一个学生需要完成数学、语文、英语、物理四门课的作业。有一种写作业的办法就是：按顺序做完每一科作业，做完数学作业再开始做物理作业。第二种方式则是数学做一点，语文做一点，英文做一点，物理做一点，之后再数学做一点，一直到所有的作业都做完。其实两种写作业所用的时间相差无几，但是在视觉效果上看，这个学生好像四科作业同时在做。 </p>
<p>&emsp;&emsp;对于计算机的并发而言，无非就是将上述第二种写作业的方式的运行时间极大缩短，假如说做了10毫秒的数学之后立刻做10毫秒的语文。这样在极短的时间下，不仅视觉上还是感觉上都像是多个任务同时发生了。 </p>
<h4 id="2-并行"><a href="#2-并行" class="headerlink" title="2. 并行"></a>2. 并行</h4><p>&emsp;&emsp;并行则是计算机系统中同时执行两个或多个处理的计算方法。其主要目的是节省大型和复杂问题的解决时间，对代码工作做出一定的优化。将多个相互独立的任务分配给计算机的不同的CPU核中使之同时完成。但是并行并不能保证一定会加速。理论上来说，在n个并行处理的执行速度的最好结果是在单一处理器上执行的速度的n倍，但往往达不到这个比例。 </p>
<p>&emsp;&emsp;我们依旧采用上述写作业的例子来说明并行，假如这个学生依旧需要完成这四门功课。这时，这个学生又找来了三个朋友，并让这三个朋友帮助自己，使每一个人各做一门功课。这样在外人的眼中看来，这四门课才是真正的同时完成的，且也是真正节省了时间的。 </p>
<h4 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h4><p>&emsp;&emsp;并行与并发概念十分相似，但是又有所区别：并行的概念是指多个事件在同一时刻发生，而并发的概念则是多个事件在同一时间间隔内发生。在多程序的前提下，并发是指一段时间内宏观上有多个任务同时运行，但是在微观上则是只有一个任务分时交替进行。在计算机中若有多个处理器，任务被分配到不同的核心上，实现并行执行，此时多个任务是真正地同时进行。 </p>
<h3 id="基于多线程（协程）思想的几点讨论"><a href="#基于多线程（协程）思想的几点讨论" class="headerlink" title="基于多线程（协程）思想的几点讨论"></a>基于多线程（协程）思想的几点讨论</h3><p>&emsp;&emsp;在大多数情况下，我们都会说多线程多协程会节省时间，但是这个节省时间也是有一定条件的，这个条件就是I/O密集。在介绍并发的概念时我们所举的例子中，我们可能会发现每个作业做一点直到做完和按顺序做完每一科作业似乎没什么区别，甚至在并发的时候不断地换作业册反而更浪费时间。对于计算机而言其实也是一样的，线程、协程之间的调度也是需要时间和资源的，如果用并发模式来解决作业的问题显然是不可取的。 </p>
<p>&emsp;&emsp;现在我们换一种方式来理解，假如对于各个单科作业而言，每做完一小部分都需要家长核查一下答案，如果答案正确才可以继续进行。在这个前提下，如果按顺序完成单科作业的话，学生则会需要很多的等待时间。这个等待时间如果被利用下来去做其他科目的作业，那么学生和家长就可以好好地配合起来了。对于计算机而言，CPU和I/O可以被认为两种相对独立的任务，且CPU中运算速度是比I/O执行速度要快的多。例如当前的任务是打开一个文件，读取文件中的两个数，相加并写进这个文件中。那么这个任务所用的时间绝大多数都花在了打开文件和写入文件上。当I/O在完成这两个步骤时CPU其实是空闲的。 </p>
<p>&emsp;&emsp;因此可以讲，对于并发模式的使用而言，I/O密集的任务更为适合。而对于那种数学计算等任务，绝大多数运算都在CPU中，而没有文件操作，那么并发模式不仅没有节省时间，反而浪费了更多的时间。 </p>
<p>&emsp;&emsp;那么对于并行模式而言，虽然它可以真切地减少运行时间，但是能够应用并行模式的算法不多。只有同一个层面上相互独立的任务才有机会使用并行的模式。当多个函数之间存在先后关系，即后一个函数需要前一个函数的结果时，并行模式就不是很适用了。对于一个算法而言，一定会有可以并行运行的部分和必须要串行运行的部分。因此来说，即便是4核、8核的CPU，程序运行效率也无法达到4倍或8倍。 </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们介绍了进程、线程、和协程的概念，同时也区分了并行模式和并发模式的区别。在最后我们也针对并行和并发模式做出了几点讨论。可以说在这个小节中我们没有涉及到任何的代码操作，只是在思路上和概念上进行了一定的科普。在下个小节中，我们将介绍Go语言中Goroutine的语法以及其需要注意的各个事项。</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/03/27/50-Goroutine%E5%85%A5%E9%97%A8/" class="pre">Go语言从入门到放弃系列&lt;50&gt; Goroutine入门</a><a href="/2020/03/25/48-JSON%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/" class="next">Go语言从入门到放弃系列&lt;48&gt; JSON与序列化</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-49-gt-Goroutine概念简介"><span class="toc-text">Go语言从入门到放弃系列&lt;49&gt; Goroutine概念简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程、线程、协程"><span class="toc-text">进程、线程、协程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-进程"><span class="toc-text">1. 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-线程"><span class="toc-text">2. 线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-协程"><span class="toc-text">3. 协程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发与并行"><span class="toc-text">并发与并行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-并发"><span class="toc-text">1. 并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-并行"><span class="toc-text">2. 并行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-区别"><span class="toc-text">3.区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于多线程（协程）思想的几点讨论"><span class="toc-text">基于多线程（协程）思想的几点讨论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/02/54-%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/">Go语言从入门到放弃系列<54> 反射入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/31/53-channel%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<53> channel细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/30/52-channel%E7%AE%A1%E9%81%93%E5%85%A5%E9%97%A8/">Go语言从入门到放弃系列<52> channel管道入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/51-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E4%B8%8E%E7%AE%A1%E9%81%93/">Go语言从入门到放弃系列<51> 资源竞争与管道</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/27/50-Goroutine%E5%85%A5%E9%97%A8/">Go语言从入门到放弃系列<50> Goroutine入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/49-Goroutine%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/">Go语言从入门到放弃系列<49> Goroutine概念简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/25/48-JSON%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/">Go语言从入门到放弃系列<48> JSON与序列化</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/24/47-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%BA%8C/">Go语言从入门到放弃系列<47> 文件与IO<二></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/22/46-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%B8%80/">Go语言从入门到放弃系列<46> 文件与IO<一></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/21/45-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/">Go语言从入门到放弃系列<45> 面向对象-多态</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">54</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>