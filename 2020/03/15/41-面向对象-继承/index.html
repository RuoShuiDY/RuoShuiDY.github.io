<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;41&gt; 面向对象-继承 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;41&gt; 面向对象-继承</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;41&gt; 面向对象-继承</h1><div class="post-meta"><a href="/2020/03/15/41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/#comments" class="comment-count"></a><p><span class="date">Mar 15, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-41-gt-面向对象-继承"><a href="#Go语言从入门到放弃系列-lt-41-gt-面向对象-继承" class="headerlink" title="Go语言从入门到放弃系列&lt;41&gt; 面向对象-继承"></a>Go语言从入门到放弃系列&lt;41&gt; 面向对象-继承</h2><p>&emsp;&emsp;在上个小节中，我们讲解了面向对象特征其中的一个-封装的概念，封装是贯穿面向对象的一个思想而不是某些技术点，因此需要在日常开发中自行学习和加强。在这个小节中，我们将开始介绍Go语言中面向对象中的另一个特性-继承。Go语言对于继承有着独特的解决方式，与传统的面向对象语言的实现方式完全不同。如果有其他语言的开发经验，可能会对Go语言的继承的实现表示出费解，这是语言层面上的设计问题，开发者最好还是需要适应这种独特的方式。 </p>
<h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>&emsp;&emsp;在日常生活中，继承的概念随处可见，继承的关系往往涉及两个或多个个体类。例如，一个孩子的长相性格大多继承于父母，孩子也会有自己的独特的个性；在面向对象程序设计中，也经常会出现类似的问题。比如我们上一个小节提到的Account的例子，可以分为个人用户，企业用户，VIP用户等。每一个类型的用户都有其独特的特点，但是他们又同时都有存取款，查询转账等功能。因此可以说，不同类型的用户继承于Account大类。 </p>
<p>&emsp;&emsp;我们现在就针对这个问题举个简化的例子：假如我们需要一个普通账户和一个VIP账户，这两种账户都具备存款，查询，取款的功能。普通用户一次可以取10k，VIP用户一次可以取出50k。如果采用之前介绍的抽象等方式，我们需要建立两个结构体，分别为NormalAccount和VIPAccount。（暂时不考虑封装的问题）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NormalAccount&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> VIPAccount&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来，我们分别实现对应的方法，存钱取钱的方法为了简便暂时就不考虑密码的匹配，只是为了说明一下继承的问题。取钱的方法需要判断对应的取钱上限，以及余额是否少于需要取出的钱。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(na *NormalAccount)</span> <span class="title">QueryAccount</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(na.Balance)</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(na *NormalAccount)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    na.Balance += money</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(na *NormalAccount)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> money &gt; <span class="number">10000</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"超出上限"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> na.Balance &lt; money &#123;</span><br><span class="line">        fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    na.Balance -= money</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vipa *VIPAccount)</span> <span class="title">QueryAccount</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(vipa.Balance)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vipa *VIPAccount)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    vipa.Balance += money</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vipa *VIPAccount)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> money &gt; <span class="number">50000</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"超出上限"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> vipa.Balance &lt; money &#123;</span><br><span class="line">        fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    vipa.Balance -= money</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承实现"><a href="#继承实现" class="headerlink" title="继承实现"></a>继承实现</h3><p>&emsp;&emsp;在上述的代码实现中，虽说可以完成对应的功能，但是依旧有许多可以解决的问题。比如说，NormalAccount和VIPAccount的属性十分相似（在本例中完全相同），还有两种账户除了最高取款限额不同之外，其他的也十分类似。如果以当前的实现形式进行发展，那么企业账户，附属账户等需要再大致一模一样地再实现一遍，一旦账户中需要多加一个功能，则需要每一个账户类型都新写一个方法，这对大型程序来说十分不利。 </p>
<p>&emsp;&emsp;那么我们是否可以像类的构建中的抽象一般，将几个类中公有的属性再次抽象出来，形成一个父类，让所有继承于父类的子类都具备和父类一样的属性和方法，同时在子类中可以随意覆盖父类中的方法。基于这样一个思想，我们将继承的话题引入到讲解中。 </p>
<p>&emsp;&emsp;经过再次抽象后，我们发现在本例中每一个账户都需要姓名和账户余额，因此这两个属性可以被提取出来成为父类所共有的属性。同理，我们也发现每一个账户都存在取款，存款和查询功能。在取款过程中，我们可以通过传入一个参数来规定取款的最高限额，因此这三个方法都可以被写入到父类中。此时，父类Account可以被归纳如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">QueryAccount</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(a.Balance)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    a.Balance += money</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>, limit <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> money &gt; limit &#123;</span><br><span class="line">        fmt.Println(<span class="string">"超出上限"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> a.Balance &lt; money &#123;</span><br><span class="line">        fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    a.Balance -= money</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;建立了父类Account之后，我们就可以将两个账户类型定义出来了，由于两个账户均继承于父类Account，因此，父类中的属性以及行为可以直接被子类所拥有，此时在子类中就不需要再次定义了。对于取钱这个问题，我们可以重写父类的方法，将取款上限传入。我们首先写NormalAccount：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NormalAccount <span class="keyword">struct</span> &#123;</span><br><span class="line">    Account</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(na *NormalAccount)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    na.Account.WithdrawAccount(money, <span class="number">10000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述代码中，我们通过将Account父类嵌入到NormalAccount子类的方式，令子类继承了Account父类。在重写WithdrawAccount方法中，我们在子类的方法中调用了父类的方法进行了一次包装，就完成了子类的重写工作。同理对于VIPAccount类而言，做法也是类似的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> VIPAccount <span class="keyword">struct</span> &#123;</span><br><span class="line">    Account</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vipa *VIPAccount)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    vipa.Account.WithdrawAccount(money, <span class="number">50000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此时，两个子类的代码就都编写完成了。接下来，我们讲解一下如何在函数中使用上述两个子类。在主函数中，我们将分别实例化两个子类，为之赋值，并调用三个方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> na NormalAccount = NormalAccount&#123;Account&#123;<span class="string">"DENG"</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">var</span> vipa VIPAccount</span><br><span class="line">    vipa.Account.Name = <span class="string">"YANG"</span></span><br><span class="line">    vipa.Account.Balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    na.SaveAccount(<span class="number">1000</span>)</span><br><span class="line">    na.WithdrawAccount(<span class="number">300</span>)</span><br><span class="line">    na.QueryAccount()</span><br><span class="line"></span><br><span class="line">    vipa.SaveAccount(<span class="number">50000</span>)</span><br><span class="line">    vipa.WithdrawAccount(<span class="number">100000</span>)</span><br><span class="line">    vipa.QueryAccount()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在主函数中，我们通过初始化直接赋值的方式实例化了NormalAccount，也通过先创建后赋值的方式实例化了VIPAccount，接下来我们用两个对象分别进行继承得到的方法，并进行输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">700</span></span><br><span class="line">超出上限</span><br><span class="line"><span class="number">50000</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;得到了上述的结果，与预期的结果相同，也进而说明了我们的代码实现是没有问题的，继承的结果也是正确的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们通过一个案例引出了继承的概念，并通过代码的方式进行了快速入门。在案例中，我们可以发现，在Go语言中的面向对象继承，是通过嵌入匿名结构体的方式完成的。且作为父类的匿名结构体中的属性和方法均被子类所继承到，子类拥有了方法继承后可以通过子类的实例调用对应的方法。 </p>
<p>&emsp;&emsp;在传统面向对象继承中，往往是通过extends关键字的方式完成的，在Go语言中并没有这个关键字。Go语言中类的组合与继承的关系也不如传统面向对象语言那般分明，因此我们需要适应这种独特的继承方式。在下个小节中，我们将针对继承中的一些细节，例如访问修饰，属性冲突，多重继承等细节进行详细地介绍。</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/" class="pre">Go语言从入门到放弃系列&lt;42&gt; 面向对象-继承细节讨论</a><a href="/2020/03/14/40-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/" class="next">Go语言从入门到放弃系列&lt;40&gt; 面向对象-封装</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-41-gt-面向对象-继承"><span class="toc-text">Go语言从入门到放弃系列&lt;41&gt; 面向对象-继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题引入"><span class="toc-text">问题引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承实现"><span class="toc-text">继承实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/06/56-%E7%BB%88%E7%AB%A0-Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Go语言从入门到放弃系列<56> 终章-Socket网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/04/55-%E5%8F%8D%E5%B0%84%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<55> 反射细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/02/54-%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/">Go语言从入门到放弃系列<54> 反射入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/31/53-channel%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<53> channel细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/30/52-channel%E7%AE%A1%E9%81%93%E5%85%A5%E9%97%A8/">Go语言从入门到放弃系列<52> channel管道入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/51-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E4%B8%8E%E7%AE%A1%E9%81%93/">Go语言从入门到放弃系列<51> 资源竞争与管道</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/27/50-Goroutine%E5%85%A5%E9%97%A8/">Go语言从入门到放弃系列<50> Goroutine入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/49-Goroutine%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/">Go语言从入门到放弃系列<49> Goroutine概念简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/25/48-JSON%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/">Go语言从入门到放弃系列<48> JSON与序列化</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/24/47-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%BA%8C/">Go语言从入门到放弃系列<47> 文件与IO<二></a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">56</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>