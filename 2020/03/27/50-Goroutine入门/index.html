<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;50&gt; Goroutine入门 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;50&gt; Goroutine入门</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;50&gt; Goroutine入门</h1><div class="post-meta"><a href="/2020/03/27/50-Goroutine%E5%85%A5%E9%97%A8/#comments" class="comment-count"></a><p><span class="date">Mar 27, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-50-gt-Goroutine入门"><a href="#Go语言从入门到放弃系列-lt-50-gt-Goroutine入门" class="headerlink" title="Go语言从入门到放弃系列&lt;50&gt; Goroutine入门"></a>Go语言从入门到放弃系列&lt;50&gt; Goroutine入门</h2><p>&emsp;&emsp;在上个小节中我们从概念上讲解了进程、线程、协程的关系，以及并发和并行的区别与联系。同时我们也针对了线程协程的执行效率做了简要的讨论。</p>
<p>&emsp;&emsp;在这个小节中，我们将开始通过简单的代码来讲解Go语言中协程的特性与注意事项。如果说前面的各个章节中的知识点的讲解中，如果代码相同，我们都可以得到同样的答案（除了物理地址），那么对于协程的使用而言，同样的代码的执行结果大家的可能就不甚一致了，而且更多的情况中是非常不一致的。因此在这个小节中我们所展示出来的执行结果只是诸多可能的结果中的一个。 </p>
<h3 id="Goroutine快速入门"><a href="#Goroutine快速入门" class="headerlink" title="Goroutine快速入门"></a>Goroutine快速入门</h3><p>&emsp;&emsp;在上个小节中，我们提到：协程是一种逻辑上的概念而不是物理上的概念，同时我们在举例的时候也曾将协程的本质比作为一个函数。在Go语言的实现中，协程确实就是一个函数，它的内容与普通函数没有什么本质上的区别，只是在函数的调用过程中进行多协程、多线程的调用而已。 </p>
<p>&emsp;&emsp;基于上述的讲解，我们假设一种简单的需求：在Go语言主线程中每隔1秒输出一句”我在主线程X”，同时我们也需要在一个协程中每隔一秒输出一句”我在协程中X”，上述过程重复10次，X为当前所在的次数。如果我们不使用协程，因为顺序结构的存在，这两个过程就需要具有先后顺序。我们先完成顺序结构的代码的编写，进而再修改为协程的模式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inRoutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">"我在协程中"</span>, i)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inRoutine()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">"我在主线程"</span>, i)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述的程序中，我们定义了一个名为inRoutine的函数，在函数中我们循环10次，每次输出一个字符串并等待1秒钟。在主函数中我们首先调用了这个函数，然后再执行另一个循环，循环中输出10次我在主线程。那么根据之前我们所讲解的顺序结构，我们可以直接分析出执行结果：即先输出10次”我在协程中”，然后再输出10次”我在主线程”，且这个结果是一定的，不会有任何的例外。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我在协程中 <span class="number">1</span></span><br><span class="line">我在协程中 <span class="number">2</span></span><br><span class="line">...</span><br><span class="line">我在协程中 <span class="number">10</span></span><br><span class="line">我在主线程 <span class="number">1</span></span><br><span class="line">...</span><br><span class="line">我在主线程 <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个结果是毋庸置疑的，而且通过运行过程我们也可以发现大致运用了20秒的时间，因此这两个过程是串行的，并没有达到我们的要求。现在我们就将上述的串行过程修改为并行的过程，改动的地方其实只有一个，将调用函数的部分修改为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> inRoutine()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此时修改过后的程序就成为并行的形式了，可以看做为”我在主线程”的输出与”我在协程中”的输出是同时发生的。但是因为我们需要在屏幕上输出，而屏幕的输出是有顺序的，因此屏幕输出的时候是无法同时输出两个字符串的。反过来说，我们此时也无法通过屏幕输出的先后确定哪个字符串先输出了，宏观上我们认为是同时。 </p>
<p>&emsp;&emsp;既然输出的先后关系与发生的同时相悖，所以在同时发生的前提下，究竟谁会先输出是一个不可知的情况，因此大家的输出结果可能不相同。因此在一些测试中，往往不会在程序编写的题目中涉及多线程或多协程的概念，因为一旦涉及了这些概念，输出结果可能就是未知的了，我们下面列举出一个可能的结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">我在主线程 <span class="number">1</span></span><br><span class="line">我在协程中 <span class="number">1</span></span><br><span class="line">我在协程中 <span class="number">2</span></span><br><span class="line">我在主线程 <span class="number">2</span></span><br><span class="line">我在主线程 <span class="number">3</span></span><br><span class="line">我在协程中 <span class="number">3</span></span><br><span class="line">我在协程中 <span class="number">4</span></span><br><span class="line">我在主线程 <span class="number">4</span></span><br><span class="line">我在协程中 <span class="number">5</span></span><br><span class="line">我在主线程 <span class="number">5</span></span><br><span class="line">我在主线程 <span class="number">6</span></span><br><span class="line">我在协程中 <span class="number">6</span></span><br><span class="line">我在主线程 <span class="number">7</span></span><br><span class="line">我在协程中 <span class="number">7</span></span><br><span class="line">我在协程中 <span class="number">8</span></span><br><span class="line">我在主线程 <span class="number">8</span></span><br><span class="line">我在协程中 <span class="number">9</span></span><br><span class="line">我在主线程 <span class="number">9</span></span><br><span class="line">我在协程中 <span class="number">10</span></span><br><span class="line">我在主线程 <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过该结果来看，输出的先后顺序确实没有什么规律，而且再一次运行上述代码所得到的结果与上述结果可能还是不同的。但是有一点是可以确定的：在一个协程中的输出结果是有顺序的，比如协程中1就会在协程中2的前面，但是协程中1却无法保证在主线程1的后面。因此可以讲，协程之间没有确定的先后关系，但是协程之中还是满足顺序结构且具备先后关系的。</p>
<h3 id="MPG模型简介"><a href="#MPG模型简介" class="headerlink" title="MPG模型简介"></a>MPG模型简介</h3><p>&emsp;&emsp;可以说Go语言具备一次性启动上千的协程的能力都归功于其实现的MPG模型，在这个部分中我们对MPG模型做出简要的说明。M所指的是Machine，每个M一般直接关联一个内核线程，是物理级的且受操作系统管理；P指的是Processor，代表了M执行所需要的上下文环境。G代表Goroutine，其本质也是个轻量级线程，受到P的调度与对接。 </p>
<p>&emsp;&emsp;一般来说，P的数量往往取决于机器的核心数，例如我们的机器是4核的机器，那么它就会被设定为4。当然我们也可以通过GOMAXPROCS手动设定，在新版本Go中默认就是机器所具备的核数。Goroutine可以有许多个且存在于多个队列中，每个P都会将G从一个队列中取出执行，其他的G处于等待的状态。同时在多个P的情况下，通常每一个P都负责一个队列以减少资源锁的竞争。 </p>
<p><img src="/2020/03/27/50-Goroutine%E5%85%A5%E9%97%A8/1.jpg" alt></p>
<p>​                                                                     (图片来源于网络)<br>&emsp;&emsp;因此MPG的关系可以如上图表示：每一个M上挂载一个P，每一个P维护一个G的队列；在某一个时间点上，每个P上只有一个G在运行，其他的G处在队列中等待。因此可以讲，每启动一个Goroutine，都会在某个队列的末尾加入一个G，一旦P运行直到调度点的时候，某个G就会从队列中弹出，设定堆栈等后就开始执行。 </p>
<p>&emsp;&emsp;那么有些人可能会想：为什么需要这个P，直接把G队列绑定在M上不可以么。答案是不可以的，因为P存在的目的就是进行协程与线程之间的调度。例如在系统调用systemcall的时候，一个线程无法做到同时执行代码和系统调用。因此这个时候当前线程就不得不放弃当前的上下文。假设当前M0维护了一个协程队列，此时M0所执行的G0发生了系统调用，那么M0就必须要等待G0的系统调用的结束，在等待的这段时间中，系统会创建（或借用）一个M1线程，并将P以及P所维护的G队列都挂载在M1上继续进行。 </p>
<p><img src="/2020/03/27/50-Goroutine%E5%85%A5%E9%97%A8/2.jpg" alt></p>
<p>&emsp;&emsp;从图中可以看出，此时在系统调用的时候，M0上只有G0，那么当系统调用结束后，M0上就没有P了，它会选择偷一个P过来运行。如果没有多余的P可偷，那么G0就会被放入全局的队列中并被均衡负载在其他的队列中，而M0则进入线程缓存以等待下一个调用的来临。 </p>
<p>&emsp;&emsp;不仅如此，每个P会定期检查全局队列中是否有剩余的G，以便本M执行完队列中所有的G的时候有事可做。一旦全局G队列中没有多余的G的话，该P会在其他的P中借来一些G去运行。往往当P去借其他的P的时候，它会直接借取其他P的一半的队列。所以说，在多线程多协程的代码中，因为负载均衡，因为系统调用等多个因素，多个协程的执行先后顺序是完全无法被确定的，因此代码的执行结果也是无法预料的。 </p>
<h3 id="Go语言中线程与协程的关系"><a href="#Go语言中线程与协程的关系" class="headerlink" title="Go语言中线程与协程的关系"></a>Go语言中线程与协程的关系</h3><p>&emsp;&emsp;在之前的小节中，我们介绍到线程是存在于进程中的，协程是存在于线程中的，因此在Go语言中一旦主线程启动了协程之后，程序就会遵循如下的规律：当协程结束时，主线程不受影响；当主线程结束时，协程不论运行到什么状态都要停止且消失。对此我们做一个实验来证明：我们首先将协程中等待1秒改为等待0.5秒，这样协程就会先结束。然后我们令协程中等待1秒，而主线程中等待0.5秒，此时主线程会先结束。我们看最终的输出结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">我在主线程 <span class="number">1</span></span><br><span class="line">我在协程中 <span class="number">1</span></span><br><span class="line">我在协程中 <span class="number">2</span></span><br><span class="line">我在协程中 <span class="number">3</span></span><br><span class="line">我在主线程 <span class="number">2</span></span><br><span class="line">我在协程中 <span class="number">4</span></span><br><span class="line">我在主线程 <span class="number">3</span></span><br><span class="line">我在协程中 <span class="number">5</span></span><br><span class="line">我在协程中 <span class="number">6</span></span><br><span class="line">我在主线程 <span class="number">4</span></span><br><span class="line">我在协程中 <span class="number">7</span></span><br><span class="line">我在协程中 <span class="number">8</span></span><br><span class="line">我在主线程 <span class="number">5</span></span><br><span class="line">我在协程中 <span class="number">9</span></span><br><span class="line">我在协程中 <span class="number">10</span></span><br><span class="line">我在主线程 <span class="number">6</span></span><br><span class="line">我在主线程 <span class="number">7</span></span><br><span class="line">我在主线程 <span class="number">8</span></span><br><span class="line">我在主线程 <span class="number">9</span></span><br><span class="line">我在主线程 <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们会发现：协程先结束的情况下，主线程依旧执行直到结束，我们再看主线程先结束的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我在主线程 <span class="number">1</span></span><br><span class="line">我在协程中 <span class="number">1</span></span><br><span class="line">我在主线程 <span class="number">2</span></span><br><span class="line">我在协程中 <span class="number">2</span></span><br><span class="line">我在主线程 <span class="number">3</span></span><br><span class="line">我在主线程 <span class="number">4</span></span><br><span class="line">我在协程中 <span class="number">3</span></span><br><span class="line">我在主线程 <span class="number">5</span></span><br><span class="line">我在主线程 <span class="number">6</span></span><br><span class="line">我在协程中 <span class="number">4</span></span><br><span class="line">我在主线程 <span class="number">7</span></span><br><span class="line">我在主线程 <span class="number">8</span></span><br><span class="line">我在协程中 <span class="number">5</span></span><br><span class="line">我在主线程 <span class="number">9</span></span><br><span class="line">我在主线程 <span class="number">10</span></span><br><span class="line">我在协程中 <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们会发现，主线程结束后，协程还未运行完的情况下也就结束了。当然此时的”我在协程中 6”出现的原因是屏幕输出并发的原因，而不是主线程结束后协程依旧执行完6才结束的。 </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们讲解了Goroutine的入门程序，简单体验了一下Go语言中多协程编程的过程。在入门案例过后，我们又简单介绍了Go语言中MPG模型，也简单介绍了Go语言中G队列的调度方式。最后我们也说明了线程和协程的执行关系。到目前为止，我们尚只能通过在主线程中延时的方式（time.Sleep）等待协程结束，在下个小节中，我们将介绍Go语言协程中资源竞争的现象与管道Channel的用法，使得主线程以及协程之间可以互相通信。</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/03/29/51-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E4%B8%8E%E7%AE%A1%E9%81%93/" class="pre">Go语言从入门到放弃系列&lt;51&gt; 资源竞争与管道</a><a href="/2020/03/26/49-Goroutine%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/" class="next">Go语言从入门到放弃系列&lt;49&gt; Goroutine概念简介</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-50-gt-Goroutine入门"><span class="toc-text">Go语言从入门到放弃系列&lt;50&gt; Goroutine入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Goroutine快速入门"><span class="toc-text">Goroutine快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MPG模型简介"><span class="toc-text">MPG模型简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go语言中线程与协程的关系"><span class="toc-text">Go语言中线程与协程的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/51-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E4%B8%8E%E7%AE%A1%E9%81%93/">Go语言从入门到放弃系列<51> 资源竞争与管道</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/27/50-Goroutine%E5%85%A5%E9%97%A8/">Go语言从入门到放弃系列<50> Goroutine入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/49-Goroutine%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/">Go语言从入门到放弃系列<49> Goroutine概念简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/25/48-JSON%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/">Go语言从入门到放弃系列<48> JSON与序列化</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/24/47-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%BA%8C/">Go语言从入门到放弃系列<47> 文件与IO<二></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/22/46-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%B8%80/">Go语言从入门到放弃系列<46> 文件与IO<一></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/21/45-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/">Go语言从入门到放弃系列<45> 面向对象-多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/44-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<44> 面向对象-接口细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/17/43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/">Go语言从入门到放弃系列<43> 面向对象-接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<42> 面向对象-继承细节讨论</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">51</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>