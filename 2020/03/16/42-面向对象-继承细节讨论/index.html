<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;42&gt; 面向对象-继承细节讨论 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;42&gt; 面向对象-继承细节讨论</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;42&gt; 面向对象-继承细节讨论</h1><div class="post-meta"><a href="/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/#comments" class="comment-count"></a><p><span class="date">Mar 16, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-42-gt-面向对象-继承细节讨论"><a href="#Go语言从入门到放弃系列-lt-42-gt-面向对象-继承细节讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;42&gt; 面向对象-继承细节讨论"></a>Go语言从入门到放弃系列&lt;42&gt; 面向对象-继承细节讨论</h2><p>&emsp;&emsp;在上个小节中，我们通过银行账户的例子引入了Go语言中面向对象中继承的概念，并用代码演示了继承的实现方式。在入门案例中，我们通过将父类的结构体以匿名的方式嵌入到子类结构体中完成了子类对父类的属性和方法的继承。在这个小节中，我们将针对Go语言中继承的概念的一些细节做出更为详细的讨论。</p>
<h4 id="1-Go语言中继承关系是通过匿名结构体完成的"><a href="#1-Go语言中继承关系是通过匿名结构体完成的" class="headerlink" title="1. Go语言中继承关系是通过匿名结构体完成的"></a>1. Go语言中继承关系是通过匿名结构体完成的</h4><p>&emsp;&emsp;在传统面向对象语言中，例如Java，继承关系是通过extends关键字完成的，且子类与父类之间有着明确的继承关系。父类中的属性和方法是有选择性地被子类所继承。然而在Go语言中，继承关系是通过匿名结构体的方式完成的，且在Go语言中继承与组合的关系变得不是那么的明确。继承可以讲是一种“is-a”的关系，例如VIP账户继承了账户类，那么VIP账户自身就是一个账户。而组合关系则是一种“has-a”的关系，例如一辆车具备车轮，一只猫有四条腿，而不是一辆车是车轮，一只猫是四条腿。我们通过代码来说明这个问题： </p>
<p>&emsp;&emsp;假如我们事先定义好了一个Account类，并在VIPAccount类中继承这个类，那么代码会是以下的形式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> VIPAccount <span class="keyword">struct</span>&#123;</span><br><span class="line">    Account</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上述代码中反映的就是一种继承关系。接下来我们再通过代码讲解一下组合的关系，我们保留Account类不变，我们修改一下VIPAccount类的构成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> VIPAccount <span class="keyword">struct</span>&#123;</span><br><span class="line">    a Account</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这段代码中，Account类的一个实例成为了VIPAccount类中的一个属性，因此我们讲此时VIPAccount拥有了一个Account变量。当然此时我们在主函数调用VIP实例的时候依旧需要通过“变量.属性.属性”的形式完成。在这个角度上看，Go语言中继承与组合的关系十分密切，甚至可以讲，Go语言中的继承关系就是通过组合关系的形式完成的。</p>
<h4 id="2-父类中的全部属性和方法均被继承"><a href="#2-父类中的全部属性和方法均被继承" class="headerlink" title="2. 父类中的全部属性和方法均被继承"></a>2. 父类中的全部属性和方法均被继承</h4><p>&emsp;&emsp;在传统面向对象语言中，父类中的private修饰的属性是不可以被子类所继承的，包括private修饰的方法也是不可以被继承的。然而在Go语言中，这个规则不再被继续遵循。父类的所有属性和方法（不论首字母大小写）均会被子类所继承。我们依旧采用Account类为例，我们设定Name属性为公有，balance属性为私有，Query方法为公有，withdraw方法为私有，最后再用VIPAccount类继承：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name     <span class="keyword">string</span></span><br><span class="line">    balance   <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">Query</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.Name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">withdraw</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    a.balance -= money</span><br><span class="line">    fmt.Println(<span class="string">"余额为："</span>, a.balance)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VIPAccount <span class="keyword">struct</span>&#123;</span><br><span class="line">    Account</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来我们在当前的包中的主函数中分别为两个属性赋值并调用两个不同的方法。如果子类完全继承了父类的全部属性和方法，那么父类中首字母小写的也可以正确地被表示出来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> vipa VIPAccount</span><br><span class="line">    vipa.Account.Name = <span class="string">"DENG"</span></span><br><span class="line">    vipa.Account.balance = <span class="number">10000</span></span><br><span class="line">    vipa.Account.withdraw(<span class="number">500</span>)</span><br><span class="line">    vipa.Account.Query()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们在主函数中声明了一个VIP账户，并为该账户的用户名和初始余额赋值，接下来我们通过私有方法withdraw模拟取出一些余额，最后在通过公有方法输出剩余的余额值。程序的输出结果为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">余额为： <span class="number">9500</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从上述结果可知，通过子类对象是可以调用父类的属性和方法，且不论父类的属性方法是公有的还是私有的，全部可以被继承下来。这个点上是与传统面向对象语言完全不同的。不过即便是子类继承了父类的所有属性和方法，但是继承得到的作用域还是不变的。即父类中withdraw是私有的，不可以在其他包中使用，那么子类中的withdraw也是私有的，同样不可以在其他的包中使用。</p>
<h4 id="3-子类中调用属性和方法可以简化"><a href="#3-子类中调用属性和方法可以简化" class="headerlink" title="3. 子类中调用属性和方法可以简化"></a>3. 子类中调用属性和方法可以简化</h4><p>&emsp;&emsp;在上个小节的快速入门和这个小节的前面一部分中，我们都是通过子类对象.匿名结构体.属性/方法的方式来完成调用的，这种调用方式是可以在任何情况下都适用的。不过在一些情况下，为了简便操作，我们可以将匿名结构体所省略。可以理解为：子类中继承了父类的所有属性，因此子类相当于有了同样的属性，所以，我们可以直接通过子类对象.属性/方法的方式来调用。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> vipa VIPAccount</span><br><span class="line">    vipa.Account.Name = <span class="string">"DENG"</span></span><br><span class="line">    vipa.Account.balance = <span class="number">10000</span></span><br><span class="line">    vipa.Account.withdraw(<span class="number">500</span>)</span><br><span class="line">    vipa.Account.Query()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上述的代码中我们使用的方式就是原始的方式，我们可以对上述代码修改为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> vipa VIPAccount</span><br><span class="line">    vipa.Name = <span class="string">"DENG"</span></span><br><span class="line">    vipa.balance = <span class="number">10000</span></span><br><span class="line">    vipa.withdraw(<span class="number">500</span>)</span><br><span class="line">    vipa.Query()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但是这种简化方式并不是任何时候都通用的，当出现属性或者方法名冲突的时候，就需要明确指定具体的属性或方法了。</p>
<h4 id="4-当子类和匿名结构体有同样的属性或字段时就近原则"><a href="#4-当子类和匿名结构体有同样的属性或字段时就近原则" class="headerlink" title="4. 当子类和匿名结构体有同样的属性或字段时就近原则"></a>4. 当子类和匿名结构体有同样的属性或字段时就近原则</h4><p>&emsp;&emsp;在一些情况下，子类中的属性和父类中的属性可能会相互冲突，例如马车既继承与马，又继承与车，而马和车都可以移动，这样马车在继承了两个父类的情况下，它的移动行为的继承就是相互冲突的。我们通过例子来说明这个问题。首先我们假设如下两个类：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从上述代码中我们可以看出，我们首先声明了一个Person类，且Person类中包含Name和Age属性。接下来我们又定义了Child类，Child类不仅继承了Person类，还又定义了一个Name属性。此时在Child类中就具备了两个Name属性，我们依旧在main函数中进行声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Child</span><br><span class="line">    c.Name = <span class="string">"DENG"</span></span><br><span class="line">    c.Person.Name = <span class="string">"YANG"</span></span><br><span class="line">    fmt.Println(c.Name)</span><br><span class="line">    fmt.Println(c.Person.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DENG</span><br><span class="line">YANG</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述的代码中，我们分别采用子类对象.属性和子类对象.匿名结构体.属性进行了赋值和输出，通过运行结果可以发现，这两种不同的赋值方法所得到的结果是不同的。当父类和子类都有同名的属性时，且当直接子类对象.属性时，访问的是子类的属性。我们再举一个例子，假设A类中有Name属性，B类继承于A类，且B类中自己又定义一个Name属性，再之后C类继承于B类。假如主函数中C类有一个实例c，此时c.Name访问的是B类中的Name属性，c.B.A.Name才是A类中的Name属性。 </p>
<p>&emsp;&emsp;换句话说，当我们简化调用时，会根据继承树逐级向上找，直到找到距离调用点最近的属性为止，如果找遍了继承树都没有找到对应的属性，就会报错。此外，方法的冲突也是同一个道理。</p>
<h4 id="5-多重继承导致的属性-方法冲突，必须要明确匿名结构体"><a href="#5-多重继承导致的属性-方法冲突，必须要明确匿名结构体" class="headerlink" title="5. 多重继承导致的属性/方法冲突，必须要明确匿名结构体"></a>5. 多重继承导致的属性/方法冲突，必须要明确匿名结构体</h4><p>&emsp;&emsp;在第四个小点中，我们讲解的情况是子类中新定义了父类中存在的属性或方法，在这个小点中，我们将讲解子类继承了多个父类，且多个父类中存在相同的属性。当直接使用子类对象访问属性时，会根据继承树找到最近的属性，然而当两个父类中的属性同样近的时候，则必须需要指明，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">struct</span> &#123;</span><br><span class="line">    A</span><br><span class="line">    B</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c C</span><br><span class="line">    c.Name = <span class="string">"DENG"</span></span><br><span class="line">    fmt.Println(c.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述代码中，我们可以发现，A类和B类中都具备Name属性，且C继承了A和B两个类，此时我们通过c.Name来访问属性则会出现模糊的问题。因为C类中没有Name属性，因此需要根据继承树向上查找，且找到了A类和B类均有Name属性，此时错误结果为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ambiguous selector c.Name</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们在代码中所写的c.Name编译器并不能确定具体是哪个父类的属性，因此就会报错。此时我们再访问属性的时候，就需要指明具体哪个父类的匿名结构体中的属性了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c C</span><br><span class="line">    c.A.Name = <span class="string">"DENG"</span></span><br><span class="line">    fmt.Println(c.A.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们通过代码和概念更为深入地讲解了Go语言中继承技术的细节点，并讲解了在属性访问过程中的几个原则。Go语言中具备多继承的理念即一个子类继承多个父类，但在日常开发中这个理念并不提倡，因为在多继承的过程中十分容易出现属性或方法名的冲突，使得开发者不得不需要指定对应的父类匿名结构体来调用。这个过程相对而言不是很方便。最后我们在小节中出一道简单的测试，来证明是否完全理解了本节的知识点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span> <span class="title">sayName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(a.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    A</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">sayName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b.A.Name = <span class="string">"GUO"</span></span><br><span class="line">    fmt.Println(b.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b B</span><br><span class="line">    b.Name = <span class="string">"DENG"</span></span><br><span class="line">    b.A.Name = <span class="string">"YANG"</span></span><br><span class="line">    b.A.sayName()</span><br><span class="line">    b.sayName()</span><br><span class="line">    b.A.sayName()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这段程序的最终输出结果是什么？</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/03/17/43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/" class="pre">Go语言从入门到放弃系列&lt;43&gt; 面向对象-接口</a><a href="/2020/03/15/41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/" class="next">Go语言从入门到放弃系列&lt;41&gt; 面向对象-继承</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-42-gt-面向对象-继承细节讨论"><span class="toc-text">Go语言从入门到放弃系列&lt;42&gt; 面向对象-继承细节讨论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Go语言中继承关系是通过匿名结构体完成的"><span class="toc-text">1. Go语言中继承关系是通过匿名结构体完成的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-父类中的全部属性和方法均被继承"><span class="toc-text">2. 父类中的全部属性和方法均被继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-子类中调用属性和方法可以简化"><span class="toc-text">3. 子类中调用属性和方法可以简化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-当子类和匿名结构体有同样的属性或字段时就近原则"><span class="toc-text">4. 当子类和匿名结构体有同样的属性或字段时就近原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-多重继承导致的属性-方法冲突，必须要明确匿名结构体"><span class="toc-text">5. 多重继承导致的属性&#x2F;方法冲突，必须要明确匿名结构体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/17/43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/">Go语言从入门到放弃系列<43> 面向对象-接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<42> 面向对象-继承细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/">Go语言从入门到放弃系列<41> 面向对象-继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/14/40-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/">Go语言从入门到放弃系列<40> 面向对象-封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/39-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">Go语言从入门到放弃系列<39> 面向对象-方法细节与工厂模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/12/38-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95/">Go语言从入门到放弃系列<38> 面向对象-方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/11/37-%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<37> 结构体细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/36-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%93%E6%9E%84%E4%BD%93/">Go语言从入门到放弃系列<36> 面向对象-结构体</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/09/35-map%E6%98%A0%E5%B0%84%E7%9A%84%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<35> map映射的细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/08/34-map%E6%98%A0%E5%B0%84/">Go语言从入门到放弃系列<34> map映射</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">43</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>