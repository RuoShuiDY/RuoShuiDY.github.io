<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;36&gt; 面向对象-结构体 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;36&gt; 面向对象-结构体</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;36&gt; 面向对象-结构体</h1><div class="post-meta"><a href="/2020/03/10/36-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%93%E6%9E%84%E4%BD%93/#comments" class="comment-count"></a><p><span class="date">Mar 10, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-36-gt-面向对象-结构体"><a href="#Go语言从入门到放弃系列-lt-36-gt-面向对象-结构体" class="headerlink" title="Go语言从入门到放弃系列&lt;36&gt; 面向对象-结构体"></a>Go语言从入门到放弃系列&lt;36&gt; 面向对象-结构体</h2><p>&emsp;&emsp;在这个小节之前，可以说我们一直在讨论面向过程的各个知识点。不论是否理解什么是面向过程，我们到目前为止所想到的解决办法都是基于过程的，即分析出解决问题所需要的所有步骤，通过函数逐一进行实现，最后再一个一个地依次调用，以达到解决问题的目的。这种编程思想的需求便是要对过程有着清楚的了解，对过程逻辑有较好的实现，但是在大型程序的后期维护上相对较难。 </p>
<p>&emsp;&emsp;从这个小节中，我们将开始介绍Go语言中面向对象思想以及Go语言的独特的面向对象的实现方式。由于我们是从面向过程部分开始讲解的，因此一开始可能会相对难从面向过程的思想中跳出，而转变这个编程思路的唯一方式就是多思考、多编程而已。</p>
<h3 id="面向对象概念"><a href="#面向对象概念" class="headerlink" title="面向对象概念"></a>面向对象概念</h3><p>&emsp;&emsp;准确地说，不同人对于面向对象的理解都不太一致，直接复制粘贴其他人的或者维基百科的理解并不能加深个人对面向对象思想的理解。况且面向对象只是一种思想，不同的语言对于这个思想的实现方式不同，其侧重点也不甚相同，在这个小节中，我也只是讲述的是我个人对面向对象思想的理解、以及Go语言前提下独特的对面向对象的实现。  </p>
<p>&emsp;&emsp;首先，我们举一个相对容易理解的例子来说明面向过程：贪食蛇游戏的开发。首先初始化地图与蛇身，之后判断蛇的运动方向，进行蛇移动操作，判断是否吃到食物，判断是否撞到障碍，判断是否游戏结束，之后再一次进行同样的循环。把以上的各个需求分别用函数完成，最后再以上述的顺序连接就完成了游戏的开发。 用这种方式思考得出结果的过程就是面向过程的思想。</p>
<p>&emsp;&emsp;如果采用面向对象的方式来解决这个问题，考虑的方式则完全不同。这个需求可以分为几个大的部分：1. 蛇的部分，它具备位置与是否死亡等多种属性，具备向四个方向移动、成长等多种行为；2. 食物的部分：它具备自己的自然属性即碰到后身体加长、随机生成初始位置等行为；3. 地图的部分：控制游戏的开始与结束行为，完成蛇头与墙壁、石头的碰撞逻辑等。最后通过一定的方式将不同部分的不同属性、行为联系在一起完成程序的开发。换句话说，就是几个实体之间的行为与属性的联系。</p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>&emsp;&emsp;在了解面向对象的各个特点之前，我们首先需要介绍一下对象的概念，对象就是指现实世界或虚拟世界中存在的任何的所有的事物实体，可以讲：一切均是对象。整体来说，对象可以由两部分构成：属性与行为。 </p>
<p>&emsp;&emsp;属性是用来描述某个抽象物体的特征的，例如我们将一个人作为对象来看，她的身高、体重、国籍、甚至家庭住址都是这个人的属性。属性是是对象的静态的一面，虽说身高体重等都可以发生改变，但是这些依旧是可以通过数值等来形容的。而行为则是对象中属于动态的一面，我们依旧以一个人为例：这个人可以跑、可以跳、会算数、能长大。这些动态的行为就是面向对象的方法，而类之中的方法往往是服务于类中的属性的。 </p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>&emsp;&emsp;那么什么是类：具备同种属性的对象称之为类，这是个相对抽象的概念，具象地理解可以理解为模板。例如：人就是一个类，而具体到你我他都是人类所对应的对象。人类具备两个眼睛、两个耳朵、一个鼻子等，而具体到每个人都具备这些属性。因此来说，类就相当于一个模板，这个模板定义了对象们应该有的属性、公共特征以及行为功能，而对象则是类的一个实例化。我们在编写程序的时候经常会将一个类实例化，并且使用该对象，就类比于某个人会弹琴，而不是人类会弹琴。 </p>
<h4 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h4><p>&emsp;&emsp;面向对象编程中有三大特性，分别为继承、封装、多态。在这里我们先不做过多的讲述，因为这三个特性在后续的讲解中均是重点知识，而且Go语言对这三个特性的实现也与其他很多语言都不同。 </p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>&emsp;&emsp;现在我们回到技术层面来考虑问题，在Go语言中是如何实现面向对象编程的。在之前所讲解的map映射中我们一直在回避一个问题，这个问题就是一个学号对应一个学生姓名，但是往往并不是仅仅如此，我们需要存储更多的信息，例如学生姓名、学生性别、学生住址等。当输入学生的学号时，将对应学生的信息都打印出来，这个需求该如何去完成。如果采用之前讲解到的技术，可能为值为map类型的map映射： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stuInfo <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">stuInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">stuInfo[<span class="number">10001</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">stuInfo[<span class="number">10001</span>][<span class="string">"name"</span>] = <span class="string">"Devin"</span></span><br><span class="line">stuInfo[<span class="number">10001</span>][<span class="string">"gender"</span>] = <span class="string">"Male"</span></span><br><span class="line">stuInfo[<span class="number">10001</span>][<span class="string">"address"</span>] = <span class="string">"Melbourne"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(stuInfo[<span class="number">10001</span>][<span class="string">"gender"</span>])</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这种实现方式虽然可以完成上述需求，但是这种方式实在是过于繁琐，假如需要根据平均分等指标进行排序就又会更复杂。因此我们可能会想在Go语言中是否存在这样一种数据结构：它可以是多个数据类型的集合，在逻辑上可以被看做一个整体，这样在做管理的时候会十分地方便。 </p>
<p>&emsp;&emsp;结构体就刚好可以满足上述的要求，它更贴近于类的概念。在之前我们的设想中采用多个数组分别存储这些属性，根据数组的下标值进行管理，可以讲这种方式是一种横向的方式，各个属性是相互分立的。而结构体则是一种纵向的方式，将一个对象的各个属性集合在一起，不同的对象是相互分立的。采用结构体完成上述需求的入门案例为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stuInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    gender <span class="keyword">string</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu stuInfo</span><br><span class="line">    stu.name = <span class="string">"Devin"</span></span><br><span class="line">    stu.gender = <span class="string">"Male"</span></span><br><span class="line">    stu.address = <span class="string">"Melbourne"</span></span><br><span class="line">    fmt.Println(stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述代码中，我们首先定义了一个结构体，即定义了一个数据模板，目前这个结构体中只含有三个属性。在主函数中，我们根据这个类实例化了一个对象stu，在这之后所有的操作都是针对对象stu的，为stu中三个属性进行赋值，最后再进行输出。</p>
<h3 id="结构体中内存对齐"><a href="#结构体中内存对齐" class="headerlink" title="结构体中内存对齐"></a>结构体中内存对齐</h3><p>&emsp;&emsp;在Go语言的结构体中，存在着一种叫做内存对齐的情况，熟悉旧版C语言但是没有接触过内存对齐的人可能会对这个问题比较陌生。我们举一个例子：假如一个结构体中按顺序含有一个byte，一个int64，两个bool，和一个float32数据，那么这个结构体在内存中占用了多大的空间。结构体体定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> str <span class="keyword">struct</span> &#123;</span><br><span class="line">    byte_field 	<span class="keyword">byte</span></span><br><span class="line">    int64_field <span class="keyword">int64</span></span><br><span class="line">    bool1    	<span class="keyword">bool</span></span><br><span class="line">    float_field <span class="keyword">float32</span></span><br><span class="line">    bool2    	<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在标准C语言的思想中，我们可能会想：byte是1个字节、int64是8个字节、bool是1个字节、float32是4个字节，所以这个结构体总共占据1+8+1+1+4=15个字节的空间，这种问题往往还会在考试中考。然而如果我们采用”unsafe”包中的Sizeof函数来测量这个结构体在内存中的空间时，其输出结构竟然是32个字节，而不是我们分析得到的15个字节。 </p>
<p>&emsp;&emsp;出现这个差异的原因就是Go语言中的结构体实行了内存对齐。计算机以及一些嵌入式设备在读取内存的时候往往不是一个字节一个字节的地读，而是一块一块地读。对于64位的机器而言，计算机一次读取8个字节的内存，对于32位机器而言则是读取4个字节。假如所有数据都是两两相邻的，例如一个bool变量和一个int64变量，计算机在读取的时候（64位机器），是先读取8个字节的空间，发现里面有bool变量，但是当计算机读取int64变量的时候，它需要先读取前8个字节并取其中的后7个字节，然后再读取后8个字节取其中的第一个字节，最后再将两部分拼接起来，这样读取速度就会受到影响。 </p>
<p>&emsp;&emsp;因此内存对齐的作用就体现出来了，其思想便是利用空间换取时间，让第一个bool单独占据8个字节的位置，然后int64占据8个字节，这样读取效率就会提升。不仅如此，在对齐的最后还会让结构体的空间再对齐，使得结构体数组中任意两个结构体的读取更快捷。Go语言结构体中内存对齐有两个原则：1. 每个变量相对于结构体地址的偏移量应该成为该数据类型所占字节的整数倍，例如int16相对于起始位置需要是2的整数倍，float64相对于起始位置需要是8的整数倍。对于数组等集合型数据类型，按其中元素的数据类型来算。 2.结构体整体占据的空间需要是4的整数倍（32位机器）或8的整数倍（64位机器）。 </p>
<p>&emsp;&emsp;因此针对于题目中的结构体我们需要做如下的分析：<br>&emsp;&emsp;&emsp;&emsp;1. 首先第一个属性是一个byte，其占据一个字节的空间。目前的内存为：     </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|x</span><br><span class="line">(x表示有数据，.表示空余)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;&emsp;&emsp;2. 第二个属性是一个int64数据，其占据8个字节，然而假如将其直接加在后面，其偏移量不是8的整数倍，因此对于这个变量需要进行内存对齐，对齐的方式是中间空余7个位置，内存表示如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;&emsp;&emsp;3.第三个属性是bool变量，应该占据1个字节，由于任何数都是1的整数倍，因此直接加在后面是满足于条件1的，内存表示如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|x</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;&emsp;&emsp;4. 第四个属性是float32类型变量，占据4个字节，如果直接加在bool的后面，其偏移量为17,而17并不是4的整数倍，因此需要进行内存对齐，对齐位置应该是偏移量为20的位置，内存如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|x...xxxx|</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;&emsp;&emsp;5. 最后一个变量还是bool类型，同理它可以直接加入到任何一个变量的后面，所以这个变量直接加在float32后面。此时的内存如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|x...xxxx|x</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;&emsp;&emsp;6. 此时结构体内部的各个变量的位置已经分好了，即每一个属性的位置都满足于条件1，而整个结构体此时的字节数为25，然而25并不是8的整数倍，其最近的整数倍为32，所以最终这个结构体在内存中的分布为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|x...xxxx|x.......|</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从上述的解释中，我们可以发现：其实在第一个字节中有效位置只有一个二进制位，而浪费了七个二进制位，对于最后一个字节依旧是如此。那么在结构体的设计上，我们明明可以将两个bool变量定义到一起去，这样不仅第一个字节利用率变高，最后一个字节也不需要整体内存对齐，对于结构体的空间占用就减少了1/4。而解决办法，其实只是将属性定义的顺序修改一下即可。</p>
<p>&emsp;&emsp;但是一般的算法优化并不会针对结构体的设计方面进行优化，因为相比于主流的时间空间复杂度的优化方式，这种优化所得到的收益实在是太低了。因此，内存对齐的优化方式并不主流，但也不失为一种简单而有效的优化方式。</p>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>&emsp;&emsp;在这个地方为了加强对内存对齐的理解，我们假设存在这样的一个结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int64</span></span><br><span class="line">    isAdult <span class="keyword">bool</span></span><br><span class="line">    grades [<span class="number">3</span>]<span class="keyword">float32</span> <span class="comment">//假设只有三门课</span></span><br><span class="line">    friends []stu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;那么请问，这个结构体变量在内存中会占据多大的空间。答案是64  ，读者可以自行分析。（注：string类型占16字节、切片占24字节，具体原因我们在前面都讲解过）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|xxxxxxxx|xxxxxxxx|xxxxxxxx| x...xxxx|xxxxxxxx|xxxxxxxx|xxxxxxxx|xxxxxxxx|</span><br><span class="line">|<span class="keyword">string</span>           |<span class="keyword">int64</span>   |<span class="keyword">bool</span>|[<span class="number">3</span>]<span class="keyword">float32</span>   |[]stu                     |</span><br></pre></td></tr></table></figure>



<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们初步讲解了面向对象编程思想与面向过程编程思想的区别，同时引入了Go语言中结构体这种数据类型，并对结构体数据类型做了一个简单的快速入门举例。最后我们讲解了Go语言结构体中的内存对齐的现象，说明了这种语言与其他某些语言的不同点。 </p>
<p>&emsp;&emsp;在下一个小节中，我们依旧将针对于结构体数据类型的四种声明以及初始化方式进行讲解，并集中提及在代码实现过程中需要注意到的问题和细节。</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/03/11/37-%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/" class="pre">Go语言从入门到放弃系列&lt;37&gt; 结构体细节讨论</a><a href="/2020/03/09/35-map%E6%98%A0%E5%B0%84%E7%9A%84%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/" class="next">Go语言从入门到放弃系列&lt;35&gt; map映射的细节讨论</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-36-gt-面向对象-结构体"><span class="toc-text">Go语言从入门到放弃系列&lt;36&gt; 面向对象-结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象概念"><span class="toc-text">面向对象概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#对象"><span class="toc-text">对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类"><span class="toc-text">类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面向对象三大特性"><span class="toc-text">面向对象三大特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体"><span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体中内存对齐"><span class="toc-text">结构体中内存对齐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#练习"><span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/17/43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/">Go语言从入门到放弃系列<43> 面向对象-接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<42> 面向对象-继承细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/">Go语言从入门到放弃系列<41> 面向对象-继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/14/40-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/">Go语言从入门到放弃系列<40> 面向对象-封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/39-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">Go语言从入门到放弃系列<39> 面向对象-方法细节与工厂模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/12/38-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95/">Go语言从入门到放弃系列<38> 面向对象-方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/11/37-%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<37> 结构体细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/36-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%93%E6%9E%84%E4%BD%93/">Go语言从入门到放弃系列<36> 面向对象-结构体</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/09/35-map%E6%98%A0%E5%B0%84%E7%9A%84%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<35> map映射的细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/08/34-map%E6%98%A0%E5%B0%84/">Go语言从入门到放弃系列<34> map映射</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">43</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>