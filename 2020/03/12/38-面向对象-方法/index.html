<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;38&gt; 面向对象-方法 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;38&gt; 面向对象-方法</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;38&gt; 面向对象-方法</h1><div class="post-meta"><a href="/2020/03/12/38-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95/#comments" class="comment-count"></a><p><span class="date">Mar 12, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-38-gt-面向对象-方法"><a href="#Go语言从入门到放弃系列-lt-38-gt-面向对象-方法" class="headerlink" title="Go语言从入门到放弃系列&lt;38&gt; 面向对象-方法"></a>Go语言从入门到放弃系列&lt;38&gt; 面向对象-方法</h2><p>&emsp;&emsp;在上两个小节中，我们讲解了Go语言中面向对象部分的结构体的概念及使用。在结构体中，我们涉及到的最多的都是各种属性，例如一个人的类的结构体中会具备眼睛、鼻子、耳朵、嘴等属性，但是这些属性相对于面向对象而言更为”静态”。即它只说明了一个结构体中、一个类中具备什么样的性质，而没有指明这个类对应的实例能够做什么，例如一个人可以行走、可以观察等，这些相对”动态”的行为是由面向对象中的方法完成的。 </p>
<h3 id="方法快速入门"><a href="#方法快速入门" class="headerlink" title="方法快速入门"></a>方法快速入门</h3><p>&emsp;&emsp;在Go语言的面向对象体系中，有一个和函数十分类似的概念，我们称之为方法。在一些完全面向对象的计算机语言中，函数和方法是通用的，函数主要是指面向过程中的程序单元，方法主要是指面向对象中的类行为。可以说函数的说法是先于方法的，面向对象语言的发展是基于面向过程的，因此对于Java、PHP等语言来说函数和方法是等价的，而对于C++、Go等既包含面向过程部分也包含面向对象部分的语言来说，函数和方法是两个十分相似但是本质不同的概念。 </p>
<p>&emsp;&emsp;我们在方法的引出过程中也提及到了：方法(method)是针对于某一个类甚至是某几个类而言的，不同的类方法是可以不相同的，例如对于人类来说，我们可以具备使用工具、计算、行走等行为，但是对于鸟类来说他们具备飞行等行为，同理在Go语言中，每一个方法的出现往往会指定某一个类型作为”接收者”，即在某种情况下这个方式仅仅隶属于某一个类。在这里我们依旧沿用上一节中举的例子：学生类</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int</span></span><br><span class="line">    friends []stu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这个类中，我们仅仅指明了一个学生结构体中具备姓名、年龄、以及朋友三个属性，而对于学生类的实例具体能做什么没有任何的说明。接下来我们假设一个学生实例可以完成计算两个数的加和的行为，此时根据上述的分析，方法在定义中需要指明某一个行为属于某一个类，那么此时计算的行为可以如下表示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s stu)</span> <span class="title">calculate</span><span class="params">(n1, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上述的程序段就可以称为一个方法，我们可以发现方法和函数不仅在概念上十分的相似，在定义方式上也是十分的相像。既然方法也是为了完成某一个目的而进行了抽象，那么方法的定义中也可以存在参数或者返回值，它与函数的唯一区别就是它需要指明这个方法归属于哪个类，在上述的方法定义中指明了归属于stu。 </p>
<p>&emsp;&emsp;在一些面向对象语言中，方法的定义是在class类中，和属性的定义相平行，这样的做法使方法得以访问到类中所定义的属性。在Go语言中，方法的实现是不相同的，它的方法是定义在struct结构体之外的，通过字段的指定来确定方法的归属。因此方法的调用是需要通过对应的类的实例来完成的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> student stu = stu&#123;&#125;</span><br><span class="line">    fmt.Println(student.calculate(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;首先通过学生类实例化一个对象，然后通过这个student对象来完成计算方法的调用。一个类具备某种行为，由该类实例化得到的个体对象当然也具备该方法的使用能力，因此此时可以通过”.”来完成从属关系的调用。</p>
<h3 id="方法的”传参”机制"><a href="#方法的”传参”机制" class="headerlink" title="方法的”传参”机制"></a>方法的”传参”机制</h3><p>&emsp;&emsp;在这个小部分中，我们所说的传参可以分为两部分来理解，一部分是方法的参数中的真的参数，另一部分则是方法归属类的抽象实例。方法的参数与函数的参数是相同的，即传入的数据类型是值类型的时候是在内存中复制一份原有数据再传入，传入的数据与原数据没有关系；当传入的数据类型为引用类型或指针时，则复制一份指向的地址传入，函数、方法中对数据的修改会影响到原数据。这个似乎不难理解，我们在函数的讲解中已经十分详细地介绍过了。 </p>
<p>&emsp;&emsp;现在我们回到Go语言对于面向对象特性的实现方式上，其他语言可以在方法中调用到类中的属性，那么在Go语言中这个特性也应该可以完成。由于方法的定义中已然指明了它所归属的类，所以此时<strong>假如</strong>我们再传入一个该类所对应的实例（对象），通过该对象来访问实例中的属性数据就可以了。在Go语言中也确实就是如此设计的，方法在指明对应类的同时直接传入一个抽象的实例，传入的方式和函数的传参一致，而又由于结构体本身是值类型，因此对应的抽象实例也就是和值传递相同。 </p>
<p>&emsp;&emsp;我们换一种理解方式：假如在一个函数中需要传入一个对象，在函数中输出对象所对应的一个属性，我们可能会采用如下的方式来完成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span> <span class="params">(student stu)</span></span>&#123;</span><br><span class="line">    fmt.Println(student.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此时的student对象是作为函数参数传入的，且传入的方式为值传递，我们通过该对象完成了name属性值的输出。那么对于方法而言，已然指出的类的归属，那么就可以如下来完成了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(student stu)</span> <span class="title">method</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(student.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这个方法的定义中，student依然是值传递的方式传入的，从某种程度上讲，上述两种不同的函数与方法的实现方式，在理解过程中可以认为是相同的，即类的从属的指定作为方法的另一个参数。</p>
<h3 id="自定义类型的方法"><a href="#自定义类型的方法" class="headerlink" title="自定义类型的方法"></a>自定义类型的方法</h3><p>&emsp;&emsp;在Go语言中可以说通过type关键字所修饰的都是自定义数据类型，包括结构体的声明也可以被归结为自定义数据类型，因为不同的属性名、属性的数据类型、属性的个数所确定的结构体类型是完全不同的。既然Go语言中方法是作用于指定的数据类型上，那么只要是自定义类型，就都可以有方法，我们举一个例子： </p>
<p>&emsp;&emsp;现在我们的需求是为一个整数（int）添加一个方法，如果这个整数是奇数则返回false，是偶数则返回true。在此之前我们在程序中需要整数时直接定义一个int类型的变量，也不曾听说过整数类的概念，此时添加方法的途径就是将其变为一个自定义的数据类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Integer)</span> <span class="title">isEven</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num Integer = <span class="number">10</span></span><br><span class="line">    fmt.Println(num.isEven())</span><br><span class="line">    num++</span><br><span class="line">    fmt.Println(num.isEven())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如同声明结构体数据类型一般，我们通过type的方式将一个int类型自定义为Integer，此处的Integer数据类型就可以添加方法了，不仅如此，我们在main函数中将Integer变量进行自加操作，程序依旧可以完成对应的加法。由此可见：通过type的方式可以借助一些内置数据类型来自定义一些类型，这些类型可以添加方法，同时也同样具备数据本身的属性，如数学运算等。 </p>
<p>&emsp;&emsp;需要注意的一点是：我们通过type的方式为int类型自定义了一个Integer类型，如果在程序中有两个变量分别由int和Integer类型所定义，这两个变量的数据类型是不同的，在相互转化的时候需要进行强制转化。因此通过int定义的变量，是不具备isEven方法的，但是将其强转成Integer类型时就可以使用该方法了。</p>
<h3 id="String-方法"><a href="#String-方法" class="headerlink" title="String()方法"></a>String()方法</h3><p>&emsp;&emsp;在Go语言中我们经常通过fmt.Println()函数来完成数据向屏幕的输出，那我们可能会想了：当输出一个整数变量时编译器输出对应的值，当输出数组时编译器将数组中所有值都输出了，当输出引用类型的map时，编译器输出了指向的内存中的key和value的所有值，那么这个输出究竟遵循什么原则。 </p>
<p>&emsp;&emsp;在Go语言中一个数据类型如果实现了String()方法，那么当执行fmt.Println()时，输出到屏幕上的就是String()方法的返回值，我们举个例子：假如我们还是使用stu结构体，现在要求当我们使用fmt.Println(stu对象)的时候输出为：xxx(stu对象中的name属性)是个好人。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int</span></span><br><span class="line">    friends []stu</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s stu)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.name + <span class="string">"是个好人"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> student stu = stu&#123;<span class="string">"DENG"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    fmt.Println(student)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此时输出结果为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DENG是个好人</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;同样地我们也可以采用String方法来完成一些基本数据类型的其他形式的输出，当然前提条件是通过type关键字根据基本数据类型完成自定义类型的创建，然后再覆盖String方法，此处也不再做举例了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们引入了面向对象编程的另一个组成部分：方法，同时我们也通过一个入门案例完成了对方法的介绍。如果读者在之前掌握了Go语言中函数的概念与使用方式，那么对于方法的理解就轻而易举了，二者也有十分多的相似之处。最后我们又介绍了Go语言中独特的自定义数据类型的方法调用方式，以及String方法对一个数据类型的作用。 </p>
<p>&emsp;&emsp;在下个小节中，我们将继续讲解面向对象中方法的细节与注意事项，同时也会在下个小节中插入代码篇部分，简单针对几个小需求举几个方法的例子并进行简要地讲解。 </p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/03/13/39-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="pre">Go语言从入门到放弃系列&lt;39&gt; 面向对象-方法细节与工厂模式</a><a href="/2020/03/11/37-%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/" class="next">Go语言从入门到放弃系列&lt;37&gt; 结构体细节讨论</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-38-gt-面向对象-方法"><span class="toc-text">Go语言从入门到放弃系列&lt;38&gt; 面向对象-方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法快速入门"><span class="toc-text">方法快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法的”传参”机制"><span class="toc-text">方法的”传参”机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义类型的方法"><span class="toc-text">自定义类型的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-方法"><span class="toc-text">String()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/21/45-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/">Go语言从入门到放弃系列<45> 面向对象-多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/44-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<44> 面向对象-接口细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/17/43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/">Go语言从入门到放弃系列<43> 面向对象-接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<42> 面向对象-继承细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/">Go语言从入门到放弃系列<41> 面向对象-继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/14/40-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/">Go语言从入门到放弃系列<40> 面向对象-封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/39-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">Go语言从入门到放弃系列<39> 面向对象-方法细节与工厂模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/12/38-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95/">Go语言从入门到放弃系列<38> 面向对象-方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/11/37-%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<37> 结构体细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/36-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%93%E6%9E%84%E4%BD%93/">Go语言从入门到放弃系列<36> 面向对象-结构体</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">45</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>