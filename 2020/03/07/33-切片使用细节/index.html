<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;33&gt; 切片使用细节 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;33&gt; 切片使用细节</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;33&gt; 切片使用细节</h1><div class="post-meta"><a href="/2020/03/07/33-%E5%88%87%E7%89%87%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/#comments" class="comment-count"></a><p><span class="date">Mar 07, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-33-gt-切片使用细节"><a href="#Go语言从入门到放弃系列-lt-33-gt-切片使用细节" class="headerlink" title="Go语言从入门到放弃系列&lt;33&gt; 切片使用细节"></a>Go语言从入门到放弃系列&lt;33&gt; 切片使用细节</h2><p>&emsp;&emsp;在上一个小节中，我们通过案例引入了切片的概念，同时也讲解了切片的定义方式、使用方式、独特的追加元素与拷贝的方式。不仅如此，我们也讲解了切片的内存构成，并得到一个结论是切片是一个引用类型，且引用的底层就是一个Go语言中的数组。在这个小节中，我们将继续针对Go语言中的切片数据类型进行深入的讲解，并对其使用过程中的注意事项进行讲解。 </p>
<h3 id="len与cap函数"><a href="#len与cap函数" class="headerlink" title="len与cap函数"></a>len与cap函数</h3><p>&emsp;&emsp;在上一小节中，我们在对切片的内存进行图解的讲解时，我们在图中不仅画出了切片所指向的数组的物理地址，我们还在其后画出了两个值，分别为：切片的长度与切片的容量。首先我们通过一个入门程序来通过这两个函数的调用完成切片的长度与容量的获取：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice))</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从程序中，我们可以发现len函数和cap函数都是系统内建函数，是不需要引入任何的包的。同时len函数的返回值为切片的长度，cap函数的返回值为切片的容量。那么为什么会在切片的结构体中定义这两个变量，是因为切片的长度是可以动态变化的。 </p>
<p>&emsp;&emsp;如果我们将视角返回到数组中，如果我们有一个需求为当前已经满了的数组添加一个数字，我们可以能采用两种方式：第一种为将数组改变成为链表，这样就可以随意地添加、删减元素，但是此时数据的快速查找就变得非常不容易；第二种方式为：每当需要插入一个数据，就新申请一个长度+1的数组，并将原数组中的所有值复制给新的数组，并在最后加入新值，这种方式保存了数组的元素快速查找的特性，但是对于频繁增加数据的情况下就十分地浪费资源，因为做了极多次的申请与复制操作。 </p>
<p>&emsp;&emsp;而对于切片而言，由于其底层就是一个数组，因此将数组改为链表这个方式就基本不可能了，而每次都申请长度+1的数组又太过频繁了。因此解决方式是当数组元素个数已经满了，申请新的数组时就多申请一部分的空间以备用。当申请结束后新数组的长度成为切片的容量，新数组中存在元素的个数成为切片的长度，我们举一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice[<span class="number">0</span>])</span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice[<span class="number">0</span>])</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice))</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述程序中，我们定义了一个切片，且指定了长度为5，容量为10，此时由于切片定义后未修改值，所以输出的slice结果为：[0 0 0 0 0]，且输出了数组中第0个元素的物理地址，本次本机输出值为：0xc00008e000。然后我们为slice切片追加一个元素1，再一次输出该切片的元素，此时切片的长度变为了6，输出结果为：[0 0 0 0 0 1]，此时再次输出数组中的第0个元素的物理地址，本次本机为0xc00008e000。最后输出切片的长度为6，容量为10。 </p>
<p>&emsp;&emsp;从上述的输出结果中，我们可以总结出以下几点：每次执行append函数时，切片的长度会变为两个参数切片（或者可变参数）的长度的和，因为此时只追加一个元素，所以长度变为+1后的值；切片的容量在长度不超过容量数时不发生变化，一旦超出了我们下面会继续讲解；两次输出的切片所对应的数组的首地址是相同的，因此可以断定追加前与追加后是同一个数组，物理地址没有发生变化。 </p>
<p>&emsp;&emsp;上面的例子是追加元素后没有超出容量的情况，下面我们再举一个超出容量的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice[<span class="number">0</span>])</span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice[<span class="number">0</span>])</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice))</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这段程序与上述程序的唯一区别就是：将切片定义时的容量由10变为5，所以最初状态就是切片的长度为5，且只能容纳5个值，即底层的数组处于满员的状态。此时再添加一个元素，由于原数组已经无法容纳这些值了，所以需要申请一个新的数组，其输出结果可以证明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"><span class="number">0xc000080060</span></span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"><span class="number">0xc000092000</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从上述的输出结果中，我们可以看出：数组的首地址是不相同的，所以当追加数据时数据溢出的情况下底层会新申请一个数组。不仅如此，新申请的数组的长度（切片的容量）由5变成了10。</p>
<h3 id="切片注意事项与细节说明"><a href="#切片注意事项与细节说明" class="headerlink" title="切片注意事项与细节说明"></a>切片注意事项与细节说明</h3><p>&emsp;&emsp;在接下来的部分中，我们将针对于切片的使用细节以及注意事项作出简要的说明，这些细节可能在之前的部分中有所提及，可以一并回忆一下之前的知识点。 </p>
<ol>
<li><p>切片通过数组初始化时var slice = array[start:end] 是从数组下标为start开始到end为止（不含）的截取，且截取方式为：<strong>左闭右开</strong>。 </p>
<p>&emsp;&emsp;例如：取出数组中的全部元素成为切片是array[0:len(array)]而不是array[0:len(array)-1]。</p>
</li>
<li><p>切片初始化时依然不可以越界，其范围依旧在0到len(array)之间（左闭右开），但是是可以动态增长的。在数组的截取过程中，有一些截取部分的简化操作：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = array[<span class="number">0</span>:end]        		==&gt;  <span class="keyword">var</span> slice = array[:end]</span><br><span class="line"><span class="keyword">var</span> slice = array[start: <span class="built_in">len</span>(array)]  	==&gt;  <span class="keyword">var</span> slice = array[start:]</span><br><span class="line"><span class="keyword">var</span> slice = array[<span class="number">0</span>: <span class="built_in">len</span>(array)]    	==&gt;  <span class="keyword">var</span> slice = array[:]</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>cap是一个内置函数，不需要引入任何的包，用于统计切片的最大容量，在数据追加过程中，如果追加后长度没有超出容量则不变，一旦超出容量则新申请数组后容量变为二倍。在这里不做演示了，只放置一个示例程序，读者可以自行运行后观察数据规律：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"长度为：%d，容量为：%d\n"</span>, <span class="built_in">len</span>(nums), <span class="built_in">cap</span>(nums))</span><br><span class="line">    nums = <span class="built_in">append</span>(nums, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>切片的核心其实就是底层的数组，因此切片可以继续切片。</p>
</li>
<li><p>切片是引用类型，即作为函数参数传递时，被调用者对切片数据进行修改时会影响到调用者函数中的值。 </p>
<p>&emsp;&emsp;针对这个特性我们举一个例子：利用一个字符（整数）切片存储多个字符，并且在自定义函数中将该切片中所有大写字母转换成对应的小写字母。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> info []<span class="keyword">byte</span> = []<span class="keyword">byte</span>&#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'L'</span>, <span class="string">'O'</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(info); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, info[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    change(info)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(info); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, info[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(slice []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> delta = <span class="string">'a'</span> - <span class="string">'A'</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> slice[i] &gt;= <span class="string">'A'</span> &amp;&amp; slice[i] &lt;= <span class="string">'Z'</span> &#123;</span><br><span class="line">            slice[i] += <span class="keyword">byte</span>(delta)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="string类型与切片"><a href="#string类型与切片" class="headerlink" title="string类型与切片"></a>string类型与切片</h3><p>&emsp;&emsp;在Go语言中，string类型是一种相对特殊的基本数据类型。说其特殊是因为它也是引用了某一个底层数组而存在的。可以说，string类型的底层就是一个byte数组，但是这个数组是不能够通过单个字符修改方式进行访问或修改，在string的引用中，依旧无法对其进行修改。 </p>
<p>&emsp;&emsp;那么既然string的底层是byte数组，而切片底层也可以是byte数组，所以string和切片可以有一些异曲同工之妙，同时string字符串类型是可以进行切片操作的，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> info <span class="keyword">string</span> = <span class="string">"Hello World"</span></span><br><span class="line"><span class="keyword">var</span> slice = info[:<span class="number">6</span>]</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们之前只通过裁剪的方式对数组进行操作，而上述的程序中是可以直接通过裁剪的方式对string字符串进行操作的，这也侧面反映出了string的核心就是一个数组。 </p>
<p>&emsp;&emsp;除此之外，字符串类型是一种常量，一旦定义初始化后就不可以进行修改了，在数组中，我们可以通过a[i] = 10的方式对数组中任意一个元素进行修改，但是在string类型中，我们不可以通过str[0] = ‘a’的方式进行修改。这个是常量的属性所规定的。 </p>
<p>&emsp;&emsp;但有些时候可能就会出现类似如下的需求：输入一个字符串后，需要对每一个字符进行操作，例如把所有的大写字母转换成小写字母（程序核心实现函数已在上面的代码中提及）。既然string类型是常量无法被修改，我们只能通过将其转换成为一个切片来操作，我们只举一个简单的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> info <span class="keyword">string</span> = <span class="string">"Hello World"</span></span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">byte</span> = []<span class="keyword">byte</span>(info)</span><br><span class="line">...</span><br><span class="line">info = <span class="keyword">string</span>(slice)</span><br><span class="line">fmt.Println(info)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述程序中，我们首先定义了一个字符串string，然后将其强转成为一个byte切片（如果字符串中含有中文，需要转换成为rune切片），接下来对切片进行某种处理后，我们再将切片强转回string类型，这个过程结束后才相当于对字符串中的某些元素进行了操作。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们集中讲解了slice切片中的两个函数：len函数与cap函数的含义以及注意事项，同时也讲解了当执行append操作后slice中len和cap发生的变化，以及底层数组发生的相应的改变。除此之外，我们还讲解了slice类型在程序编写的过程中需要注意的问题，最后我们讲解了string基本数据类型与slice引用类型的相互关系。 </p>
<p>&emsp;&emsp;在下一个小节中，我们将开始介绍Go语言中map的含义以及使用方式，并将map这种数据类型与数组、切片等数据类型相结合做出相对具体的讲解。</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/03/08/34-map%E6%98%A0%E5%B0%84/" class="pre">Go语言从入门到放弃系列&lt;34&gt; map映射</a><a href="/2020/03/06/32-%E5%88%87%E7%89%87%E5%BC%95%E5%85%A5/" class="next">Go语言从入门到放弃系列&lt;32&gt; 切片引入</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-33-gt-切片使用细节"><span class="toc-text">Go语言从入门到放弃系列&lt;33&gt; 切片使用细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#len与cap函数"><span class="toc-text">len与cap函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切片注意事项与细节说明"><span class="toc-text">切片注意事项与细节说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string类型与切片"><span class="toc-text">string类型与切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/08/34-map%E6%98%A0%E5%B0%84/">Go语言从入门到放弃系列<34> map映射</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/07/33-%E5%88%87%E7%89%87%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/">Go语言从入门到放弃系列<33> 切片使用细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/32-%E5%88%87%E7%89%87%E5%BC%95%E5%85%A5/">Go语言从入门到放弃系列<32> 切片引入</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/05/31-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/">Go语言从入门到放弃系列<31> 二维数组与多维数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/04/30-%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81%E7%AF%87-%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/">Go语言从入门到放弃系列<30> 数组代码篇-几种排序方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/03/29-%E6%95%B0%E7%BB%84%E7%BB%86%E8%8A%82%E8%AE%B2%E8%A7%A3/">Go语言从入门到放弃系列<29> 数组细节讲解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/02/28-%E6%95%B0%E7%BB%84%E5%BC%95%E5%85%A5/">Go语言从入门到放弃系列<28> 数组引入</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/01/27-%E9%97%AD%E5%8C%85%E3%80%81defer%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/">Go语言从入门到放弃系列<27> 闭包、defer与作用域</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/26-init%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/">Go语言从入门到放弃系列<26> init函数与匿名函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/28/25-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%BA%8C/">Go语言从入门到放弃系列<25> 函数使用细节<二></a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">34</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>