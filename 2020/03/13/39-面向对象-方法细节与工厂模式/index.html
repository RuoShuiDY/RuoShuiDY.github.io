<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;39&gt; 面向对象-方法细节与工厂模式 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;39&gt; 面向对象-方法细节与工厂模式</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;39&gt; 面向对象-方法细节与工厂模式</h1><div class="post-meta"><a href="/2020/03/13/39-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/#comments" class="comment-count"></a><p><span class="date">Mar 13, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-39-gt-面向对象-方法细节与工厂模式"><a href="#Go语言从入门到放弃系列-lt-39-gt-面向对象-方法细节与工厂模式" class="headerlink" title="Go语言从入门到放弃系列&lt;39&gt; 面向对象-方法细节与工厂模式"></a>Go语言从入门到放弃系列&lt;39&gt; 面向对象-方法细节与工厂模式</h2><p>&emsp;&emsp;在上一个小节中，我们简单讲解了Go语言面向对象部分中的方法的概念，同时我们也通过简单的案例进行了快速入门的讲解。方法不论在定义上与使用上都与函数十分的类似，包括方法的传参机制也与函数如出一辙。除此之外，我们也对其他的自定义数据类型的方法做出了一定的讲解，并说明了Go语言中String方法的作用。 </p>
<p>&emsp;&emsp;在这个小节中，我们依旧对Go语言的方法进行讲解，主要说明方法在使用过程中的一些注意事项，以及Go语言中的工厂模式。</p>
<h3 id="方法的细节与注意事项"><a href="#方法的细节与注意事项" class="headerlink" title="方法的细节与注意事项"></a>方法的细节与注意事项</h3><h4 id="1-Go语言中的方法不支持重载"><a href="#1-Go语言中的方法不支持重载" class="headerlink" title="1. Go语言中的方法不支持重载"></a>1. Go语言中的方法不支持重载</h4><p>&emsp;&emsp;在传统面向对象语言中，方法是可以被重载的，即多个方法函数名相同，返回值相同，但是函数参数不同。例如，当初始化一个学生类的时候需要调用initStudent方法，且我们可以传入学生的姓名与学号。当用户只传入学号时则只初始化学号，当用户只传入姓名时则只初始化姓名，如果两个都输入则全部初始化。 </p>
<p>&emsp;&emsp;由于方法中定义的参数类型不同，参数个数不同，传统面向对象语言可以根据这两个特点寻找到用户需要调用哪一个初始化方法，并能够成功地完成操作。然而这个特性在Go语言中并不存在，一旦两个方法或函数的名字相同的时候，在编译过程中就会报错，且报错的内容为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method redeclared: xxx</span><br></pre></td></tr></table></figure>
<h4 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h4><p>&emsp;&emsp;当初在介绍到包的概念的时候我们提及过作用域的一些问题，在Go语言中存在两种作用域分别为共有的和私有的。当变量的首字母大写的时候是可以在其他包中访问到该变量的，当变量首字母是小写的时候则无法在其他包中访问。函数与方法也遵循这个原则：当函数名或方法名首字母大写的时候才可以在其他包中调用函数或方法，方法名首字母小写则只能在本包中使用，具体便不再举例了。</p>
<h4 id="3-接收者的类型"><a href="#3-接收者的类型" class="headerlink" title="3. 接收者的类型"></a>3. 接收者的类型</h4><p>&emsp;&emsp;接收者即指明的从属类，我们在之前的案例中都使用的是类的对象，也可以某种程度上理解为传入的一个参数为一个对象。由于struct是值传递，因此传入对象之后在方法中无法改变对象中的值，这个特性对于熟悉面向对象编程的开发者来说十分不友好，因此接收者不仅可以是类的对象，也可以是一个指针，我们举两个例子进行对比：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s stu)</span> <span class="title">setName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    s.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> student stu = stu&#123;<span class="string">"DENG"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    student.setName(<span class="string">"YANG"</span>)</span><br><span class="line">    fmt.Println(student.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在第一个例子中，我们在方法的接收者部分使用的是struct变量，且在setName方法中我们将stu中对应的name属性赋值。在main函数中我们首先为student的name赋值为”DENG”，然后通过setName方法进行修改，最后再进行输出。由于结构体的值类型的属性，传入到setName方法中的student是另一段内存，调用过后就释放了，因此输出结果为：DENG </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stu)</span> <span class="title">setName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    s.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> student stu = stu&#123;<span class="string">"DENG"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    student.setName(<span class="string">"YANG"</span>)</span><br><span class="line">    fmt.Println(student.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这个例子中，我们将方法的接收者改为一个stu指针，这样传入的就是一个student的引用，方法中的name修改直接影响到调用者的属性，因此此时的输出为：YANG </p>
<p>&emsp;&emsp;值得最后一次一提的是：我们只将stu改为了*stu，而其他的部分均没有发生变化，因此在上述的程序中我们使用了非常多的编译优化的特性，且这种特性对Java等开发者十分友好。如果读者已经完全明白引用与值的关系，在以后的编程过程中可以活用这个编译特性，本人在这里以及以后也对读者不做任何的限制了。</p>
<h4 id="4-编译器优化指针"><a href="#4-编译器优化指针" class="headerlink" title="4. 编译器优化指针"></a>4. 编译器优化指针</h4><p>&emsp;&emsp;在之前的介绍中，我们提到了Go语言的编译器对指针类型与数值类型的使用进行了优化，即根据函数参数的类型自动判断其应当传入的指针或数值类型。这种编译器优化只针对于方法，而不针对于函数。假如在函数的使用过程中出现了不匹配的情况，在编译过程中将直接报出错误。 </p>
<p>&emsp;&emsp;首先我们举一个函数的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showName</span><span class="params">(stu *student)</span></span> &#123;</span><br><span class="line">    fmt.Println(stu.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu student = student&#123;</span><br><span class="line">        name: <span class="string">"DENG"</span>,</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//showName(stu)  //cannot use stu (type student) as type *student in argument to showName</span></span><br><span class="line">    showName(&amp;stu)  <span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述的代码中，我们首先定义了一个结构体，然后又定义了一个showName的函数，由于它并没有绑定对象，因此它只是一个函数而非方法。最后在主函数中我们实例化一个结构体，并分别通过结构体对象和结构体对象指针进行showName的调用。由于在showName函数定义中，我们采用了student指针作为入参。因此在通过对象实例进行传参的时候出现了参数不匹配的情况。而采用实例指针进行传参的时候，程序可以正确执行并输出相应的结果。 </p>
<p>&emsp;&emsp;因此对于普通函数来说，<strong>编译器并没有对普通函数参数检查进行指针优化</strong>。 </p>
<p>&emsp;&emsp;接下来，我们将showName函数改为student类的一个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span> <span class="title">showName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(s.name)    <span class="comment">//正确</span></span><br><span class="line">    fmt.Println((*s).name)  <span class="comment">//正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu student = student&#123;</span><br><span class="line">        name: <span class="string">"DENG"</span>,</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    (&amp;stu).showName()  <span class="comment">//正确</span></span><br><span class="line">    stu.showName()    <span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这段代码中，我们将showName方法绑定到student类上，并在主函数中通过stu对象调用了showName方法。在主函数中，我们实例化了student类成为一个对象，并分别通过对象的方式和对象指针的方式调用了方法。同时，在方法中，我们通过传入的指针参数调用了s对象指针的name属性。在运行结果中，都可以正确地完成姓名的输出。 </p>
<p>&emsp;&emsp;因此，对于方法而言，<strong>编译器对方法进行了指针的优化</strong>。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>&emsp;&emsp;在这个部分中，我们将对Go语言中的工厂模式进行阐述，这种代码模式在日常开发中还是十分常见的。而且在多人代码合作中，这个模式用到地就更为常见了。 </p>
<h4 id="1-工厂模式引入"><a href="#1-工厂模式引入" class="headerlink" title="1. 工厂模式引入"></a>1. 工厂模式引入</h4><p>&emsp;&emsp;在之前的讲解中，我们提到标识符首字母的大小写是控制其可见性的一个标准。当标识符首字母大写的时候，我们可以通过其他包访问到这个变量或函数。如果标识符首字母小写的话，我们只可以在本包中访问对应的变量。然而在程序开发过程中，将所有的属性、方法都设定为共有是及其不可取的做法，这样做意味着其他的开发者可以在其他包中任意修改本包的数据。而将属性方法设定为私有的话，其他开发者又完全没有办法读取本包数据。因此，我们采用工厂模式来完成对应的优化。 </p>
<p>&emsp;&emsp;我们依旧采用demo包和test包举例，在test包中存在一个student的类，在demo包中完成对student对象属性的调用。首先我们假设Student类中有两个属性：Name和Age：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">test.<span class="keyword">go</span>：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">package</span> test</span><br><span class="line">    <span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        Age <span class="keyword">int8</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">demo.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">package</span> main</span><br><span class="line">    <span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"test"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> stu = test.Student&#123;</span><br><span class="line">            Name: <span class="string">"DENG"</span>,</span><br><span class="line">            Age: <span class="number">18</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(stu.Name)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上述代码实现当然是没有问题，因为Student的首字母是大写的，Student类中所有属性的首字母也都是大写的，因此Student类是完全共有的，不会出现属性访问的问题。那么假如两个包是由两个不同的人开发，且每个人都希望保护自己的代码，将Student的首字母小写成为student，那么当前的做法就会报错了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;修改过后，此时demo中会报错：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cannot refer to unexported name test.student</span><br><span class="line">undefined: test.student</span><br></pre></td></tr></table></figure>
<h4 id="2-解决方式"><a href="#2-解决方式" class="headerlink" title="2. 解决方式"></a>2. 解决方式</h4><p>&emsp;&emsp;既然类已经被限定在本包中使用而其他包无法创建，那么就让该类的实例化过程出现在该类对应的包中：在一个公有的函数中完成类的实例化，并将该对象通过指针的形式返回出去。这个公有的函数可以具备一些形式参数来完成对象的初始化，类似于构造函数。基于上述的案例，我们将test包中的代码修改为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">student</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">        Name: name,</span><br><span class="line">        Age: age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述代码中，我们在test包中通过NewStudent函数做了student类的实例化操作，并将该对象的指针通过返回值返回给调用者，由于NewStudent函数是公有的，因此其他包可以通过这个函数来完成实例化操作。对应的demo包中代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"test"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu = test.NewStudent(<span class="string">"DENG"</span>, <span class="number">18</span>)</span><br><span class="line">    fmt.Println(stu.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-属性权限控制"><a href="#3-属性权限控制" class="headerlink" title="3. 属性权限控制"></a>3. 属性权限控制</h4><p>&emsp;&emsp;完成了私有类的实例化操作后，对象中属性也可能会出现私有的现象。例如：希望student类中的Age属性只可以在其他包中读取，但是不可以在其他包中修改。完成这个操作的思路其实和类的实例化非常相似，唯一的区别是属性的权限控制可以通过方法来完成。我们直接通过代码说明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">student</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">        Name: name,</span><br><span class="line">        age: age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span> <span class="title">GetAge</span><span class="params">()</span> <span class="title">int8</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述代码中，我们修改了age的访问权限（首字母变为小写），这样在其他的包中就无法访问了，同时我们又添加了一个公有的方法GetAge，在这个方法中访问age属性。由于其他包中可以通过NewStudent函数得到对象，又可以通过对象得到属性，因此这种实现方式相当于间接访问到了age属性，但不可以修改它。 </p>
<p>&emsp;&emsp;此时demo.go中代码变为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main    </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"test"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu = test.NewStudent(<span class="string">"DENG"</span>, <span class="number">18</span>)</span><br><span class="line">    <span class="comment">//stu.age = 20  //stu.age undefined (cannot refer to unexported field or method age)</span></span><br><span class="line">    fmt.Println(stu.GetAge())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p> &emsp;&emsp;在这个小节中，我们继续讲解了Go语言中方法的概念以及注意事项，同时我们也针对Go语言中工厂模式进行了讲解，解决了私有属性的访问权限控制以及类的实例化的函数。在下几个小节中，我们将针对面向对象中的抽象和封装两个概念进行讲解。</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/03/14/40-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/" class="pre">Go语言从入门到放弃系列&lt;40&gt; 面向对象-封装</a><a href="/2020/03/12/38-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95/" class="next">Go语言从入门到放弃系列&lt;38&gt; 面向对象-方法</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-39-gt-面向对象-方法细节与工厂模式"><span class="toc-text">Go语言从入门到放弃系列&lt;39&gt; 面向对象-方法细节与工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法的细节与注意事项"><span class="toc-text">方法的细节与注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Go语言中的方法不支持重载"><span class="toc-text">1. Go语言中的方法不支持重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-作用域"><span class="toc-text">2. 作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-接收者的类型"><span class="toc-text">3. 接收者的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-编译器优化指针"><span class="toc-text">4. 编译器优化指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工厂模式"><span class="toc-text">工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-工厂模式引入"><span class="toc-text">1. 工厂模式引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-解决方式"><span class="toc-text">2. 解决方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-属性权限控制"><span class="toc-text">3. 属性权限控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/49-Goroutine%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/">Go语言从入门到放弃系列<49> Goroutine概念简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/25/48-JSON%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/">Go语言从入门到放弃系列<48> JSON与序列化</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/24/47-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%BA%8C/">Go语言从入门到放弃系列<47> 文件与IO<二></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/22/46-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%B8%80/">Go语言从入门到放弃系列<46> 文件与IO<一></a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/21/45-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/">Go语言从入门到放弃系列<45> 面向对象-多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/44-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<44> 面向对象-接口细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/17/43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/">Go语言从入门到放弃系列<43> 面向对象-接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<42> 面向对象-继承细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/">Go语言从入门到放弃系列<41> 面向对象-继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/14/40-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/">Go语言从入门到放弃系列<40> 面向对象-封装</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">49</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>