<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;56&gt; 终章-Socket网络编程 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;56&gt; 终章-Socket网络编程</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;56&gt; 终章-Socket网络编程</h1><div class="post-meta"><a href="/2020/04/06/56-%E7%BB%88%E7%AB%A0-Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#comments" class="comment-count"></a><p><span class="date">Apr 06, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-56-gt-终章-Socket网络编程"><a href="#Go语言从入门到放弃系列-lt-56-gt-终章-Socket网络编程" class="headerlink" title="Go语言从入门到放弃系列&lt;56&gt; 终章-Socket网络编程"></a>Go语言从入门到放弃系列&lt;56&gt; 终章-Socket网络编程</h2><p>&emsp;&emsp;在上个小节中，我们主要讲解了Go语言的反射技术。在这个小节中，我们将开始讲解Go语言中tcp/ip中socket编程的部分。对网络稍有了解的读者可能会知道网络编程中还有http协议的编写以及相应的cookie、session等操作，但是这个部分我将其归属在Go Web部分，因此在这个系列中我们不做讲解，我们只讲解更为基层的socket编程。 </p>
<p>&emsp;&emsp;由于Go语言对socket编程的封装已然很好了，因此这个小节我们其实主要是带读者查询以及实现一下对应的API，完成最基本的服务器与客户端之间的信息交互。更为复杂的问题基本上都是简单问题的罗列，只是需要处理更多的冲突而已。 </p>
<h3 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h3><p>&emsp;&emsp;在这个部分，我们主要讲解与socket编程相关的网络基础，而对于更为广泛的知识点我们就不做提及了，如果读者有兴趣可以专门系统地去学习计算机网络，里面会有更为全面的讲解。因为封装的特性，用户可以不必知道某个函数方法的底层做了什么，只需要在特定的环境下调用特定的方法即可。因此我也只说到这个层面为止。 </p>
<p>&emsp;&emsp;首先说什么是socket，socket也被称之为套接字，用于描述机器的IP地址与端口。socket也是一个通信句柄，客户端与服务器通过套接字发出请求与回复网络请求。在计算机系统中，套接字其实就是一种文件，亦或是文件模式的一种特殊的实现。文件可以有打开、关闭、读取、写入等操作，因此socket也具备这些操作。socket可以完成不同计算机之间的数据传输，例如QQ消息，网页操作等均是socket通信完成的。 </p>
<p>&emsp;&emsp;那么tcp/ip协议和udp协议与socket又有什么关系，tcp/ip与udp其实是两种协议，而socket则是操作系统实现的、面向两种协议簇的接口。因此可以说tcp/ip是一种规定，而socket是针对这个规定的实现。我们通过Go语言实现网络通信是在操纵socket，理论上来说不需要深度了解tcp/ip与udp的协议内容。但是既然是网络通讯还是简单说明一下tcp/ip协议与udp协议的区别： </p>
<p>&emsp;&emsp;tcp/ip协议是一种可靠的连接的协议，当两端通过tcp/ip协议通讯时首先通过三次握手建立连接，然后才可以互相发送请求。当连接需要关闭的时候，在进行四次挥手完成断开。因此数据的传输是在成功建立的连接的基础上的，因此当网络中出现丢包的现象时，两端是可以检测到的。 </p>
<p>&emsp;&emsp;而udp协议相对而言就比较简单了，他是一种无连接的传输方式。即不需要复杂的断开与连接，不需要确定客户端、服务器是否能收到发出的消息。只要知道了对方的ip和端口，就可以直接发送。因为其省却了建立连接与断开连接的繁杂的步骤，因此其效率更高，但是由于数据传输不以建立连接为基础，所以它并不安全。如果用一个形象的比喻来说：tcp/ip更像是打电话，电话接通了才能讲话，而udp更像是写信，信一旦寄出去可能顺利到达，也可能丢失在不知名的角落。 </p>
<h3 id="IP与端口"><a href="#IP与端口" class="headerlink" title="IP与端口"></a>IP与端口</h3><p>&emsp;&emsp;在上一个部分中我们提到了，socket网络传输是通过IP地址和端口号来完成的。IP地址是为网络中的电脑进行编号的，每一个联网的计算机（不论是局域网还是广域网）都需要有一个IP地址，只有这样一个计算机在网络中才具备一个身份。IP地址是一个32位的二进制数，一般情况下被分为四个8位的部分（0-255），用十进制进行表示，每个部分用点号隔开，例如：192.168.0.1；127.0.0.1等等。常见IP地址可以分为IPV4和IPV6，IPV6的出现是因为网络的发展过快，IPV4的发放不够用，因此需要更多的位数的IPV6重新定义地址空间。但是更多的情况下还是在使用IPV4。 </p>
<p>&emsp;&emsp;那么端口又是做什么的，端口可以说是区分一台机器上不同的进程的方式。我们举一个例子：一台计算机可以同时完成访问互联网（80），通过Java的Tomcat接收请求（8080），ssh远端连接（22），MySQL数据访问（3306）。那么一台计算机在网络中具备一个特殊标识，但是一台计算机与多个应用是处于一对多的关系，这个一对多关系的载体就是端口。例如，我们希望通过远端访问网络中某一台机器的数据库，我们就需要对IP+对应的端口进行请求。 </p>
<p>&emsp;&emsp;端口号是由整数标记的，范围是从0到65535。但是这么多的端口并不是全部都可以让程序员随意使用。首先0号端口是保留端口，不可以使用。1-1024是固定端口，这些端口是被某些系统级别的程序固定使用，一般来说程序员也不应该使用，例如如果某个程序占用了22端口，那么这个机器可能就不能完成ssh访问了，亦或在ssh服务打开的情况下，自己写的软件根本不能运行。剩余的1025-65535端口是动态端口，这些端口程序员可以使用，但是依旧需要避开一些主流软件所占用的端口。例如假如我们的软件使用的端口是3306，这个端口处于动态端口之中，理论上讲程序员可以随意使用。但是如果这样做就会出现一个问题，要么MySQL数据库在3306上就用不了，要么就是我们的软件用不了。因此端口的选用还是需要注意的。 </p>
<h3 id="网络编程入门案例"><a href="#网络编程入门案例" class="headerlink" title="网络编程入门案例"></a>网络编程入门案例</h3><p>&emsp;&emsp;在这个部分中，我们将逐步介绍Go语言中socket网络编程的入门案例。从服务器监听、客户端连接，到客户端与服务器相互发送消息，我们将一一实现。至于像QQ聊天室一般多对多的聊天，无非就是控制向哪个connection发送数据而已。首先我们从最为简单最为基础的案例开始：</p>
<h4 id="1-实现服务器监听，客户端连接"><a href="#1-实现服务器监听，客户端连接" class="headerlink" title="1.实现服务器监听，客户端连接"></a>1.实现服务器监听，客户端连接</h4><p>&emsp;&emsp;从这里开始，我们由于需要分别写服务器与客户端的代码实现，因此像之前一样用一个go文件显然是不合适的，因此我们重新建立两个独立的文件夹，第一个文件夹是client文件夹，里面放client相关的代码，另一个是server文件夹，里面放置server相关的go文件。 </p>
<p>&emsp;&emsp;首先我们讲解服务器的书写：对于一台机器而言，如果希望其成为一个服务器，首先需要为其分配一个监听的端口，一旦有消息从这个端口中进入计算机，那么就由这个服务器进行数据处理。因此服务器的第一个步骤是监听。那么当分配给了端口之后，服务器需要等待客户端去连接，如果没有客户端来连接，服务器应当处于一种阻塞的状态，因此服务器的第二个步骤是接收连接。当接收到连接之后，服务器就可以通过这个连接进行数据交互了，我们暂时先不说数据交互的方式，只测试监听与接收连接是否成功。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Server starts listening"</span>)</span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"0.0.0.0:2333"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Server listen error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> listener.Close()</span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Accept error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Server conn is:"</span>, conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述代码中，我们首先输出服务器开始监听，通过Listen方法指定tcp连接与ip+端口号，该方法返回net.Listener接口，该接口中含有Addr方法，Accept方法，与Close方法。为了程序结束时将listener关闭，我们通过defer来完成该操作。当服务器开始监听之后，我们让listener接收进来的请求，并将得到的连接对象输出出来。 </p>
<p>&emsp;&emsp;说完服务器，我们再说客户端，客户端相比于服务器操作就少了很多。客户端只需要在希望连接时向服务器的ip地址与端口号发送一个请求，如果能够连接上，就会返回net.Conn接口实例，然后再通过该对象进行数据交互。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:2333"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"connection fail"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    fmt.Println(<span class="string">"Client conn is:"</span>, conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这段代码中，我们通过net包中的Dial函数指定通过tcp方式向后面的ip+端口发送连接，在程序结束之后关闭对应的connection。当连接成功后，我们输出对应的conn接口实例。我们首先执行服务器代码，然后再执行客户端代码。结果如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server starts listening</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当执行了客户端代码之后，客户端控制台会输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Client conn is: &amp;&#123;&#123;<span class="number">0xc00009a000</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;因为有了客户端的连接，所以服务器会再输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server conn is: &amp;&#123;&#123;<span class="number">0xc00008e2c0</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-服务器循环等待多客户端"><a href="#2-服务器循环等待多客户端" class="headerlink" title="2. 服务器循环等待多客户端"></a>2. 服务器循环等待多客户端</h4><p>&emsp;&emsp;在前一段代码中，我们让服务器监听2333端口，等待客户端的连接，但是当有客户端来连接过后，服务器就直接结束了。一般情况下服务器还是要为多客户端服务的，因此往往等待客户端连接的操作是在循环中完成的。代码修改如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Server starts listening"</span>)</span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"0.0.0.0:2333"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Server listen error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> listener.Close()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Accept error:"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"Server conn is:"</span>, conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;服务器修改成如上代码之后，我们通过终端启动多个客户端，此时服务器就已然具备等待多个客户端的能力了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Server starts listening</span><br><span class="line">Server conn is: &amp;&#123;&#123;<span class="number">0xc00009e2c0</span>&#125;&#125;</span><br><span class="line">Server conn is: &amp;&#123;&#123;<span class="number">0xc00009e580</span>&#125;&#125;</span><br><span class="line">Server conn is: &amp;&#123;&#123;<span class="number">0xc00009e840</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-客户端服务器互相发送数据"><a href="#3-客户端服务器互相发送数据" class="headerlink" title="3.客户端服务器互相发送数据"></a>3.客户端服务器互相发送数据</h4><p>&emsp;&emsp;在客户端与服务器相连之后，就可以通过Conn接口实例进行数据传输了，在API文档中，Conn中含有两个方法，分别为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Read(b []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">Write(b []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读和写两个方法，我们就通过这两个方法完成数据的交互。首先我们依旧从服务器开始：当服务器接收到客户端的连接之后，服务器启动一个协程。这个协程专门负责服务器与这个客户端的信息交互。我们在先在服务器接收到消息，然后将消息输出到服务器的终端中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">        num, err := conn.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Read Error"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        content := <span class="keyword">string</span>(buf[:num])</span><br><span class="line">        fmt.Print(conn, <span class="string">":"</span>, content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Accept error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> process(conn)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在服务器中，我们写一个函数process，并通过协程调用它。在process中，我们将与客户端连接的conn传入，并在函数中循环接收消息：我们首先定义一个切片，并将切片传入到Read方法中，其返回值是一个整数num和一个error。我们取出buf切片中的前num个并组成一个字符串，就是接收到的消息了。</p>
<p>&emsp;&emsp;客户端中当然就是循环从控制台中读取消息，每读取一个字符串就通过conn的Write方法将该字符串写出到服务器：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    reader := bufio.NewReader(os.Stdin)</span><br><span class="line">    content, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Read from console error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    _, err = conn.Write([]<span class="keyword">byte</span>(content))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Write error"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此时再运行服务器，我们再启动两个客户端，我们可以发现两个客户端发送的消息都可以在服务器中接收到，并输出出来。</p>
<h4 id="4-服务器向客户端回送消息"><a href="#4-服务器向客户端回送消息" class="headerlink" title="4. 服务器向客户端回送消息"></a>4. 服务器向客户端回送消息</h4><p>&emsp;&emsp;现在我们再更新需求，当服务器收到了消息后，不仅要输出到终端，还要向客户端回送一条数据称消息已然收到。对于这个需求而言，我们首先修改服务器代码： </p>
<p>&emsp;&emsp;服务器在协程中循环接收客户端的消息，当接收到了消息之后直接通过Write方法向对应的conn接口写出即可，因此需要改动的部分并不大：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">        num, err := conn.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Read Error"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        _, err = conn.Write([]<span class="keyword">byte</span>(<span class="string">"Receive your message"</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Write error"</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        content := <span class="keyword">string</span>(buf[:num])</span><br><span class="line">        fmt.Print(conn, <span class="string">":"</span>, content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们修改了server中的process函数，在里面添加了Write相关代码。 </p>
<p>&emsp;&emsp;对于客户端而言，由于我们并不能确定服务器何时能够发过来数据，因此我们需要启动一个协程专门循环地读取数据。有读者可能会认为在这个需求中，服务器发回来数据一定发生在客户端写数据之后，因此不必要启动协程。但是当程序完善后，其他客户端给该客户端发消息时，该客户端就无法确定何时能够收到服务器发来的消息了，因此在这里，我们直接就启动协程了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">        num, err := conn.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Read Error"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="keyword">string</span>(buf[:num]))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="keyword">go</span> receive(conn)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    reader := bufio.NewReader(os.Stdin)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们在客户端中定义一个receive函数，并在主函数中通过协程启动这个函数。在函数中我们循环接收从服务器发来的消息，当接收到了过后，我们将消息输出到终端中。此时程序代码就可以接收到从服务器发来的消息了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们提及了socket的本质与概念，同时讲解了tcp/ip协议与udp协议，然后又说明了计算机的ip地址与端口号的作用。之后我们引入了socket编程的快速入门案例。从浅入深地讲解了服务器与客户端代码编写的方式与规则。更复杂的功能也不过是基于上述的案例进行进一步的发展了。 </p>
<p>&emsp;&emsp;到了这里，这一系列的连载也就告一段落了。我们也讲解到了Go语言中一部分的知识点，当然大多数的知识点我们依旧没有涉及。这个连载也只是面向刚刚接触Go语言的开发者，如果能坚持到这个小节也可以说是入门了。如果没有坚持到这里，也算是放弃了，倒也是符合系列连载的题目了（笑）。如果日后还有机会，也会出一些其他的相关的例如数据结构与算法，Go web，甚至其他语言的连载。如果喜欢请多多支持。(～￣▽￣)～ skr～</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/04/04/55-%E5%8F%8D%E5%B0%84%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/" class="next">Go语言从入门到放弃系列&lt;55&gt; 反射细节讨论</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-56-gt-终章-Socket网络编程"><span class="toc-text">Go语言从入门到放弃系列&lt;56&gt; 终章-Socket网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#网络基础"><span class="toc-text">网络基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP与端口"><span class="toc-text">IP与端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络编程入门案例"><span class="toc-text">网络编程入门案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-实现服务器监听，客户端连接"><span class="toc-text">1.实现服务器监听，客户端连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-服务器循环等待多客户端"><span class="toc-text">2. 服务器循环等待多客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-客户端服务器互相发送数据"><span class="toc-text">3.客户端服务器互相发送数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-服务器向客户端回送消息"><span class="toc-text">4. 服务器向客户端回送消息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/06/56-%E7%BB%88%E7%AB%A0-Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Go语言从入门到放弃系列<56> 终章-Socket网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/04/55-%E5%8F%8D%E5%B0%84%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<55> 反射细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/02/54-%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/">Go语言从入门到放弃系列<54> 反射入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/31/53-channel%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<53> channel细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/30/52-channel%E7%AE%A1%E9%81%93%E5%85%A5%E9%97%A8/">Go语言从入门到放弃系列<52> channel管道入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/51-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E4%B8%8E%E7%AE%A1%E9%81%93/">Go语言从入门到放弃系列<51> 资源竞争与管道</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/27/50-Goroutine%E5%85%A5%E9%97%A8/">Go语言从入门到放弃系列<50> Goroutine入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/49-Goroutine%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/">Go语言从入门到放弃系列<49> Goroutine概念简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/25/48-JSON%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/">Go语言从入门到放弃系列<48> JSON与序列化</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/24/47-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%BA%8C/">Go语言从入门到放弃系列<47> 文件与IO<二></a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">56</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>