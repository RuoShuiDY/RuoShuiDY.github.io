<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Go语言从入门到放弃系列&lt;54&gt; 反射入门 | 云钰的亭轩阁</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go语言从入门到放弃系列&lt;54&gt; 反射入门</h1><a id="logo" href="/.">云钰的亭轩阁</a><p class="description">Running water never goes stale, so you gotta just keep on flowing.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go语言从入门到放弃系列&lt;54&gt; 反射入门</h1><div class="post-meta"><a href="/2020/04/02/54-%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/#comments" class="comment-count"></a><p><span class="date">Apr 02, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Go语言从入门到放弃系列-lt-54-gt-反射入门"><a href="#Go语言从入门到放弃系列-lt-54-gt-反射入门" class="headerlink" title="Go语言从入门到放弃系列&lt;54&gt; 反射入门"></a>Go语言从入门到放弃系列&lt;54&gt; 反射入门</h2><p>&emsp;&emsp;在这个小节中，我们将集中介绍Go语言中反射的一些概念与使用方法。即便是在不同的计算机语言中，反射都是一个非常重要的知识点，同时也是一个非常难的知识点。究其原因主要是：初学者乃至于初入工作的开发者往往不会接触到这个技术，甚至来说对这个技术基本没有需求。而当更为深入地去写框架的时候，才会逐渐意识到它的重要性。 </p>
<p>&emsp;&emsp;基于上述的反射的特点，我们在这个小节中简单地介绍一下Go语言反射的使用方式，难度相比于真实开发所能用到的难度会相对浅显。因此如果看完这个小节觉得反射这个概念十分地有趣，可以去查找其他的专业的教科书或文章深入地研究。在学习过程中，确实不是每个人都能够体会到反射的重要性的，而一旦没有体会到其重要性，反而会觉得这个技术既没什么作用，实现起来又复杂。这样的话就大可以不必纠结于这个小节，毕竟开发初期真的用不到这个知识点。</p>
<h3 id="反射引入"><a href="#反射引入" class="headerlink" title="反射引入"></a>反射引入</h3><p>&emsp;&emsp;其实我们在之前对序列化与空接口的讲解过程中，已然或多或少地带有了反射的概念。比如说，我们曾经在类的属性后添加了tag，使得序列化结果中的key是tag中的内容而不是属性字段，能够实现这个功能的原因其实就是反射。 </p>
<p>&emsp;&emsp;不仅如此，我们曾经在空接口的叙述中提到了类型断言的这个知识点。任何的类都可以说实现了空接口，因此任何的变量都可以作为空接口的参数传入。那么我们通过类型断言将变量从空接口转换成对象的时候，我们之前都是手动完成的，现在学过反射之后，我们就可以让其自动地完成断言。 </p>
<p>&emsp;&emsp;现在我们通过一个案例来完成快速入门：假设我们的工作是写一个函数，这个函数可以接收任何类型的变量，且在函数体中输出该变量的类型，例如输入的是int型整数，在函数中就要输出int；输入的是float64，在函数中就要输出float64。 </p>
<p>&emsp;&emsp;如果我们通过现有的知识储备，其实很难完成上述的要求。首先，Go语言不支持函数重载，用同一个函数名且入参不同的方式是不可行的。同时即便我们采用了空接口的形式，我们只能通过空接口来操作变量，依旧不知道它的类型（需要先知道类型才能断言，需要断言成功才人为地知道类型），因此我们引入反射：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectDemo</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        reflectType := reflect.TypeOf(args[i])</span><br><span class="line">        fmt.Println(reflectType)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> i8 <span class="keyword">int8</span> = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> f32 <span class="keyword">float32</span> = <span class="number">10.0</span></span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">"Hello World"</span></span><br><span class="line">    reflectDemo(i, i8, f32, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上面的入门案例中，我们可以发现，我们引入了”reflect”包，同时在main函数中定义了四种不同的数据类型，且将这四种数据类型传入到reflectDemo函数中。在reflectDemo函数定义中，我们采用了空接口的可变参数的方式接收数据，在函数体中，我们遍历传入的参数输出其参数的类型。其输出结果如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="keyword">int8</span></span><br><span class="line"><span class="keyword">float32</span></span><br><span class="line"><span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过这个输出结果我们可以发现，不同的类型的数据传入到函数中最终输出了不同的结果。如果再配合以类型断言，将空接口转为对应的类型的变量，我们就可以在函数内部操控传入的数据了。当然事情并不会这样简单，但是作为快速入门案例，我们就暂时先讲解到这，我们在后面会相对具体地说明。</p>
<h3 id="Type与Value"><a href="#Type与Value" class="headerlink" title="Type与Value"></a>Type与Value</h3><p>&emsp;&emsp;我们在正常使用一个变量的时候，往往会关注它的数据类型以及其内部的值，反射技术关心的往往也是这些。因此可以说reflect包下的Type类与Value是两个相对占比比较大的技术点。其他的知识点例如获取结构体信息之类的都可以从手册中查到。 </p>
<h4 id="1-Type"><a href="#1-Type" class="headerlink" title="1. Type"></a>1. Type</h4><p>&emsp;&emsp;我们首先说变量的Type，在上一个入门案例中，我们已然获取到了通过空接口的某些数据类型的Type。但是我们只获取了基本数据类型的Type，这里我们利用代码来说明其他的数据类型，例如结构体，数据等数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    student := Stu&#123;</span><br><span class="line">        Name: <span class="string">"Devin"</span>,</span><br><span class="line">        Age: <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    array := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">    reflectDemo(student, array, slice, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这次我们将Stu结构体（类）的实例，以及数组、切片、映射传入到入门案例的refelctDemo函数中，我们可以发现结果依然是正确的，且在输出Stu的时候是带有包名的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.Stu</span><br><span class="line">[<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">[]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;换句话说，我们既然获取到了变量的Type，我们就相当于拥有了变量的各个性质。我们可以通过该Type获取它的包名，包路径，占据字节数，实现了哪些接口，有多少个属性，获取具体属性等。通过下面的截图（部分截图）我们可以发现：<br><img src="/2020/04/02/54-%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/1.png" alt><br>&emsp;&emsp;Go语言中Type其实是一个接口，我们之前也提及过，可以通过接口调用接口中的方法，因此所有的数据类型都可以获取其Type，获取其Type之后全部都可以调用图中方法。当然，有些方法是针对特定的数据类型的，例如获取传入map中的key就只能针对map类型的数据，对于其他数据类型而言，编译器会报出panic。 </p>
<h4 id="2-Value"><a href="#2-Value" class="headerlink" title="2. Value"></a>2. Value</h4><p>&emsp;&emsp;如果说获取了Type就相当于得到了变量的各个性质，那么获取了Value就相当于得到了变量的值的相关操作的所有权。我们知道，变量定义出来就是为了存储，使用，因此Value作为反射的一部分用处也是非常的大。我们依旧通过快速入门案例来说明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectDemo</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        reflectValue := reflect.ValueOf(args[i])</span><br><span class="line">        fmt.Println(reflectValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    student := Stu&#123;</span><br><span class="line">        Name: <span class="string">"Devin"</span>,</span><br><span class="line">        Age: <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    array := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">    reflectDemo(i, student, array, slice, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这段程序中，我们将reflectDemo函数的函数体改为ValueOf函数，获取的是传入参数的值而不是类型，根据输出结果我们可以发现，反射确实是可以获取变量内部的值的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line">&#123;Devin <span class="number">25</span>&#125;</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"><span class="keyword">map</span>[]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;与Type不同的是，Go语言中的Type是一个接口，而Value是一个类，其包含属于自己的多个方法。我们截部分图来说明Value的使用： </p>
<p><img src="/2020/04/02/54-%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/2.png" alt></p>
<p>&emsp;&emsp;从图中我们可以发现：当我们获取了Value值之后，我们可以通过Value变量判断该变量是否目前处于nil的状态，如果它是整数那么整数的值是多少，如果是slice或者map，它的容量是多大。值得注意的是：在Value的方法中，我们可以看到一个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v value)</span> <span class="title">Type</span><span class="params">()</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个方法可以通过Value实例获取到变量的Type，但是我们并没有在Type接口所包含的方法中找到获取Value的方法。从某种意义上说：空接口，Type，和Value是可以互相转换的。 </p>
<p>&emsp;&emsp;除了获取变量的值这个功能之外，我们当然可以改变变量的值，我们再通过下面的截图说明（中间省略了许多的方法）： </p>
<p><img src="/2020/04/02/54-%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/3.png" alt></p>
<p>&emsp;&emsp;这里带有Set的方法都是改变数据所用到的方法，且每一种Set方法都对应着自己的独特的数据类型，一旦数据类型匹配有误（例如为整数类型Set浮点数），会报出相应的panic。那么我们将如何知道传入的变量都是什么数据类型呢，获取其Type就明确了。</p>
<h4 id="3-Type，Value，空接口转换"><a href="#3-Type，Value，空接口转换" class="headerlink" title="3. Type，Value，空接口转换"></a>3. Type，Value，空接口转换</h4><p>&emsp;&emsp;在Go语言的反射中，这三个概念十分重要，当然在实际应用过程中需要相互地配合，也就需要经常地转换了。 </p>
<p>&emsp;&emsp;1.变量与空接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量---------------&gt;空接口</span><br><span class="line">空接口--（类型断言）--&gt;变量</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2.空接口与Type</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflect.TypeOf(空接口)------&gt;Type</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3.空接口与Value</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reflect.ValueOf(空接口)-----&gt;Value</span><br><span class="line">Value.Interface()----------&gt;空接口</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;4. Value与Type</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value.Type()------&gt;Type</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们简单地引入了反射的概念与基本用法，介绍了Go语言中反射包的两个比重较大的概念：Type和Value。对于这两个概念我们也初步地讲解了其入门案例及其使用方式，通过截图也大致介绍了其方法的作用。最后我们又总结出了变量、空接口、Value、Type之间的互相转化关系。 </p>
<p>&emsp;&emsp;在下个小节中，我们将继续针对反射做出相对详细的解释以及开发过程中需要注意的问题。然后我们将会再通过一些案例讲解为变量赋值等相对高级的操作。</p>
</div><div class="tags"><a href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post-share"></div><div class="post-nav"><a href="/2020/04/04/55-%E5%8F%8D%E5%B0%84%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/" class="pre">Go语言从入门到放弃系列&lt;55&gt; 反射细节讨论</a><a href="/2020/03/31/53-channel%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/" class="next">Go语言从入门到放弃系列&lt;53&gt; channel细节讨论</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言从入门到放弃系列-lt-54-gt-反射入门"><span class="toc-text">Go语言从入门到放弃系列&lt;54&gt; 反射入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#反射引入"><span class="toc-text">反射引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Type与Value"><span class="toc-text">Type与Value</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Type"><span class="toc-text">1. Type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Value"><span class="toc-text">2. Value</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Type，Value，空接口转换"><span class="toc-text">3. Type，Value，空接口转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/06/56-%E7%BB%88%E7%AB%A0-Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Go语言从入门到放弃系列<56> 终章-Socket网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/04/55-%E5%8F%8D%E5%B0%84%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<55> 反射细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/02/54-%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/">Go语言从入门到放弃系列<54> 反射入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/31/53-channel%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/">Go语言从入门到放弃系列<53> channel细节讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/30/52-channel%E7%AE%A1%E9%81%93%E5%85%A5%E9%97%A8/">Go语言从入门到放弃系列<52> channel管道入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/51-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E4%B8%8E%E7%AE%A1%E9%81%93/">Go语言从入门到放弃系列<51> 资源竞争与管道</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/27/50-Goroutine%E5%85%A5%E9%97%A8/">Go语言从入门到放弃系列<50> Goroutine入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/49-Goroutine%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/">Go语言从入门到放弃系列<49> Goroutine概念简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/25/48-JSON%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/">Go语言从入门到放弃系列<48> JSON与序列化</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/24/47-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%BA%8C/">Go语言从入门到放弃系列<47> 文件与IO<二></a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">Go语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">56</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Devin DENG.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script></body></html>