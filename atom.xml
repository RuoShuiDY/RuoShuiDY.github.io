<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>云钰的亭轩阁</title>
  
  <subtitle>Running water never goes stale, so you gotta just keep on flowing.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-10T03:39:10.903Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Devin DENG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;7&gt; 数据与数据的存储&lt;二&gt;</title>
    <link href="http://yoursite.com/2020/02/10/7-%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/02/10/7-%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BA%8C/</id>
    <published>2020-02-10T03:37:57.000Z</published>
    <updated>2020-02-10T03:39:10.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-7-gt-数据与数据的存储-lt-二-gt"><a href="#Go语言从入门到放弃系列-lt-7-gt-数据与数据的存储-lt-二-gt" class="headerlink" title="Go语言从入门到放弃系列&lt;7&gt; 数据与数据的存储&lt;二&gt;"></a>Go语言从入门到放弃系列&lt;7&gt; 数据与数据的存储&lt;二&gt;</h2><p>&emsp;&emsp;在上一节集中介绍了二进制的原码，反码和补码之后，我们在这一章简要地介绍一下Go语言中的基本数据类型，简单地列举一下几个基本数据类型所能存储的数字范围，并对数据范围的大小作出讲解。</p><h3 id="Go语言中的基本数据类型"><a href="#Go语言中的基本数据类型" class="headerlink" title="Go语言中的基本数据类型"></a>Go语言中的基本数据类型</h3><h4 id="（计算机内存进制）"><a href="#（计算机内存进制）" class="headerlink" title="（计算机内存进制）"></a>（计算机内存进制）</h4><p>&emsp;&emsp;在介绍数据类型之前，我们首先介绍计算机中的几个表示内存的单位，分别为：bit、byte、kb、mb、gb等等。在bit和byte转换规则中存在一个等式：1byte=8bit，换句话说1个字节的长度等于8个二进制位的长度。而在bit和kb之间、kb和mb之间的进率这个现在很难讲。从我接触到计算机开始，我所学到的进制表示法始终是1kb=1024bit，也就是进制为1024，不过近来我在网上查资料的时候，发现了一种进制表示是1kb=1000bit，而且这两种表示方法均存在，在不同的计算机系统中（如Windows和Mac）也是不同的。此时此刻我依旧为这个问题而感到费解，因此这个进制我不做说明，希望读者自行去查找。 </p><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>&emsp;&emsp;正如我们所理解的一般，整型所代表的就是计算机存储的整数，是不具备小数位的数字。根据不同的定义，整数可以分为有符号整型以及无符号整型。根据上个小节对码制的介绍，有符号整数的最高位代表符号位，并且负数的表示方式为补码方式。而对于无符号整数来说，其最高位表示的是数字中的一部分，不代表符号，是计入数字的计数的，同时因为其无符号的特性，该值永远是正值。下表将列出Go语言中整数的定义方式，以及其分配的bit空间和可表示的范围：</p><table><thead><tr><th>类型名称</th><th align="left">是否有符号</th><th align="left">分配的bit数</th><th align="center">可表示范围</th></tr></thead><tbody><tr><td>int8</td><td align="left">有</td><td align="left">8</td><td align="center">-128到127</td></tr><tr><td>int16</td><td align="left">有</td><td align="left">16</td><td align="center">-32768到32767</td></tr><tr><td>int32</td><td align="left">有</td><td align="left">32</td><td align="center">-2^31到2^31-1</td></tr><tr><td>int64</td><td align="left">有</td><td align="left">64</td><td align="center">-2^63到2^63-1</td></tr><tr><td>uint8</td><td align="left">无</td><td align="left">8</td><td align="center">0到255</td></tr><tr><td>uint16</td><td align="left">无</td><td align="left">16</td><td align="center">0到65535</td></tr><tr><td>uint32</td><td align="left">无</td><td align="left">32</td><td align="center">0到2^32-1</td></tr><tr><td>uint64</td><td align="left">无</td><td align="left">64</td><td align="center">0到2^64-1</td></tr><tr><td>int</td><td align="left">有</td><td align="left">与CPU位数相关</td><td align="center">与CPU位数相关</td></tr><tr><td>uint</td><td align="left">无</td><td align="left">与CPU位数相关</td><td align="center">与CPU位数相关</td></tr><tr><td>rune</td><td align="left">有</td><td align="left">与int32等价</td><td align="center">暂不做介绍</td></tr><tr><td>byte</td><td align="left">无</td><td align="left">与uint8等价</td><td align="center">暂不做介绍</td></tr><tr><td>uintptr</td><td align="left">无</td><td align="left">-</td><td align="center">-</td></tr></tbody></table><p>&emsp;&emsp;其中需要说明的是，int和uint整形变量分配的位数，这个是与CPU位数相关，如果计算机的CPU位数是32位，则为之分配32个bit位，即4个字节的空间。如果计算机CPU位数是64位，则为之分配64个bit位，即8个字节的空间。至于rune以及byte我们会在字符部分为之说明。</p><p>&emsp;&emsp;uintptr是一种无符号的整数，没有指定具体大小，但是足以容纳指针，一般来说是内存地址的哈希值，关于指针我们会在后续介绍到。uintptr类型一般用在底层编程中，在我们入门级别的学习中往往并不常见，在GO语言与C语言函数库的对接以及与操作系统底层硬件交互时才会经常用到。</p><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>&emsp;&emsp;浮点数在计算机中可以被理解为小数，Go语言提供了两种不同精度的小数，分别为float32以及float64，它们的定义符合IEEE754规范的定义，与整数的表示方式不同。这个规范是被现有的所有的各式CPU所支持。根据定义可以看出，float32的浮点数被分配的空间是32个二进制位，float64则分配64个二进制位。</p><p>&emsp;&emsp;那么我们可能会思考，一个整数，即便是64个二进制位，也不过是1.8*10^19（大约）这么大的数字。对于一个小数而言，既有整数部分，也有小数部分，其表示的数字范围岂不是小的可怜。为了防止出现这个结果，浮点数的存储方式与整数的存储方式是截然不同的。</p><p>&emsp;&emsp;一个浮点数可以被分为三个部分，我们以32位浮点数为例，其第一部分为最高位，也就是符号位，同整数相同，0代表正数，1代表负数。第二部分为指数位，被分配8个二进制位并通过移码后专门表示指数。最后剩下23位是第三部分，为尾数部分，这部分将代表这个小数以科学计数法表示后的整数部分。对于float64而言，则是1位的符号位，11位的指数部分，和52位的尾数部分。</p><p>&emsp;&emsp;我们举一个例子，十进制的135.5这个数字用二进制来表示为:1000 0111.1，我们采用二进制的科学计数法为：1.00001111*2^7，首先我们知道，这个数字为正数，因此符号位为0。然后指数部分采用移码的形式，即32位小数用127移，64位小数用1023移，所以7+127=134，将134化成二进制为：10000110，最后是尾数部分，由于科学计数法表示后，整数位一定是1，因此这个位可以被忽略掉，只表示00001111即可，在后面补充0，直到23位，所以结果如下：</p><table><thead><tr><th>符号位</th><th align="left">指数部分</th><th align="center">尾数部分</th></tr></thead><tbody><tr><td>0</td><td align="left">10000110</td><td align="center">00001111000000000000000</td></tr></tbody></table><p>&emsp;&emsp;因此，这个数字在内存中表示为：01000011000001111000000000000000(图片来自于binaryconvert)</p><p><img src="/2020/02/10/7-%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BA%8C/1.png" alt></p><p>&emsp;&emsp;通过这种存储方式，浮点数可以表示的范围就会极大了，粗略来说，float32表示范围可为：-3.4*10^38到3.4*10^38，对于float64而言，其范围可以是：-1.79*10^308到1.79*10^308。</p><h4 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h4><p>&emsp;&emsp;Go语言支持对复数的定义，同样也具备两种精度的复数类型，分别为complex64和complex128，正如我们所了解的，复数一般是由实部和虚部构成，因此这两种复数类型的实部和虚部分别相对应float32和float64。一般来说，复数的使用在应用开发中很少会出现，在数学计算中可能会得到应用。在此不做详细的说明了。</p><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><p>&emsp;&emsp;布尔值一般代表逻辑值，一般来说只有真或假，所对应的值为true或false。在程序中分支控制和循环控制中往往会用到布尔值。布尔值可以通过“与或非”三种逻辑进行运算，但是并不参与数学运算。在有些开发语言中，true可以表示为1，而false可以表示为0，这两种值可以被替换为整数进行数学运算。而在Go语言开发中，这个是不成立的，因此不能参与数学运算。布尔值的具体用法我们将会在分支结构中更为详细地讲述。</p><h4 id="（字符型）"><a href="#（字符型）" class="headerlink" title="（字符型）"></a>（字符型）</h4><p>&emsp;&emsp;这个字符型为什么会打了一个括号，是因为这个数据类型在Go语言中不存在，不过在其他语言中是存在的，对于后面字符串的引出也是即为重要的，因此单独做出介绍。在前面我们介绍编码的时候就提及过，最初的计算机只能应用在英语的环境中，而大小写英文字母的数量加一些转义字符的数量也不超过256个。因此最初字符是可以通过一个8位的整数来表示，这便是我们在介绍整数的时候byte的用法。</p><p>&emsp;&emsp;在后面计算机到了各国之后，不同国家开始应用各个国家的字符集，例如中国汉字，其个数就远超了256个，因此一个byte的空间就没有办法进行存储汉字了，而UTF-8编码格式又融入了所有国家的所有的字符编码，于是就需要寻找容量更大的存储方式，在Go语言中我们采用int32的数据类型来存储汉字，为了区分字符与整数的表示方式，我们采用rune的方式表示。</p><p>&emsp;&emsp;虽说字符一般采用byte和rune的方式进行定义与表示，其核心本质依旧是uint8和int32，所以说Go语言中不存在字符型的变量，传统的字符型都用整数来表示了。</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>&emsp;&emsp;在其他的编程语言中，往往会把字符串作为复杂数据类型来划分，但是字符串同时在编程中应用地十分地普遍，因此Go语言便也把它划分在基础数据类型中。字符串是一个不可改变的字节序列，可以理解为多个字符拼接而成的常量，用双引号所包含（如入门程序中的”Hello World”）。字符串可以包含任何的数据，文本字符串通常会表示为UTF-8编码的rune序列。在这里只是提一句字符串的概念，在后续学习中，我们会针对于字符串及其自带的函数做出详细地讲解。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这两个小节中，我们集中介绍了数据的存储形式，介绍了原码，反码和补码。并通过对这三种码制引出了Go语言的基本数据类型，这几种类型将会在下几小节中详细地叙述。在下一节中，我们将会主要介绍变量与常量的概念，命名规则以及针对基本数据类型定义过程的一些例子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-7-gt-数据与数据的存储-lt-二-gt&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-7-gt-数据与数据的存储-lt-二-gt&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;7&amp;
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;6&gt; 数据与数据的存储&lt;一&gt;</title>
    <link href="http://yoursite.com/2020/02/09/6-%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%80/"/>
    <id>http://yoursite.com/2020/02/09/6-%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%80/</id>
    <published>2020-02-09T06:29:44.000Z</published>
    <updated>2020-02-09T06:30:58.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-6-gt-数据与数据的存储-lt-一-gt"><a href="#Go语言从入门到放弃系列-lt-6-gt-数据与数据的存储-lt-一-gt" class="headerlink" title="Go语言从入门到放弃系列&lt;6&gt; 数据与数据的存储&lt;一&gt;"></a>Go语言从入门到放弃系列&lt;6&gt; 数据与数据的存储&lt;一&gt;</h2><p>&emsp;&emsp;在上一个小节中，我们集中说明了一些二进制相关的事，介绍了不同进制之间的转换规律以及该规律的原理，并对二进制有了最基本的认识。那么在这个小节中，我们将基于二进制的知识，引出基本数据类型的存储格式，介绍到原码，反码和补码的知识，进而对Go语言的数据类型进行简要的引出。</p><h3 id="原码，反码，和补码"><a href="#原码，反码，和补码" class="headerlink" title="原码，反码，和补码"></a>原码，反码，和补码</h3><p>&emsp;&emsp;我们回顾一下自己对数字的认识过程，相信大多数人都经历了如下的过程。在很小的时候只知道正数，然后到了初中开始接触负数，之后再考虑到0这个特殊的数字。那么我们就暂时遵循这个过程，对这几种码制作出阐述。可以说，大家对于正数的了解是普遍的，日常生活中也经常会出现与正数打交道的情况。那么对于正数，计算机是如何存储的呢。</p><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>&emsp;&emsp;读过上一个小节的人们可能会直接想到，无非就是把十进制的正数转换成二进制的数而已，这个想法是正确的，只不过是在现有的想法上加上一个符号位，而这个符号位则是最高位，同时我们将符号位的0作为正数的标志，符号位的1就作为负数的标志，因此，对于106这个十进制正数而言，其带符号位的二进制数是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01101010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最高位的0代表了正数。相信大家很容易接受这种表示方式，毕竟改变不是很大。当我们对正数做完阐述之后，我们可能会想到，既然如此，我们将符号位置1，其余的不变，就可以表示对应的负数了。确实这是一种表示方法，也就是我们今天所提及的原码方式。对于-106而言，其二进制数为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11101010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是现在问题就来了，这种方式虽然存储起来很方便，但是对计算而言是极为的不利的。例如，我们每个人都知道的一个等式&nbsp;-1+1=0&nbsp;在计算机用原码表示来计算就会出现错误，我们列举一下计算过程，假设我们依旧用8位来表示每一个数字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000001</span>+<span class="number">10000001</span>=<span class="number">10000010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们会发现结果是-2，而不是0。不仅如此，任何一个正数与一个负数相加，其结果都是负数，因为符号位的0+1=1。很显然，这种数制的表示方法并不能完成计算的任务，因此我们引进了反码。</p><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>&emsp;&emsp;正数的反码与原码是相同的，负数的反码则是符号位不变，其余的位数取反。比如说，对于-106而言，其反码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10010101</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么反码的好处在哪里呢，我们依旧回到-1+1=0的问题上，根据我们上述所说，-1的反码为：11111110，+1的反码为：00000001，那么两个数字相加，我们会得到11111111，对此结果我们再取反码，得到了10000000，换算成十进制为-0，其计算结果是可以接受的，但是现在我们依旧存在一个问题，即+0与-0的问题。</p><p>&emsp;&emsp;不仅如此，即便是在一次计算中真值部分得到了正确的结果，但涉及到中途结果为-0的时候，就又一次出现了问题，我们举一个简单的例子，我们都知道，-1+1+1=1，那么我们采用反码的形式再一次做出计算：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11111110</span>+<span class="number">00000001</span>+<span class="number">00000001</span>=<span class="number">100000000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在计算之前，我们首先假定了由8位构成一个数字，那么计算结果应该也是由8位构成，但是我们的到的结果是9位，因此计算机选择的是忽略掉溢出的位置，因此结果为00000000，也就是我们所说的10进制的0。这个结果显然是不能接受的，而导致这个不可接受的结果的原因则是这个-0的参与运算。因此，单纯地采用补码来运算依旧不是一个很好的方法，接下来，我我们将对补码进行简要地介绍。</p><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>&emsp;&emsp;首先，我们需要对补码有一个相对直观的认识，举一个很常见的例子，就是我们平日生活中的钟表。我们假设时针指向12的时候为0点，时针顺时针为正，逆时针为负，并且以时针指向6为分界，即小于6的时候为正值，大于6点为负值。同时我们采用上一章节所提及的“模”的概念，即在时钟的周期中模为12。</p><p>&emsp;&emsp;现在我们转换一下思想，在上述情况下所说的-1点，就是平时我们称的11点，同时上述情况下所称的1点依旧是平时我们所想的1点，这便是补码的一种直观的思想。即负数可以表示为：<strong>周期的模减去该负数的绝对值</strong>，比如说：-1点即11点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>-abs(<span class="number">-1</span>)=<span class="number">11</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么现在我们回过头来看一下-3用补码是怎样表示的，首先我们依旧假设用8位来表示一个数字，那么8个二进制位所能表示的数字的模是多少。十进制的模是十，是个位为0同时其高位为1，那么8个二进制位的模当然就是八个位都是0，而其高位（借来的第九位）为1：100000000。同时，-3的绝对值是3，其二进制表示方法为：00000011。现在我们将其相减，得到的-3的补码是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11111101</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在我们对-3的补码和-3的原码进行对比，并从中寻找一个转换的规律。我们说，-3的原码为：10000011，-3的补码为：11111101，我们可以发现，补码的转换规则为：<strong>正数的补码是原码本身，负数的补码是，符号位不变，从右向左找到第一个1不变，这个1向左的各位取反。</strong></p><p>&emsp;&emsp;再一次回到-1+1+1的问题上，我们知道-1的表示方法为：模-1，那么-1+1便是：模-1+1=模。根据上述的说明，模的表示方法为：各个位数为0，高位为1，而高位在计算中会溢出而不做计算，因此结果为0，这个+0再加上任何的数字就是正常的数字了。现在我们已然解决了正0的问题，那么原来的-0究竟表示了什么呢。</p><p>&emsp;&emsp;通过上述的描述，我们知道了负数的表示方法，那么我们可以这样来想，模减去某个负数的绝对值等于了“-0”，因此这个“某个负数”的绝对值便是模的大小，取负数之后便是其可以表示的数。因此，原来的-0即表示了-模长。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在本节中，我们集中介绍了计算机存储数据的方法，即原码、反码、和补码的概念，并分别阐述了这三种表示方式的来由。在下一小节中，我们将介绍数据类型的概念，计算机内存中如何表示整数、小数、字符等等，并对其可表示范围作出讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-6-gt-数据与数据的存储-lt-一-gt&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-6-gt-数据与数据的存储-lt-一-gt&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;6&amp;
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;5&gt; 二进制浅谈</title>
    <link href="http://yoursite.com/2020/02/08/5-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%85%E8%B0%88/"/>
    <id>http://yoursite.com/2020/02/08/5-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%85%E8%B0%88/</id>
    <published>2020-02-08T03:48:41.000Z</published>
    <updated>2020-02-08T03:49:47.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-5-gt-二进制浅谈"><a href="#Go语言从入门到放弃系列-lt-5-gt-二进制浅谈" class="headerlink" title="Go语言从入门到放弃系列&lt;5&gt; 二进制浅谈"></a>Go语言从入门到放弃系列&lt;5&gt; 二进制浅谈</h2><p>&emsp;&emsp;在上一个小节中，我们集中阐述了Go语言的一些命令，并对其中的几个常用命令进行讲解，在这一小节中，我们将对进制的概念进行阐述，并且对进制之间的相互转换进行详细地说明。</p><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>&emsp;&emsp;说起进制，大家似乎都不陌生，因为我们每天都在以十进制的形式计数，那么什么是十进制呢，便是逢十进一。换句话说，在十进制数中每一个位都可以存放十种不同的数字，分别为0到9，当当前的数字为9的时候，再向上加1，就需要向更高的位进1，而自身的数字归零。在这里，我们也可以称这种计数单位的模为10。</p><p>&emsp;&emsp;如果我们沿用上述的方式，换一种思路，将逢十进一的概念转变为逢二进一，似乎二进制的概念就会比较好理解了。在十进制中，每个位都可以有10种数字，在二进制中，每个位只有两种形式，分别为0和1。在当前位为1的时候再加1，便向更高位进1，自身的数字归零。这便是二进制的计数方式。</p><p>&emsp;&emsp;为什么计算机会采取二进制的形式用来表示数据，是因为二进制是世界上比较常见的一种进制方式，尽管我们我日常生活中并不常用。开关的闭合或开启、逻辑的真与假、电容器是否具有电势等，都是两种状态之间的互相转换。在数字电路中，高电平与低电平也代表两种不同的逻辑态。对于完全由电路构成的计算机而言，主要处理的便是逻辑运算，因此二进制当然也就再合适不过了。</p><h3 id="二进制向十进制的转换"><a href="#二进制向十进制的转换" class="headerlink" title="二进制向十进制的转换"></a>二进制向十进制的转换</h3><p>&emsp;&emsp;虽说计算机非常喜欢二进制的计数方式，但是似乎人们并不喜欢，因为从小到大所接触到的都是十进制的世界，为了更好地理解数字的本质，我们需要了解不同进制之间的转换规则。同样地，我们先从十进制出发，例如我首先写下一个数字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不出意外的话，每个人都能迅速地说出来这个数字是十二万三千四百五十六，那么为什么这个一串的字符就可以表示出这个数字呢，是因为这个结果是可以通过某种计算方式而得到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X=<span class="number">1</span>*<span class="number">10</span>^<span class="number">5</span>+<span class="number">2</span>*<span class="number">10</span>^<span class="number">4</span>+<span class="number">3</span>*<span class="number">10</span>^<span class="number">3</span>+<span class="number">4</span>*<span class="number">10</span>^<span class="number">2</span>+<span class="number">5</span>*<span class="number">10</span>^<span class="number">1</span>+<span class="number">6</span>*<span class="number">10</span>^<span class="number">0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果理解了上述的这个公式，那么对于二进制而言，我们仿照这个计算模式，将其迅速地转换为十进制的表达方式，例如如下的这个二进制数字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11001010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X=<span class="number">1</span>*<span class="number">2</span>^<span class="number">7</span>+<span class="number">1</span>*<span class="number">2</span>^<span class="number">6</span>+<span class="number">0</span>*<span class="number">2</span>^<span class="number">5</span>+<span class="number">0</span>*<span class="number">2</span>^<span class="number">4</span>+<span class="number">1</span>*<span class="number">2</span>^<span class="number">3</span>+<span class="number">0</span>*<span class="number">2</span>^<span class="number">2</span>+<span class="number">1</span>*<span class="number">2</span>^<span class="number">1</span>+<span class="number">0</span>*<span class="number">2</span>^<span class="number">0</span>=<span class="number">202</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果继续向下总结的话，我们可以得到一条规律，从任何进制向十进制的转换规律为：第i位的数字乘以模的i次幂的求和（i从0开始）。根据这个规则，我们就可以自行理解八进制和十六进制，乃至于其他进制向十进制转换的规则了。</p><h3 id="十进制向二进制的转换"><a href="#十进制向二进制的转换" class="headerlink" title="十进制向二进制的转换"></a>十进制向二进制的转换</h3><p>&emsp;&emsp;在这个部分中，我们换一种方法来表示二进制向十进制转换过程，所举的例子依旧是上方提到的两个数字，我们可以分别表示为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123456</span>=(((((<span class="number">1</span>*<span class="number">10</span>)+<span class="number">2</span>)*<span class="number">10</span>+<span class="number">3</span>)*<span class="number">10</span>+<span class="number">4</span>)*<span class="number">10</span>+<span class="number">5</span>)*<span class="number">10</span>+<span class="number">6</span></span><br><span class="line"><span class="number">202</span>=(((((((<span class="number">1</span>*<span class="number">2</span>)+<span class="number">1</span>)*<span class="number">2</span>+<span class="number">0</span>)*<span class="number">2</span>+<span class="number">0</span>)*<span class="number">2</span>+<span class="number">1</span>)*<span class="number">2</span>+<span class="number">0</span>)*<span class="number">2</span>+<span class="number">1</span>)*<span class="number">2</span>+<span class="number">0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们会发现这种表达方式和上述的表达方式的结果是一致的，那么我们为什么采用这种表述方式，是因为在这种表达方式中，我们可以很直观地理解如何从十进制转回到二进制中。如果我们将转回的过程看做上述过程的一个逆过程，答案就会很简单了。我们用两个未知数来表示上述表达式中的两个部分，我们会发现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">202</span>=X*<span class="number">2</span>+Y  （X，Y为整数）</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;虽说这个二元一次方程具备很多的解，但是联合二进制的规定，我们会加一个条件，即Y&lt;2。这样，我们就会轻而易举地得出X为101，Y为0，也就是说，我们得到了二进制的最后一位。接下来，我们针对101进行分析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">101</span>=X*<span class="number">2</span>+Y</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个方程中，我们可以得到X为50，Y为1，这样我们就得到了倒数第二位的数值，如果一直重复上述过程，我们将会得到二进制的最终结果。换句话说，十进制整数向二进制的转换规则为：该数字除以模数向下取整，取余数，最后将余数倒序输出，即为二进制数。这个规则同样也适用于十进制向任何一个进制转换的过程。</p><h3 id="浮点数的进制转换"><a href="#浮点数的进制转换" class="headerlink" title="浮点数的进制转换"></a>浮点数的进制转换</h3><p>&emsp;&emsp;说完整数的数制转换后，我们对浮点数（小数）的进制转换做出简要的说明。在说明之前，我们首先思考一个问题，根据上述的二进制转十进制的规则来看，对于一个<strong>有限位数的整数</strong>而言，是否每一个二进制数都有一个有限位数的十进制数相对应，是否每个十进制数都有一个有限位数的二进制数相对应。两个答案都是肯定的。那么对于小数而言，上述两句话还是否依旧成立？</p><p>&emsp;&emsp;我们以以下的这个二进制数为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1011</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个二进制数转换成十进制数是多少呢，根据刚刚所讲的计算规律，我们将之拓展，就会发现它可以通过这种方式来表示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X=<span class="number">1</span>*<span class="number">2</span>^(<span class="number">-1</span>)+<span class="number">0</span>*<span class="number">2</span>^(<span class="number">-2</span>)+<span class="number">1</span>*<span class="number">2</span>^(<span class="number">-3</span>)+<span class="number">1</span>*<span class="number">2</span>^(<span class="number">-4</span>)=<span class="number">0.6875</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种二进制小数向十进制小数的转换方式是非常容易的，可以说依旧遵循着第i位的值乘以模的i次幂的求和。那么对于小数而言，如何将这个小数转回到二进制的表示方式。现在我们首先假设二进制的每一位为Xi，那么对于上述的小数我们可以表示为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.6875</span>=(X0)*<span class="number">2</span>^(<span class="number">-1</span>)+(X1)*<span class="number">2</span>^(<span class="number">-2</span>)+(X2)*<span class="number">2</span>^(<span class="number">-3</span>)+(X3)*<span class="number">2</span>^(<span class="number">-4</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来，我们在等式两边同时乘以2，我们即可以得到如下的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.375</span>=(X0)+(X1)*<span class="number">2</span>^(<span class="number">-1</span>)+(X2)*<span class="number">2</span>^(<span class="number">-2</span>)+(X3)*<span class="number">2</span>^(<span class="number">-3</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么对于上述这个等式进行分析，以及二进制的限制我们还可以知道X0、X1、X2、X3均小于2，并且只有X0可以代表整数位，我们便可以得到X0的值为1。接下来等式两边再同时减去X0的值，我们可以得到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.375</span>=(X1)*<span class="number">2</span>^(<span class="number">-1</span>)+(X2)*<span class="number">2</span>^(<span class="number">-2</span>)+(X3)*<span class="number">2</span>^(<span class="number">-3</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;重复上述的过程，我们可以得到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.75</span>=(X1)+(X2)*<span class="number">2</span>^(<span class="number">-1</span>)+(X3)*<span class="number">2</span>^(<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因此，只有X1的值可以表示整数位的值，即X1的值为0，以此类推，我们最终是可以得到1011的值的。通过这个过程，我们可以得到这样的一个小数的转换规则：该小数乘以模，取整数位的值，顺序输出。</p><p>&emsp;&emsp;我们回到刚刚提出的那个问题，是否每一个有限位数的二进制小数都有一个有限位数的十进制小数向对应，这个结果是是的，根据本节提到的公式也可以得到这个结果。那么是否每一个有限位数的十进制小数都有一个有限位数的二进制小数相对应，这个结果是否定的，比如十进制中的0.1就无法用有限位数的二进制进行表示，它是一个无限的循环小数。计算机只能无限地去接近这个数，却永远也无法精确地达到这个小数的真值。其具体原因，我目前尚不能明确地说清楚，也希望大家可以考虑一下，相信在考虑的过程中会有一定的收获。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;经过上述的一些讨论过后，我们集中说明了十进制与二进制的互相转化规律，将此推广，其他进制之间的转换规律也如出一辙，简而化之的记忆口诀就为<strong>除模取余，逆序排序，乘模取整，顺序输出</strong>。我们最后再用一张图片演示进制的过程。（图片转自网络）</p><p><img src="/2020/02/08/5-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%85%E8%B0%88/1.jpg" alt></p><p>&emsp;&emsp;在下一个小节中，我们将介绍二进制表示数字的几种形式，原码，反码以及补码，通过对这三种码制的介绍，我们引出基本数据类型的概念，以及变量和常量的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-5-gt-二进制浅谈&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-5-gt-二进制浅谈&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;5&amp;gt; 二进制浅谈&quot;&gt;&lt;/a&gt;Go语言从入门
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;4&gt; 常用的Go命令</title>
    <link href="http://yoursite.com/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/</id>
    <published>2020-02-07T04:00:21.000Z</published>
    <updated>2020-02-07T04:06:28.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-4-gt-常用的Go命令"><a href="#Go语言从入门到放弃系列-lt-4-gt-常用的Go命令" class="headerlink" title="Go语言从入门到放弃系列&lt;4&gt; 常用的Go命令"></a>Go语言从入门到放弃系列&lt;4&gt; 常用的Go命令</h2><p>&emsp;&emsp;在上一节中，我们集中对快速入门程序Hello World的编写做出了简要的讲解，同时对包的概念，引入的方式，主函数的执行流程做出基本的介绍。在这一节中，我们将对Go语言的中命令行的常用命令进行介绍。</p><p>&emsp;&emsp;相信许多初学者通过集成开发工具进行入门开发时，将两个go文件写在了同一个文件夹下，同时又都具备main函数，在用ide运行的时候报出了错误，我们从这个错误引入到今天的命令的介绍中。</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/1.png" alt><br><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/2.png" alt></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>&emsp;&emsp;在上一节中，我们提出了包的概念，并且说明了一个项目中只能存在一个main函数，而一般来说，ide的编译运行是以工程为基础。换句话讲，便是以文件夹为基础的编译。因此当开发工具检测到同一个文件夹中含有两个或多个main函数时，会报出主函数重定义的错误。</p><p>&emsp;&emsp;1. 第一个解决办法当然便是将不同的go文件分放在不同的文件夹下，这样使得每个文件夹即每个工程都可以单独地进行编译以及运行，不过对于初学者来说这种做法尚不甚方便，到目前为止乃至于之后一段时间内所写的Demo性质的程序往往都是以单个文件为基础的，因此这个方法对于目前来说不是很适用。</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/3.png" alt></p><p>&emsp;&emsp;2. 第二个解决办法便是通过Go语言的命令行形式进行编译运行，就如同在前几节所提及的那样，通过控制台的cd命令进入到go文件所在的目录，然后运用go run命令进行运行，这种方式是以单个文件的方式进行编译的，因此不会报出重定义的错误。go语言的命令相对来说并不多，常用的也就更少了，我们会在下面着重讲述几个命令。</p><h3 id="常用的Go命令"><a href="#常用的Go命令" class="headerlink" title="常用的Go命令"></a>常用的Go命令</h3><p>&emsp;&emsp;如果在控制台直接输入go help命令，我们会发现系统提示了许多的可用命令，在这里便列一个表格，分别简单解释一下每个命令的含义。在后面我们也会针对其中的几个进行详细地讲解。</p><table><thead><tr><th>Go命令</th><th align="center">含义</th></tr></thead><tbody><tr><td>build</td><td align="center">编译包和依赖</td></tr><tr><td>clean</td><td align="center">移除对象文件</td></tr><tr><td>doc</td><td align="center">显示包或者符号的文档</td></tr><tr><td>env</td><td align="center">打印go的环境信息</td></tr><tr><td>bug</td><td align="center">启动错误报告</td></tr><tr><td>fix</td><td align="center">运行go tool fix</td></tr><tr><td>fmt</td><td align="center">运行gofmt进行格式化</td></tr><tr><td>generate</td><td align="center">从processing source生成go文件</td></tr><tr><td>get</td><td align="center">下载并安装包和依赖</td></tr><tr><td>install</td><td align="center">编译并安装包和依赖</td></tr><tr><td>list</td><td align="center">列出包</td></tr><tr><td>run</td><td align="center">编译并运行go程序</td></tr><tr><td>test</td><td align="center">运行测试</td></tr><tr><td>tool</td><td align="center">运行go提供的工具</td></tr><tr><td>version</td><td align="center">显示go的版本</td></tr><tr><td>vet</td><td align="center">运行go tool vet</td></tr></tbody></table><h4 id="build和run命令"><a href="#build和run命令" class="headerlink" title="build和run命令"></a>build和run命令</h4><p>&emsp;&emsp;正如同其他的静态语言一般，Go语言也是需要先编译再运行的。编译过程产生可执行文件，如Windows中的exe文件，之后再运行该可执行文件。而go build命令就是用来编译的，并不是所有的go程序都会编译出可执行文件，其条件即为：go程序属于main包、main包中包含main函数。现在假如在test文件夹中只有一个TestDemo.go文件，我们通过命令行定位到该位置后，键入go build TestDemo.go后，结果将如下图所示：</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/4.png" alt></p><p>&emsp;&emsp;从上图我们可以发现，build命令会生成一个与go文件相同名的可执行文件，进而执行该文件可以得到输出结果。可是往往我们在实际开发中，并不希望生成的可执行文件与go文件是同名的，在另一些情况下多个go程序生成的名字是相同的时候，会覆盖旧版本的exe文件（在大工程中很容易出现）。因此我们希望在编译过程中将生成的结果修改名字，其命令为： go build -o 新名字 go文件。</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/5.png" alt></p><p>&emsp;&emsp;而go run的方法则是将编译和运行两个步骤合并为一个步骤，因此我们在使用go run命令时，在当前的文件夹中或其他的位置是找不到可执行文件的生成的，这很适用于程序开发中的调试阶段，具体便不做演示了。</p><h4 id="fmt以及doc命令"><a href="#fmt以及doc命令" class="headerlink" title="fmt以及doc命令"></a>fmt以及doc命令</h4><p>&emsp;&emsp;在上一节中我们演示到一个问题，就是大括号的位置问题。同时，Go语言有一个特性，便是对格式的要求十分的严格。不同的开发者对这个特性的看法不一，不过也是需要遵守这个格式的。各个开发者的格式是统一的，便利于组合开发以及代码的清晰。go fmt命令便是格式化代码，将代码根据规定的格式进行调整。其格式为：go fmt xxx.go，这个也不做演示了，而且一般情况下也不要手动去调用，一般的集成开发工具都会自动帮助我们去调整。</p><p>&emsp;&emsp;doc命令是查看文档的命令，例如我们在使用fmt包的时候忘记了某个函数如何去写，或希望查到某个函数的具体含义，可能就会用到这个命令，其格式为:go doc package，在终端上就会显示这个包的文档。由于控制台的大小有限，一般来说直接go doc一个包会显示不全。不过我们可以使用go doc package.function来查具体的功能。</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/6.png" alt></p><p>&emsp;&emsp;还有一个比较好的一点是，这个命令可以启动我们自己的文档服务器，比如说我们使用godoc -http=:10000(数字可以随意，不过需要大于1024)，之后打开一个浏览器，在网址栏中输入localhost:10000我们会发现出现了图形界面的帮助文档，可以离线地、更方便地查询信息。</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/7.png" alt></p><h4 id="get和install命令"><a href="#get和install命令" class="headerlink" title="get和install命令"></a>get和install命令</h4><p>&emsp;&emsp;get命令也是十分常用的命令，我们可以通过这个命令来直接从网上下载第三方的包，调用方式为go get source。如果本地已经存有该文件，便会更新指定的代码和依赖，如果使用go语言操作redis数据库，下载并使用beego的web框架时等，会通过这个命令进行下载。</p><p>&emsp;&emsp;install命令与build命令十分的相像，其结果都是生成一个可执行程序，不同点便是生成的可执行文件的路径、名字、以及依赖包。这时我们需要在环境变量中配置GOBIN变量，这个变量的值便是GOPATH下的bin目录，在这里我们简要地演示一下。</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/8.png" alt></p><p>&emsp;&emsp;那么install和build的区别具体可用如下的表格来表示:</p><table><thead><tr><th>区别</th><th align="left">install</th><th align="center">build</th></tr></thead><tbody><tr><td>生成可执行文件路径</td><td align="left">在工作目录的bin目录下，或GOBIN下</td><td align="center">当前目录下</td></tr><tr><td>可执行文件名</td><td align="left">和源码所在的目录同名</td><td align="center">与go文件同名，或-o设定</td></tr><tr><td>依赖包</td><td align="left">在工作目录的pkg文件夹中</td><td align="center">-</td></tr></tbody></table><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小结中，我们初步解决了在Demo演示过程中出现的主函数重定义问题，以及介绍了一些Go语言中相对常用的几个命令。在下一小节中，我们将集中讲解进制相关的一些问题，进而在后续的文章中引出数据类型的概念以及其可以表示的大小的限制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-4-gt-常用的Go命令&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-4-gt-常用的Go命令&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;4&amp;gt; 常用的Go命令&quot;&gt;&lt;/a&gt;G
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;3&gt; 基于Hello World的几点讨论</title>
    <link href="http://yoursite.com/2020/02/06/3-%E5%9F%BA%E4%BA%8EHelloWorld%E7%9A%84%E5%87%A0%E7%82%B9%E8%AE%A8%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/02/06/3-%E5%9F%BA%E4%BA%8EHelloWorld%E7%9A%84%E5%87%A0%E7%82%B9%E8%AE%A8%E8%AE%BA/</id>
    <published>2020-02-06T03:38:07.000Z</published>
    <updated>2020-02-06T03:40:23.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-3-gt-基于Hello-World的几点讨论"><a href="#Go语言从入门到放弃系列-lt-3-gt-基于Hello-World的几点讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;3&gt; 基于Hello World的几点讨论"></a>Go语言从入门到放弃系列&lt;3&gt; 基于Hello World的几点讨论</h2><p>&emsp;&emsp;在第一个小节中，我们阐述了Go语言环境的安装与配置，同时也写了一小段的程序来验证开发环境是否正确配置。那么在这一节中，我们集中针对于这段代码自上而下进行几点简要的讲解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hello World的编写</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go语言代码注释"><a href="#Go语言代码注释" class="headerlink" title="Go语言代码注释"></a>Go语言代码注释</h3><p>&emsp;&emsp;Go语言的注释风格依旧遵循了C语言的注释风格，即采用两个斜杠（//）对单行注释，同时也支持/*…*/的方式对代码块进行注释。一般来说，行注释更为通用，块注释主要是针对包的详细说明或者屏蔽更大的代码块而使用的。 </p><p>&emsp;&emsp;注释的作用往往是为了标注某个变量、代码块、或者函数等的具体功能，以备后续维护时能够快速地理解代码的含义。因此在实际开发中，强烈建议每个包都具备一个注解，即package前的注解，这个注解会详细介绍此包、提供相应的包信息、注明作者引用等等。</p><p>&emsp;&emsp;处在注释中的语句是不执行的，同样地，在编译的过程中也不会参与编译的过程。因此，不必担心写太多的注释会令可执行文件增大。注释出现的位置也是十分地灵活，可以出现在某行中，也可以出现在某条语句的结尾，但不可以出现在某条语句的中间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//注释可以出现在某行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;<span class="comment">//也可以出现在某语句的结尾</span></span><br><span class="line">fmt.Println(<span class="string">"您好世界"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go语言的包"><a href="#Go语言的包" class="headerlink" title="Go语言的包"></a>Go语言的包</h3><p>&emsp;&emsp;同一些其他的语言一样，Go语言是以包package作为管理单位，如果针对于文件系统可以理解为以文件夹为管理单位。因此，每个Go文件都需要声明包，并且只能存在于一个包内。不仅如此，每个程序中都必须要有一个main包，如果没有main包是无法编译通过的。</p><p><img src="/2020/02/06/3-%E5%9F%BA%E4%BA%8EHelloWorld%E7%9A%84%E5%87%A0%E7%82%B9%E8%AE%A8%E8%AE%BA/2.png" alt></p><p>&emsp;&emsp;在日后的开发过程中，package的名字当然可以不是main，但是具备main函数的go文件必须是main包，因此在开发中，尤其指多人的开发中，每个程序员负责自己的部分，便会以包的名字建立一个文件夹，只是不在其中写main函数，这个问题我们在后面的一些章节会再次提及。由于我们目前的开发均在一个文件中，不需要跨越文件编程，因此在习惯上暂且先都写package main即可。</p><h3 id="包的引入"><a href="#包的引入" class="headerlink" title="包的引入"></a>包的引入</h3><p>&emsp;&emsp;在开发的过程中往往需要使用开发者所提供的函数，或者其他人的代码，这时就需要将这个包进行引入操作，所用的关键字为import。fmt包是我们接触到的第一个引用的包，这个包的作用是提供了许多的格式化输出的函数。当我们希望在屏幕上打印出某行汉字的时候，我们不需要了解其内部的过程，如何让屏幕的像素点亮起来，我们只需要知道调用该包的特定函数可以完成需求。当然，fmt包中不仅仅具备格式化输出的函数，随着学习的深入，我们将会接触到更多的包和相应的函数。</p><p>&emsp;&emsp;有时候在程序开发的过程中，我们可能不仅仅需要引用一个包，而是需要引入多个包。比如说，我希望生成一个随机数，并且采用当前时间为种子进行随机生成，最后将这个随机数打印在屏幕上（这个案例我们后续会讲到）。那么，我们可能需要多个包，生成随机数需要一个包，获取时间需要一个包，打印在屏幕上需要一个包，因此需要多个包的引入。引入的方式有两种，分别为：多个import关键字，一个import后加一个小括号，将包写于括号中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"math/rand"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="主函数及大括号"><a href="#主函数及大括号" class="headerlink" title="主函数及大括号"></a>主函数及大括号</h3><p>&emsp;&emsp;每一个项目中都需要有一个主函数，注意这不是指每一个Go文件都有一个主函数。主函数作为程序的入口，往往会最先被执行（这个说法不好，后面会对这句话进行更正，初期可以先这样理解）。声明函数的关键字func即function的前四个字母，main为函数名，后面的括号为函数参数，大括号所包裹的代码即为函数体（在函数的章节中会详细讲）。程序便从大括号后的第一行开始执行，直到函数的结束。</p><p>&emsp;&emsp;与一些传统的编程语言相不同的是，Go语言语句后不需要以分号为结尾。同时，大括号的位置也不如C语言等那样灵活。Go语言的规定是：左大括号的位置一定需要是某个块定义的结尾，而不能单独另取一行，否则在编译时是无法通过的。</p><p><img src="/2020/02/06/3-%E5%9F%BA%E4%BA%8EHelloWorld%E7%9A%84%E5%87%A0%E7%82%B9%E8%AE%A8%E8%AE%BA/5.png" alt></p><h3 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h3><p>&emsp;&emsp;在日后的计算机的学习中，我们将会接触到计算机程序的三大流程控制，分别为：顺序结构、分支结构、和循环结构。我们今天所接触到的便是其中的第一个：顺序结构。</p><p>&emsp;&emsp;顺序结构的核心思想是，程序从上至下逐条依次执行，每一条都会被执行，而且每条都会被执行一次。例如我们在程序中令其多次输出几个字符串，我们会发现结果的输出与程序中的输出顺序是相一致的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"您好世界 1"</span>)</span><br><span class="line">fmt.Println(<span class="string">"您好世界 2"</span>)</span><br><span class="line">fmt.Println(<span class="string">"您好世界 3"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段代码的输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">您好世界 <span class="number">1</span></span><br><span class="line">您好世界 <span class="number">2</span></span><br><span class="line">您好世界 <span class="number">3</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在我们后续讲到函数，并且提及defer关键字时，会对现有的理解的顺序结构产生冲击，这个问题我们在日后会详细地进行讲解。</p><p>&emsp;&emsp;在程序中，我们可以看到的是，函数的调用往往是需要包的存在的，也就是说Println函数是属于fmt包的，即便是自己定义的函数，也是属于当前的package的。如果不通过fmt包，就无法直接使用Println函数，也就无法通过这个函数向屏幕中输出了。还有一个需要注意的点是：当引入了某个包，但是这个包并没有在程序中被使用，也是不允许的。在编译过程中会报如下的错误： </p><p><img src="/2020/02/06/3-%E5%9F%BA%E4%BA%8EHelloWorld%E7%9A%84%E5%87%A0%E7%82%B9%E8%AE%A8%E8%AE%BA/7.png" alt></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们针对快速入门程序，Hello World的输出程序，进行了几点简要的讨论，分别讲解了注释的用法，包的概念的入门，主函数的作用，以及函数体中的顺序结构。同时，也对开发中的几点小细节做出了说明，如大括号位置，包的使用等等。</p><p>&emsp;&emsp;在下一小节中，我们将讲解一些cmd命令行中与Go相关的一些命令，并集中讲解几个常用的命令以及实际过程中的运用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-3-gt-基于Hello-World的几点讨论&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-3-gt-基于Hello-World的几点讨论&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;l
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;2&gt; 编码及几种ide的介绍</title>
    <link href="http://yoursite.com/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-02-05T04:34:38.000Z</published>
    <updated>2020-02-05T04:36:46.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-2-gt-编码及几种ide的介绍"><a href="#Go语言从入门到放弃系列-lt-2-gt-编码及几种ide的介绍" class="headerlink" title="Go语言从入门到放弃系列&lt;2&gt; 编码及几种ide的介绍"></a>Go语言从入门到放弃系列&lt;2&gt; 编码及几种ide的介绍</h2><p>&emsp;&emsp;在这个小节中，我们首先介绍几个实用的常用的Go语言的集成开发工具，并对几种工具做一个简要的比较，集成开发工具的选择会方便程序员对程序的编写，但对于语言本身来说是基本没有关系的。因此，不必过于纠结于集成开发工具的选择，做到能用、方便、正确即可以。同时，对于初学者来说，建议使用功能不是十分强大的开发工具，这样能相对强制性地记住更多的基本的语法与应用。</p><h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p>&emsp;&emsp;在这一小节中，我们首先介绍计算机中的编码格式，通过对编码格式的叙述引入对ide的介绍。编码是用预先规定的方法将文字、数字或其它对象编成数码，或将信息、数据转换成规定的电脉冲信号（引用自百度百科）。通俗一点解释便是，将每个字符（汉字、字母等）与计算机中的数字相关联。字符是有限的，而数字是无限的，因此，每一个字符必定能对应于一个数字，这个对应关系便是编码。 </p><p>&emsp;&emsp;目前来说，对于中国的用户而言，常见的编码格式有ASCII、ANSI、GBK、GB2312、UTF-8等等。不同的编码格式有不同的对应关系，因此在网络传输时，或者在打开文件时，如若对应的编码格式是不一致的，内容就会显示为乱码。</p><p>&emsp;&emsp;从计算机对多国语言的支持程度上来分，编码可以分为三个阶段。第一个阶段是计算机的初期，只在美国国内通用时，是只支持英文显示的，而其他国家的语言是无法显示的。在这个阶段的代表性编码规则为ASCII码。随着计算机的国际通用，各国均开始研发适应于本国的编码规则，也为第二阶段，不同的国家制定了不同的标准，出现了采用两个字节代表一个字符的汉字延伸编码方式，称为ANSI编码，如GB2312等。然而不同国家的ANSI编码依旧不兼容。所以便进入了第三个阶段，UNICODE编码，这种编码为每一个国家、每一种语言、每一个字符均设定了统一的且是唯一的数字编号，以满足跨语言，跨平台的特性，代表字符集为UTF-8编码。</p><p> &emsp;&emsp;对于Go语言来说，为了出现字符集的冲突与乱码的形成，官方规定：所有的字符编码均为<strong>UTF-8</strong>编码，如果采用了其他的编码样式，程序是无法编译通过的。采用上一个小节所举的例子，将编码改为ANSI后并输入对应的中文，运行时会出现如下的效果：</p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/1.png" alt></p><p>&emsp;&emsp;在将字符集恢复成UTF-8编码之后，就恢复了正常的显示。所以在各个集成开发工具中，默认的字符编码均为UTF-8编码，所以在使用工具时，可以不需要担心这个问题。</p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/2.png" alt></p><h3 id="几种集成开发工具的介绍"><a href="#几种集成开发工具的介绍" class="headerlink" title="几种集成开发工具的介绍"></a>几种集成开发工具的介绍</h3><h4 id="1-LiteIDE"><a href="#1-LiteIDE" class="headerlink" title="1. LiteIDE"></a>1. LiteIDE</h4><p>&emsp;&emsp;LiteIDE是一款开源的简单的IDE，同时也是Go语言的首个发布的正式版的IDE，通过QT开发，是专门为了Go语言而设计的。在LiteIDE中，可以直接配置构建命令，高级代码编辑，代码管理，自动完成格式化等多个功能。是一个十分轻量级且功能强大的小开发工具。</p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/3.png" alt></p><h4 id="2-VSCode"><a href="#2-VSCode" class="headerlink" title="2. VSCode"></a>2. VSCode</h4><p>&emsp;&emsp;VSCode是微软开发的一个开源IDE，单独这款IDE本身不支持Go语言开发，需要在IDE中进行Go语言的扩展，也是十分方便的。同样地，VSCode的诸多插件也为开发者提供了许多的功能。不仅如此，它也提供了多种语言的支持，使之成为广受欢迎的集成开发工具。</p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/4.png" alt></p><h4 id="3-GoClipse插件"><a href="#3-GoClipse插件" class="headerlink" title="3. GoClipse插件"></a>3. GoClipse插件</h4><p>&emsp;&emsp;看到这个名字可能会比较熟悉，会想起一款名为eclipse的开发工具，GoClipse正是eclipse的插件，通过使用这个插件，开发者可以通过流行的eclipse开发工具进行go语言的开发，其优点是高度的可扩展性，包括源代码编辑器，项目向导，以及GDB项目调试器等等。eclipse和GoClipse插件均为开源的，因此也是免费的。 </p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/5.png" alt></p><h4 id="4-VIM编辑器"><a href="#4-VIM编辑器" class="headerlink" title="4. VIM编辑器"></a>4. VIM编辑器</h4><p>&emsp;&emsp;这个想必也不需要多说，经常使用Linux和MacOS操作系统的对于这个简直不能更熟悉，通过VIM-Go插件使得该编辑器具备了编译器，增强的语法高亮、代码折叠等等功能。除此之外，也可以集成一些高级的源分析工具。可以讲，VIM编辑器的强大之处完全不仅仅在于对Go语言的支持上。</p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/6.png" alt></p><h4 id="5-Goland"><a href="#5-Goland" class="headerlink" title="5. Goland"></a>5. Goland</h4><p>&emsp;&emsp;Goland是由JetBrains公司开发的，旨在为Go语言开发者提供一个更为简便、快速的开发环境。这个商业的IDE整合了IntelliJ平台的Go相关的辅助编码功能和其他的工具。Goland是一个极为强大的开发工具，具备智能补全，检查和快速修复，格式化程序，以及调试器，版本控制器等功能。当然商业工具是需要付费的，对于个人使用可以采用破解<strong>（划掉，改为购买~）</strong>的方式。</p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/7.png" alt></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们首先介绍了编码的含义以及Go语言对编码的要求，同时也介绍了几款相对好用的集成开发工具可供选择，在下一个小节中，我们将集中对第一个Go语言程序，Hello World的输出程序，进行简要的讲解以及对初期开发过程中所需要注意的问题和要求进行说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-2-gt-编码及几种ide的介绍&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-2-gt-编码及几种ide的介绍&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;2&amp;gt; 编码及几种i
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;1&gt; 环境安装及设置</title>
    <link href="http://yoursite.com/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/</id>
    <published>2020-02-04T12:05:41.000Z</published>
    <updated>2020-02-04T13:45:46.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-1-gt-环境安装及设置"><a href="#Go语言从入门到放弃系列-lt-1-gt-环境安装及设置" class="headerlink" title="Go语言从入门到放弃系列&lt;1&gt; 环境安装及设置"></a>Go语言从入门到放弃系列&lt;1&gt; 环境安装及设置</h2><p>&emsp;&emsp;首先第一节，今天便说一说Go语言开发环境的搭建。所谓工欲善其事，必先利其器，没有开发环境对于Go语言的开发简直如同空谈。因此在本章节中，我们会集中阐述开发环境的安装，环境变量的配置，以及对环境变量配置的结果进行验证。</p><h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><p>&emsp;&emsp;最先说明，在写这篇文章的时候，我采用的是windows环境，因此我的各项操作均是基于windows操作系统的，如果读者希望采用其他的系统进行开发，可以在网络上找到配置的方式。此处只介绍windows相关配置，其他系统暂不再赘述。</p><p>&emsp;&emsp;首先，作为最初的，便是在网络中下载Go的安装包，本文给出安装包的下载地址：<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a> </p><p>&emsp;&emsp;需要说明的是，这个网站可能需要翻墙才能进入，因此如果打不开可以尝试这个地址：<a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a> 因为本人是在国内开始写的这个连载，因此采用的是第二个网址。进入下载页面后如下图（图片将来可能会根据网站版本不同而改变）：</p><p><img src="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/1.png" alt></p><p>&emsp;&emsp;从图中可以看出，Go官方提供了基于不同系统的不同的安装包，只需要下载相应系统的安装包，再根据不同系统的命令进行安装即可，我们以下依旧采用windows为例。安装过程便不作具体描述了，一般来说不需要修改其中的设置，只需要下一步直到完成。值得说明的是，当选择Go语言开发环境的安装位置时如果不作修改便是C:\Go这个文件夹，修改的话需要记住修改后的位置，在后续配置中是需要的。同时，在安装过程中，尽量不要出现中文路径，以防止后续出现问题。</p><p>&emsp;&emsp;在安装过后，我们打开cmd命令控台，键入go version命令（中间有空格）</p><p><img src="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/2.png" alt></p><p>&emsp;&emsp;从上图我们可以看到的是，我的机器的Go开发环境版本为1.11.2，如果安装不同的版本，这个版本号会不同。在安装过后，我们进入环境变量中会发现，系统自动为我们设置了GOROOT环境变量，并且该值为 <strong>刚刚安装的目录</strong> ，如果发现该值与安装目录不同，需要进行修改。本人在安装的时候没有对安装目录进行修改，所以均为默认值。</p><p>&emsp;&emsp;除此之外，还需要检查Path变量是否进行了更新，对Path的配置便是在后面加入 <strong>安装目录下的bin\目录</strong> 的全路径，建议用分号将其与前后的其他设置分开。</p><p><img src="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/3.png" alt></p><p> &emsp;&emsp;到目前为止，可以说环境变量已经配置完了，可以进行初级的开发，不过为了后续的开发方便，我们继续配置GOPATH环境变量，在Go语言的包引入过程中，是采用%GoPath%\src为起始的目录引入的，因此建议单独生成一个文件夹，并将所有的源代码均写在这个文件夹的src目录中，而GOPATH的配置便是这个文件夹，本人在E盘下新建了GoProject，并且所有的源代码均写于E:\GoProject\src\xxx\yyy.go下，因此我的GOPATH为： <strong>E:\GoProject</strong></p><p>&emsp;&emsp;此时我们在cmd控制台中键入： go env，将显示出当前GO的所有环境配置，如下图所示。</p><p><img src="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/4.png" alt></p><h3 id="环境测试"><a href="#环境测试" class="headerlink" title="环境测试"></a>环境测试</h3><p>&emsp;&emsp;安装环境已经结束，接下来我们需要对环境的配置进行检测，便写一段简单的代码进行验证。代码也是众所周知的Hello World的输出。首先，我们在任意一个文件夹下建立一个.txt文件并将扩展名改为.go，本人便于桌面上建立一个test.go文件。请注意，在修改文件时一并修改的文件格式，也就是将隐藏已知文件名的选项去掉，否则会成为一个test.go.txt的文件。（windows各版本设置方式不同，windows7为例）</p><p><img src="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/5.png" alt></p><p>&emsp;&emsp;采用记事本的方式打开，并在其中输入如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hello World的编写</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后，打开cmd控制台，进入到桌面上，键入go run test.go后会立刻出现程序的执行结果，也就是在控制台输出了Hello World字样，如果成功输出则代表Go环境在本机配置正确，可以进行代码的编写了。</p><p><img src="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/6.png" alt></p><p>&emsp;&emsp;环境配置工作是相对简单的，本人也暂时没有发现在这个过程中出现什么问题，因此也不知如何去写问题的解答。不过一定要注意将环境配好，这可能会影响后续一些小节的内容的讲解。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;这个小节集中阐述了Go语言开发环境的安装，环境变量的配置，以及入门程序Hello World的编写。其版本号以及其他图片实例均与个人的配置相关，或在版本升级后将有其他的样式。在下一章，我们将集中介绍几款GO开发的集成开发环境，并选择其中一个进行安装。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-1-gt-环境安装及设置&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-1-gt-环境安装及设置&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;1&amp;gt; 环境安装及设置&quot;&gt;&lt;/a&gt;G
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
