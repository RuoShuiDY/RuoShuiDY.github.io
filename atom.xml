<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>云钰的亭轩阁</title>
  
  <subtitle>Running water never goes stale, so you gotta just keep on flowing.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-21T07:09:07.646Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Devin DENG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;45&gt; 面向对象-多态</title>
    <link href="http://yoursite.com/2020/03/21/45-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2020/03/21/45-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/</id>
    <published>2020-03-21T07:08:16.000Z</published>
    <updated>2020-03-21T07:09:07.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-45-gt-面向对象-多态"><a href="#Go语言从入门到放弃系列-lt-45-gt-面向对象-多态" class="headerlink" title="Go语言从入门到放弃系列&lt;45&gt; 面向对象-多态"></a>Go语言从入门到放弃系列&lt;45&gt; 面向对象-多态</h2><p>&emsp;&emsp;在前几个小节中，我们分别讲解了Go语言中的继承概念与接口概念，同时我们也曾提及：Go语言的多态特性是通过接口的形式反映出来的。因此我们先讲解了接口的概念与语法，进而再讲解Go语言中面向对象的另一大特性：多态。在这个小节中，我们将首先讲解Go语言中继承与接口的不同点、多态的引出、以及类型断言的用法。在这之后，Go语言中面向对象部分的讲解就基本结束了。</p><h3 id="继承与接口的区别"><a href="#继承与接口的区别" class="headerlink" title="继承与接口的区别"></a>继承与接口的区别</h3><p>&emsp;&emsp;通过前几个小节的讲解，有人可能会疑惑，Go语言中既然支持了多重继承，又具备接口实现，这两种技术有一定的交叉点，概念上也有些类似，那么出现两种技术的意义又何在。在这个部分中，我们将着重讲解Go语言中继承与接口实现的关系。 </p><p>&emsp;&emsp;我们首先基于一个童话来引入这个问题，相信大家都曾经听过老虎向猫咪学艺的故事，在这个童话中出现了两种生物：猫和老虎。如果两种生物没有任何交集，那么小虎继承于老虎、小猫继承与大猫是不需要怀疑，且是天然存在的继承关系。但在故事中老虎想向猫学习一些本领，例如说爬树，此时在小虎的“固有人设”上就会发生变化。小虎不仅有老虎的所有的属性与行为，它还希望具备猫身上的一种行为，这个过程就是实现接口。我们通过案例来说明这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span> <span class="title">climbTree</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"我会爬树"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Tiger <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tiger)</span> <span class="title">attack</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"我会进攻"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样地，我们依旧定义了虎类与猫类，类中不含属性，且每个类具备一个方法。现在我们假设一只小虎想要学爬树，我们可能有两种做法：第一种做法是将爬树这个行为作为接口，让小虎实现这个接口；第二种方式就是让小虎继承于虎类，同时继承于猫类。这两种办法在代码实现的层面上讲，都可以完成代码任务，但是在实际层面上讲，第二种方法简直荒谬，因为这样做的结果就是小虎的多继承破坏了虎类的继承树，使得虎的祖先不仅有虎还有猫（我们不谈生物现象）。因此我们说，为了实现某个功能而进行多重继承不是一个合理的选择，而是应该通过接口实现的方式为一个类添加方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LikeCat <span class="keyword">interface</span> &#123;</span><br><span class="line">    climbTree()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> LittleTiger <span class="keyword">struct</span> &#123;</span><br><span class="line">    Tiger</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LittleTiger)</span> <span class="title">climbTree</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"小虎会爬树了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，由于Go语言实现接口是通过实现方法的特性，我们也可以说：猫类实现了LikeCat接口具备了爬树行为，小虎类也实现了LikeCat接口与爬树行为。 </p><p>&emsp;&emsp;那么接口与继承的意义究竟何在，我们通过前几个小节的侧重点发现：继承的价值在于<strong>代码复用与维护性</strong>，而接口的意义则在于<strong>代码编写过程中规范的设计</strong>。接口的使用实际上是比继承更为灵活且轻量，继承关系一旦确立，则需要继承父类所有的属性与所有的方法，而接口则只需要实现对应的方法即可。由于我们所举的例子都十分简单，因此体会不到接口的轻量，假如虎类和猫类都有上百种行为，而小虎只需要具备猫类中爬树的行为，那么多重继承的重量性就不言而喻了。 </p><p>&emsp;&emsp;那么我们再思考这样一个问题：为什么我们写了LikeCat接口，如果我们不写这个接口而直接在小虎类中添加一个ClimbTree方法，程序其实也是没有错误的。但是此时假如在代码中有一个切片，让会爬树的动物都添加到切片中，此时小虎是做不到的，因为数据类型不一致。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>&emsp;&emsp;讲解了接口的概念与使用过后，多态的概念就十分简单了。多态按字面的意思理解就是多个状态，那么到目前为止我们在什么情况下接触到一种“实例”可以对应多个类型，答案就是在接口的介绍过程中，接口的多种不同的实现类的实例可以赋值给接口变量。换句话说，一个接口变量可以具备很多不同的类型，而这些类型都是实现了该接口的类。“多态性是允许你将父对象设置成为一个子对象相等的技术，赋值过后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作”（摘自Delphi4编程技术内幕）。这句话有些专业且不易理解，我们用一个简单的方式表述就是：将实现类的指针赋值给接口变量指针。 </p><p>&emsp;&emsp;对于有十分丰富的编程经历的开发者而言，这里尤其需要注意的是：Go语言中不支持将子类对象指针赋值给父类对象指针，因为变量类型不匹配。在Java中存在向上转型的概念，但是在Go语言中子类父类是不能相互赋值的，例如在刚刚的案例中我们如下写就会报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t Tiger = LittleTiger&#123;&#125;</span><br><span class="line">cannot use LittleTiger literal (<span class="keyword">type</span> LittleTiger) as <span class="keyword">type</span> Tiger in assignment</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们回到具体的案例中，多态是同一个行为具备不同表现形式或形态的能力，根据传入的实例不同，程序具备不同的相应。例如在现实中，我们经常使用的ctrl+c组合是指复制的功能，然而在命令行中同样的组合则代表强制结束当前的执行过程，因此同一个行为在不同的情况下具备不同的响应。 </p><p>&emsp;&emsp;我们在通过USB接口的案例继续说明多态的技术点：除了键盘与鼠标实现了USB接口规范之外，手机类Phone也实现了USB接口规范，现在我们有一个需求：将实现了USB接口的设备统一放置于一个切片中，遍历这个切片，调用每一个切片元素的Start方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Mouse <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mouse)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"鼠标开始工作"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Keyboard <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k *Keyboard)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"键盘开始工作"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Phone)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"手机开始工作"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m Mouse</span><br><span class="line">    <span class="keyword">var</span> k Keyboard</span><br><span class="line">    <span class="keyword">var</span> p Phone</span><br><span class="line">    usbSlice := <span class="built_in">make</span>([]USB, <span class="number">0</span>)</span><br><span class="line">    usbSlice = <span class="built_in">append</span>(usbSlice, &amp;m)</span><br><span class="line">    usbSlice = <span class="built_in">append</span>(usbSlice, &amp;k)</span><br><span class="line">    usbSlice = <span class="built_in">append</span>(usbSlice, &amp;p)</span><br><span class="line">    <span class="keyword">for</span> _, device := <span class="keyword">range</span> usbSlice &#123;</span><br><span class="line">        device.Start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码我们在讲解接口的时候已经提及过了，此处也就不再过多赘述了。它反映出来的一个思想就是：切片中每一个“USB实例”的Start方法所得到的结果均是不同的。</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>&emsp;&emsp;在上一个部分中，我们讲解的是将实现类的实例赋值给接口变量，使得接口实例可以通过同一个方法调用得到不同的结果。这个小部分中我们所讲解的过程是上一个部分的逆过程，在实际编码过程中，不仅需要让实现类进行“向上转型”，还需要让接口变量进行“向下转型”。 </p><p>&emsp;&emsp;我们回到USB的例子中，假设Mouse类不仅具备Start方法，还具备独特的按键点击Click方法，Keyboard类依旧具备Start方法。根据刚刚的描述，我们可以将Mouse实例和Keyboard实例赋给USB实例，他们都可以调用Start方法，但是此时我们希望如果是Mouse实例的话，同时再调用Click方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mouse <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mouse)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"鼠标启动"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mouse)</span> <span class="title">Click</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"鼠标点击"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m Mouse</span><br><span class="line">    <span class="keyword">var</span> usb USB = &amp;m</span><br><span class="line">    usb.Start()    <span class="comment">//可以调用</span></span><br><span class="line">    usb.Click()    <span class="comment">//编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们在main函数中将一个Mouse实例赋值给USB实例，并通过USB实例调用Start方法和Click方法。在调用Start方法时（假如Click方法被注释），程序是可以成功完成调用的。但是在调用Click方法时，会出现编译错误的情况，因为USB接口中没有对应的Click方法，Click方法是Mouse类所独有的方法，所以通过接口实例是不能调用接口外的方法的。 </p><p>&emsp;&emsp;但是我们确实是将Mouse实例赋给了usb对象，所以理论上它还是具备调用Click方法的能力的，如果想要调用这个方法，我们就需要使用类型断言，其格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接口实例.(类的类型)</span><br><span class="line">convertM := usb.(*Mouse)</span><br><span class="line">convertM.Click()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，我们通过类型断言（和强制转换不同）将usb“实例”重新返回给了Mouse对象指针，此时convertM就相当于是Mouse实例了，因此就可以调用其本身的Click方法了。 </p><p>&emsp;&emsp;这里需要注意的是：在使用类型断言的时候，如果出现了类型断言的错误，程序会抛出panic并跳出。例如我们将Mouse指针赋给了USB实例，却使用了Keyboard指针作为类型断言，程序在编译过程是不会报错的，但是在执行过程中会出现如下的panic:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> conversion: main.USB is *main.Mouse, not *main.Keyboard</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因此在使用类型断言的时候，我们往往通过两个变量进行接收结果：第一个变量是类型转换过后的实例类型，第二个则是在转换过程中是否出现了错误。我们通过后一个变量接收是否出现panic，并判断是否为true，这样就可以避免程序在执行过程中跳出了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Keyboard代码省略，和之前的一样</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m Mouse</span><br><span class="line">    <span class="keyword">var</span> usb USB = &amp;m</span><br><span class="line">    usb.Start()</span><br><span class="line">    convertM, err := usb.(*Keyboard)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">true</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"类型转换错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    convertM.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的程序中，我们留一个彩蛋，希望读者自行验证一下。笔者暂时不清楚上述代码结果的原因，是这种独特的设计还是后续版本会更新。在代码中，我们首先定义了Mouse实例并赋给了usb对象，然后我们通过usb实例进行调用Start，此时输出毋庸置疑，是：鼠标启动。然后我们将usb转换成为Keyboard，此时当然是类型不匹配，因此“类型转换错误”是一定会输出的。<strong>然后，convertM的Start方法会输出什么？</strong> </p><p>&emsp;&emsp;其输出结果是：键盘启动。换句话就是转换过程中报出了panic，但是转换是成功的，Keyboard由于也实现了USB接口，所以也具备Start方法。程序依旧可以正常执行，而没有出现运行时错误。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们介绍了Go语言面向对象特点中的多态特点。多态特性的显示是通过接口完成的，由于接口实例的存在，使得通过接口实例调用的方法可以根据实现类的实现方法而不同。同时，我们也讲解了Go语言中继承和接口实现的不同点，以及Go语言中“向下转型”的方式：类型断言的使用。 </p><p>&emsp;&emsp;到此Go语言的面向对象部分就已经介绍完了，在后续的章节中，我们将开始介绍Go语言中的文件操作以及I/O的使用方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-45-gt-面向对象-多态&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-45-gt-面向对象-多态&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;45&amp;gt; 面向对象-多态&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;44&gt; 面向对象-接口细节讨论</title>
    <link href="http://yoursite.com/2020/03/19/44-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/03/19/44-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/</id>
    <published>2020-03-19T04:21:41.000Z</published>
    <updated>2020-03-19T04:22:29.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-44-gt-面向对象-接口细节讨论"><a href="#Go语言从入门到放弃系列-lt-44-gt-面向对象-接口细节讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;44&gt; 面向对象-接口细节讨论"></a>Go语言从入门到放弃系列&lt;44&gt; 面向对象-接口细节讨论</h2><p>&emsp;&emsp;在上个小节中，我们通过案例讲解了Go语言中接口的概念，并在最后也简单介绍了Go语言中对接口实现的独特方式。与传统面向对象语言相比，Go语言中接口的实现并不依赖于关键字，而是依赖于接口方法的实现与否。在这个小节中，我们将针对接口的使用规则与细节进行更为详细的描述。</p><h4 id="1-接口不创建实例，但可以接收实例，接收的实例必须实现该接口"><a href="#1-接口不创建实例，但可以接收实例，接收的实例必须实现该接口" class="headerlink" title="1. 接口不创建实例，但可以接收实例，接收的实例必须实现该接口"></a>1. 接口不创建实例，但可以接收实例，接收的实例必须实现该接口</h4><p>&emsp;&emsp;这句话可能相对难以理解，我们根据上一章节中所举的USB接口为例来说明这个问题。在之前的代码中，Computer的Work方法的形式参数是一种USB所指代的实例，而在主函数中传入的却是Mouse和Keyboard，以及Printer类的实例。因此我们说：USB接口并不创建实例，因为代码中并没有如下的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> usb USB</span><br><span class="line">usb.Start()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的写法在运行过程中会报错，因为此时声明的usb“对象”是一个抽象的概念，通过这个抽象的概念来完成Start方法的调用会引发panic：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: runtime error: invalid memory address or <span class="literal">nil</span> pointer dereference</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是假如我们将USB接口与其实现类绑定，换句话说此时的接口就具备的一个实体，这个实体可以完成Start方法。再通俗一些理解就是：USB接口是一种规范，要求实现该接口的硬件都要有Start方法；这个规范是一种抽象的、虚构的存在，但是实现了该接口的硬件却是一种实际的物体，可以进行工作。因此接口不能创建实例，但是接口可以接收实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m *Mouse</span><br><span class="line"><span class="keyword">var</span> usb USB = m</span><br><span class="line">usb.Start()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，我们声明了一个usb引用，且让该引用指向一个Mouse实例，此时usb就从虚无变成了存在了，因此它就可以调用接口中的方法了。 </p><p>&emsp;&emsp;那么这种语法存在的意义是什么，假如我们在写一个游戏，这个游戏中具备多个角色子类，每种角色有不同的技能。此时我们需要统计一下具有某一种技能的所有角色有哪些，并将该角色存入到一个切片中。在之前的讲解中，我们说到切片与数组都是同一种数据类型的集合体。那么现在不同角色是不同的结构体类型，是不可以放到同一个切片中的。为了解决这个问题，我们可以通过定义接口切片的形式来完成：</p><p>&emsp;&emsp;既然一个对象实例可以赋给一个接口，那么只要实现了该接口的所有类的实例就都可以赋给该接口，这样相当于所有的类都是“同一种数据类型”了，我们通过代码说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Run <span class="keyword">interface</span> &#123;</span><br><span class="line">    Move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Attack <span class="keyword">interface</span> &#123;</span><br><span class="line">    Attack()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Role <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Role)</span> <span class="title">Move</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"行动"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Role)</span> <span class="title">Attack</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"攻击"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r Role = Role&#123;<span class="string">"DENG"</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> runSlice = <span class="built_in">make</span>([]Run, <span class="number">0</span>)</span><br><span class="line">    runSlice = <span class="built_in">append</span>(runSlice, r)</span><br><span class="line">    fmt.Println(runSlice)</span><br><span class="line">    <span class="keyword">var</span> attackSlice = <span class="built_in">make</span>([]Attack, <span class="number">0</span>)</span><br><span class="line">    attackSlice = <span class="built_in">append</span>(attackSlice, r)</span><br><span class="line">    fmt.Println(attackSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们在程序中定义了两个接口，并让Role类实现了两个接口，在主函数中，我们分别声明了两个不同类型的切片：Run接口类型的切片和Attack接口类型的切片。实例化一个Role之后，将该对象追加到两个切片中，程序正常运行且正确输出。这是一种向上转型的思想，可以理解为一个类实现的某个接口，那么这个类就是这个接口实例。</p><h4 id="2-实现接口需要实现接口中所有方法，且接口中方法没有方法体"><a href="#2-实现接口需要实现接口中所有方法，且接口中方法没有方法体" class="headerlink" title="2. 实现接口需要实现接口中所有方法，且接口中方法没有方法体"></a>2. 实现接口需要实现接口中所有方法，且接口中方法没有方法体</h4><p>&emsp;&emsp;既然接口定义的方法是一种规则的制定，那么在接口中制定的方法就不需要被实现。因为不同的类实现该接口的时候会覆盖重写该方法。就如同USB接口规则的制定者并不需要说明这个接口如何实现它，只需要指定入参是什么，返回值是什么，方法名是什么。实现者才需要考虑具体的实现方式，手机有手机的实现方式，鼠标有鼠标的实现方式。 </p><p>&emsp;&emsp;那么对于Go语言的接口定义而言，直接实现对应的方法会报错，其原因即是上述所讲：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Run <span class="keyword">interface</span> &#123;</span><br><span class="line">    Move()&#123;</span><br><span class="line">        fmt.Println(<span class="string">"Hello"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">syntax error: unexpected &#123;, expecting semicolon or newline or &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;除了所有方法都没有方法体之外，当一个类实现了某个接口时，需要覆盖实现接口中所有的方法。反过来说也是成立的，如果一个类没有实现一个接口中的所有方法，那么这个类就没有实现该接口。在Go语言中不通过implements关键字指定实现关系，因此只能通过检测一个类是否实现全部方法来判定是否实现了接口。 </p><p>&emsp;&emsp;有时在多人开发过程中，每个人可能制定了自己的接口规则，也存在这种两个人定义的接口名不同，但是方法签名都相同的可能性。那么此时一个类实现了其中的一个接口，实现了接口中所有的方法，那么这个类也就同时实现了另一个接口了。 </p><p>&emsp;&emsp;这种接口实现方式说实话不同人有不同的看法。有些开发者认为这个隐式实现的特性非常好，这是一种松耦合的体现。但是也有人会感到这种方式比较怪异，当程序量比较大之后，一旦对接口中的方法签名发生了修改，或添加了一个方法，由于没有明确的实现关系，因此编译器并不能提示开发者哪些类需要作出相应的修改。如果类中没有相应的方法更新或实现，那么编译器就直接认为放弃了接口的实现。</p><h4 id="3-一个自定义类型可以实现多个接口"><a href="#3-一个自定义类型可以实现多个接口" class="headerlink" title="3. 一个自定义类型可以实现多个接口"></a>3. 一个自定义类型可以实现多个接口</h4><p>&emsp;&emsp;在这个小标题中包含了两个知识点，第一个知识点是在Go语言中只要是自定义类型，不仅仅局限于结构体，都可以实现接口。第二个知识点是一个结构体类可以实现多个接口。 </p><p>&emsp;&emsp;在之前介绍方法的时候我们就提及过，一个自定义类型就可以存在方法。我们也通过为一个自定义整数（Integer）类型添加判断奇偶性的方法来举例。对于接口实现而言，这个现象依旧通用，我们依旧可以为整数等等类实现接口。由于在Go语言中是通过实现方法来实现接口的，而自定义类具备方法这个特性我们已然讲解过，那么自定义数据类型当然顺理成章就可以实现接口了。 </p><p>&emsp;&emsp;对于多个接口的实现，Go语言乃至于传统面向对象语言是都支持的。在前文中我们也提到了：如果两个接口中的方法名，那么一个类实现了一个接口的同时就自动实现了另一个接口，当然多接口实现不仅仅于此，我们通过一个案例来说明： </p><p>&emsp;&emsp;假如我们的投影仪不仅仅有VGA接口，还有HDMI接口，那么一个投影仪就需要实现两个接口。我们用代码说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> VGA <span class="keyword">interface</span> &#123;</span><br><span class="line">    StartVGA()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> HDMI <span class="keyword">interface</span> &#123;</span><br><span class="line">    StartHDMI()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Projector <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Projector)</span> <span class="title">StartVGA</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"VGA start"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Projector)</span> <span class="title">StartHDMI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"HDMI start"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *Projector</span><br><span class="line">    <span class="keyword">var</span> vga VGA = p</span><br><span class="line">    <span class="keyword">var</span> hdmi HDMI = p</span><br><span class="line">    vga.StartVGA()</span><br><span class="line">    hdmi.StartHDMI()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们定义了两个接口，分别为VGA和HDMI接口。两个接口中规定的方法不同，然后我们又定义了一个Projector结构体类，并让这个类实现了两个方法。最后在主函数中我们实例化了一个Projector，同时用两个接口接收了p对象。最后通过两个接口来调用方法，程序的数据结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VGA start</span><br><span class="line">HDMI start</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上个小节中我们讲到，只有一个类实现了对应接口，才可以将该类的对象赋给接口对象。而在上述程序中，p对象成功地被分配给了两个接口，且程序正常输出，因此这个类确实实现了多个接口。</p><h4 id="4-接口可以继承接口，但是不能实现接口"><a href="#4-接口可以继承接口，但是不能实现接口" class="headerlink" title="4. 接口可以继承接口，但是不能实现接口"></a>4. 接口可以继承接口，但是不能实现接口</h4><p>&emsp;&emsp;在这之前我们讲解了接口与实现类的关系，那么其实接口与接口之间也可以存在关系。在第2个知识点中，我们说到接口中定义的方法是不可以被实现的，是抽象方法。同时如果一个类实现了一个接口，就需要实现接口中所有的方法。因此接口实现接口这个命题从根本上就是矛盾的，一方面接口中方法不可以实现，另一方面实现了方法才实现了接口，因此接口之间是没有实现关系的。 </p><p>&emsp;&emsp;但是接口之间是存在继承关系的，其继承模式与类的继承的表现形式是相同的。都是通过匿名的方式完成。例如，一个组织定义了一种接口形式以及接口方法，但是随着时代的推进，原来的方法不足以满足所有的需求，于是基于原来的接口出现了新的接口，这个形式就是接口的继承。 </p><p>&emsp;&emsp;接口的继承规定了子接口中的方法完全继承了父接口的方法，因此如果一个类想要实现该接口，则需要实现该接口中的所有方法，以及父接口中的所有方法。此处不通过代码说明了，读者可以自己验证一下。 </p><p>&emsp;&emsp;值得说明的是，在接口的继承中一定要注意一个问题：父接口中的方法名一定不要和子接口新增的方法名相同，即便是返回值不同，参数不同也不可以。因为归根结底接口中的方法声明在实现类中都是方法，而Go语言不支持方法重载，所以同名是不可以的，这个接口也就不可能被实现了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们针对Go语言的接口的各个细节进行了说明，讲解了接口实例与实现类对象的关系，接口中方法规定，多接口实现以及接口的继承的概念。在这个小节中其实知识点含量较多，初学者可以自行通过写代码去练习，接口在Go语言中的用处还是十分地大的。 </p><p>&emsp;&emsp;在下个小节中，我们将集中说明Go语言通过继承与接口实现的方式对于多态概念的实现，以及接口与继承的比较关系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-44-gt-面向对象-接口细节讨论&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-44-gt-面向对象-接口细节讨论&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;44&amp;gt; 面向对
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;43&gt; 面向对象-接口</title>
    <link href="http://yoursite.com/2020/03/17/43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2020/03/17/43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-03-17T04:10:38.000Z</published>
    <updated>2020-03-17T04:11:29.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-43-gt-面向对象-接口"><a href="#Go语言从入门到放弃系列-lt-43-gt-面向对象-接口" class="headerlink" title="Go语言从入门到放弃系列&lt;43&gt; 面向对象-接口"></a>Go语言从入门到放弃系列&lt;43&gt; 面向对象-接口</h2><p>&emsp;&emsp;在这之前，我们已然介绍了面向对象编程部分的抽象思想，封装思想，和继承技术。在接下来的几个小节中我们将开始介绍面向对象的另一个特性-多态。然而就目前而言，直接介绍多态相对复杂，因此我们先介绍接口的技术，然后通过接口和继承的技术来说明多态的特性。在这个小节中，我们将通过案例引入接口的概念以进行快速入门程序的书写。</p><h3 id="接口引入"><a href="#接口引入" class="headerlink" title="接口引入"></a>接口引入</h3><p>&emsp;&emsp;在日常生活中，接口的概念十分广泛。比如我们都十分熟悉的USB接口，TypeC接口，HDMI接口，VGA接口等。在面向对象语言中，也存在接口的概念。我们通过物理的接口为例来了解Go语言的接口：现在我们的计算机基本都有USB接口，手机可以通过USB接口连入计算机，打印机可以通过USB接口连入计算机。不同的设备通过同一种接口连入计算机，却能够拥有不同的响应，换句话说：接口可以根据连入的设备不同自动判断对应的执行结果。 </p><p>&emsp;&emsp;在好多年前的计算机中，鼠标和键盘与计算机的连接都不是通过USB接口的，而是有各自的具体的接口，且不同的接口是连不上的。这也意味着曾经计算机需要为不同的硬件专门设计不同的接口。我们通过简化的代码来模拟这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mouse <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Mouse)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"鼠标开始工作"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Keyboard <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k Keyboard)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"键盘开始工作"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们定义了两个类分别为鼠标类和键盘类，且类中没有属性只有方法。向鼠标和键盘类分别绑定各自的不同的Start方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Computer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Computer)</span> <span class="title">MouseWork</span><span class="params">(m *Mouse)</span></span> &#123;</span><br><span class="line">    m.Start()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Computer)</span> <span class="title">KeyboardWork</span><span class="params">(k *Keyboard)</span></span> &#123;</span><br><span class="line">    k.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们接下来又定义了一个计算机类，在计算机类中依旧没有任何的属性，且计算机类需要分别为鼠标和键盘绑定一个方法。此时我们调用不同的方法以将鼠标或键盘连接到计算机上，我们用主函数模拟：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Computer</span><br><span class="line">    <span class="keyword">var</span> m Mouse</span><br><span class="line">    <span class="keyword">var</span> k Keyboard</span><br><span class="line">    c.MouseWork(&amp;m)</span><br><span class="line">    c.KeyboardWork(&amp;k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在主函数中，我们声明了一个计算机实例，鼠标实例，和键盘实例，并通过计算机实例的两个不同的接口完成设备的连入。此时程序的输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">鼠标开始工作</span><br><span class="line">键盘开始工作</span><br></pre></td></tr></table></figure><h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>&emsp;&emsp;在这种当前的解决方案下，即使程序可以正常执行，结果可以正确输出，但是这种做法的扩展性相对较低。例如我们再定义一个打印机类，打印机类具备自己的驱动方法，自己的执行方式。同时我们需要修改计算机类，让计算机类为打印机留出一个接口。程序修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Printer <span class="keyword">struct</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Printer)</span> <span class="title">Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Computer)</span> <span class="title">PrinterWork</span><span class="params">(p *Printer)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种修改方式实在过于繁琐，且随着硬件的增多，程序会变得非常的大，而且代码十分重复。不仅如此，假如不同的硬件厂商的设计理念不同，生产出的硬件不兼容，计算机只好为不同厂商的同一种硬件做不同的适配，这无疑会增加更多的工作量。 </p><p>&emsp;&emsp;除此之外，即便是我们可以为所有的不同种类的硬件都预留出对应的接口，还是会出现一定的问题。一般情况下，计算机外设只有鼠标和键盘，但对于一些人来说可能需要打印机，对于开发人员来说，需要各种手机的连入接口。换句话说，不同的使用者更倾向于不同的特定的功能，而其他的预留接口都被浪费了。 </p><p>&emsp;&emsp;因此，如果存在着一种规定，不同的硬件厂商在生产的时候都遵循这个规定，计算机只接受实现了这个规定的硬件。这样的话，计算机只需要预留出几个接口就可以了，需要什么功能的硬件直接插入即可。因为规定都是相同的，协议都是一致的，在Go语言中，接口就可以起到这个功能。</p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>&emsp;&emsp;对于上述问题的解决方式可以分为以下几个步骤：<br>&emsp;&emsp;1. 制定一种规定，设计一种接口；<br>&emsp;&emsp;2. 让鼠标和键盘实现这种规定；<br>&emsp;&emsp;3. 让计算机拥有这个接口。<br>&emsp;&emsp;因此，我们首先定义一个接口，这个接口中有一个抽象方法，即只有实现了这个方法，才算是实现了这个接口，然后我们让鼠标和键盘分别实现这两个方法，最后在计算机类的方法中注入这个接口实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span>&#123;</span><br><span class="line">    Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于我们在之前的代码中已然为Mouse和Keyboard类绑定了Start方法，因此这两个类不需要做出改动。如果之前写的方法名不是Start的话，则需要改为Start方法。 </p><p>&emsp;&emsp;接下来我们修改Computer类，这个类不再需要为每一个硬件都预留方法，因此将其他方法删除，而是需要把USB接口传入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Computer)</span> <span class="title">Work</span><span class="params">(usb USB)</span></span> &#123;</span><br><span class="line">    usb.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后在main函数中定义一个Computer类，Mouse类，和Keyboard类。并将Mouse和Keyboard传入到Computer类中的Work方法中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Computer</span><br><span class="line">    <span class="keyword">var</span> m Mouse</span><br><span class="line">    <span class="keyword">var</span> k Keyboard</span><br><span class="line">    c.Work(&amp;m)</span><br><span class="line">    c.Work(&amp;k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的代码中，我们可以发现，在定义Work方法的时候定义的参数是USB实例，但是我们传入的是Mouse和Keyboard对象指针。即便如此，并没有出现参数不匹配的现象，反而根据传入对象的不同输出结果不同，这就是一种多态的体现。 </p><p>&emsp;&emsp;现在假设我们又添加了一个新的打印机类，只要这个类实现了Start方法，它就可以被传入到Work方法中，并完成程序的调用。对于Computer类而言，则完全不需要进行修改。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们主要通过USB接口的案例来说明Go语言中的接口的概念，并通过该案例引入了Go语言接口实现的方式。在一些面向对象的语言中，接口的实现是通过implements关键字完成的，并且直接指明了实现关系。但是在Go语言中并没有这个关键字，接口的实现完全是靠实现接口定义的方法完成的。假如程序中定义了两个接口，且接口中定义的抽象方法是相同的，那么一个类实现其中一个接口的同时也就实现了另一个接口。 </p><p>&emsp;&emsp;在下个小节中，我们将针对Go语言中接口的使用方式和需要注意的细节进行相对深入的讨论。在讨论过程中也会通过代码案例来完成相应的说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-43-gt-面向对象-接口&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-43-gt-面向对象-接口&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;43&amp;gt; 面向对象-接口&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;42&gt; 面向对象-继承细节讨论</title>
    <link href="http://yoursite.com/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/</id>
    <published>2020-03-16T15:43:52.000Z</published>
    <updated>2020-03-16T15:44:39.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-42-gt-面向对象-继承细节讨论"><a href="#Go语言从入门到放弃系列-lt-42-gt-面向对象-继承细节讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;42&gt; 面向对象-继承细节讨论"></a>Go语言从入门到放弃系列&lt;42&gt; 面向对象-继承细节讨论</h2><p>&emsp;&emsp;在上个小节中，我们通过银行账户的例子引入了Go语言中面向对象中继承的概念，并用代码演示了继承的实现方式。在入门案例中，我们通过将父类的结构体以匿名的方式嵌入到子类结构体中完成了子类对父类的属性和方法的继承。在这个小节中，我们将针对Go语言中继承的概念的一些细节做出更为详细的讨论。</p><h4 id="1-Go语言中继承关系是通过匿名结构体完成的"><a href="#1-Go语言中继承关系是通过匿名结构体完成的" class="headerlink" title="1. Go语言中继承关系是通过匿名结构体完成的"></a>1. Go语言中继承关系是通过匿名结构体完成的</h4><p>&emsp;&emsp;在传统面向对象语言中，例如Java，继承关系是通过extends关键字完成的，且子类与父类之间有着明确的继承关系。父类中的属性和方法是有选择性地被子类所继承。然而在Go语言中，继承关系是通过匿名结构体的方式完成的，且在Go语言中继承与组合的关系变得不是那么的明确。继承可以讲是一种“is-a”的关系，例如VIP账户继承了账户类，那么VIP账户自身就是一个账户。而组合关系则是一种“has-a”的关系，例如一辆车具备车轮，一只猫有四条腿，而不是一辆车是车轮，一只猫是四条腿。我们通过代码来说明这个问题： </p><p>&emsp;&emsp;假如我们事先定义好了一个Account类，并在VIPAccount类中继承这个类，那么代码会是以下的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> VIPAccount <span class="keyword">struct</span>&#123;</span><br><span class="line">    Account</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码中反映的就是一种继承关系。接下来我们再通过代码讲解一下组合的关系，我们保留Account类不变，我们修改一下VIPAccount类的构成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> VIPAccount <span class="keyword">struct</span>&#123;</span><br><span class="line">    a Account</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，Account类的一个实例成为了VIPAccount类中的一个属性，因此我们讲此时VIPAccount拥有了一个Account变量。当然此时我们在主函数调用VIP实例的时候依旧需要通过“变量.属性.属性”的形式完成。在这个角度上看，Go语言中继承与组合的关系十分密切，甚至可以讲，Go语言中的继承关系就是通过组合关系的形式完成的。</p><h4 id="2-父类中的全部属性和方法均被继承"><a href="#2-父类中的全部属性和方法均被继承" class="headerlink" title="2. 父类中的全部属性和方法均被继承"></a>2. 父类中的全部属性和方法均被继承</h4><p>&emsp;&emsp;在传统面向对象语言中，父类中的private修饰的属性是不可以被子类所继承的，包括private修饰的方法也是不可以被继承的。然而在Go语言中，这个规则不再被继续遵循。父类的所有属性和方法（不论首字母大小写）均会被子类所继承。我们依旧采用Account类为例，我们设定Name属性为公有，balance属性为私有，Query方法为公有，withdraw方法为私有，最后再用VIPAccount类继承：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name     <span class="keyword">string</span></span><br><span class="line">    balance   <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">Query</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.Name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">withdraw</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    a.balance -= money</span><br><span class="line">    fmt.Println(<span class="string">"余额为："</span>, a.balance)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VIPAccount <span class="keyword">struct</span>&#123;</span><br><span class="line">    Account</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们在当前的包中的主函数中分别为两个属性赋值并调用两个不同的方法。如果子类完全继承了父类的全部属性和方法，那么父类中首字母小写的也可以正确地被表示出来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> vipa VIPAccount</span><br><span class="line">    vipa.Account.Name = <span class="string">"DENG"</span></span><br><span class="line">    vipa.Account.balance = <span class="number">10000</span></span><br><span class="line">    vipa.Account.withdraw(<span class="number">500</span>)</span><br><span class="line">    vipa.Account.Query()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们在主函数中声明了一个VIP账户，并为该账户的用户名和初始余额赋值，接下来我们通过私有方法withdraw模拟取出一些余额，最后在通过公有方法输出剩余的余额值。程序的输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">余额为： <span class="number">9500</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述结果可知，通过子类对象是可以调用父类的属性和方法，且不论父类的属性方法是公有的还是私有的，全部可以被继承下来。这个点上是与传统面向对象语言完全不同的。不过即便是子类继承了父类的所有属性和方法，但是继承得到的作用域还是不变的。即父类中withdraw是私有的，不可以在其他包中使用，那么子类中的withdraw也是私有的，同样不可以在其他的包中使用。</p><h4 id="3-子类中调用属性和方法可以简化"><a href="#3-子类中调用属性和方法可以简化" class="headerlink" title="3. 子类中调用属性和方法可以简化"></a>3. 子类中调用属性和方法可以简化</h4><p>&emsp;&emsp;在上个小节的快速入门和这个小节的前面一部分中，我们都是通过子类对象.匿名结构体.属性/方法的方式来完成调用的，这种调用方式是可以在任何情况下都适用的。不过在一些情况下，为了简便操作，我们可以将匿名结构体所省略。可以理解为：子类中继承了父类的所有属性，因此子类相当于有了同样的属性，所以，我们可以直接通过子类对象.属性/方法的方式来调用。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> vipa VIPAccount</span><br><span class="line">    vipa.Account.Name = <span class="string">"DENG"</span></span><br><span class="line">    vipa.Account.balance = <span class="number">10000</span></span><br><span class="line">    vipa.Account.withdraw(<span class="number">500</span>)</span><br><span class="line">    vipa.Account.Query()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的代码中我们使用的方式就是原始的方式，我们可以对上述代码修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> vipa VIPAccount</span><br><span class="line">    vipa.Name = <span class="string">"DENG"</span></span><br><span class="line">    vipa.balance = <span class="number">10000</span></span><br><span class="line">    vipa.withdraw(<span class="number">500</span>)</span><br><span class="line">    vipa.Query()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是这种简化方式并不是任何时候都通用的，当出现属性或者方法名冲突的时候，就需要明确指定具体的属性或方法了。</p><h4 id="4-当子类和匿名结构体有同样的属性或字段时就近原则"><a href="#4-当子类和匿名结构体有同样的属性或字段时就近原则" class="headerlink" title="4. 当子类和匿名结构体有同样的属性或字段时就近原则"></a>4. 当子类和匿名结构体有同样的属性或字段时就近原则</h4><p>&emsp;&emsp;在一些情况下，子类中的属性和父类中的属性可能会相互冲突，例如马车既继承与马，又继承与车，而马和车都可以移动，这样马车在继承了两个父类的情况下，它的移动行为的继承就是相互冲突的。我们通过例子来说明这个问题。首先我们假设如下两个类：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述代码中我们可以看出，我们首先声明了一个Person类，且Person类中包含Name和Age属性。接下来我们又定义了Child类，Child类不仅继承了Person类，还又定义了一个Name属性。此时在Child类中就具备了两个Name属性，我们依旧在main函数中进行声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Child</span><br><span class="line">    c.Name = <span class="string">"DENG"</span></span><br><span class="line">    c.Person.Name = <span class="string">"YANG"</span></span><br><span class="line">    fmt.Println(c.Name)</span><br><span class="line">    fmt.Println(c.Person.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DENG</span><br><span class="line">YANG</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们分别采用子类对象.属性和子类对象.匿名结构体.属性进行了赋值和输出，通过运行结果可以发现，这两种不同的赋值方法所得到的结果是不同的。当父类和子类都有同名的属性时，且当直接子类对象.属性时，访问的是子类的属性。我们再举一个例子，假设A类中有Name属性，B类继承于A类，且B类中自己又定义一个Name属性，再之后C类继承于B类。假如主函数中C类有一个实例c，此时c.Name访问的是B类中的Name属性，c.B.A.Name才是A类中的Name属性。 </p><p>&emsp;&emsp;换句话说，当我们简化调用时，会根据继承树逐级向上找，直到找到距离调用点最近的属性为止，如果找遍了继承树都没有找到对应的属性，就会报错。此外，方法的冲突也是同一个道理。</p><h4 id="5-多重继承导致的属性-方法冲突，必须要明确匿名结构体"><a href="#5-多重继承导致的属性-方法冲突，必须要明确匿名结构体" class="headerlink" title="5. 多重继承导致的属性/方法冲突，必须要明确匿名结构体"></a>5. 多重继承导致的属性/方法冲突，必须要明确匿名结构体</h4><p>&emsp;&emsp;在第四个小点中，我们讲解的情况是子类中新定义了父类中存在的属性或方法，在这个小点中，我们将讲解子类继承了多个父类，且多个父类中存在相同的属性。当直接使用子类对象访问属性时，会根据继承树找到最近的属性，然而当两个父类中的属性同样近的时候，则必须需要指明，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">struct</span> &#123;</span><br><span class="line">    A</span><br><span class="line">    B</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c C</span><br><span class="line">    c.Name = <span class="string">"DENG"</span></span><br><span class="line">    fmt.Println(c.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们可以发现，A类和B类中都具备Name属性，且C继承了A和B两个类，此时我们通过c.Name来访问属性则会出现模糊的问题。因为C类中没有Name属性，因此需要根据继承树向上查找，且找到了A类和B类均有Name属性，此时错误结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ambiguous selector c.Name</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们在代码中所写的c.Name编译器并不能确定具体是哪个父类的属性，因此就会报错。此时我们再访问属性的时候，就需要指明具体哪个父类的匿名结构体中的属性了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c C</span><br><span class="line">    c.A.Name = <span class="string">"DENG"</span></span><br><span class="line">    fmt.Println(c.A.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们通过代码和概念更为深入地讲解了Go语言中继承技术的细节点，并讲解了在属性访问过程中的几个原则。Go语言中具备多继承的理念即一个子类继承多个父类，但在日常开发中这个理念并不提倡，因为在多继承的过程中十分容易出现属性或方法名的冲突，使得开发者不得不需要指定对应的父类匿名结构体来调用。这个过程相对而言不是很方便。最后我们在小节中出一道简单的测试，来证明是否完全理解了本节的知识点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span> <span class="title">sayName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(a.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    A</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">sayName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b.A.Name = <span class="string">"GUO"</span></span><br><span class="line">    fmt.Println(b.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b B</span><br><span class="line">    b.Name = <span class="string">"DENG"</span></span><br><span class="line">    b.A.Name = <span class="string">"YANG"</span></span><br><span class="line">    b.A.sayName()</span><br><span class="line">    b.sayName()</span><br><span class="line">    b.A.sayName()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序的最终输出结果是什么？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-42-gt-面向对象-继承细节讨论&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-42-gt-面向对象-继承细节讨论&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;42&amp;gt; 面向对
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;41&gt; 面向对象-继承</title>
    <link href="http://yoursite.com/2020/03/15/41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2020/03/15/41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/</id>
    <published>2020-03-15T12:06:23.000Z</published>
    <updated>2020-03-15T12:06:53.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-41-gt-面向对象-继承"><a href="#Go语言从入门到放弃系列-lt-41-gt-面向对象-继承" class="headerlink" title="Go语言从入门到放弃系列&lt;41&gt; 面向对象-继承"></a>Go语言从入门到放弃系列&lt;41&gt; 面向对象-继承</h2><p>&emsp;&emsp;在上个小节中，我们讲解了面向对象特征其中的一个-封装的概念，封装是贯穿面向对象的一个思想而不是某些技术点，因此需要在日常开发中自行学习和加强。在这个小节中，我们将开始介绍Go语言中面向对象中的另一个特性-继承。Go语言对于继承有着独特的解决方式，与传统的面向对象语言的实现方式完全不同。如果有其他语言的开发经验，可能会对Go语言的继承的实现表示出费解，这是语言层面上的设计问题，开发者最好还是需要适应这种独特的方式。 </p><h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>&emsp;&emsp;在日常生活中，继承的概念随处可见，继承的关系往往涉及两个或多个个体类。例如，一个孩子的长相性格大多继承于父母，孩子也会有自己的独特的个性；在面向对象程序设计中，也经常会出现类似的问题。比如我们上一个小节提到的Account的例子，可以分为个人用户，企业用户，VIP用户等。每一个类型的用户都有其独特的特点，但是他们又同时都有存取款，查询转账等功能。因此可以说，不同类型的用户继承于Account大类。 </p><p>&emsp;&emsp;我们现在就针对这个问题举个简化的例子：假如我们需要一个普通账户和一个VIP账户，这两种账户都具备存款，查询，取款的功能。普通用户一次可以取10k，VIP用户一次可以取出50k。如果采用之前介绍的抽象等方式，我们需要建立两个结构体，分别为NormalAccount和VIPAccount。（暂时不考虑封装的问题）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NormalAccount&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> VIPAccount&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来，我们分别实现对应的方法，存钱取钱的方法为了简便暂时就不考虑密码的匹配，只是为了说明一下继承的问题。取钱的方法需要判断对应的取钱上限，以及余额是否少于需要取出的钱。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(na *NormalAccount)</span> <span class="title">QueryAccount</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(na.Balance)</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(na *NormalAccount)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    na.Balance += money</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(na *NormalAccount)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> money &gt; <span class="number">10000</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"超出上限"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> na.Balance &lt; money &#123;</span><br><span class="line">        fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    na.Balance -= money</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vipa *VIPAccount)</span> <span class="title">QueryAccount</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(vipa.Balance)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vipa *VIPAccount)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    vipa.Balance += money</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vipa *VIPAccount)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> money &gt; <span class="number">50000</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"超出上限"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> vipa.Balance &lt; money &#123;</span><br><span class="line">        fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    vipa.Balance -= money</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承实现"><a href="#继承实现" class="headerlink" title="继承实现"></a>继承实现</h3><p>&emsp;&emsp;在上述的代码实现中，虽说可以完成对应的功能，但是依旧有许多可以解决的问题。比如说，NormalAccount和VIPAccount的属性十分相似（在本例中完全相同），还有两种账户除了最高取款限额不同之外，其他的也十分类似。如果以当前的实现形式进行发展，那么企业账户，附属账户等需要再大致一模一样地再实现一遍，一旦账户中需要多加一个功能，则需要每一个账户类型都新写一个方法，这对大型程序来说十分不利。 </p><p>&emsp;&emsp;那么我们是否可以像类的构建中的抽象一般，将几个类中公有的属性再次抽象出来，形成一个父类，让所有继承于父类的子类都具备和父类一样的属性和方法，同时在子类中可以随意覆盖父类中的方法。基于这样一个思想，我们将继承的话题引入到讲解中。 </p><p>&emsp;&emsp;经过再次抽象后，我们发现在本例中每一个账户都需要姓名和账户余额，因此这两个属性可以被提取出来成为父类所共有的属性。同理，我们也发现每一个账户都存在取款，存款和查询功能。在取款过程中，我们可以通过传入一个参数来规定取款的最高限额，因此这三个方法都可以被写入到父类中。此时，父类Account可以被归纳如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">QueryAccount</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(a.Balance)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    a.Balance += money</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>, limit <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> money &gt; limit &#123;</span><br><span class="line">        fmt.Println(<span class="string">"超出上限"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> a.Balance &lt; money &#123;</span><br><span class="line">        fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    a.Balance -= money</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;建立了父类Account之后，我们就可以将两个账户类型定义出来了，由于两个账户均继承于父类Account，因此，父类中的属性以及行为可以直接被子类所拥有，此时在子类中就不需要再次定义了。对于取钱这个问题，我们可以重写父类的方法，将取款上限传入。我们首先写NormalAccount：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NormalAccount <span class="keyword">struct</span> &#123;</span><br><span class="line">    Account</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(na *NormalAccount)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    na.Account.WithdrawAccount(money, <span class="number">10000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们通过将Account父类嵌入到NormalAccount子类的方式，令子类继承了Account父类。在重写WithdrawAccount方法中，我们在子类的方法中调用了父类的方法进行了一次包装，就完成了子类的重写工作。同理对于VIPAccount类而言，做法也是类似的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> VIPAccount <span class="keyword">struct</span> &#123;</span><br><span class="line">    Account</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vipa *VIPAccount)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    vipa.Account.WithdrawAccount(money, <span class="number">50000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时，两个子类的代码就都编写完成了。接下来，我们讲解一下如何在函数中使用上述两个子类。在主函数中，我们将分别实例化两个子类，为之赋值，并调用三个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> na NormalAccount = NormalAccount&#123;Account&#123;<span class="string">"DENG"</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">var</span> vipa VIPAccount</span><br><span class="line">    vipa.Account.Name = <span class="string">"YANG"</span></span><br><span class="line">    vipa.Account.Balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    na.SaveAccount(<span class="number">1000</span>)</span><br><span class="line">    na.WithdrawAccount(<span class="number">300</span>)</span><br><span class="line">    na.QueryAccount()</span><br><span class="line"></span><br><span class="line">    vipa.SaveAccount(<span class="number">50000</span>)</span><br><span class="line">    vipa.WithdrawAccount(<span class="number">100000</span>)</span><br><span class="line">    vipa.QueryAccount()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在主函数中，我们通过初始化直接赋值的方式实例化了NormalAccount，也通过先创建后赋值的方式实例化了VIPAccount，接下来我们用两个对象分别进行继承得到的方法，并进行输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">700</span></span><br><span class="line">超出上限</span><br><span class="line"><span class="number">50000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;得到了上述的结果，与预期的结果相同，也进而说明了我们的代码实现是没有问题的，继承的结果也是正确的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们通过一个案例引出了继承的概念，并通过代码的方式进行了快速入门。在案例中，我们可以发现，在Go语言中的面向对象继承，是通过嵌入匿名结构体的方式完成的。且作为父类的匿名结构体中的属性和方法均被子类所继承到，子类拥有了方法继承后可以通过子类的实例调用对应的方法。 </p><p>&emsp;&emsp;在传统面向对象继承中，往往是通过extends关键字的方式完成的，在Go语言中并没有这个关键字。Go语言中类的组合与继承的关系也不如传统面向对象语言那般分明，因此我们需要适应这种独特的继承方式。在下个小节中，我们将针对继承中的一些细节，例如访问修饰，属性冲突，多重继承等细节进行详细地介绍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-41-gt-面向对象-继承&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-41-gt-面向对象-继承&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;41&amp;gt; 面向对象-继承&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;40&gt; 面向对象-封装</title>
    <link href="http://yoursite.com/2020/03/14/40-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/"/>
    <id>http://yoursite.com/2020/03/14/40-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/</id>
    <published>2020-03-14T15:15:50.000Z</published>
    <updated>2020-03-14T15:17:27.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-40-gt-面向对象-封装"><a href="#Go语言从入门到放弃系列-lt-40-gt-面向对象-封装" class="headerlink" title="Go语言从入门到放弃系列&lt;40&gt; 面向对象-封装"></a>Go语言从入门到放弃系列&lt;40&gt; 面向对象-封装</h2><p>&emsp;&emsp;在面向对象部分的介绍中，我们自始至终地都在强化一种思想，即是抽象的思想。我们在定义一个结构体(类)的时候，实际上就是将一类事物所共有的属性和行为提取出来，建立一个物理模型，就成为了一个类。在这其中,             共有的属性以字段的形式存在，行为以方法的形式存在。这个提取的过程就是抽象的思想，因此我们所说的抽象并不涉及技术上的实现，而是贯穿整个面向对象的一种解决问题的方法。 </p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>&emsp;&emsp;作为面向对象的特性之一，封装的概念在Go语言中也有所体现。封装就是将抽象出来的字段和对字段的操作封装在一起，将数据在内部保护起来，其他的程序只可以通过放出的方法接口来对属性字段进行操作。就如同我们在讲解工厂模式的时候举的例子：学生的年龄只可以读取而不可以在其他包中修改。我们说在这个例子中，我们将年龄这个属性与读取的方法封装在了一起。 </p><p>&emsp;&emsp;通过封装的概念，使得程序员在基于他人的代码进行二次开发过程中不需要完全了解其代码实现，只需要了解一个方法应当如何输入，其返回值是什么，对于程序中其他的属性是否存在关联的变动。而这三个方面往往都会在用户的开发文档中或代码注释中标明。 </p><p>&emsp;&emsp;举一个很典型的例子：我们普通用户并不需要知道电视机的成像原理，不需要知道其内部的集成电路是如何工作的，也不需要知道红外线控制器的协议过程。我们只需要知道对于一个电视机，哪些按键是开关，哪些按键控制频道，哪些按键控制音量。而一旦电视机出现问题，我们只需要联系维修人员即可。同理，对于其他人的代码，我们只需要知道输入格式，输出格式，而代码中出现bug，则需要联系开发人员，或通过其他途径完成自己的开发需求。</p><h3 id="案例讲解"><a href="#案例讲解" class="headerlink" title="案例讲解"></a>案例讲解</h3><p>&emsp;&emsp;假设一个银行在写管理系统，并且我们负责系统中个人账户的部分，要求用户可以查询余额，存钱取钱，且单次取钱额度不超过10k，以及用户之间互相转账的功能，单次转账也不超过50k。我们通过这个小案例进行封装的入门。当然真实的开发操作要比这个复杂地多得多，而且还需要进行加锁操作，数据库操作等等，我们在这里只是针对这个案例进行一个简单的分析和实现而已，只是介绍一下封装的使用方式，对于实现方式就当做一个代码篇来看吧。 </p><h3 id="1-属性行为分析"><a href="#1-属性行为分析" class="headerlink" title="1. 属性行为分析"></a>1. 属性行为分析</h3><p>&emsp;&emsp;在代码编写之前，我们往往需要首先分析一下一个类的构成。在这个案例中，我们可以清楚地知道：转账过程需要对方的用户名和本人的密码，查询余额和存钱取钱需要余额的显示，其他的暂时先不需要了。因此我们可以将在Account类中包含三个属性，分别为用户名，密码，和余额。 </p><p>&emsp;&emsp;接下来，我们继续分析这个类的行为。根据需求描述，我们可以知道需求中存在着如下的几个行为：查询，存储，取出，转账这四个行为，且这四个行为均是账户管理中的行为。因此对于类的设计中我们可以采用如下的类定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">    UserName <span class="keyword">string</span></span><br><span class="line">    Password <span class="keyword">string</span></span><br><span class="line">    Balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">QueryAccount</span><span class="params">(password <span class="keyword">string</span>)</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">Transfer</span><span class="params">(to *Account, money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="2-权限控制修改"><a href="#2-权限控制修改" class="headerlink" title="2. 权限控制修改"></a>2. 权限控制修改</h4><p>&emsp;&emsp;在对工厂模式的讲解中，我们介绍到了私有类的访问方式，以及私有属性的访问方式。在大多数情况下，我们将类名以及属性名的首字母小写，使之成为私有，可见性只针对于本包。此时我们需要为之添加一个公有类型的工厂函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> account <span class="keyword">struct</span> &#123;</span><br><span class="line">    userName <span class="keyword">string</span></span><br><span class="line">    password <span class="keyword">string</span></span><br><span class="line">    balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAccount</span><span class="params">(userName <span class="keyword">string</span>, password <span class="keyword">string</span>)</span> *<span class="title">account</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;account&#123;</span><br><span class="line">        userName: userName,</span><br><span class="line">        password: password,</span><br><span class="line">        balance: <span class="number">0.0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述程序中，我们添加了NewAccount函数，且需要两个入参分别为用户名和密码，在函数中为本类中的userName和password赋值，同时我们设定balance的初始值为0。</p><h4 id="3-方法的实现"><a href="#3-方法的实现" class="headerlink" title="3. 方法的实现"></a>3. 方法的实现</h4><p>&emsp;&emsp;我们首先完成余额查询的功能。在这个功能中我们需要首先判断输入的密码是否与account中的密码相匹配，如果匹配则输出对应的balance属性的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *account)</span> <span class="title">QueryAccount</span><span class="params">(password <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> password == a.password &#123;</span><br><span class="line">        fmt.Println(a.balance)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"密码错误！"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们完成存款的实现，首先依旧是判断输入密码是否与account中密码相同，如果相同则将balance加上对应的金额：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *account)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> password == a.password &#123;</span><br><span class="line">        a.balance += money</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"密码错误！"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来是取钱的操作，它与存钱的区别便是一次性取钱不能超过10k，且余额不能小于0。 在密码得以匹配和上述条件均满足的情况下，balance的值减少对应的money金额：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *account)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> password == a.password &#123;</span><br><span class="line">        <span class="keyword">if</span> money &gt;= <span class="number">10000</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"超出额度"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> money &gt; a.balance &#123;</span><br><span class="line">            fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        a.balance -= money</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"密码错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后是转账操作的实现，一次转账操作可以相当于两个行为：一方的取出操作和另一方的存入操作。取出操作依旧遵循上述的判断过程，存入操作不需要什么其他的限制：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *account)</span> <span class="title">Transfer</span><span class="params">(to *account, money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> password == a.password &#123;</span><br><span class="line">        <span class="keyword">if</span> money &gt;= <span class="number">50000</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"超出额度"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> money &gt; a.balance &#123;</span><br><span class="line">            fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        a.balance -= money</span><br><span class="line">        to.balance += money</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"密码错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> acc1 = test.NewAccount(<span class="string">"DENG"</span>, <span class="string">"123456"</span>)</span><br><span class="line">    <span class="keyword">var</span> acc2 = test.NewAccount(<span class="string">"YANG"</span>, <span class="string">"654321"</span>)</span><br><span class="line">    acc1.SaveAccount(<span class="number">5000</span>, <span class="string">"123456"</span>)</span><br><span class="line">    acc1.WithdrawAccount(<span class="number">2000</span>, <span class="string">"123456"</span>)</span><br><span class="line">    acc1.Transfer(acc2, <span class="number">1000</span>, <span class="string">"123456"</span>)</span><br><span class="line">    acc1.QueryAccount(<span class="string">"123456"</span>)</span><br><span class="line">    acc2.QueryAccount(<span class="string">"654321"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最终我们在demo文件下的main包中进行功能的测试，我们只写了简单的几个过程，并没有将所有的功能全部都测试完全，代码也只是作为demo说明而已。其结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2000</span></span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这两个数值的输出也一定程度上证实了主要功能的正确，对于其他的错误的输出没有做任何的测试。</p><h3 id="封装规则"><a href="#封装规则" class="headerlink" title="封装规则"></a>封装规则</h3><p>&emsp;&emsp;在Go语言的开发过程中，其实并没有特别强调封装的概念。Go语言说起来并没有对面向过程或面向对象有着明显的倾向性，它对于面向对象的实现也有着自己一套的灵活的实现方式。它与Java语言，C/C++语言不同，不能以传统的面向对象的语法特性看待Go语言。Go语言本身而言对面向对象的概念是做了一定的简化的。 </p><p>&emsp;&emsp;相较于传统面向对象的开发习惯，Go语言的封装规则可以总结为一下的几个步骤： </p><p>&emsp;&emsp;1. 将结构体和属性字段的首字母小写，将其变为私有属性，在其他包中不可导出，类似于传统面向对象中的private属性。 </p><p>&emsp;&emsp;2. 为结构体所在包提供一个工厂函数，函数的首字母大写，该函数可以在其他包中被调用，导出结构体实例指针。 </p><p>&emsp;&emsp;3. 为私有属性提供首字母大写的SetXXX方法，在该方法中对属性进行判断与赋值。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *XXX)</span> <span class="title">SetYYY</span> <span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line">    ...  <span class="comment">//数据验证等操作</span></span><br><span class="line">    x.YYY = 参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;4. 为私有属性提供首字母大学的GetXXX方法，在该方法中返回该属性的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *XXX)</span> <span class="title">GetYYY</span> <span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.YYY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们讲解了Go语言中面向对象概念中的封装，并通过一个案例讲解了封装思路。可以说，封装是一种思想而不是一种技术，因此开发人员需要在日常开发中多多积累相应经验。由于它是思想，因此不同的人对这个思想的理解倾向性不同，因此很难辨明孰是孰非。针对于同一个需求，开发的思路也不同。笔者开发经验也不多，在一些问题上考虑地也并不完善，说的不到的地方希望见谅。 </p><p>&emsp;&emsp;在下一个小节中，我们将开始讲解面向对象特性中的另一个概念，继承。继承与封装不太相似，继承是一个技术点，因此具备一定的语法规则，我们会在下几节中详细地说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-40-gt-面向对象-封装&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-40-gt-面向对象-封装&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;40&amp;gt; 面向对象-封装&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;39&gt; 面向对象-方法细节与工厂模式</title>
    <link href="http://yoursite.com/2020/03/13/39-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/13/39-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-03-13T11:02:37.000Z</published>
    <updated>2020-03-13T11:05:05.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-39-gt-面向对象-方法细节与工厂模式"><a href="#Go语言从入门到放弃系列-lt-39-gt-面向对象-方法细节与工厂模式" class="headerlink" title="Go语言从入门到放弃系列&lt;39&gt; 面向对象-方法细节与工厂模式"></a>Go语言从入门到放弃系列&lt;39&gt; 面向对象-方法细节与工厂模式</h2><p>&emsp;&emsp;在上一个小节中，我们简单讲解了Go语言面向对象部分中的方法的概念，同时我们也通过简单的案例进行了快速入门的讲解。方法不论在定义上与使用上都与函数十分的类似，包括方法的传参机制也与函数如出一辙。除此之外，我们也对其他的自定义数据类型的方法做出了一定的讲解，并说明了Go语言中String方法的作用。 </p><p>&emsp;&emsp;在这个小节中，我们依旧对Go语言的方法进行讲解，主要说明方法在使用过程中的一些注意事项，以及Go语言中的工厂模式。</p><h3 id="方法的细节与注意事项"><a href="#方法的细节与注意事项" class="headerlink" title="方法的细节与注意事项"></a>方法的细节与注意事项</h3><h4 id="1-Go语言中的方法不支持重载"><a href="#1-Go语言中的方法不支持重载" class="headerlink" title="1. Go语言中的方法不支持重载"></a>1. Go语言中的方法不支持重载</h4><p>&emsp;&emsp;在传统面向对象语言中，方法是可以被重载的，即多个方法函数名相同，返回值相同，但是函数参数不同。例如，当初始化一个学生类的时候需要调用initStudent方法，且我们可以传入学生的姓名与学号。当用户只传入学号时则只初始化学号，当用户只传入姓名时则只初始化姓名，如果两个都输入则全部初始化。 </p><p>&emsp;&emsp;由于方法中定义的参数类型不同，参数个数不同，传统面向对象语言可以根据这两个特点寻找到用户需要调用哪一个初始化方法，并能够成功地完成操作。然而这个特性在Go语言中并不存在，一旦两个方法或函数的名字相同的时候，在编译过程中就会报错，且报错的内容为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method redeclared: xxx</span><br></pre></td></tr></table></figure><h4 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h4><p>&emsp;&emsp;当初在介绍到包的概念的时候我们提及过作用域的一些问题，在Go语言中存在两种作用域分别为共有的和私有的。当变量的首字母大写的时候是可以在其他包中访问到该变量的，当变量首字母是小写的时候则无法在其他包中访问。函数与方法也遵循这个原则：当函数名或方法名首字母大写的时候才可以在其他包中调用函数或方法，方法名首字母小写则只能在本包中使用，具体便不再举例了。</p><h4 id="3-接收者的类型"><a href="#3-接收者的类型" class="headerlink" title="3. 接收者的类型"></a>3. 接收者的类型</h4><p>&emsp;&emsp;接收者即指明的从属类，我们在之前的案例中都使用的是类的对象，也可以某种程度上理解为传入的一个参数为一个对象。由于struct是值传递，因此传入对象之后在方法中无法改变对象中的值，这个特性对于熟悉面向对象编程的开发者来说十分不友好，因此接收者不仅可以是类的对象，也可以是一个指针，我们举两个例子进行对比：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s stu)</span> <span class="title">setName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    s.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> student stu = stu&#123;<span class="string">"DENG"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    student.setName(<span class="string">"YANG"</span>)</span><br><span class="line">    fmt.Println(student.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在第一个例子中，我们在方法的接收者部分使用的是struct变量，且在setName方法中我们将stu中对应的name属性赋值。在main函数中我们首先为student的name赋值为”DENG”，然后通过setName方法进行修改，最后再进行输出。由于结构体的值类型的属性，传入到setName方法中的student是另一段内存，调用过后就释放了，因此输出结果为：DENG </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stu)</span> <span class="title">setName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    s.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> student stu = stu&#123;<span class="string">"DENG"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    student.setName(<span class="string">"YANG"</span>)</span><br><span class="line">    fmt.Println(student.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个例子中，我们将方法的接收者改为一个stu指针，这样传入的就是一个student的引用，方法中的name修改直接影响到调用者的属性，因此此时的输出为：YANG </p><p>&emsp;&emsp;值得最后一次一提的是：我们只将stu改为了*stu，而其他的部分均没有发生变化，因此在上述的程序中我们使用了非常多的编译优化的特性，且这种特性对Java等开发者十分友好。如果读者已经完全明白引用与值的关系，在以后的编程过程中可以活用这个编译特性，本人在这里以及以后也对读者不做任何的限制了。</p><h4 id="4-编译器优化指针"><a href="#4-编译器优化指针" class="headerlink" title="4. 编译器优化指针"></a>4. 编译器优化指针</h4><p>&emsp;&emsp;在之前的介绍中，我们提到了Go语言的编译器对指针类型与数值类型的使用进行了优化，即根据函数参数的类型自动判断其应当传入的指针或数值类型。这种编译器优化只针对于方法，而不针对于函数。假如在函数的使用过程中出现了不匹配的情况，在编译过程中将直接报出错误。 </p><p>&emsp;&emsp;首先我们举一个函数的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showName</span><span class="params">(stu *student)</span></span> &#123;</span><br><span class="line">    fmt.Println(stu.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu student = student&#123;</span><br><span class="line">        name: <span class="string">"DENG"</span>,</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//showName(stu)  //cannot use stu (type student) as type *student in argument to showName</span></span><br><span class="line">    showName(&amp;stu)  <span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们首先定义了一个结构体，然后又定义了一个showName的函数，由于它并没有绑定对象，因此它只是一个函数而非方法。最后在主函数中我们实例化一个结构体，并分别通过结构体对象和结构体对象指针进行showName的调用。由于在showName函数定义中，我们采用了student指针作为入参。因此在通过对象实例进行传参的时候出现了参数不匹配的情况。而采用实例指针进行传参的时候，程序可以正确执行并输出相应的结果。 </p><p>&emsp;&emsp;因此对于普通函数来说，<strong>编译器并没有对普通函数参数检查进行指针优化</strong>。 </p><p>&emsp;&emsp;接下来，我们将showName函数改为student类的一个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span> <span class="title">showName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(s.name)    <span class="comment">//正确</span></span><br><span class="line">    fmt.Println((*s).name)  <span class="comment">//正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu student = student&#123;</span><br><span class="line">        name: <span class="string">"DENG"</span>,</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    (&amp;stu).showName()  <span class="comment">//正确</span></span><br><span class="line">    stu.showName()    <span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，我们将showName方法绑定到student类上，并在主函数中通过stu对象调用了showName方法。在主函数中，我们实例化了student类成为一个对象，并分别通过对象的方式和对象指针的方式调用了方法。同时，在方法中，我们通过传入的指针参数调用了s对象指针的name属性。在运行结果中，都可以正确地完成姓名的输出。 </p><p>&emsp;&emsp;因此，对于方法而言，<strong>编译器对方法进行了指针的优化</strong>。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>&emsp;&emsp;在这个部分中，我们将对Go语言中的工厂模式进行阐述，这种代码模式在日常开发中还是十分常见的。而且在多人代码合作中，这个模式用到地就更为常见了。 </p><h4 id="1-工厂模式引入"><a href="#1-工厂模式引入" class="headerlink" title="1. 工厂模式引入"></a>1. 工厂模式引入</h4><p>&emsp;&emsp;在之前的讲解中，我们提到标识符首字母的大小写是控制其可见性的一个标准。当标识符首字母大写的时候，我们可以通过其他包访问到这个变量或函数。如果标识符首字母小写的话，我们只可以在本包中访问对应的变量。然而在程序开发过程中，将所有的属性、方法都设定为共有是及其不可取的做法，这样做意味着其他的开发者可以在其他包中任意修改本包的数据。而将属性方法设定为私有的话，其他开发者又完全没有办法读取本包数据。因此，我们采用工厂模式来完成对应的优化。 </p><p>&emsp;&emsp;我们依旧采用demo包和test包举例，在test包中存在一个student的类，在demo包中完成对student对象属性的调用。首先我们假设Student类中有两个属性：Name和Age：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">test.<span class="keyword">go</span>：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">package</span> test</span><br><span class="line">    <span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        Age <span class="keyword">int8</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">demo.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">package</span> main</span><br><span class="line">    <span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"test"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> stu = test.Student&#123;</span><br><span class="line">            Name: <span class="string">"DENG"</span>,</span><br><span class="line">            Age: <span class="number">18</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(stu.Name)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码实现当然是没有问题，因为Student的首字母是大写的，Student类中所有属性的首字母也都是大写的，因此Student类是完全共有的，不会出现属性访问的问题。那么假如两个包是由两个不同的人开发，且每个人都希望保护自己的代码，将Student的首字母小写成为student，那么当前的做法就会报错了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;修改过后，此时demo中会报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cannot refer to unexported name test.student</span><br><span class="line">undefined: test.student</span><br></pre></td></tr></table></figure><h4 id="2-解决方式"><a href="#2-解决方式" class="headerlink" title="2. 解决方式"></a>2. 解决方式</h4><p>&emsp;&emsp;既然类已经被限定在本包中使用而其他包无法创建，那么就让该类的实例化过程出现在该类对应的包中：在一个公有的函数中完成类的实例化，并将该对象通过指针的形式返回出去。这个公有的函数可以具备一些形式参数来完成对象的初始化，类似于构造函数。基于上述的案例，我们将test包中的代码修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">student</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">        Name: name,</span><br><span class="line">        Age: age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们在test包中通过NewStudent函数做了student类的实例化操作，并将该对象的指针通过返回值返回给调用者，由于NewStudent函数是公有的，因此其他包可以通过这个函数来完成实例化操作。对应的demo包中代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"test"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu = test.NewStudent(<span class="string">"DENG"</span>, <span class="number">18</span>)</span><br><span class="line">    fmt.Println(stu.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-属性权限控制"><a href="#3-属性权限控制" class="headerlink" title="3. 属性权限控制"></a>3. 属性权限控制</h4><p>&emsp;&emsp;完成了私有类的实例化操作后，对象中属性也可能会出现私有的现象。例如：希望student类中的Age属性只可以在其他包中读取，但是不可以在其他包中修改。完成这个操作的思路其实和类的实例化非常相似，唯一的区别是属性的权限控制可以通过方法来完成。我们直接通过代码说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">student</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">        Name: name,</span><br><span class="line">        age: age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span> <span class="title">GetAge</span><span class="params">()</span> <span class="title">int8</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们修改了age的访问权限（首字母变为小写），这样在其他的包中就无法访问了，同时我们又添加了一个公有的方法GetAge，在这个方法中访问age属性。由于其他包中可以通过NewStudent函数得到对象，又可以通过对象得到属性，因此这种实现方式相当于间接访问到了age属性，但不可以修改它。 </p><p>&emsp;&emsp;此时demo.go中代码变为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main    </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"test"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu = test.NewStudent(<span class="string">"DENG"</span>, <span class="number">18</span>)</span><br><span class="line">    <span class="comment">//stu.age = 20  //stu.age undefined (cannot refer to unexported field or method age)</span></span><br><span class="line">    fmt.Println(stu.GetAge())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p> &emsp;&emsp;在这个小节中，我们继续讲解了Go语言中方法的概念以及注意事项，同时我们也针对Go语言中工厂模式进行了讲解，解决了私有属性的访问权限控制以及类的实例化的函数。在下几个小节中，我们将针对面向对象中的抽象和封装两个概念进行讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-39-gt-面向对象-方法细节与工厂模式&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-39-gt-面向对象-方法细节与工厂模式&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;39&amp;g
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;38&gt; 面向对象-方法</title>
    <link href="http://yoursite.com/2020/03/12/38-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/12/38-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95/</id>
    <published>2020-03-12T15:16:11.000Z</published>
    <updated>2020-03-12T15:16:41.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-38-gt-面向对象-方法"><a href="#Go语言从入门到放弃系列-lt-38-gt-面向对象-方法" class="headerlink" title="Go语言从入门到放弃系列&lt;38&gt; 面向对象-方法"></a>Go语言从入门到放弃系列&lt;38&gt; 面向对象-方法</h2><p>&emsp;&emsp;在上两个小节中，我们讲解了Go语言中面向对象部分的结构体的概念及使用。在结构体中，我们涉及到的最多的都是各种属性，例如一个人的类的结构体中会具备眼睛、鼻子、耳朵、嘴等属性，但是这些属性相对于面向对象而言更为”静态”。即它只说明了一个结构体中、一个类中具备什么样的性质，而没有指明这个类对应的实例能够做什么，例如一个人可以行走、可以观察等，这些相对”动态”的行为是由面向对象中的方法完成的。 </p><h3 id="方法快速入门"><a href="#方法快速入门" class="headerlink" title="方法快速入门"></a>方法快速入门</h3><p>&emsp;&emsp;在Go语言的面向对象体系中，有一个和函数十分类似的概念，我们称之为方法。在一些完全面向对象的计算机语言中，函数和方法是通用的，函数主要是指面向过程中的程序单元，方法主要是指面向对象中的类行为。可以说函数的说法是先于方法的，面向对象语言的发展是基于面向过程的，因此对于Java、PHP等语言来说函数和方法是等价的，而对于C++、Go等既包含面向过程部分也包含面向对象部分的语言来说，函数和方法是两个十分相似但是本质不同的概念。 </p><p>&emsp;&emsp;我们在方法的引出过程中也提及到了：方法(method)是针对于某一个类甚至是某几个类而言的，不同的类方法是可以不相同的，例如对于人类来说，我们可以具备使用工具、计算、行走等行为，但是对于鸟类来说他们具备飞行等行为，同理在Go语言中，每一个方法的出现往往会指定某一个类型作为”接收者”，即在某种情况下这个方式仅仅隶属于某一个类。在这里我们依旧沿用上一节中举的例子：学生类</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int</span></span><br><span class="line">    friends []stu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个类中，我们仅仅指明了一个学生结构体中具备姓名、年龄、以及朋友三个属性，而对于学生类的实例具体能做什么没有任何的说明。接下来我们假设一个学生实例可以完成计算两个数的加和的行为，此时根据上述的分析，方法在定义中需要指明某一个行为属于某一个类，那么此时计算的行为可以如下表示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s stu)</span> <span class="title">calculate</span><span class="params">(n1, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的程序段就可以称为一个方法，我们可以发现方法和函数不仅在概念上十分的相似，在定义方式上也是十分的相像。既然方法也是为了完成某一个目的而进行了抽象，那么方法的定义中也可以存在参数或者返回值，它与函数的唯一区别就是它需要指明这个方法归属于哪个类，在上述的方法定义中指明了归属于stu。 </p><p>&emsp;&emsp;在一些面向对象语言中，方法的定义是在class类中，和属性的定义相平行，这样的做法使方法得以访问到类中所定义的属性。在Go语言中，方法的实现是不相同的，它的方法是定义在struct结构体之外的，通过字段的指定来确定方法的归属。因此方法的调用是需要通过对应的类的实例来完成的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> student stu = stu&#123;&#125;</span><br><span class="line">    fmt.Println(student.calculate(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先通过学生类实例化一个对象，然后通过这个student对象来完成计算方法的调用。一个类具备某种行为，由该类实例化得到的个体对象当然也具备该方法的使用能力，因此此时可以通过”.”来完成从属关系的调用。</p><h3 id="方法的”传参”机制"><a href="#方法的”传参”机制" class="headerlink" title="方法的”传参”机制"></a>方法的”传参”机制</h3><p>&emsp;&emsp;在这个小部分中，我们所说的传参可以分为两部分来理解，一部分是方法的参数中的真的参数，另一部分则是方法归属类的抽象实例。方法的参数与函数的参数是相同的，即传入的数据类型是值类型的时候是在内存中复制一份原有数据再传入，传入的数据与原数据没有关系；当传入的数据类型为引用类型或指针时，则复制一份指向的地址传入，函数、方法中对数据的修改会影响到原数据。这个似乎不难理解，我们在函数的讲解中已经十分详细地介绍过了。 </p><p>&emsp;&emsp;现在我们回到Go语言对于面向对象特性的实现方式上，其他语言可以在方法中调用到类中的属性，那么在Go语言中这个特性也应该可以完成。由于方法的定义中已然指明了它所归属的类，所以此时<strong>假如</strong>我们再传入一个该类所对应的实例（对象），通过该对象来访问实例中的属性数据就可以了。在Go语言中也确实就是如此设计的，方法在指明对应类的同时直接传入一个抽象的实例，传入的方式和函数的传参一致，而又由于结构体本身是值类型，因此对应的抽象实例也就是和值传递相同。 </p><p>&emsp;&emsp;我们换一种理解方式：假如在一个函数中需要传入一个对象，在函数中输出对象所对应的一个属性，我们可能会采用如下的方式来完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span> <span class="params">(student stu)</span></span>&#123;</span><br><span class="line">    fmt.Println(student.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时的student对象是作为函数参数传入的，且传入的方式为值传递，我们通过该对象完成了name属性值的输出。那么对于方法而言，已然指出的类的归属，那么就可以如下来完成了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(student stu)</span> <span class="title">method</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(student.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个方法的定义中，student依然是值传递的方式传入的，从某种程度上讲，上述两种不同的函数与方法的实现方式，在理解过程中可以认为是相同的，即类的从属的指定作为方法的另一个参数。</p><h3 id="自定义类型的方法"><a href="#自定义类型的方法" class="headerlink" title="自定义类型的方法"></a>自定义类型的方法</h3><p>&emsp;&emsp;在Go语言中可以说通过type关键字所修饰的都是自定义数据类型，包括结构体的声明也可以被归结为自定义数据类型，因为不同的属性名、属性的数据类型、属性的个数所确定的结构体类型是完全不同的。既然Go语言中方法是作用于指定的数据类型上，那么只要是自定义类型，就都可以有方法，我们举一个例子： </p><p>&emsp;&emsp;现在我们的需求是为一个整数（int）添加一个方法，如果这个整数是奇数则返回false，是偶数则返回true。在此之前我们在程序中需要整数时直接定义一个int类型的变量，也不曾听说过整数类的概念，此时添加方法的途径就是将其变为一个自定义的数据类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Integer)</span> <span class="title">isEven</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num Integer = <span class="number">10</span></span><br><span class="line">    fmt.Println(num.isEven())</span><br><span class="line">    num++</span><br><span class="line">    fmt.Println(num.isEven())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如同声明结构体数据类型一般，我们通过type的方式将一个int类型自定义为Integer，此处的Integer数据类型就可以添加方法了，不仅如此，我们在main函数中将Integer变量进行自加操作，程序依旧可以完成对应的加法。由此可见：通过type的方式可以借助一些内置数据类型来自定义一些类型，这些类型可以添加方法，同时也同样具备数据本身的属性，如数学运算等。 </p><p>&emsp;&emsp;需要注意的一点是：我们通过type的方式为int类型自定义了一个Integer类型，如果在程序中有两个变量分别由int和Integer类型所定义，这两个变量的数据类型是不同的，在相互转化的时候需要进行强制转化。因此通过int定义的变量，是不具备isEven方法的，但是将其强转成Integer类型时就可以使用该方法了。</p><h3 id="String-方法"><a href="#String-方法" class="headerlink" title="String()方法"></a>String()方法</h3><p>&emsp;&emsp;在Go语言中我们经常通过fmt.Println()函数来完成数据向屏幕的输出，那我们可能会想了：当输出一个整数变量时编译器输出对应的值，当输出数组时编译器将数组中所有值都输出了，当输出引用类型的map时，编译器输出了指向的内存中的key和value的所有值，那么这个输出究竟遵循什么原则。 </p><p>&emsp;&emsp;在Go语言中一个数据类型如果实现了String()方法，那么当执行fmt.Println()时，输出到屏幕上的就是String()方法的返回值，我们举个例子：假如我们还是使用stu结构体，现在要求当我们使用fmt.Println(stu对象)的时候输出为：xxx(stu对象中的name属性)是个好人。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int</span></span><br><span class="line">    friends []stu</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s stu)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.name + <span class="string">"是个好人"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> student stu = stu&#123;<span class="string">"DENG"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    fmt.Println(student)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DENG是个好人</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样地我们也可以采用String方法来完成一些基本数据类型的其他形式的输出，当然前提条件是通过type关键字根据基本数据类型完成自定义类型的创建，然后再覆盖String方法，此处也不再做举例了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们引入了面向对象编程的另一个组成部分：方法，同时我们也通过一个入门案例完成了对方法的介绍。如果读者在之前掌握了Go语言中函数的概念与使用方式，那么对于方法的理解就轻而易举了，二者也有十分多的相似之处。最后我们又介绍了Go语言中独特的自定义数据类型的方法调用方式，以及String方法对一个数据类型的作用。 </p><p>&emsp;&emsp;在下个小节中，我们将继续讲解面向对象中方法的细节与注意事项，同时也会在下个小节中插入代码篇部分，简单针对几个小需求举几个方法的例子并进行简要地讲解。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-38-gt-面向对象-方法&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-38-gt-面向对象-方法&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;38&amp;gt; 面向对象-方法&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;37&gt; 结构体细节讨论</title>
    <link href="http://yoursite.com/2020/03/11/37-%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/03/11/37-%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/</id>
    <published>2020-03-11T11:00:25.000Z</published>
    <updated>2020-03-11T11:01:19.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-37-gt-结构体细节讨论"><a href="#Go语言从入门到放弃系列-lt-37-gt-结构体细节讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;37&gt; 结构体细节讨论"></a>Go语言从入门到放弃系列&lt;37&gt; 结构体细节讨论</h2><p>&emsp;&emsp;在上一个小节中，我们引入了结构体的概念，讲解了Go语言中结构体内存对齐的原理，同时也简要提及了面向对象与面向过程的区别，准确地说Go语言并不是一个严格的面向对象的语言，但是它具备着面向对象的许多的特点。在这个小节中，我们依旧暂时不去讲解面向对象的其他特性，而是依旧针对于结构体进行一些细节上的讲解。 </p><h3 id="结构体的声明方式"><a href="#结构体的声明方式" class="headerlink" title="结构体的声明方式"></a>结构体的声明方式</h3><p>&emsp;&emsp;在Go语言中，结构体声明与使用可以由四种方式来完成，分别对应于熟悉不同开发语言的用户。在实际运用中均十分地常见，在这个部分中，我们将分别介绍这四种方式。首先我们先声明一个如下结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int</span></span><br><span class="line">    friends []stu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们定义了一个学生结构体，结构体中三个属性分别是指学生的姓名、学生的年龄、以及学生对应的朋友切片，切片的元素类型依旧是stu类型。由于上一个小节我们已经讲解了内存对齐的问题，因此在这里我们也就不再说这个结构体占据多大的内存空间了。接下来就是四种使用方式：</p><h4 id="1-先定义再赋值"><a href="#1-先定义再赋值" class="headerlink" title="1. 先定义再赋值"></a>1. 先定义再赋值</h4><p>&emsp;&emsp;这种方式与我们入门案例程序中的使用方式是相同的，即将其想象成为一个普通的数据类型，用同样的方式进行定义变量，之后再为每个属性进行赋值。值得说明的是：属性中的map映射需要进行make操作才能够正常使用，对于slice而言，如果直接用append操作就可以不用make了。我们举一个例子说明即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 stu</span><br><span class="line">stu1.name = <span class="string">"Devin"</span></span><br><span class="line">stu1.age = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> stu2 stu</span><br><span class="line">stu1.friends = <span class="built_in">append</span>(stu1.friends, stu2)</span><br><span class="line">fmt.Println(stu1)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们定义了一个stu结构体变量，之后我们再分别为每一个属性进行赋值，在为friends赋值时，我们又定义了一个新的变量，并将新的变量加入到切片中，由于stu2只进行了定义而没有做任何赋值，因此stu2的各个属性默认值均为其零值，即数字类型为0，字符串为空串，切片等引用类型及指针为nil。</p><h4 id="2-定义时初始化"><a href="#2-定义时初始化" class="headerlink" title="2. 定义时初始化"></a>2. 定义时初始化</h4><p>&emsp;&emsp;就如同普通变量在定义时直接赋值成为初始化一样，结构体在定义的时候也可以直接赋值进行初始化。其实通过上述的例子可以发现，当我们没有显式初始化而是只定义的情况下，编译器其实是通过属性对应的零值进行了初始化操作。如果我们不想使用其初值而是使用自己赋给的值时，可以直接进行初始化操作，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 stu = stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">fmt.Println(stu1)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于了解面向对象编程的读者而言，可以将其理解为stu类的构造函数，虽然在Go语言中并不存在构造函数的概念，同时也不支持函数的重载。但是这种定义方式可以直接为类中所有的变量进行数据的初始化，那么既然可以为所有的数据进行初始化，那么对某一部分属性进行初始化也应该是可以完成的。 </p><p>&emsp;&emsp;例如我们只希望初始化stu的对象中的name和age属性，而其他属性则保持其默认的零值。解决办法则是在结构体初始化过程中指明需要初始化哪个属性，不需要初始化的属性不予体现即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student stu = stu&#123;</span><br><span class="line">    name: <span class="string">"DENG"</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;既然我们在程序中指明了哪些属性需要初始化，且初始化的值也一一对应了，那么在运行时编译器就可以为特定的值进行赋值了。在这里需要尤其注意的一点是：在这种初始化过程中，每指定一对属性和值之后都有一个逗号，即便是对属性赋值这个操作是最后一个（age:25后面有一个逗号），如果没有逗号则会编译错误。 </p><h4 id="3-new函数实现内存分配"><a href="#3-new函数实现内存分配" class="headerlink" title="3. new函数实现内存分配"></a>3. new函数实现内存分配</h4><p>&emsp;&emsp;第三种方式可以说对于熟悉Java等语言的开发者十分地友好，因为开发者往往需要通过new关键字来完成对象的创建。Go语言的开发者考虑到类似的需求，便为结构体创建实例添加了这个方式。只是在Go语言中，new并不是其中的关键字，而是一个内建函数，其返回值也不是结构体变量，而是指向结构体变量的指针，我们通过程序来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 = <span class="built_in">new</span>(stu)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, stu1)</span><br><span class="line">(*stu1).name = <span class="string">"Devin"</span></span><br><span class="line">stu1.age = <span class="number">25</span></span><br><span class="line">fmt.Println(*stu1)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果运行上述的程序，我们可以看到第二行对应的输出结构为*main.stu，其含义为main包下的stu类的指针，因此new函数的返回值是一个结构体指针。既然它是一个指针变量，当然就需要遵守指针的原则，即先取出指针所指向的结构体，再进行成员操作。由于运算符的优先级中成员符号要高于取值符号，因此我们在取出对应的结构体时需要用括号进行修饰，即(*stu1).name。假如不使用括号进行修饰，则.运算符先进行运算，虽然Go语言底层对于指针进行了优化操作，将指针的成员默认为指针对应结构体成员，但是对一个变量做*运算依旧是错误的，因此括号是必须要加的。 </p><p>&emsp;&emsp;说起Go语言对底层的优化，我们在之前的小节中也有相应的讲解，上述代码中也运用到了这个优化操作，即stu1.age = 25这一行代码。对指针进行成员操作是无意义的，因此编译器就自动翻译成为了取值后再做成员操作。如果读者对于什么是指针、什么是值、什么时候应该怎样的操作都十分熟悉了，那么当然就可以利用这个优化进行简要的操作了。</p><h4 id="4-初始化时返回指针"><a href="#4-初始化时返回指针" class="headerlink" title="4. 初始化时返回指针"></a>4. 初始化时返回指针</h4><p>&emsp;&emsp;准确地说这个方式不算是一个特殊的方式，它只是将方式2中的结构体初始化结果以指针形式进行返回，当然其定义部分的数据类型也当然就是指针，这种方式在程序开发中也是十分常用，由于其只是方式2的变形，我们就只举个例子，不再过多说明了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 *stu = &amp;stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">fmt.Println(*stu1)</span><br></pre></td></tr></table></figure><h3 id="结构体的赋值"><a href="#结构体的赋值" class="headerlink" title="结构体的赋值"></a>结构体的赋值</h3><p>&emsp;&emsp;在之前的各个章节中，我们均介绍到了各个数据类型是值类型还是引用类型，在这个部分中，我们将针对结构体的性质进行讲解。我们采用的结构体声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name   <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int</span></span><br><span class="line">    class   *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-结构体是值类型"><a href="#1-结构体是值类型" class="headerlink" title="1. 结构体是值类型"></a>1. 结构体是值类型</h4><p>&emsp;&emsp;在Go语言中，结构体是值类型而不是引用类型，这也就说明了一旦将一个结构体变量赋值给另一个结构体变量，其内部属性的所有值将会全部复制，在内存中出现一个完全新的结构体变量，两者之间并不互相影响，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 stu = stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="keyword">var</span> stu2 stu = stu1</span><br><span class="line">stu2.name = <span class="string">"RuoShui"</span></span><br><span class="line">fmt.Println(stu1)</span><br><span class="line">fmt.Println(stu2)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们定义了一个结构体变量stu1，且将该变量直接赋值给另一个变量stu2，此时内存中存在着两个地址不同但内容相同的结构体变量。接下来我们将stu2的name属性修改后，分别输出两个结构体观察结果，最后可以发现，对stu2的修改并不影响stu1的属性。 </p><p>&emsp;&emsp;在这个特性上Go语言与Java语言是不同的，Java秉承了没有显式指针的思想，但核心是全部都是指针，因此熟悉Java的读者在使用Go语言结构体赋值的时候可能会不甚适应，那么如何让一个结构体变量的修改影响到另一个结构体，我们可以采用如下指针的方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 *stu = &amp;stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="keyword">var</span> stu2 *stu = stu1</span><br><span class="line">stu2.name = <span class="string">"RuoShui"</span>    <span class="comment">//这里采用了编译器优化</span></span><br><span class="line">fmt.Println(*stu1)</span><br><span class="line">fmt.Println(*stu2)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们通过指针进行直接赋值，stu2也同样指向了结构体变量，就如同一个机器具备两个控制源，任何一个控制源发布命令，机器都会做出响应。这种实现方式可能更适合于熟悉Java开发的人们。 </p><h4 id="2-深浅拷贝"><a href="#2-深浅拷贝" class="headerlink" title="2. 深浅拷贝"></a>2. 深浅拷贝</h4><p>&emsp;&emsp;我们在这里介绍的概念在笔试乃至于面试中经常出现，即深拷贝与浅拷贝的区别，这两种拷贝方式并不局限于Go语言，而是适用于每一个编程开发语言，只是不同的语言可能采用着不同的拷贝策略，既然Go语言中结构体的赋值是将一个结构体在内存中完全复制、新建、粘贴，那么在这个过程中它究竟是深拷贝还是浅拷贝。 </p><p>&emsp;&emsp;首先我们介绍一下什么是深拷贝，什么是浅拷贝。这两种拷贝方式的区别十分简单：深拷贝就是完全复制，首先对外层对象进行拷贝，对内层引用也进行拷贝；而浅拷贝则是只复制了对象本身，其内部的引用其他对象不做复制，只做引用。 </p><p>&emsp;&emsp;用一个通俗的例子来讲便是，假如我们有一个收纳盒（结构体），盒子中有一个遥控器（引用），这个遥控器可以控制房间内的电视机（指针指向的值）。现在我们希望再建立一个收纳盒，且保持其中的物品不变，将这个收纳盒送给其他人（结构体赋值）。深拷贝的做法就是用一个新的收纳盒，装载一个新的遥控器，控制一个新的电视机，将这三样物品全部交给其他人；浅拷贝的做法就是用一个新的收纳盒，复制那个遥控器，电视机不做任何改动，将收纳盒与遥控器交给其他人，这两个遥控器均可以控制该屋子中的电视机。 </p><p>&emsp;&emsp;那么在Go语言中结构体的赋值是哪一种拷贝方式，我们做一个简单的验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> stu1 *stu = &amp;stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, &amp;a&#125;</span><br><span class="line"><span class="keyword">var</span> stu2 *stu = stu1</span><br><span class="line">fmt.Println(*stu1)</span><br><span class="line">fmt.Println(*stu2)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的程序中，我们依旧将stu1直接赋值给stu2，在最后的输出中，我们会将stu1与stu2中的class属性的地址直接输出。通过对结果的检验，我们可以发现两个结构体变量中class所指向的地址是相同的，因此可以验证得到Go语言中结构体的直接赋值过程是一个浅拷贝过程。 </p><p>&emsp;&emsp;通过这个结果我们可以想象到：当一个结构体中存在一个引用类型或者指针类型时，即便是结构体本身是值类型，其复制得到的结构体变量中的引用是不变的，从这个角度来说通过一个结构体变量修改引用类型或指针类型数据时是会影响到另一个结构体变量的，但是这与结构体值类型中两个结构体内存无关联是不相矛盾的。</p><h4 id="3-结构体类型强转"><a href="#3-结构体类型强转" class="headerlink" title="3. 结构体类型强转"></a>3. 结构体类型强转</h4><p>&emsp;&emsp;在我们之前讲解到的基本数据类型中，我们讲解过基本数据类型之间的相互转化，那么作为数据类型集合的结构体数据类型也可以发生强制转化。例如我们案例中的学生结构体是由姓名、年龄、班级所构成的，假如存在一个person类，且person类中的三个属性分别为姓名、年龄、以及性别（假如性别使用整数来表示），那么stu类与person类是否可以强制互相转化。 </p><p>&emsp;&emsp;在Go语言中，数据类型是十分严格的，即便是同一种数据类型精度不同也不可以不作声明地直接转化，结构体变量也是相同的。如果希望从一个结构体强制转换成另一个结构体，需要满足一个条件：两个结构体需要有完全相同的字段，完全相同是指属性的名字、个数、类型完全相同。我们举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> per <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">    class *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> stu1 stu = stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, &amp;a&#125;</span><br><span class="line">    <span class="keyword">var</span> per1 per = per(stu1)</span><br><span class="line">    fmt.Println(per1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们又新建了一个结构体叫做per，它也是由三个属性构成的，分别为name，age，和class。在主函数中，我们定义了一个stu类型的变量，且将该变量强制类型转换成为per类型赋给per1，最后输出per1，这段程序在编译以及运行过程中均不会报错，也就证明了强制类型转化是成功的。现在我们将per结构体做一些改变：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> per <span class="keyword">struct</span> &#123;</span><br><span class="line">    name   <span class="keyword">string</span></span><br><span class="line">    age    <span class="keyword">int</span></span><br><span class="line">    gender   *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时由于两个结构体的字段（属性）并不是完全一致的，主函数中的程序是无法编译通过的，其报错的信息为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert stu1 (<span class="keyword">type</span> stu) to <span class="keyword">type</span> per</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在本章节中，我们深入Go语言的结构体进行了深入的讲解，包括结构体的四种定义方式：两种返回值、两种返回指针，结构体值类型的特性以及结构体赋值时的浅拷贝特性，再有就是不同结构体之间做类型转换的条件与错误类型。 </p><p>&emsp;&emsp;在下个小节中，我们将不再针对结构体的属性进行讲解，而是进入到面向对象的另一个小部分：成员方法的讲解。在讲解的过程中，我们也将会详细说明一个类中的方法的概念、使用方式、以及它与函数的区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-37-gt-结构体细节讨论&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-37-gt-结构体细节讨论&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;37&amp;gt; 结构体细节讨论&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;36&gt; 面向对象-结构体</title>
    <link href="http://yoursite.com/2020/03/10/36-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://yoursite.com/2020/03/10/36-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%93%E6%9E%84%E4%BD%93/</id>
    <published>2020-03-10T12:00:42.000Z</published>
    <updated>2020-03-10T12:01:25.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-36-gt-面向对象-结构体"><a href="#Go语言从入门到放弃系列-lt-36-gt-面向对象-结构体" class="headerlink" title="Go语言从入门到放弃系列&lt;36&gt; 面向对象-结构体"></a>Go语言从入门到放弃系列&lt;36&gt; 面向对象-结构体</h2><p>&emsp;&emsp;在这个小节之前，可以说我们一直在讨论面向过程的各个知识点。不论是否理解什么是面向过程，我们到目前为止所想到的解决办法都是基于过程的，即分析出解决问题所需要的所有步骤，通过函数逐一进行实现，最后再一个一个地依次调用，以达到解决问题的目的。这种编程思想的需求便是要对过程有着清楚的了解，对过程逻辑有较好的实现，但是在大型程序的后期维护上相对较难。 </p><p>&emsp;&emsp;从这个小节中，我们将开始介绍Go语言中面向对象思想以及Go语言的独特的面向对象的实现方式。由于我们是从面向过程部分开始讲解的，因此一开始可能会相对难从面向过程的思想中跳出，而转变这个编程思路的唯一方式就是多思考、多编程而已。</p><h3 id="面向对象概念"><a href="#面向对象概念" class="headerlink" title="面向对象概念"></a>面向对象概念</h3><p>&emsp;&emsp;准确地说，不同人对于面向对象的理解都不太一致，直接复制粘贴其他人的或者维基百科的理解并不能加深个人对面向对象思想的理解。况且面向对象只是一种思想，不同的语言对于这个思想的实现方式不同，其侧重点也不甚相同，在这个小节中，我也只是讲述的是我个人对面向对象思想的理解、以及Go语言前提下独特的对面向对象的实现。  </p><p>&emsp;&emsp;首先，我们举一个相对容易理解的例子来说明面向过程：贪食蛇游戏的开发。首先初始化地图与蛇身，之后判断蛇的运动方向，进行蛇移动操作，判断是否吃到食物，判断是否撞到障碍，判断是否游戏结束，之后再一次进行同样的循环。把以上的各个需求分别用函数完成，最后再以上述的顺序连接就完成了游戏的开发。 用这种方式思考得出结果的过程就是面向过程的思想。</p><p>&emsp;&emsp;如果采用面向对象的方式来解决这个问题，考虑的方式则完全不同。这个需求可以分为几个大的部分：1. 蛇的部分，它具备位置与是否死亡等多种属性，具备向四个方向移动、成长等多种行为；2. 食物的部分：它具备自己的自然属性即碰到后身体加长、随机生成初始位置等行为；3. 地图的部分：控制游戏的开始与结束行为，完成蛇头与墙壁、石头的碰撞逻辑等。最后通过一定的方式将不同部分的不同属性、行为联系在一起完成程序的开发。换句话说，就是几个实体之间的行为与属性的联系。</p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>&emsp;&emsp;在了解面向对象的各个特点之前，我们首先需要介绍一下对象的概念，对象就是指现实世界或虚拟世界中存在的任何的所有的事物实体，可以讲：一切均是对象。整体来说，对象可以由两部分构成：属性与行为。 </p><p>&emsp;&emsp;属性是用来描述某个抽象物体的特征的，例如我们将一个人作为对象来看，她的身高、体重、国籍、甚至家庭住址都是这个人的属性。属性是是对象的静态的一面，虽说身高体重等都可以发生改变，但是这些依旧是可以通过数值等来形容的。而行为则是对象中属于动态的一面，我们依旧以一个人为例：这个人可以跑、可以跳、会算数、能长大。这些动态的行为就是面向对象的方法，而类之中的方法往往是服务于类中的属性的。 </p><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>&emsp;&emsp;那么什么是类：具备同种属性的对象称之为类，这是个相对抽象的概念，具象地理解可以理解为模板。例如：人就是一个类，而具体到你我他都是人类所对应的对象。人类具备两个眼睛、两个耳朵、一个鼻子等，而具体到每个人都具备这些属性。因此来说，类就相当于一个模板，这个模板定义了对象们应该有的属性、公共特征以及行为功能，而对象则是类的一个实例化。我们在编写程序的时候经常会将一个类实例化，并且使用该对象，就类比于某个人会弹琴，而不是人类会弹琴。 </p><h4 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h4><p>&emsp;&emsp;面向对象编程中有三大特性，分别为继承、封装、多态。在这里我们先不做过多的讲述，因为这三个特性在后续的讲解中均是重点知识，而且Go语言对这三个特性的实现也与其他很多语言都不同。 </p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>&emsp;&emsp;现在我们回到技术层面来考虑问题，在Go语言中是如何实现面向对象编程的。在之前所讲解的map映射中我们一直在回避一个问题，这个问题就是一个学号对应一个学生姓名，但是往往并不是仅仅如此，我们需要存储更多的信息，例如学生姓名、学生性别、学生住址等。当输入学生的学号时，将对应学生的信息都打印出来，这个需求该如何去完成。如果采用之前讲解到的技术，可能为值为map类型的map映射： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stuInfo <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">stuInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">stuInfo[<span class="number">10001</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">stuInfo[<span class="number">10001</span>][<span class="string">"name"</span>] = <span class="string">"Devin"</span></span><br><span class="line">stuInfo[<span class="number">10001</span>][<span class="string">"gender"</span>] = <span class="string">"Male"</span></span><br><span class="line">stuInfo[<span class="number">10001</span>][<span class="string">"address"</span>] = <span class="string">"Melbourne"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(stuInfo[<span class="number">10001</span>][<span class="string">"gender"</span>])</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种实现方式虽然可以完成上述需求，但是这种方式实在是过于繁琐，假如需要根据平均分等指标进行排序就又会更复杂。因此我们可能会想在Go语言中是否存在这样一种数据结构：它可以是多个数据类型的集合，在逻辑上可以被看做一个整体，这样在做管理的时候会十分地方便。 </p><p>&emsp;&emsp;结构体就刚好可以满足上述的要求，它更贴近于类的概念。在之前我们的设想中采用多个数组分别存储这些属性，根据数组的下标值进行管理，可以讲这种方式是一种横向的方式，各个属性是相互分立的。而结构体则是一种纵向的方式，将一个对象的各个属性集合在一起，不同的对象是相互分立的。采用结构体完成上述需求的入门案例为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stuInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    gender <span class="keyword">string</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu stuInfo</span><br><span class="line">    stu.name = <span class="string">"Devin"</span></span><br><span class="line">    stu.gender = <span class="string">"Male"</span></span><br><span class="line">    stu.address = <span class="string">"Melbourne"</span></span><br><span class="line">    fmt.Println(stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们首先定义了一个结构体，即定义了一个数据模板，目前这个结构体中只含有三个属性。在主函数中，我们根据这个类实例化了一个对象stu，在这之后所有的操作都是针对对象stu的，为stu中三个属性进行赋值，最后再进行输出。</p><h3 id="结构体中内存对齐"><a href="#结构体中内存对齐" class="headerlink" title="结构体中内存对齐"></a>结构体中内存对齐</h3><p>&emsp;&emsp;在Go语言的结构体中，存在着一种叫做内存对齐的情况，熟悉旧版C语言但是没有接触过内存对齐的人可能会对这个问题比较陌生。我们举一个例子：假如一个结构体中按顺序含有一个byte，一个int64，两个bool，和一个float32数据，那么这个结构体在内存中占用了多大的空间。结构体体定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> str <span class="keyword">struct</span> &#123;</span><br><span class="line">    byte_field <span class="keyword">byte</span></span><br><span class="line">    int64_field <span class="keyword">int64</span></span><br><span class="line">    bool1    <span class="keyword">bool</span></span><br><span class="line">    float_field <span class="keyword">float32</span></span><br><span class="line">    bool2    <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在标准C语言的思想中，我们可能会想：byte是1个字节、int64是8个字节、bool是1个字节、float32是4个字节，所以这个结构体总共占据1+8+1+1+4=15个字节的空间，这种问题往往还会在考试中考。然而如果我们采用”unsafe”包中的Sizeof函数来测量这个结构体在内存中的空间时，其输出结构竟然是32个字节，而不是我们分析得到的15个字节。 </p><p>&emsp;&emsp;出现这个差异的原因就是Go语言中的结构体实行了内存对齐。计算机以及一些嵌入式设备在读取内存的时候往往不是一个字节一个字节的地读，而是一块一块地读。对于64位的机器而言，计算机一次读取8个字节的内存，对于32位机器而言则是读取4个字节。假如所有数据都是两两相邻的，例如一个bool变量和一个int64变量，计算机在读取的时候（64位机器），是先读取8个字节的空间，发现里面有bool变量，但是当计算机读取int64变量的时候，它需要先读取前8个字节并取其中的后7个字节，然后再读取后8个字节取其中的第一个字节，最后再将两部分拼接起来，这样读取速度就会受到影响。 </p><p>&emsp;&emsp;因此内存对齐的作用就体现出来了，其思想便是利用空间换取时间，让第一个bool单独占据8个字节的位置，然后int64占据8个字节，这样读取效率就会提升。不仅如此，在对齐的最后还会让结构体的空间再对齐，使得结构体数组中任意两个结构体的读取更快捷。Go语言结构体中内存对齐有两个原则：1. 每个变量相对于结构体地址的偏移量应该成为该数据类型所占字节的整数倍，例如int16相对于起始位置需要是2的整数倍，float64相对于起始位置需要是8的整数倍。对于数组等集合型数据类型，按其中元素的数据类型来算。 2.结构体整体占据的空间需要是4的整数倍（32位机器）或8的整数倍（64位机器）。 </p><p>&emsp;&emsp;因此针对于题目中的结构体我们需要做如下的分析：<br>&emsp;&emsp;&emsp;&emsp;1. 首先第一个属性是一个byte，其占据一个字节的空间。目前的内存为：     </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|x</span><br><span class="line">(x表示有数据，.表示空余)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;2. 第二个属性是一个int64数据，其占据8个字节，然而假如将其直接加在后面，其偏移量不是8的整数倍，因此对于这个变量需要进行内存对齐，对齐的方式是中间空余7个位置，内存表示如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;3.第三个属性是bool变量，应该占据1个字节，由于任何数都是1的整数倍，因此直接加在后面是满足于条件1的，内存表示如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|x</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;4. 第四个属性是float32类型变量，占据4个字节，如果直接加在bool的后面，其偏移量为17,而17并不是4的整数倍，因此需要进行内存对齐，对齐位置应该是偏移量为20的位置，内存如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|x...xxxx|</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;5. 最后一个变量还是bool类型，同理它可以直接加入到任何一个变量的后面，所以这个变量直接加在float32后面。此时的内存如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|x...xxxx|x</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;6. 此时结构体内部的各个变量的位置已经分好了，即每一个属性的位置都满足于条件1，而整个结构体此时的字节数为25，然而25并不是8的整数倍，其最近的整数倍为32，所以最终这个结构体在内存中的分布为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|x...xxxx|x.......|</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述的解释中，我们可以发现：其实在第一个字节中有效位置只有一个二进制位，而浪费了七个二进制位，对于最后一个字节依旧是如此。那么在结构体的设计上，我们明明可以将两个bool变量定义到一起去，这样不仅第一个字节利用率变高，最后一个字节也不需要整体内存对齐，对于结构体的空间占用就减少了1/4。而解决办法，其实只是将属性定义的顺序修改一下即可。</p><p>&emsp;&emsp;但是一般的算法优化并不会针对结构体的设计方面进行优化，因为相比于主流的时间空间复杂度的优化方式，这种优化所得到的收益实在是太低了。因此，内存对齐的优化方式并不主流，但也不失为一种简单而有效的优化方式。</p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>&emsp;&emsp;在这个地方为了加强对内存对齐的理解，我们假设存在这样的一个结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int64</span></span><br><span class="line">    isAdult <span class="keyword">bool</span></span><br><span class="line">    grades [<span class="number">3</span>]<span class="keyword">float32</span> <span class="comment">//假设只有三门课</span></span><br><span class="line">    friends []stu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么请问，这个结构体变量在内存中会占据多大的空间。答案是64  ，读者可以自行分析。（注：string类型占16字节、切片占24字节，具体原因我们在前面都讲解过）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|xxxxxxxx|xxxxxxxx|xxxxxxxx| x...xxxx|xxxxxxxx|xxxxxxxx|xxxxxxxx|xxxxxxxx|</span><br><span class="line">|<span class="keyword">string</span>           |<span class="keyword">int64</span>   |<span class="keyword">bool</span>|[<span class="number">3</span>]<span class="keyword">float32</span>   |[]stu                     |</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们初步讲解了面向对象编程思想与面向过程编程思想的区别，同时引入了Go语言中结构体这种数据类型，并对结构体数据类型做了一个简单的快速入门举例。最后我们讲解了Go语言结构体中的内存对齐的现象，说明了这种语言与其他某些语言的不同点。 </p><p>&emsp;&emsp;在下一个小节中，我们依旧将针对于结构体数据类型的四种声明以及初始化方式进行讲解，并集中提及在代码实现过程中需要注意到的问题和细节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-36-gt-面向对象-结构体&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-36-gt-面向对象-结构体&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;36&amp;gt; 面向对象-结构体&quot;
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;35&gt; map映射的细节讨论</title>
    <link href="http://yoursite.com/2020/03/09/35-map%E6%98%A0%E5%B0%84%E7%9A%84%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/03/09/35-map%E6%98%A0%E5%B0%84%E7%9A%84%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/</id>
    <published>2020-03-09T12:04:59.000Z</published>
    <updated>2020-03-09T12:05:49.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-35-gt-map映射的细节讨论"><a href="#Go语言从入门到放弃系列-lt-35-gt-map映射的细节讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;35&gt; map映射的细节讨论"></a>Go语言从入门到放弃系列&lt;35&gt; map映射的细节讨论</h2><p>&emsp;&emsp;在上一小节中，我们对Go语言中的map映射进行了引入，同时也讲解了map的定义初始化方式以及对其中数据的增删改查操作的方式。在这个小节中，我们依旧针对map映射的其他特性进行相对深入的讲解，以及在程序编写过程中需要注意的几个问题进行提及。 </p><h3 id="键值对类型"><a href="#键值对类型" class="headerlink" title="键值对类型"></a>键值对类型</h3><p>&emsp;&emsp;在上一个小节中，我们提到map映射中数据的存储方式是以键-值的方式存储的，同时每一个键都对应于一个值。在上一节的入门案例中，我们只使用了整数类型以及字符串类型作为map的键值，在这一部分中我们将介绍其他的可以作为键值的数据类型。 </p><p>&emsp;&emsp;到目前为止，我们已经讲解过的数据类型有：整数类型、浮点类型、布尔类型、字符串类型、数组、切片、函数类型、以及正在讲解的映射类型。那么这些数据类型是否全部都可以作为map的键值类型呢，答案是否定的。在Go语言中切片、映射、和函数是不可以作为map的键的类型的。 </p><p>&emsp;&emsp;对于这个规定的理解，我们可以想象一下如下的过程，当我们希望通过一个键来查找值的时候，map中是维护了一个键的列表的。当在这个列表中存在着当前键的时候，才将值进行输出，同时判断两个键值是否相同的方式只有通过==的方式。到目前为止我们所演示的所有案例中，均没有出现过判断两个切片是否相等、两个映射是否相等、以及两个函数是否相等。从某种意义上来说可以判断是否相等的两个值大小需要是固定的，而slice以及map刚好不满足，而function作为一个map的键一般来说也是没有意义的。 </p><p>&emsp;&emsp;那么对于map的值类型是否也存在着某些限制，理论上来说，map映射对于value的数据类型是没有限制的，即slice等不可以作为key的类型但是是可以作为value的类型的。不论某个数据类型是值类型还是引用类型，它在内存中都是可以被另一个指针所指向的，因此value的类型是可以任意的。我们通过两小段程序来说明这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sys <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">sys[<span class="string">"1"</span>] = slice</span><br><span class="line">fmt.Println(sys)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一段程序是可以成功编译运行的，这个map映射的key类型为string字符串，value类型为一个int切片。我们接下来为这个切片赋值，再添加到map中，最终的结果可以成功输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sys <span class="keyword">map</span>[[]<span class="keyword">int</span>]<span class="keyword">string</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[[]<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">sys2[slice] = <span class="string">"1"</span></span><br><span class="line">fmt.Println(sys)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第二段程序就无法编译通过了，因为他的key类型是一个int切片，由于int切片是无法通过==或!=来判断的，因此这个map是无法构成的。在编译过程中，会报出：invalid map key type []int的错误。</p><h3 id="map的无序性"><a href="#map的无序性" class="headerlink" title="map的无序性"></a>map的无序性</h3><p>&emsp;&emsp;在我们之前所接触到的多数据集合的类型中，例如数组切片等都是有序的集合，即先输入的数据排在前方而后输入的数据排在后方。我们也可以采用某些数据结构或独特的排序方式使之成为有序的状态，例如插入排序、堆排序等。而在Golang的map映射中，这两种特性均不存在，也就是说当遍历map中的数据时，往往不会遵循数据的大小规律以及输入的先后规律。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sys := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="string">"one"</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">"two"</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="string">"three"</span>,</span><br><span class="line">    <span class="number">4</span>: <span class="string">"four"</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">"five"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(sys)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中我们输出了10次map映射，在这里我就不将执行结果写出来了，因为不同的人在执行这样同一段代码的时候，其结果可能完全不同。但是可以保证的是：map映射中会存在5个数据，且这5个数据均是正确显示的，只是输出的顺序是不同的。 </p><p>&emsp;&emsp;出现这个效果的原因是每一次key的遍历顺序不同，而这个不同则是Go语言的设计者的有意为之（虽说我不太理解这个做法）。在其他语言中程序员对于map的遍历时往往依赖于其key的稳定输出顺序，在Go语言中是完全不可以的。不过奇怪的是：在早版本的golang中，输出的key并非是随机化的，无序这个特性是设计者在后续版本中加入的一个特性。 </p><p>&emsp;&emsp;再需要提及的一个问题是：map中的值的存储是不连续的，即不像是数组那样两个元素是相连的。在Go语言中键与值的对应关系满足哈希算法，即通过键的值经过某种计算直接得到值的物理地址，从而可以快速查找。因此值的存储是不连续的，不仅如此，value的访问是不可以通过指针访问的，即便是我们知道了value的物理地址，也不能通过*运算来访问。因为当map扩容时，所有的数据可能会采用新的hash算法进行计算，之前的物理地址可能就不再指向原来的数据了。</p><h3 id="map的排序"><a href="#map的排序" class="headerlink" title="map的排序"></a>map的排序</h3><p>&emsp;&emsp;既然map的key的遍历是无序的，value的输出也是无序的，当遇到了对map排序的需求时就需要对其做一些变通。此时我们需要用一个数组或切片进行辅助排序。我们就首先遍历map中的键，并将每一个遍历到的键加入到一个切片中。然后对这个切片进行排序，最后按排序后的key进行对应值的查找，进而完成按key的大小排序，程序如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sort"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sys := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="number">1</span>: <span class="string">"one"</span>,</span><br><span class="line">        <span class="number">2</span>: <span class="string">"two"</span>,</span><br><span class="line">        <span class="number">3</span>: <span class="string">"three"</span>,</span><br><span class="line">        <span class="number">4</span>: <span class="string">"four"</span>,</span><br><span class="line">        <span class="number">5</span>: <span class="string">"five"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> keys []<span class="keyword">int</span> = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> key, _ := <span class="keyword">range</span> sys &#123;</span><br><span class="line">        keys = <span class="built_in">append</span>(keys, key)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(keys)</span><br><span class="line">    <span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        fmt.Println(sys[key])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="键的唯一性"><a href="#键的唯一性" class="headerlink" title="键的唯一性"></a>键的唯一性</h3><p>&emsp;&emsp;这个特性是相对好理解的，因为在日常生活中处处存在类似的例子。例如，在一所学校中不会出现两个相同学号的学生，不会出现两个相同身份证号的人。因此这个特性就决定了map映射中每一个key都需要是不同的，而对于value则完全没有要求。例如“信用卡-用户”这个键值对，每个信用卡都可以独特地对应一个人，但是一个人可能对应的不止一个信用卡。对于键的唯一性我们通过代码举例说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">stu[<span class="number">1</span>] = <span class="string">"Devin"</span></span><br><span class="line">stu[<span class="number">2</span>] = <span class="string">"RuoShui"</span></span><br><span class="line">stu[<span class="number">3</span>] = <span class="string">"RuoShui"</span></span><br><span class="line">stu[<span class="number">1</span>] = <span class="string">"Evelyn"</span></span><br><span class="line">fmt.Println(stu)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们声明了一个map映射，并向其中插入了四条数据，在这四条数据中，我们验证了在Go语言中map的键、值是否可以重复。stu2和stu3的值是相同的，而Devin和Evelyn的键是相同的。通过结果我们可以发现：stu2和stu3是可以共存的，而stu1的Devin值是被Evelyn所覆盖了，因为根据哈希算法，通过一个键值的计算所得到的物理地址是一定的，因此对应于同一个键，只能存在一个值，也就是最后覆盖的那个值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="number">3</span>:RuoShui <span class="number">1</span>:Devin <span class="number">2</span>:Evelyn]</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们针对Go语言中的map映射进行了相对具体的讲解，并介绍了map的键类型与值类型的限制，以及map内key的遍历的无序性和对应的排序方式，最后我们也提及了map映射中键的唯一性。 </p><p>&emsp;&emsp;从下个小节开始，我们将开始进入面向对象的部分，讲解Go语言中面向对象的特性以及实现方式，同时也将针对Go语言对面向对象的几大特性的独特的设计理念进行讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-35-gt-map映射的细节讨论&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-35-gt-map映射的细节讨论&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;35&amp;gt; map映射
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;34&gt; map映射</title>
    <link href="http://yoursite.com/2020/03/08/34-map%E6%98%A0%E5%B0%84/"/>
    <id>http://yoursite.com/2020/03/08/34-map%E6%98%A0%E5%B0%84/</id>
    <published>2020-03-08T13:19:27.000Z</published>
    <updated>2020-03-08T13:20:08.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-34-gt-map映射"><a href="#Go语言从入门到放弃系列-lt-34-gt-map映射" class="headerlink" title="Go语言从入门到放弃系列&lt;34&gt; map映射"></a>Go语言从入门到放弃系列&lt;34&gt; map映射</h2><p>&emsp;&emsp;在之前的几个小节中，我们分别讲解了数组与切片两种相对复杂的数据类型，并讲解了其使用方式和注意事项。在这个小节中，我们将进入对下一个话题的讨论-map映射。在这几小节中，我们也将延续之前的讲解模式，以案例驱动快速入门程序，然后针对使用方式进行讲解，最后再面向一些使用细节做出更深入的讨论。 </p><h3 id="map映射引入"><a href="#map映射引入" class="headerlink" title="map映射引入"></a>map映射引入</h3><p>&emsp;&emsp;map映射与之前介绍到的数组等数据结构完全不同，数组包括切片都是同一种数据的有序集合，而map则是以键值对的形式进行数据存储，每一个键（key）对应于一个值（value）成对出现。 </p><p>&emsp;&emsp;首先我们举一个例子，在日常生活中具备很多的一对一键值的例子。例如：每一个公民都具备一个独一无二的身份证号码，且这个号码可以唯一且精确地代表这个人。再例如在某个班级或者学校中，每个学号可以对应于每一个人，且依旧是唯一且精确地代表。假如我们希望完成一个如下需求的程序：写一个小的管理系统，系统中需要存储用户的身份证号以及姓名，且需要通过身份证号来直接查找到用户。 </p><p>&emsp;&emsp;如果采用之前我们提及的各个技术来完成这个需求，其实还是比较有难度的，因为之前我们所介绍的名字与值唯一相对的只有变量名与变量值的相对关系，然而定义多个变量的方式很不现实，使用切片的方式也相对麻烦，我们实现一下： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ids []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> names []<span class="keyword">string</span> = []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    ids = <span class="built_in">append</span>(ids, <span class="number">10001</span>)</span><br><span class="line">    names = <span class="built_in">append</span>(names, <span class="string">"Devin"</span>)</span><br><span class="line">    ids = <span class="built_in">append</span>(ids, <span class="number">10002</span>)</span><br><span class="line">    names = <span class="built_in">append</span>(names, <span class="string">"RuoShui"</span>)</span><br><span class="line">    fmt.Println(ids)</span><br><span class="line">    fmt.Println(names)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们定义了两个切片分别来存储身份id以及用户姓名，当添加新的用户时，需要对两个切片进行append操作，通过id查找姓名时需要先查找id所在数组（切片）中的下标，然后再提取names切片中对应下标的元素，当删除时，同样需要先找到对应下标后再进行切片的删除。因此通过切片来完成这个需求只能说可以达到目的，但是这个实现方式非常的繁琐。 </p><p>&emsp;&emsp;所以我们进而引入map映射的概念，map映射有两个组成部分，分别是key和value，且每个键都需要唯一对应一个值，在上述的这个需求中，用户的身份id刚好可以唯一指定一个用户的用户名，因此是十分适用的。我们利用map的方式来完成上述的需求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sys <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    sys[<span class="number">10001</span>] = <span class="string">"Devin"</span></span><br><span class="line">    sys[<span class="number">10002</span>] = <span class="string">"RuoShui"</span></span><br><span class="line">    fmt.Println(sys[<span class="number">10002</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们定义且初始化了一个map映射，然后向该映射中添加了两组数据，分别是两个用户的身份id以及用户姓名，当通过id进行查找姓名时，可以直接通过map中的键得到对应的值，相比于用两个切片来保存，使用映射的技术更为合适。</p><h3 id="map的使用方式"><a href="#map的使用方式" class="headerlink" title="map的使用方式"></a>map的使用方式</h3><p>&emsp;&emsp;在这个小节中，我们不准备介绍map映射的内存构成，因为其构成方式十分的复杂，其核心是采用hashmap的算法方式进行的分布存储，且数据结构也包含了数组配合链表，且采用红黑树的原则进行存储。因此在没有讲解数据结构与算法相关知识之前，直接介绍map的内存构成不是一个好的选择，这对初学者来说也并不十分友好，因此就直接跳过这部分进而对map的使用进行讲解。 </p><h4 id="make函数的使用"><a href="#make函数的使用" class="headerlink" title="make函数的使用"></a>make函数的使用</h4><p>&emsp;&emsp;关于make函数，我们在讲解切片的时候就已然提及过了，我们曾用这个函数为切片分配空间。同理，在map映射中，我们依旧需要这个函数对映射进行初始化，否则该map只是一个空指针，输出时会出现nil。 </p><p>&emsp;&emsp;make函数在初始化map映射时有两种写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(映射类型,初始大小)</span><br><span class="line"><span class="built_in">make</span>(映射类型)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述两个方式中，唯一区别就是是否需要为map分配初始大小。如果省略该参数，编译器会自动为map分配默认的大小，而如果指定大小的话则会分配对应的空间，其特性与切片大致相似：当为map插入数据时一旦溢出该空间则会自动增长。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> , <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="1-先声明再初始化最后赋值"><a href="#1-先声明再初始化最后赋值" class="headerlink" title="1. 先声明再初始化最后赋值"></a>1. 先声明再初始化最后赋值</h4><p>&emsp;&emsp;同切片数据类型一样，map映射的使用方式也是这三个步骤。接下来我们将针对这三个步骤分别进行讲解：首先是声明部分，由于映射需要键的数据类型与值的数据类型两个部分，再加上变量名等等，因此map的声明方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 <span class="keyword">map</span>[键的数据类型]值的数据类型 = <span class="keyword">map</span>[键的数据类型]值的数据类型</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如采用上述的需求：用户的id号为整数类型，用户的姓名为字符串类型，因此其声明方式为：map[int]string。再举一个例子：我们需要存储用户的email以及用户的年龄，且email值可以唯一指定这个用户的年龄。因此此时的声明方式中键的类型为string，值的类型为int：map[string]int。 </p><p>&emsp;&emsp;在map映射声明后，我们暂时还无法使用它，因为此时它只是一个指向nil的指针类型，是没有分配空间的，因此声明过后需要通过make函数为map分配空间与资源：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> , <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个地方需要注意的问题是：在make函数中传入的参数类型要与map声明的类型相同，例如map的声明类型为键是字符串、值为整数，则传入的参数的类型也是需要是这个类型不可以改变。 </p><p>&emsp;&emsp;在为map分配的内存空间资源后，它就可以进行赋值等使用操作了，在后面我们将针对map结构的增加、删除、修改、查找分别进行举例讲解，所以在这里我们暂时不提map的使用。</p><h4 id="2-直接make初始化后再赋值"><a href="#2-直接make初始化后再赋值" class="headerlink" title="2. 直接make初始化后再赋值"></a>2. 直接make初始化后再赋值</h4><p>&emsp;&emsp;经过了前面多个小节的讲解，想必对Go语言中直接将声明和初始化合称为一条语句的做法都不陌生了，所以map映射也是可以在定义时直接初始化空间的，同理对于变量的类型自动推导也不难理解，此处就举一个例子而不全部讲解了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sys <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">sys := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="3-直接赋值初始化"><a href="#3-直接赋值初始化" class="headerlink" title="3. 直接赋值初始化"></a>3. 直接赋值初始化</h4><p>&emsp;&emsp;正如基本数据类型变量的初始化一样，map映射也可以直接在定义的时候初始化其初始值。初始化的方式与切片的初始化方式十分相似，其不同点就是map初始化的时候需要采用键：值的方式进行初始化。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sys := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="number">10001</span>: <span class="string">"Devin"</span>,</span><br><span class="line">        <span class="number">10002</span>: <span class="string">"RuoShui"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(sys)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面的这段程序中，类型自动推导sys的数据类型，且声明键为int，值为string的map过后直接用大括号进行初始化。初始化过程中的键和值的类型需要与定义完全一致。这里需要注意的一个地方就是初始化过程中的最后一个逗号，一般来说逗号是分割两组数组的符号，因此在最后一个数据后是没有逗号的，但是，在map的初始化过程中，这个逗号是必要的不可以被省略。 </p><h3 id="map映射的增删改查"><a href="#map映射的增删改查" class="headerlink" title="map映射的增删改查"></a>map映射的增删改查</h3><h4 id="1-增加数据与修改数据"><a href="#1-增加数据与修改数据" class="headerlink" title="1. 增加数据与修改数据"></a>1. 增加数据与修改数据</h4><p>&emsp;&emsp;之所以将这两个部分放在一起来讲是因为其使用形式是一样的，都是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名[键]=值</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当map中不存在当前的这个键时，执行上述形式的代码可以将对应的键和值加入到map中，即添加数据。当map中已经存在了这个键，则将新的value覆盖掉原来对应的值，即修改数据。具体的案例我们在入门程序中已然有所提及。 </p><h4 id="2-查询数据"><a href="#2-查询数据" class="headerlink" title="2. 查询数据"></a>2. 查询数据</h4><p>&emsp;&emsp;在执行网络编程等程序中，我们可能并不知道map中究竟含有什么数据，因此需要对数据进行通过键来查找。同样地，此时也会出现两种情况：键存在与键不存在。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value值, 键是否存在 = 变量名[键]</span><br><span class="line">value, exist = sys[<span class="number">10003</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的调用方式中，如果在map中存在希望查找的键，则exist的值为true，value就是map中对应的值，当map中不存在对应的键时，exist的返回值为false。 </p><p>&emsp;&emsp;除此之外，我们有时候不仅需要通过键来寻找对应的值，而是希望得知值中是否包含某个值，此时就需要对map进行遍历，然而map只支持通过键来得到值，因此map的遍历其实就是对key的遍历。当得到了key后，其value就自然可以得到了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sys := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="number">10001</span>: <span class="string">"Devin"</span>,</span><br><span class="line">        <span class="number">10002</span>: <span class="string">"RuoShui"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> key, value := <span class="keyword">range</span> sys &#123;</span><br><span class="line">        fmt.Println(key, <span class="string">" "</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3. 删除数据"></a>3. 删除数据</h4><p>&emsp;&emsp;既然查询数据是需要通过键来完成，那么删除数据当然也是需要通过键来完成。在map数据的删除中，我们使用的是系统内建函数:delete。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>名，键)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;即从指定的map中删除对应的键和值，这个调用方式与切片的追加append函数调用方式相同，只是append函数需要通过一个切片进行接收，而delete函数是可以不用变量来接收。 </p><p>&emsp;&emsp;在删除数据的过程中，当需要删除的键存在时，直接在map中删除对应的键和值，当需要删除的键不存在时，则什么都不做，程序运行过程中不会报错。 </p><p>&emsp;&emsp;在Go语言中，不存在一个函数用来完全清空一个map映射，如果用户希望清空一个map，则需要对map进行遍历，在遍历的同时逐个进行删除。亦或使用make函数为该map重新分配一个空间，而抛弃原有的空间，此时原有的空间可以被垃圾回收机制gc所回收，新的空间是空的，也算是另一种意义上的清空。 </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们对Go语言中的另一种数据类型map映射进行了引入，并使用它完成了一个简单的需求案例。除此之外我们也讲解了map映射的三种定义及使用方式以及在代码中对map进行数据增删改查的操作方式。在下一小节中我们将会依旧针对于map映射深入讲解一些细节以及注意事项。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-34-gt-map映射&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-34-gt-map映射&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;34&amp;gt; map映射&quot;&gt;&lt;/a&gt;Go语言
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;33&gt; 切片使用细节</title>
    <link href="http://yoursite.com/2020/03/07/33-%E5%88%87%E7%89%87%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/"/>
    <id>http://yoursite.com/2020/03/07/33-%E5%88%87%E7%89%87%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/</id>
    <published>2020-03-07T13:00:02.000Z</published>
    <updated>2020-03-07T13:00:53.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-33-gt-切片使用细节"><a href="#Go语言从入门到放弃系列-lt-33-gt-切片使用细节" class="headerlink" title="Go语言从入门到放弃系列&lt;33&gt; 切片使用细节"></a>Go语言从入门到放弃系列&lt;33&gt; 切片使用细节</h2><p>&emsp;&emsp;在上一个小节中，我们通过案例引入了切片的概念，同时也讲解了切片的定义方式、使用方式、独特的追加元素与拷贝的方式。不仅如此，我们也讲解了切片的内存构成，并得到一个结论是切片是一个引用类型，且引用的底层就是一个Go语言中的数组。在这个小节中，我们将继续针对Go语言中的切片数据类型进行深入的讲解，并对其使用过程中的注意事项进行讲解。 </p><h3 id="len与cap函数"><a href="#len与cap函数" class="headerlink" title="len与cap函数"></a>len与cap函数</h3><p>&emsp;&emsp;在上一小节中，我们在对切片的内存进行图解的讲解时，我们在图中不仅画出了切片所指向的数组的物理地址，我们还在其后画出了两个值，分别为：切片的长度与切片的容量。首先我们通过一个入门程序来通过这两个函数的调用完成切片的长度与容量的获取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice))</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从程序中，我们可以发现len函数和cap函数都是系统内建函数，是不需要引入任何的包的。同时len函数的返回值为切片的长度，cap函数的返回值为切片的容量。那么为什么会在切片的结构体中定义这两个变量，是因为切片的长度是可以动态变化的。 </p><p>&emsp;&emsp;如果我们将视角返回到数组中，如果我们有一个需求为当前已经满了的数组添加一个数字，我们可以能采用两种方式：第一种为将数组改变成为链表，这样就可以随意地添加、删减元素，但是此时数据的快速查找就变得非常不容易；第二种方式为：每当需要插入一个数据，就新申请一个长度+1的数组，并将原数组中的所有值复制给新的数组，并在最后加入新值，这种方式保存了数组的元素快速查找的特性，但是对于频繁增加数据的情况下就十分地浪费资源，因为做了极多次的申请与复制操作。 </p><p>&emsp;&emsp;而对于切片而言，由于其底层就是一个数组，因此将数组改为链表这个方式就基本不可能了，而每次都申请长度+1的数组又太过频繁了。因此解决方式是当数组元素个数已经满了，申请新的数组时就多申请一部分的空间以备用。当申请结束后新数组的长度成为切片的容量，新数组中存在元素的个数成为切片的长度，我们举一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice[<span class="number">0</span>])</span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice[<span class="number">0</span>])</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice))</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述程序中，我们定义了一个切片，且指定了长度为5，容量为10，此时由于切片定义后未修改值，所以输出的slice结果为：[0 0 0 0 0]，且输出了数组中第0个元素的物理地址，本次本机输出值为：0xc00008e000。然后我们为slice切片追加一个元素1，再一次输出该切片的元素，此时切片的长度变为了6，输出结果为：[0 0 0 0 0 1]，此时再次输出数组中的第0个元素的物理地址，本次本机为0xc00008e000。最后输出切片的长度为6，容量为10。 </p><p>&emsp;&emsp;从上述的输出结果中，我们可以总结出以下几点：每次执行append函数时，切片的长度会变为两个参数切片（或者可变参数）的长度的和，因为此时只追加一个元素，所以长度变为+1后的值；切片的容量在长度不超过容量数时不发生变化，一旦超出了我们下面会继续讲解；两次输出的切片所对应的数组的首地址是相同的，因此可以断定追加前与追加后是同一个数组，物理地址没有发生变化。 </p><p>&emsp;&emsp;上面的例子是追加元素后没有超出容量的情况，下面我们再举一个超出容量的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice[<span class="number">0</span>])</span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice[<span class="number">0</span>])</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice))</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序与上述程序的唯一区别就是：将切片定义时的容量由10变为5，所以最初状态就是切片的长度为5，且只能容纳5个值，即底层的数组处于满员的状态。此时再添加一个元素，由于原数组已经无法容纳这些值了，所以需要申请一个新的数组，其输出结果可以证明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"><span class="number">0xc000080060</span></span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"><span class="number">0xc000092000</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述的输出结果中，我们可以看出：数组的首地址是不相同的，所以当追加数据时数据溢出的情况下底层会新申请一个数组。不仅如此，新申请的数组的长度（切片的容量）由5变成了10。</p><h3 id="切片注意事项与细节说明"><a href="#切片注意事项与细节说明" class="headerlink" title="切片注意事项与细节说明"></a>切片注意事项与细节说明</h3><p>&emsp;&emsp;在接下来的部分中，我们将针对于切片的使用细节以及注意事项作出简要的说明，这些细节可能在之前的部分中有所提及，可以一并回忆一下之前的知识点。 </p><ol><li><p>切片通过数组初始化时var slice = array[start:end] 是从数组下标为start开始到end为止（不含）的截取，且截取方式为：<strong>左闭右开</strong>。 </p><p>&emsp;&emsp;例如：取出数组中的全部元素成为切片是array[0:len(array)]而不是array[0:len(array)-1]。</p></li><li><p>切片初始化时依然不可以越界，其范围依旧在0到len(array)之间（左闭右开），但是是可以动态增长的。在数组的截取过程中，有一些截取部分的简化操作：</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = array[<span class="number">0</span>:end]        ==&gt;  <span class="keyword">var</span> slice = array[:end]</span><br><span class="line"><span class="keyword">var</span> slice = array[start: <span class="built_in">len</span>(array)]  ==&gt;  <span class="keyword">var</span> slice = array[start:]</span><br><span class="line"><span class="keyword">var</span> slice = array[<span class="number">0</span>: <span class="built_in">len</span>(array)]    ==&gt;  <span class="keyword">var</span> slice = array[:]</span><br></pre></td></tr></table></figure><ol start="3"><li>cap是一个内置函数，不需要引入任何的包，用于统计切片的最大容量，在数据追加过程中，如果追加后长度没有超出容量则不变，一旦超出容量则新申请数组后容量变为二倍。在这里不做演示了，只放置一个示例程序，读者可以自行运行后观察数据规律：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"长度为：%d，容量为：%d\n"</span>, <span class="built_in">len</span>(nums), <span class="built_in">cap</span>(nums))</span><br><span class="line">    nums = <span class="built_in">append</span>(nums, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>切片的核心其实就是底层的数组，因此切片可以继续切片。</p></li><li><p>切片是引用类型，即作为函数参数传递时，被调用者对切片数据进行修改时会影响到调用者函数中的值。 </p><p>&emsp;&emsp;针对这个特性我们举一个例子：利用一个字符（整数）切片存储多个字符，并且在自定义函数中将该切片中所有大写字母转换成对应的小写字母。</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> info []<span class="keyword">byte</span> = []<span class="keyword">byte</span>&#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'L'</span>, <span class="string">'O'</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(info); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, info[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    change(info)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(info); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, info[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(slice []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> delta = <span class="string">'a'</span> - <span class="string">'A'</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> slice[i] &gt;= <span class="string">'A'</span> &amp;&amp; slice[i] &lt;= <span class="string">'Z'</span> &#123;</span><br><span class="line">            slice[i] += <span class="keyword">byte</span>(delta)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="string类型与切片"><a href="#string类型与切片" class="headerlink" title="string类型与切片"></a>string类型与切片</h3><p>&emsp;&emsp;在Go语言中，string类型是一种相对特殊的基本数据类型。说其特殊是因为它也是引用了某一个底层数组而存在的。可以说，string类型的底层就是一个byte数组，但是这个数组是不能够通过单个字符修改方式进行访问或修改，在string的引用中，依旧无法对其进行修改。 </p><p>&emsp;&emsp;那么既然string的底层是byte数组，而切片底层也可以是byte数组，所以string和切片可以有一些异曲同工之妙，同时string字符串类型是可以进行切片操作的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> info <span class="keyword">string</span> = <span class="string">"Hello World"</span></span><br><span class="line"><span class="keyword">var</span> slice = info[:<span class="number">6</span>]</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们之前只通过裁剪的方式对数组进行操作，而上述的程序中是可以直接通过裁剪的方式对string字符串进行操作的，这也侧面反映出了string的核心就是一个数组。 </p><p>&emsp;&emsp;除此之外，字符串类型是一种常量，一旦定义初始化后就不可以进行修改了，在数组中，我们可以通过a[i] = 10的方式对数组中任意一个元素进行修改，但是在string类型中，我们不可以通过str[0] = ‘a’的方式进行修改。这个是常量的属性所规定的。 </p><p>&emsp;&emsp;但有些时候可能就会出现类似如下的需求：输入一个字符串后，需要对每一个字符进行操作，例如把所有的大写字母转换成小写字母（程序核心实现函数已在上面的代码中提及）。既然string类型是常量无法被修改，我们只能通过将其转换成为一个切片来操作，我们只举一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> info <span class="keyword">string</span> = <span class="string">"Hello World"</span></span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">byte</span> = []<span class="keyword">byte</span>(info)</span><br><span class="line">...</span><br><span class="line">info = <span class="keyword">string</span>(slice)</span><br><span class="line">fmt.Println(info)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述程序中，我们首先定义了一个字符串string，然后将其强转成为一个byte切片（如果字符串中含有中文，需要转换成为rune切片），接下来对切片进行某种处理后，我们再将切片强转回string类型，这个过程结束后才相当于对字符串中的某些元素进行了操作。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们集中讲解了slice切片中的两个函数：len函数与cap函数的含义以及注意事项，同时也讲解了当执行append操作后slice中len和cap发生的变化，以及底层数组发生的相应的改变。除此之外，我们还讲解了slice类型在程序编写的过程中需要注意的问题，最后我们讲解了string基本数据类型与slice引用类型的相互关系。 </p><p>&emsp;&emsp;在下一个小节中，我们将开始介绍Go语言中map的含义以及使用方式，并将map这种数据类型与数组、切片等数据类型相结合做出相对具体的讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-33-gt-切片使用细节&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-33-gt-切片使用细节&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;33&amp;gt; 切片使用细节&quot;&gt;&lt;/a&gt;G
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;32&gt; 切片引入</title>
    <link href="http://yoursite.com/2020/03/06/32-%E5%88%87%E7%89%87%E5%BC%95%E5%85%A5/"/>
    <id>http://yoursite.com/2020/03/06/32-%E5%88%87%E7%89%87%E5%BC%95%E5%85%A5/</id>
    <published>2020-03-06T13:59:21.000Z</published>
    <updated>2020-03-06T14:04:12.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-32-gt-切片引入"><a href="#Go语言从入门到放弃系列-lt-32-gt-切片引入" class="headerlink" title="Go语言从入门到放弃系列&lt;32&gt; 切片引入"></a>Go语言从入门到放弃系列&lt;32&gt; 切片引入</h2><p>&emsp;&emsp;在之前的各个小节中，我们集中讲解了数组的概念及其用法，同时我们也拓展了二维数组以及多维数组的概念，在这个小节中，我们将根据之前我们接触到的数组的概念，来讲解Go语言中的另一个数据类型：切片。同时，我们也会对切片的定义及使用通过入门程序进行讲解，读者在阅读过程中，可以将其与数组的相应的概念进行对比，找出其共同点与不同点，以免在后续的章节中混淆。</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>&emsp;&emsp;在这个部分中，我们依旧采用一个需求来引出切片的含义以及使用范围。我们假设一个简单的需求：为学校完成一个学生成绩管理系统，存储学生的单科的成绩信息。这个需求与数组的引入需求十分类似，因此如果使用之前所说的数组来完成，我们可能会写出如下的代码结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> grades [<span class="number">50</span>]<span class="keyword">int</span> = [<span class="number">50</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(grades); i++ &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么对于上述的代码块而言，依旧存在着一些不足，其关键的问题点是：数组究竟需要定义多么大。在上述的代码块中，我们硬编码了学生人数为50人，但是假如一个班的学生不足50人，则会出现内存空间的浪费，同时在对数组进行遍历的时候也会出现一些麻烦的事，后面的一些数据都是0。同理，假如一个班中的人数超过了50人，则数组定义的长度是无法足够存储的，会造成信息的缺失，乃至于数组的越界。因此，我们需要一个长度可以动态变化的数组，切片就刚好满足了这个特性。 </p><p>&emsp;&emsp;其实类似的需求还有很多，例如从文件中读取数据，但是并不知道文件中究竟有多少个数据。从网络输入流中读取信息，但不知道信息有多少字节。这种不确定性会对开发者造成很多不必要的麻烦，所以在工程项目中，切片所被运用的范围是比数组要广的，而在数学运算等领域，数组（矩阵）还是占据更多的位置。 </p><p>&emsp;&emsp;运用切片后，我们可以将上述的代码改写为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> grades [<span class="number">50</span>]<span class="keyword">int</span> = [<span class="number">50</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> slice = grades[:]</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">slice = <span class="built_in">append</span>(slice,<span class="number">100</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="切片的存储结构"><a href="#切片的存储结构" class="headerlink" title="切片的存储结构"></a>切片的存储结构</h3><p>&emsp;&emsp;介绍完切片的使用场景后，我们对切片的内存构造进行简要的讲解。首先我们考虑一个问题，在Go语言中这个数据类型为什么被称为切片，亦或说它究竟是谁的切片。弄清楚这个问题后，切片的内存构造就迎刃而解了，根据我们的入门程序来看可以知道：切片这种数据类型就是数组的切片，是数组的一部分。首先我们看一小段程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">fmt.Println(array)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序似乎并不难理解，因为我们只是在程序中定义并初始化了一个数组，这个数组具备自己的独立的对元素的控制权，此处也就不需要多做说明了，相信这个数组在内存中的存储形式也不需要多说了。接下来，我们在程序中添加两条语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">var</span> slice = array[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, array)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, slice)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从程序中，我们可以发现我们对array数组做出了某种操作并将结构赋值给一个slice变量，最后我们分别输出了array的数据类型以及slice的数据类型。其输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">[]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据两个输出结果，我们可以发现：对array进行的某种操作并没有改变array的任何属性，它依旧是一个10个元素的数组。而新定义的slice类型为[]int，这个结果我们在讲解数组的时候就提及过了，这个类型就是切片。接下来我们再输出此时array的值以及slice的值，我们可以发现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;切片内数据的输出值与数组内数据的输出值十分类似，只是说切片输出的值是数组中的某一部分，即数组的某个切片，那么切片数据在内存中是怎样存储的呢，它是不是像数组一样存储，我们进行分析。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">var</span> slice = array[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">slice[<span class="number">0</span>] = <span class="number">11</span></span><br><span class="line">fmt.Println(array)</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这一小段程序中，我们通过slice切片来对slice中的第0个值进行修改，并将其赋值为11，最后我们再次输出array的值以及slice的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">11</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span>]</span><br><span class="line">[<span class="number">11</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个结果中，我们可以发现，通过slice切片进行切片内的数据修改，直接影响到了数组中的数据，这与之前我们所说到的通过指针改变数据的现象十分相似。因此可以得到一个结论：切片的内存存储形式是与数组相关的，而且很大程度上切片是数组的某个引用，而不是相互独立的两个不同的连续的内存空间。我们再做一个小实验：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;array[<span class="number">0</span>])</span><br><span class="line">fmt.Printf(<span class="string">"%p"</span>, &amp;slice[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将切片中的第0个元素的物理地址输出来，并将数组中的第0个元素的物理地址输出来，我们会发现这两个输出结果是完全一致的，换句话说，slice和array是共用一套数据的。其内存构成我们用一个图来说明：<br><img src="/2020/03/06/32-%E5%88%87%E7%89%87%E5%BC%95%E5%85%A5/1.png" alt></p><p>&emsp;&emsp;所以说，Go语言中的切片是由三部分组成的，第一部分是数组中裁剪区的首地址，第二部分是切片目前的长度，第三部分则是当前切片的容量，len和cap这两个属性我们会在下一小节中精讲。由于数组的内存是连续的，因此对于切片而言，只需要明白裁剪部分的首地址和切片的数据类型，就可以轻松地通过加减法得到第i个值的内存地址及其数值，同时这也说明了为什么切片的数据发生修改会影响到其裁切的数组的值。</p><h3 id="切片的使用"><a href="#切片的使用" class="headerlink" title="切片的使用"></a>切片的使用</h3><p>&emsp;&emsp;由于切片的底层实现就是数组，因此切片的使用方式和数组的使用方式如出一辙。包括切片的两种遍历方式，切片下标初始值，是否出现溢出现象，这些特性都与数组完全相似。在这里我们再简要讲解一下。</p><h4 id="切片的定义与初始化"><a href="#切片的定义与初始化" class="headerlink" title="切片的定义与初始化"></a>切片的定义与初始化</h4><p>&emsp;&emsp;在Go语言中，切片的初始化方式有三种，在我们上一部分的代码讲解中，我们可以知道第一种定义方式就是借助一个定义好的数组进行裁剪得到一个切片。此时切片具备数组的引用，切片和数组同时可以控制内存中的数据。 </p><p>&emsp;&emsp;第二种方式便是采用Go语言中内建函数make的方式进行，通过make函数进行的内存分配是在堆区，且它只能运用在channel、map、以及slice的创建。其返回值的类型就是这三种类型本身。make函数的签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span> <span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以说make函数的参数中，需要指明返回值的类型是什么，如果我们传入了一个切片，则返回的就是一个切片。后面的可变参数中，在slice的内存分配上，往往是需要两个值的，分别为切片长度，以及切片容量。在这两个值中，切片容量可以省略，如若省略则代表其容量与长度是相同的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line">    slice[i] = i</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的这段程序中，我们通过make函数定义了一个切片，且对切片中的每个值进行赋值操作。在最后的输出中，我们可以发现输出结果中含有5个值，分别为0到4。此时在这段程序中，slice切片依旧与底层的一个数组向关联，只是此时这个数组是由切片所管理的，而不能像第一种定义方式一样控制底层数组。 </p><p>&emsp;&emsp;第三种初始化方式则和数组非常类似，唯一的区别就是在中括号中不写任何的值。我们在这里只简单地通过一个例子来讲解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过输出结果，我们可以看出：此时slice的数据类型是切片，且初始化过程是成功的。因此可以讲，数组与切片的初始化不同点只在于中括号中是否明确指定了固定的数字，一旦指定了或采用…来表示，则是数组。中括号中没有任何的值则是切片。</p><h4 id="切片的遍历与追加"><a href="#切片的遍历与追加" class="headerlink" title="切片的遍历与追加"></a>切片的遍历与追加</h4><p>&emsp;&emsp;在这个小部分中，我们首先简单地提及切片的遍历方式，由于其和数组的遍历方式完全一致，所以在这里我们只列出for循环以及for-range结构的遍历方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;既然我们讲切片相对于数组的优势就是切片是一种动态的数组，可以向切片结尾随时追加数据。而追加数据的方式则是Go语言的内建函数：append函数。其主要作用就是为了给某个切片追加元素，快速入门案例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段代码的含义是：为一个切片（[]int{1,2,3}）追加三个元素，且追加的元素为：4,5,6,追加元素过后将新的切片赋值给slice。其实在append的过程中，底层数组还是发生了一定的变化的，具体的变化我们会在下个小节的精讲中进行讲解。 </p><p>&emsp;&emsp;append函数可以将多个单独的元素追加到切片的结尾，同时也可以将另一个切片追加到某一个切片的结尾。当追加切片的时候，其传入的两个参数均是切片数据类型，并且在第二个切片后需要添加”<strong>…</strong>“这个特性则刚好可以满足于切片中删除某个元素的需求。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">slice = <span class="built_in">append</span>(slice[<span class="number">0</span>:<span class="number">2</span>], slice[<span class="number">3</span>:<span class="number">5</span>]...)</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们初始化了一个名为slice的切片，在接下来的一条语句中，我们提取出slice切片的前两个数据，又提取了切片的后两个数据，将这两个切片组合在一起后赋值给slice，最后输出结果。在结果中我们可以发现原切片中的第2个元素没有被任何一个切片所截取，因此相当于在slice切片中删除了一个元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在切片中删除第i个元素：</span><br><span class="line">slice = <span class="built_in">append</span>(slice[<span class="number">0</span>:i], slice[i+<span class="number">1</span>,<span class="built_in">len</span>(slice)...] )</span><br></pre></td></tr></table></figure><h4 id="切片的拷贝"><a href="#切片的拷贝" class="headerlink" title="切片的拷贝"></a>切片的拷贝</h4><p>&emsp;&emsp;在Go语言中，开发人员有专门为切片数据类型的拷贝封装了一个函数，也是内建函数copy，该函数具备两个参数，分别为两个切片，其含义为将第二个参数所代表的切片复制给第一个参数所代表的切片，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> slice2 = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">copy</span>(slice2, slice1)</span><br><span class="line">fmt.Println(slice2)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述代码案例中，我们可以发现copy函数成功地将slice1所代表的切片复制给了slice2所代表的切片。其中需要注意的一个问题为：当两个切片的长度不同的时候，复制过程是不会报错的，且复制结果是取两个切片中最短的切片作为最终的长度，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> slice2 = []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(slice2, slice1)</span><br><span class="line">fmt.Println(slice2)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，我们可以发现，slice1切片的长度为5，而slice2切片的长度为3。当将slice1复制给slice2的时候，其结果值保留了3个值，即slice1[0],slice1[1],slice1[2]。如果我们将copy中的slice1和slice2的位置对调，并输出slice1。我们可以发现，slice1中的前三个值发生了变化，变为了7,8,9，而后两个值依旧保持为4,5。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们通过数组的方式引入了切片的概念，并对切片的内存构成做出简要的讲解。同时我们也讲解了切片的定义方式、初始化方式以及追加数据删除数据等使用方式。可以说这个小节中的知识点都相对基础，且不难理解。在下个小节中，我们将针对切片进行更为深入的讲解、以及对一些使用时的注意事项进行列举。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-32-gt-切片引入&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-32-gt-切片引入&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;32&amp;gt; 切片引入&quot;&gt;&lt;/a&gt;Go语言从入门
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;31&gt; 二维数组与多维数组</title>
    <link href="http://yoursite.com/2020/03/05/31-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/03/05/31-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/</id>
    <published>2020-03-05T03:22:24.000Z</published>
    <updated>2020-03-05T03:25:04.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-31-gt-二维数组与多维数组"><a href="#Go语言从入门到放弃系列-lt-31-gt-二维数组与多维数组" class="headerlink" title="Go语言从入门到放弃系列&lt;31&gt; 二维数组与多维数组"></a>Go语言从入门到放弃系列&lt;31&gt; 二维数组与多维数组</h2><p>&emsp;&emsp;在之前的章节中，我们已经讲解了一维数组的定义方式、使用方式以及需要注意的几个点，同时也针对数组排序的需求对数组这个知识点进行了代码的书写与讲解。在这个小节中，我们将基于一维数组的概念推广到二维数组乃至于多维数组。对二维数组的定义方式、使用方式等做出讲解，并在最后通过二维数组走迷宫的案例进行代码讲解。</p><h3 id="二维数组的引入"><a href="#二维数组的引入" class="headerlink" title="二维数组的引入"></a>二维数组的引入</h3><p>&emsp;&emsp;在一维数组的讲解中，我们介绍了一维数组的概念，如果我们将一维数组比作为一个线性的数据存储格式，那么二维数组就是一个平面向的存储方式，同理推广到高维数组就可以理解为数组存储的多维空间。我们首先提出一个需求：通过Go语言完成一个课程表的显示，假设每周除去双休日需要学习五天，每天只有八节课，没有课的地方用“-”来表示。 </p><p>&emsp;&emsp;针对这个需求，如果我们采用之前学到的知识来完成，我们可能会定义五个一维数组来完成。每个一维数组存储当天的课程信息。假设不同周的课程是相同的，那么可能会写出如下的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> monday [<span class="number">8</span>]<span class="keyword">string</span> = [<span class="number">8</span>]<span class="keyword">string</span>&#123;<span class="string">"Math"</span>,<span class="string">"Physics"</span>,...&#125;</span><br><span class="line"><span class="keyword">var</span> tuesday [<span class="number">8</span>]<span class="keyword">string</span> = [<span class="number">8</span>]<span class="keyword">string</span>&#123;<span class="string">"Math"</span>,<span class="string">"Physics"</span>,...&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种写法是可以满足需求的，但是如果联想到我们介绍一维数组时所举的例子，我们会发现程序需要改进的地方是基本相同的，我们依旧定义了太多的变量，尽管每个变量都是一维数组，所以我们希望存在这样一个一维数组，这个一维数组中的每一个元素都是一维数组。在一维的前提下再添一维，就引出了二维数组。 </p><p>&emsp;&emsp;我们再次回忆一维数组的定义方式：var num [3]int，通过这个定义方式我们可以知道num是一个具有3个元素的数组，且每个元素都是int。现在假如我们定义是 var num [3][4]int，依旧采用刚刚的分析方式，我们可以知道num是一个具有3个元素的数组，且每个元素都是具备4个int元素的数组，换句话说即申请了一个三行四列的二维数组。二维数组的定义方式就是如此。</p><h3 id="二维数组的内存构成"><a href="#二维数组的内存构成" class="headerlink" title="二维数组的内存构成"></a>二维数组的内存构成</h3><p>&emsp;&emsp;介绍这个问题的原因是：我们计算机中的硬件内存是一个线性内存，因此通过一维的线性内存来反映二维的乃至于多维的数组是需要通过一些方式的。而不同的计算机语言对于这个一维到二维的映射方式也是不同的。主流思想有两个：按行存储（例如C语言），按列存储（例如Fortran语言），因此明白数组在内存中的结构是需要的，它会决定数组定义的简化方式以及快速查找的计算模型。首先我们通过一个案例来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;nums)</span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;nums[<span class="number">0</span>])</span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;nums[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序构成十分简单，我们单纯地定义了一个2行3列的整数型的数组，由于我们未对其进行初始化或赋值，因此数组中的每一个值都是0，即该数据类型的零值。接下来，我们输出了数组的首地址、第0行的地址、以及第1行的地址，我们可以发现其结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xc000080060</span></span><br><span class="line"><span class="number">0xc000080060</span></span><br><span class="line"><span class="number">0xc000080078</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过程序的输出结果，我们可以发现数组的地址就是第0行数组的地址，这个似乎不需要解释。其次我们可以发现，nums[0]的物理地址与nums[1]的物理地址相差了18个字节（十六进制），换算成十进制则是相差了24个字节。由于笔者的计算机是64位操作系统，因此一个int类型占据了8个字节，这样看来相差的24个字节刚好满足了存储3个int类型数据。用一个图解来表示则为：<br> <img src="/2020/03/05/31-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/1.png" alt></p><p>&emsp;&emsp;现在我们通过二维数组的内存构成来推导出高维数组的表示方式，同样地，计算机内存是线性的因此需要通过映射来完成。例如我们定义了一个三维数组：var nums [2][3][4]int，我们可以推断出：nums[0]的地址与nums[1]的地址相差：3*4*8=96个字节，nums[0][0]与nums[0][1]的地址相差：4*8=32个字节，nums[0][0][0]与nums[0][0][1]的地址相差8个字节。 </p><p>&emsp;&emsp;因此我们可以推断出：在Go语言中，数组的存储形式是按行存储，否则连续的两个元素之间的地址差将会是该数据类型的整数倍，而不是单独的一个数据空间。</p><h3 id="二维数组的定义与初始化"><a href="#二维数组的定义与初始化" class="headerlink" title="二维数组的定义与初始化"></a>二维数组的定义与初始化</h3><p>&emsp;&emsp;参照于一维数组的定义与初始化形式，二维数组也有四种基本的初始化方式，接下来我们逐一地进行讲解。首先二维数组的定义方式我们在入门案例中已经提及了，这里就不过多的讲解了。我们着重说明初始化的方式。 </p><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>&emsp;&emsp;第一种方式就是将所有需要的信息完全写在初始化过程中，不省略任何一个元素，其初始化方式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 [大小][大小]数据类型 = [大小][大小]数据类型&#123;&#123;数据，...&#125;,&#123;数据，...&#125;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们举一个例子，定义一个两行三列的数组，且初始化其值为1到6：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line">fmt.Println(nums)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们可以发现，由于1,2,3处在同一行，4,5,6处在同一行，因此，将同一行所对应的元素用大括号包裹起来，这样也有助于编译器分别对不同的值进行初始化。同时，每一行只有三个元素，因此每行最多只能初始化三个值，一旦当前行中初始化的值不够定义的个数，则用零值来补全，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时由于我们在第0行中只初始化了两个值，因此这个数组的初始化结果其实为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>&emsp;&emsp;由于我们在初始化过程中用大括号对每行数据进行了指定，因此，程序在编译过程中就可以知道这个数组究竟有几行，因此行数的大小是可以不指定的，通过三个点号来代替，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums [<span class="number">2</span>][<span class="number">3</span>] = [...][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种初始化的方式相对来说比较鸡肋，因为在数据定义的时候已经指定了数组的行数和列数，那在后面通过三个点号来表示就完全没有意义了。其实这个特性主要是用在数据类型的自动推导中，在这里暂时不做讲解。</p><h4 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h4><p>&emsp;&emsp;基本数据类型可以通过自动推导得到，那二维数组当然也具备这个特性，因此，我们介绍的第三个初始化方式就是数组的自动推导，根据初始化过程完成数据类型的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 = [大小][大小]数据类型&#123;&#123;初值,...&#125;,&#123;初值,...&#125;...&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种方式与之前提及的各种数据类型的自动推导完全一致，如果明白了方式一的定义方式，这个就迎刃而解了。当然，我们也可以通过:=的方式来完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名 := [大小][大小]数据类型&#123;&#123;初值,...&#125;,&#123;初值,...&#125;...&#125;</span><br></pre></td></tr></table></figure><h4 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a>方式四</h4><p>&emsp;&emsp;第四种方式其实就是省略行数的自动推导类型方式，这个方式与我们提及的方式二有所不同，具体不同点我们会进行讲解。首先我们先列出方式四的初始化格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 = [...][大小]数据类型&#123;&#123;初值,...&#125;,&#123;初值,...&#125;...&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过大括号定义了具体的行元素，那么有几行就可以知晓了，因此省略行数的自动推导所得到的数据类型与初始化中的大括号对数相关。这点与方式二不同，方式二得到的数据行数是通过定义指明了的，而方式四的数据行数是推导的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span> = [...][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(nums))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的这段通过方式二初始化的程序是编译不通过的，其报错的原因是：自动推导出[1][3]int的数组而赋值给[2][3]int的数组，出现了数据类型不匹配的错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [...][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(nums))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;而这一段程序是不会出现错误的，输出的结果即二维数组的行数为1，此时的nums数组为一行三列。</p><h3 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h3><p>&emsp;&emsp;在介绍二维数组的定义过后，我们继续讲解二维数组的使用方式，而众多的使用方式中，遍历是最为常见之一，因此二维数组的遍历我们在这里简单地提及。</p><h4 id="双层for循环遍历"><a href="#双层for循环遍历" class="headerlink" title="双层for循环遍历"></a>双层for循环遍历</h4><p>&emsp;&emsp;在二维数组引入的过程中，我们将二维数组看作成元素为数组的数组，因此通过这个理解方式，我们可以发现：对外层的大数组取其长度，（即得到多少个一维数组）就是该二维数组的行数，同理进入到大数组中的元素（小数组）后，该长度就是二维数组的列数，因此二维数组的遍历方式可以为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i&lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j&lt; <span class="built_in">len</span>(nums[<span class="number">0</span>]); j++ &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//取元素时通过nums[i][j]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-range方式遍历"><a href="#for-range方式遍历" class="headerlink" title="for-range方式遍历"></a>for-range方式遍历</h4><p>&emsp;&emsp;for-range遍历方式与上述双重循环类似，因为for-range其本质也就是一个循环。在for-range结构中，我们通过传入的数组可以得到该数组中每个元素的位置以及值，而对于二维数组而言，通过for-range得到其元素其实就是得到了一个一维数组，再对该一维数组进行for-range操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, valuei := <span class="keyword">range</span> nums &#123;</span><br><span class="line">    <span class="keyword">for</span> j, valuej := <span class="keyword">range</span> valuei &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//此时valuej就是遍历到的元素，i，j就是该元素的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;介绍了以上两种二维数组的遍历方式之后，对于高维数组的扩展就不必多说了，无非就是多个for循环的嵌套，或者for-range结构的嵌套，当然for循环与for-range结构混用也是没有问题的。</p><h3 id="二维数组代码举例"><a href="#二维数组代码举例" class="headerlink" title="二维数组代码举例"></a>二维数组代码举例</h3><p>&emsp;&emsp;在这个部分中，我们将针对一个走迷宫的初级问题来对二维数组的使用进行举例，需求如下：假设有一个N乘以N的数组，在数组中0代表空地，1代表墙，2代表目的地，问给定一个数组和一个起点，是否存在一条路径使得从起点到终点有一条通路。 </p><p>&emsp;&emsp;例如，我们使用如下的一个迷宫矩阵，且设定起始位置为（1,1）点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这里我们采用递归的方式进行深度优先搜索，当然这个方式不是一个非常合适的方法，只是说其中涉及到递归的技术，以及逻辑表达式的一些问题，可以复习一下前面的知识，就用这种方式举例。当然，实现方式可以不同，面对一个问题多个人就有多个解法。解法之一的思想如下： </p><p>&emsp;&emsp;我们可以将数组中的点分为三类，第一类是可继续行动的点，第二类是不可行动的点，第三类就是终点。针对于这三种不同的点逻辑是不同的。假设我们有一个返回值是布尔变量的函数，参数是当前的x、y值，当当前的点为不可行动的点（如数组中的1）时，返回false，当这个点是终点的时候，返回值是true，当这个点是一个空地，那么就需要判断它的上下左右的点能否到达终点。且上下左右能到终点的逻辑呈现或的关系，即一旦有一个方向能到终点，该点就可以通向终点。回溯回去，就可以证明从起点出发可以到达终点。函数逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CanGetToDes</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> maze[x][y] == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> maze[x][y] == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> maze[x][y] == <span class="number">0</span> &#123;</span><br><span class="line">        maze[x][y] = <span class="number">1</span></span><br><span class="line">        <span class="comment">//在这里我们将其设定为1，代表这个点已经搜索过了，以后不要再搜索了，否则会出现无限循环。</span></span><br><span class="line">        <span class="keyword">return</span> CanGetToDes(x<span class="number">-1</span>, y) || CanGetToDes(x+<span class="number">1</span>, y) || CanGetToDes(x, y<span class="number">-1</span>) || CanGetToDes(x, y+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;主函数就负责调用该函数即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(CanGetToDes(<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后将maze数组定义为全局变量，使得各个函数都可以调用该变量，当然这只是为了简便，也可以通过函数参数将maze数组进行传递而不需要全局变量。全部的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maze [<span class="number">6</span>][<span class="number">6</span>]<span class="keyword">int</span> = [<span class="number">6</span>][<span class="number">6</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(CanGetToDes(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CanGetToDes</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> maze[x][y] == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> maze[x][y] == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> maze[x][y] == <span class="number">0</span> &#123;</span><br><span class="line">        maze[x][y] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> CanGetToDes(x<span class="number">-1</span>, y) || CanGetToDes(x+<span class="number">1</span>, y) || CanGetToDes(x, y<span class="number">-1</span>) || CanGetToDes(x, y+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据输出结果，我们可以发现输出为true，即存在一条通路使得起点到达终点，如果我们修改了maze数组，例如将maze[3][4]的值修改为1，则输出结果会成为false。当然，我们可以根据这个需求和方法进行加深，例如：求取从起点到终点的最短路径，如果无法到达则输入-1。程序实现也是可以基于当前的这个代码进行扩展的，如果读者有兴趣，可以自行探索并完成代码的书写。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们集中讲解了二维数组的定义以及使用方式，进而对多维数组进行引出和拓展。我们讲解了二维数组的内存构成、四种初始化方式以及常用的遍历方式。最后我们通过走迷宫这个小案例来完成二维数组的代码案例。在下一小节中，我们将会介绍到切片数据类型，这种数据类型与数组十分相似，在看下一小节之前一定明白数组的定义方式，否则容易相互混淆。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-31-gt-二维数组与多维数组&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-31-gt-二维数组与多维数组&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;31&amp;gt; 二维数组与多维
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;30&gt; 数组代码篇-几种排序方式</title>
    <link href="http://yoursite.com/2020/03/04/30-%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81%E7%AF%87-%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/04/30-%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81%E7%AF%87-%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/</id>
    <published>2020-03-04T07:12:23.000Z</published>
    <updated>2020-03-04T07:13:03.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-30-gt-数组代码篇-几种排序方式"><a href="#Go语言从入门到放弃系列-lt-30-gt-数组代码篇-几种排序方式" class="headerlink" title="Go语言从入门到放弃系列&lt;30&gt; 数组代码篇-几种排序方式"></a>Go语言从入门到放弃系列&lt;30&gt; 数组代码篇-几种排序方式</h2><p>&emsp;&emsp;在上一小节中，我们集中讲解了数组的定义方式、使用方式、以及其使用的各个细节。在这个小节中，我们将针对数组的使用讲解一个代码篇，以对数组中的各个数字进行排序的需求讲解几个基本的排序算法。这几个算法原理十分简单，但是是之后学习数据结构的基础算法，因此是需要掌握的。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>&emsp;&emsp;首先我们先分析选择排序中大循环的一个循环体，选择排序的核心思想是每一次找到数组中最小的数（或最大的数），将该最小的数与第一个数相交换。这样一轮操作后，最小的数就到了最前面，然后我们取第二个数到最后一个数再实行同一个操作，就可以得到最小的数、次小的数。重复以上操作直到完全排序完成。 </p><p>&emsp;&emsp;首先我们完成内部循环的一轮操作，我们均以降序排序为例。</p><h4 id="1-寻找数组中最大的数"><a href="#1-寻找数组中最大的数" class="headerlink" title="1. 寻找数组中最大的数"></a>1. 寻找数组中最大的数</h4><p>&emsp;&emsp;给定一个数组，寻找数组中最大的数，可以借助一个临时变量来完成。遍历数组，将每一个元素与临时变量相比，当元素大于临时变量时，则用该元素替换临时变量的值，否则对比下一个数。由于我们再后续需要数组元素的交换，因此这里的临时变量我们将存储元素的下标，程序如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">10</span>]<span class="keyword">int</span> = [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> maxPos = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[maxPos] &#123;</span><br><span class="line">            maxPos = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"最大值为："</span>, nums[maxPos])</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们设定一个标兵maxPos，并令该值为0，即指代第一个元素。然后在遍历中，我们判断遍历到的值nums[i]与标兵所对应的值nums[maxPos]的大小关系，一旦遍历到的值比标兵对应的值大，标兵所指代的值就发生了变化。</p><h4 id="2-基于寻找最大值完成排序"><a href="#2-基于寻找最大值完成排序" class="headerlink" title="2. 基于寻找最大值完成排序"></a>2. 基于寻找最大值完成排序</h4><p>&emsp;&emsp;基于寻找到的最大值，我们可以将该最大值与数组的第一个元素交换，然后我们取后九个值做同样的操作，然后取后八个值……这个操作总共需要做10次，每次操作需要遍历的值逐次减小，因此其二重循环结构为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j:= i+<span class="number">1</span>; j&lt;<span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在我们将全部的代码完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">10</span>]<span class="keyword">int</span> = [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"排序前："</span>, nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">var</span> maxPos <span class="keyword">int</span> = i</span><br><span class="line">        <span class="comment">//找到最大值</span></span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[maxPos] &#123;</span><br><span class="line">                maxPos = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换顺序</span></span><br><span class="line">        nums[i], nums[maxPos] = nums[maxPos], nums[i]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"排序后："</span>, nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中需要注意的一个问题是：标兵的定义位置。由于每次寻找最大值都需要对标兵进行初始化操作，因此maxPos = i的这个操作一定放在外层循环里面，初学者可能会失手将其写在最外面或者忘记对其进行初始化值，排序结构就会出现错误。</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>&emsp;&emsp;插入排序的核心思想是，在前面的数组已经是有序的前提下，逐一地为每一个元素寻找到其合适的位置。我们可以先想象这样的一个场景：假如几个人在打牌，且正在处于抓牌的阶段，我们手中已经有了几个手牌，且是有序的，当我们再抓起一张牌的时候，我们会将其插入到手牌中的某个位置。然后手牌又变成了有序的状态直到抓下一张牌。</p><h4 id="1-寻找一个元素的合适位置"><a href="#1-寻找一个元素的合适位置" class="headerlink" title="1. 寻找一个元素的合适位置"></a>1. 寻找一个元素的合适位置</h4><p>&emsp;&emsp;这个问题是有一个假设的，这个假设我们在之前也提到了，即：最后一个元素之前的所有元素均是有序的，否则这一轮排序就是无用的。其做法为：数组从后到前进行遍历，跟踪最后一个无序的元素，当该元素与前一元素处于无序状态时，将这两个元素交换，我们用一个例子来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开始     ：   <span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line">第一次交换  ：  <span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line">第二次交换  ：  <span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line">第三次交换  ：  <span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line">结束</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的过程就相当于为4这个元素寻找到其正确的位置，我们用代码来实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">10</span>]<span class="keyword">int</span> = [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            nums[i], nums[i<span class="number">-1</span>] = nums[i<span class="number">-1</span>], nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中有两个需要注意的问题，第一个问题是i的初始元素。我们为i初始赋值为len(nums)-1是因为数组下标是从0开始到N-1位置，因此这个减一操作是必须要写的，否则会出现数组越界。第二个问题是循环的结束条件，我们设定的调试是i&gt;0而不是i&gt;=0，因为在循环体中我们判断i下标与i-1下标的值的大小，因此当i=0的时候，i-1的操作会令其数组越界。</p><h4 id="2-从没有元素开始进行插入排序"><a href="#2-从没有元素开始进行插入排序" class="headerlink" title="2. 从没有元素开始进行插入排序"></a>2. 从没有元素开始进行插入排序</h4><p>&emsp;&emsp;明白了上述的过程后，我们开始讲解插入排序。首先将数组分为两个部分，第一个部分是有序部分，第二个部分为无序部分。在第一轮循环时，我们将无序部分中的第一个值赋给有序部分，由于此时有序部分只有一个值，所以其自然有序。然后第二轮时，我们再将无序部分中的第一个值赋给有序部分，此时无序部分只有N-2个值，有序部分有2个值，我们将有序部分进行插入操作。然后执行第三轮…直到完全排序完，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">10</span>]<span class="keyword">int</span> = [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i; j &gt; <span class="number">0</span>; j-- &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j<span class="number">-1</span>] &#123;</span><br><span class="line">                nums[j], nums[j<span class="number">-1</span>] = nums[j<span class="number">-1</span>], nums[j]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，i所对应的外层循环可以表现为有序部分与无序部分的交界线，它的变化可以代表有序部分的个数。在内层循环中，j的初始值应该是有序部分的最后一个值，因此其初始化值就为i。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>&emsp;&emsp;在冒泡排序中，我们可以想象一个场景：在烧开的水中小的水泡处在更下的位置，大的水泡处于更靠上面的位置。每一次的循环都希望让最大的水泡跑到最上面就是这个算法的核心思想。</p><h4 id="1-单次循环的过程"><a href="#1-单次循环的过程" class="headerlink" title="1. 单次循环的过程"></a>1. 单次循环的过程</h4><p>&emsp;&emsp;单次循环的目的就是将最大的泡泡跑到最上面，其算法为：遍历整个数组，当当前的值大于其后面的下一个值时，将这两个值交换，否则不动。这个过程就类似于推着大的水泡向前进，当有更大的水泡时，就开始推动更大的水泡，我们举个例子说明一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始值为：    <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span>与<span class="number">1</span>的比较：    <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span>与<span class="number">2</span>的比较：    <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span>与<span class="number">3</span>的比较：    <span class="number">2</span> <span class="number">4</span> <span class="number">1</span> <span class="number">6</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span>与<span class="number">4</span>的比较：    <span class="number">2</span> <span class="number">4</span> <span class="number">1</span> <span class="number">3</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span>与<span class="number">5</span>的比较：    <span class="number">2</span> <span class="number">4</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">结束</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上述的演示，我们可以发现，在一轮的冒泡过程，最大的数据会被推到最后的位置（升序排序），正如同大的水泡在水中上升。我们通过程序实现该操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">10</span>]<span class="keyword">int</span> = [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">            nums[i], nums[i+<span class="number">1</span>] = nums[i+<span class="number">1</span>], nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在程序中需要注意的一个点为：循环变量i的循环条件。在数组中下标最大值为N-1，但是由于循环体中存在着i与i+1对应的值的比较，因此，循环条件需要为i&lt;N-1，而不是i&lt;=N-1，否则会出现数组越界的错误。</p><h4 id="2-冒泡排序全过程"><a href="#2-冒泡排序全过程" class="headerlink" title="2. 冒泡排序全过程"></a>2. 冒泡排序全过程</h4><p>&emsp;&emsp;基于上述的过程，我们可以知道在一轮冒泡中，最大的数据被推到了最后的位置，在这之前的数据可能是无序的。因此我们就重复上述的过程，第一轮将N个数中最大的推到顶，第二轮将N-1个数中的最大值推向次大的位置…直到完全排序结束。其程序实现为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">10</span>]<span class="keyword">int</span> = [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(nums)-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">                nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;依旧，这段程序中需要注意的点是i变量与j变量的相互关系，以及循环条件的判定，如若判定失误，则极有可能出现数组越界的问题。可以说冒泡排序是这几个排序方式中代码实现最为简单的方式了，也是最为基础的一个排序算法。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们讲解了三个数组的排序方式，分别为选择排序、插入排序、以及冒泡排序。在这三种排序方式中，当数据量相对较大的时候，插入排序的运行速度会快于选择排序的速度，选择排序的速度会快于冒泡排序的速度。尽管三种排序算法的时间复杂度均是相同的，但是实现的方式不同、比较的次数不同都会影响机器执行的速度。其具体为什么三种算法的速度不甚相同可以自行考虑一下，这个不会出现在考试中的任何角落的。 </p><p>&emsp;&emsp;在下一个小节中，我们将接触到二维数组乃至于推广到高维数组的概念、定义方式、以及使用方式和注意细节等知识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-30-gt-数组代码篇-几种排序方式&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-30-gt-数组代码篇-几种排序方式&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;30&amp;gt; 数
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;29&gt; 数组细节讲解</title>
    <link href="http://yoursite.com/2020/03/03/29-%E6%95%B0%E7%BB%84%E7%BB%86%E8%8A%82%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/03/03/29-%E6%95%B0%E7%BB%84%E7%BB%86%E8%8A%82%E8%AE%B2%E8%A7%A3/</id>
    <published>2020-03-03T13:04:03.000Z</published>
    <updated>2020-03-03T13:04:50.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-29-gt-数组细节讲解"><a href="#Go语言从入门到放弃系列-lt-29-gt-数组细节讲解" class="headerlink" title="Go语言从入门到放弃系列&lt;29&gt; 数组细节讲解"></a>Go语言从入门到放弃系列&lt;29&gt; 数组细节讲解</h2><p>&emsp;&emsp;在上一个小节中，我们对Go语言的数组的知识点进行了引出和简要的介绍，并通过一个快速入门案例来比较了数组实现方式与单纯定义多个变量的方式的不同点。不仅如此我们也讲解了数组的内存构成与两种不同的数组遍历方式。在这个小节中，我们将针对数组的知识点进行详细的细节讲解，并对每个细节做出一定的案例说明。</p><h4 id="1-数组是多个相同类型的数据的集合，其长度和数据类型一旦声明就不可以改变。"><a href="#1-数组是多个相同类型的数据的集合，其长度和数据类型一旦声明就不可以改变。" class="headerlink" title="1. 数组是多个相同类型的数据的集合，其长度和数据类型一旦声明就不可以改变。"></a>1. 数组是多个相同类型的数据的集合，其长度和数据类型一旦声明就不可以改变。</h4><p>&emsp;&emsp;在上一小节的数组定义中，我们就提到了这个概念。首先数组长度是不可以发生变化的，即数组定义中定义了N个数据，在使用过程中就只能用0到（N-1）的下标，一旦超出了这个范围就会数组越界，且不会自动改变长度。同样地，如果我们在数组中赋了一个其他类型的变量的值，编译时也会报错，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">10.5</span>    <span class="comment">//此处会报错</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将一个浮点数数据直接赋给一个int型的变量，在数据的相互转化那一小节中我们就明确提及过：Go语言中的数据类型转化是十分严格的，因此这段程序是根本无法执行的。</p><h4 id="2-var-arr-int这种定义方式不是数组定义。"><a href="#2-var-arr-int这种定义方式不是数组定义。" class="headerlink" title="2. var arr []int这种定义方式不是数组定义。"></a>2. var arr []int这种定义方式不是数组定义。</h4><p>&emsp;&emsp;有些人在刚接触到数组的时候在网上查资料，会发现如题一般的定义方式，且使用的方式以及注意的点都大致相同，因此会感到十分迷惑、认为数组定义是可以不需要指定长度的。在这里我们说明一下，这种定义方式是<strong>切片</strong>的定义方式，而不是数组。对于切片的讲解我们将会在下几个小节中进行详细的说明，此处暂时不做讲解。</p><h4 id="3-数组中的元素可以是任何的数据类型，包括值类型和引用类型，但是不可以相互混用。"><a href="#3-数组中的元素可以是任何的数据类型，包括值类型和引用类型，但是不可以相互混用。" class="headerlink" title="3. 数组中的元素可以是任何的数据类型，包括值类型和引用类型，但是不可以相互混用。"></a>3. 数组中的元素可以是任何的数据类型，包括值类型和引用类型，但是不可以相互混用。</h4><p>&emsp;&emsp;数组中可以存放多个值类型数据，这个我们就不再做过多的演示了，因为之前的例子几乎都是值类型的。不仅如此，数组中当然是可以存放引用类型的，我们简单地举一个小例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> points [<span class="number">3</span>]*<span class="keyword">int</span></span><br><span class="line">    fmt.Println(points)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的程序非常的简单，我们定义一个存放三个整数指针的数组，并且直接输出该数组中的值，由于我们并没有对数组中的指针进行任何的操作，因此这三个指针都是空指针，其输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;<span class="literal">nil</span>&gt; &lt;<span class="literal">nil</span>&gt; &lt;<span class="literal">nil</span>&gt;]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个输出结果也刚好证实了数组中是真实存放指针的。</p><h4 id="4-存放指针的数组和指向数组的指针。"><a href="#4-存放指针的数组和指向数组的指针。" class="headerlink" title="4. 存放指针的数组和指向数组的指针。"></a>4. 存放指针的数组和指向数组的指针。</h4><p>&emsp;&emsp;这两个概念在初学者看来是最为难以分清的两种概念，甚至再引出存放指针的数组的指针，概念上相对可以分得清，但是到了程序中看到其定义就会比较容易混淆，我们分别举出对应的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points [<span class="number">3</span>]*<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个对数组的定义我们在上一个细节点的例子中就已然提及了，并且我们根据其输出也知道了其含义。这种定义方式是<strong>定义了一个三个元素的数组，数组中的元素是int指针</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points *[<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">fmt.Println(points)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种定义方式和上一个不同的点为：星号位置和中括号位置不相同，这种定义方式星号的位置在中括号的前面，此时定义的其实是一个指向数组的指针，输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们依旧没有对指针进行任何操作，所以输出为空指针，同时我们也可以发现：输出结果只有一个值，且没有被中括号所包裹，因此这段程序<strong>*定义了一个指针，这个指针指向了一个数组，指向的数组存放三个整数</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points *[<span class="number">3</span>]*<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种第三个定义方式想必也不难理解了，在中括号的左右均有星号的存在，其含义为：<strong>定义了一个指针，这个指针指向了一个数组，这个数组存放了三个整数指针。</strong></p><p>&emsp;&emsp;造成这个现象的原因其实就是运算符优先级的问题，我们在运算符细节中讲解了运算符的优先级且列出了不同运算符的优先级的表格。根据表格我们可以看到中括号的优先级是高于星号的，因此在第三种定义中：中括号首先和后面的星号结合，代表数组中有三个指针，其次是第一个星号与后面向结合，代表定义结果是一个指针，最后是第二个星号与int相结合，代表数组中存放的指针是int型指针。</p><h4 id="5-数组创建后如果没有为元素赋值，其元素具备默认值。"><a href="#5-数组创建后如果没有为元素赋值，其元素具备默认值。" class="headerlink" title="5. 数组创建后如果没有为元素赋值，其元素具备默认值。"></a>5. 数组创建后如果没有为元素赋值，其元素具备默认值。</h4><p>&emsp;&emsp;我们在基本数据类型的小节中讲解到：每个数据类型都有一个默认值，也称之为零值，是当变量定义但是没有进行赋值的时候所存放的值。在数组中这个规则依旧适用，例如：定义一个整数的数组，定义后其中的所有元素都是0。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数值类型数组  ： 默认值<span class="number">0</span></span><br><span class="line">字符串数组  ： 默认值为<span class="string">""</span></span><br><span class="line"><span class="keyword">bool</span>型数组  ： 默认值为<span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="6-数组是值类型，因此在参数传递过程中是复制后再传递"><a href="#6-数组是值类型，因此在参数传递过程中是复制后再传递" class="headerlink" title="6. 数组是值类型，因此在参数传递过程中是复制后再传递"></a>6. 数组是值类型，因此在参数传递过程中是复制后再传递</h4><p>&emsp;&emsp;针对值类型与引用类型我们之前已然有所提及，其最显著的区别就是作为参数传递后，其他函数中对其修改是否会影响到原来的值。既然数组是值类型，那么就满足我们之前所说的运行时栈区结构等，我们举一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(nums [3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    nums[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">"modify函数中:"</span>, nums)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    modify(nums)</span><br><span class="line">    fmt.Println(<span class="string">"主函数中:"</span>, nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们在主函数定义了一个存放三个整数的数组，并初始化其值为1,2,3，然后我们又定义了一个modify函数并接受数组变量为参数，将该参数数组中的第1个值（从0开始）改变为10，然后输出，最后返回到主函数再对nums数组进行输出。我们得到的结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modify函数中: [<span class="number">1</span> <span class="number">10</span> <span class="number">3</span>]</span><br><span class="line">主函数中: [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从结果中我们可以看出：modify函数中对nums数组进行的修改并没有影响到main函数中的nums数据，尽管nums数组被当做参数传入了modify函数。这个特性与我们之前介绍的相符合，在程序执行过程中，main函数栈中存在一个nums数组，同时在modify函数中也存在一个数组，这两个数组只是值相同而地址完全不同。当modify函数进行修改的时候，只修改了其中的数组而没有修改主函数中的数组。 </p><p>&emsp;&emsp;数组的这种参数传递特性决定了在传参时必定要进行一次数组所有值的复制，因此当数组空间很大，且需要多个函数传递时（例如递归），每个函数中都有等大的数组，这对内存其实是一个很大的开销，因此在数组作为参数进行传递时，我们更多地使用的是指向数组的指针进行传递，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(nums *[3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    (*nums)[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">"modify函数中:"</span>, *nums)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    modify(&amp;nums)</span><br><span class="line">    fmt.Println(<span class="string">"主函数中:"</span>, nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们修改了modify函数的函数签名，即将传入数组修改成了传入一个指针，在函数体中根据指针进行修改数组的值。同时我们在主函数传入的参数则是nums数组的物理地址。由于变成了指针的传递，所以modify函数中对于数组中的值的修改就会影响主函数中的值了，其输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modify函数中: [<span class="number">1</span> <span class="number">10</span> <span class="number">3</span>]</span><br><span class="line">主函数中: [<span class="number">1</span> <span class="number">10</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结果中显示，主函数中的数组的第1个值也变成了10，执行过程可以理解为：主函数将数组的地址（其实是一个整数）传给了modify函数，因此modify函数根据地址进行修改就对主函数中的数组进行了修改。其过程与单个变量的指针传递相同，我们在函数的那一小节中也有所提及，这里就不做更多的讲解了。 </p><p>&emsp;&emsp;这里还有一个非常毁三观的彩蛋，Go语言开发者为了简化值类型与引用类型所产生的迷惑性，而对底层进行了优化，编译器可以自行判断变量是个值还是个指针，从而进行对应的正确的使用，例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*nums)[<span class="number">1</span>] = <span class="number">10</span>    改为：</span><br><span class="line">nums[<span class="number">1</span>] = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种改动丝毫不影响程序的编译以及运行，在一般的开发语言中，这是一个语法错误，但是在Go中优化后就自动免除了这个错误。但是，这个特性非常不建议新手来使用，区分值与指针是十分重要的。一旦开发者日后不进行Go开发而从事其他语言开发，在这一点上会出现很多的问题，因此：<strong>这个特性我只会在这个小节中提及一次，并在后面的所有小节中再不会出现。（此处来自后期钰的嘲讽：天真！太天真！）</strong></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们针对数组的诸多知识点总结出六条相对重要的细节，这些细节在平时的开发过程中需要注意。尤其对指针数组和数组指针的概念做出明确的划分，同时对于数组是值类型这个特性要有所了解以及对数组的指针传递进行良好的掌握。在下一小节中，我们将针对于数组的几个排序方式进行精讲，也算是对数组这个知识点进行集中的代码举例。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-29-gt-数组细节讲解&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-29-gt-数组细节讲解&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;29&amp;gt; 数组细节讲解&quot;&gt;&lt;/a&gt;G
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;28&gt; 数组引入</title>
    <link href="http://yoursite.com/2020/03/02/28-%E6%95%B0%E7%BB%84%E5%BC%95%E5%85%A5/"/>
    <id>http://yoursite.com/2020/03/02/28-%E6%95%B0%E7%BB%84%E5%BC%95%E5%85%A5/</id>
    <published>2020-03-02T08:58:57.000Z</published>
    <updated>2020-03-02T08:59:57.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-28-gt-数组引入"><a href="#Go语言从入门到放弃系列-lt-28-gt-数组引入" class="headerlink" title="Go语言从入门到放弃系列&lt;28&gt; 数组引入"></a>Go语言从入门到放弃系列&lt;28&gt; 数组引入</h2><p>&emsp;&emsp;在这之前的各个小节中，我们所接触到的都是简单的数据类型。包括指针类型在内，每一个变量都只可以表示一个值，且这个值的类型一旦确定就不可以改变。在这几个小节中，我们将会接触到Go语言中的一个复杂数据类型，数组。且在这一小节中，我们将引出数组的定义与使用场景，并对其基础操作进行简要的说明。</p><h3 id="数组的引入"><a href="#数组的引入" class="headerlink" title="数组的引入"></a>数组的引入</h3><p>&emsp;&emsp;现在我们依旧通过一个案例来完成数组的引入，我们现在有这样一个需求：假设一个小班级里面有五个人，要求输入每一个人的成绩，最后输出其平均成绩。这个需求我们如果使用之前的方式来完成也是没有难度的，我们可以定义五个变量，分别输入后再取平均值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> grade1, grade2, grade3, grade4, grade5 <span class="keyword">float32</span></span><br><span class="line">    fmt.Scanln(&amp;grade1)</span><br><span class="line">    fmt.Scanln(&amp;grade2)</span><br><span class="line">    fmt.Scanln(&amp;grade3)</span><br><span class="line">    fmt.Scanln(&amp;grade4)</span><br><span class="line">    fmt.Scanln(&amp;grade5)</span><br><span class="line">    <span class="keyword">var</span> average <span class="keyword">float32</span> = (grade1 + grade2 + grade3 + grade4 + grade5) / <span class="number">5</span></span><br><span class="line">    fmt.Printf(<span class="string">"平均成绩是:%.2f\n"</span>, average)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的代码显然可以正确地完成我们提及的需求，但是这种实现方式似乎不是很美观。首先定义五个变量的写法有些过于臃肿，然后输入成绩的操作显然是重复操作因此最好使用循环完成，再有求平均成绩的时候需要将所有的变量相加也是比较臃肿。同时还有一个最大的问题：一旦数据量变大，例如一个专业里面有300个学生，这样不论是变量定义还是代码书写，就都会是一个极大的挑战。 </p><p>&emsp;&emsp;因此在这里我们引出数组的概念：数组即有序的元素序列，是若干个连续的有限个数的相同类型的变量的集合。集合的名称我们称之为数组名，其中的变量称为数组的元素。我们先使用数组的方式将上述代码改写，然后再针对数组的基础知识进行讲解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> grades [<span class="number">5</span>]<span class="keyword">float32</span></span><br><span class="line">    <span class="keyword">var</span> average <span class="keyword">float32</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(grades); i++ &#123;</span><br><span class="line">        fmt.Scanln(&amp;grades[i])</span><br><span class="line">        average += grades[i]</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"平均成绩为:%.2f\n"</span>, average/<span class="keyword">float32</span>(<span class="built_in">len</span>(grades)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过数组的写法我们就弥补了我们所提及的几个缺点，我们不用定义五个变量，而是定义一个可以代表五个变量的变量。同时赋值操作与加和操作在循环中进行，不需要手动完成多个重复代码的书写。</p><h3 id="数组的定义与初始化"><a href="#数组的定义与初始化" class="headerlink" title="数组的定义与初始化"></a>数组的定义与初始化</h3><p>&emsp;&emsp;现在我们想，如果我们希望用一个变量来代表多个变量的集合，我们需要明确存储的变量的数据类型、以及需要存储的变量的个数，因此在数组的定义过程中，这两个要素是必不可少的。其定义方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 [数组大小]数据类型</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如，我们希望在数组中存储10个整数，我们可以定义为：var name [10]int,同理存储5个字符串可以定义为：var name [5]string，其他的例子我们就不过多地列举了。 </p><p>&emsp;&emsp;数组的定义可以通过上述的方式进行，接下来我们讲数组的初始化操作。初始化就是在定义的时候进行赋值，在Go语言中，数组的初始化可以有以下的五种表示方式，我们通过三个整数的数组举例： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">var</span> nums [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在第一种初始化的操作中，可以说十分的中规中矩，赋值号前面的部分是数组的定义部分，赋值号后的部分则指定了数组中三个元素分别对应的值。那么既然在赋值号前后都有[3]int的书写，这样完全重复了，因此我们也可以将定义部分的类型省略，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span> <span class="keyword">var</span> nums = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果继续向下说，其实在初始化的时候，甚至连数组的大小都不需要提供，编译器可以根据大括号里面的值的个数来确定其数组的大小。但是这只局限于数组中每一个数据都被初始化的前提下，一旦假如我们只初始化三个值而数组大小为四个值时就不适用了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span> <span class="keyword">var</span> nums = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的初始化形式中，我们可以使用…来代表数组的大小，其真实大小根据大括号中的个数而定。在有些情况下，我们需要分别对数组中的某个或某几个值进行初始化，且明确表明了这几个数的下标，也是可以的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span> <span class="keyword">var</span> nums [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>: <span class="number">100</span>, <span class="number">1</span>: <span class="number">200</span>, <span class="number">2</span>: <span class="number">300</span>&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这种状态下，我们通过冒号的方式，来完成对某些特定值的初始化，例如对第0个值初始化为100，第1个值初始化为200，第2个值初始化为300（数组中下标是从0开始）。当然，数组的初始化过程是支持类型推导的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.</span> nums := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="数组在内存中的形式"><a href="#数组在内存中的形式" class="headerlink" title="数组在内存中的形式"></a>数组在内存中的形式</h3><p>&emsp;&emsp;在数组的定义中，我们说数组是一段连续的同样数据类型的数据结构。换句话说，数组中每一个元素在内存中都是相连的。在之前的变量定义中，每一个变量所分配的内存空间可能是随机的，甚至说之间几乎没有任何的关系，而数组是不相同的。我们采用一个图片来表示（本次数组的首地址是0x0000580e0，不同的机器可能会不同）：<br> <img src="/2020/03/02/28-%E6%95%B0%E7%BB%84%E5%BC%95%E5%85%A5/1.png" alt></p><p>&emsp;&emsp;在上图中，我们可以发现，数组中的数据存储确实是连续的。同时，两个数之间的内存地址的差为8（十六进制），这个内存地址的差其实就是定义的数据类型所占据的内存空间。因此在数组定义的过程中，存放的数据类型是需要明确指明的，否则在空间的分配上会出现问题。我们举一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">3</span>]<span class="keyword">int8</span> = [<span class="number">3</span>]<span class="keyword">int8</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%p,%p,%p"</span>, &amp;nums[<span class="number">0</span>], &amp;nums[<span class="number">1</span>], &amp;nums[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们在数组中定义了三个int8类型的变量，且在输出语句中我们将这三个变量的物理地址输出，得到的结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xc00005a080</span>,<span class="number">0xc00005a081</span>,<span class="number">0xc00005a082</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述输出，我们可以看出：由于int8整数在内存中占据了8个二进制位，即一个字节，因此两个元素所在的物理地址的差值为1。再换句话说，只要我们知道了数组的首地址和数据类型，我们就可以根据地址直接取出指定位置的数据，这也正是数组在做二分查找等算法优化时的一大优点。同时在Go语言中，对数组名进行取地址的运算，就相当于对数组的第一个元素（下标为0）进行取地址的运算：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%p,%p"</span>,&amp;nums, &amp;nums[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序语句中，其输出的结果是相同的。当进行数组作为函数参数进行传递时，数组名可以直接传入以代表整个数组，这个特性在使用过程中是十分常见的。</p><h3 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h3><p>&emsp;&emsp;在上述我们所举的各个案例中，我们可以发现<strong>数组的元素下标是从0开始的</strong>，不同的语言对这个特性的支持是不相同的。例如我们定义的var names [3]int，其取值范围为names[0],names[1],names[2]，而不会出现names[3]，一旦出现了这个问题，编译器会报出数组越界的错误。因此在数组的遍历过程中，我们往往会使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; <span class="built_in">len</span>(names); i++ &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也就是说，局部变量i的值是从0开始，一直取到数组长度-1位置，如果不小心将条件写为i&lt;=len(names)则一定会报出数组越界的错误。这个错误一般在实际开发中很少会出现，但是在认证考试中可能会成为一个迷惑考试的一个考点。 </p><p>&emsp;&emsp;在对数组遍历的时候，我们可以采用上述方式进行逐个遍历，其实在数组中还可以采用我们在讲解循环结构时讲到的for-range结构进行遍历。for关键字后跟随两个变量，分别代表当前遍历到的下标值和该下标值所对应的变量，range关键字后跟随的是需要被遍历的数组，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> names &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里需要说明的是，index和value两个变量是在for循环内部可见的局部变量，换句话说，其作用域只在for结构之中。同时，此处的index所表示的内容与上一段程序中i所表示的内容是相同的，因此我们依旧可以不使用value这个关键字而依旧使用names[index]来表示内容，但是Go语言中变量定义后不可以不使用，因此在value处需要用下划线(‘_’)来接收。这种用法一般不会有人这样使用。 </p><p>&emsp;&emsp;同理，当用户只需要关注遍历到的各个值而不需要关注这个值所在的位置序号时，index的值就可以被省略了，同时，index处需要用下划线所表示（下划线的含义在标识符小节中有提到）。</p><h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>&emsp;&emsp;在这个小节中，我们通过输入多个学生成绩的问题简述了之前的解决方式存在的问题，从而引出了Go语言中的数组的概念，同时也讲解了数组的定义方式以及几种初始化的方式。我们也介绍了数组在内存中的存储方式以及遍历数组时采用的两种循环方式。 </p><p>&emsp;&emsp;在下一小节中，我们将针对数组的使用的细节做出相对深入的讨论和讲解，并与之前所讲解到的值类型等知识相互关联对数组进行更为深刻的解释。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-28-gt-数组引入&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-28-gt-数组引入&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;28&amp;gt; 数组引入&quot;&gt;&lt;/a&gt;Go语言从入门
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;27&gt; 闭包、defer与作用域</title>
    <link href="http://yoursite.com/2020/03/01/27-%E9%97%AD%E5%8C%85%E3%80%81defer%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2020/03/01/27-%E9%97%AD%E5%8C%85%E3%80%81defer%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2020-03-01T12:01:39.000Z</published>
    <updated>2020-03-01T12:02:44.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-27-gt-闭包、defer与作用域"><a href="#Go语言从入门到放弃系列-lt-27-gt-闭包、defer与作用域" class="headerlink" title="Go语言从入门到放弃系列&lt;27&gt; 闭包、defer与作用域"></a>Go语言从入门到放弃系列&lt;27&gt; 闭包、defer与作用域</h2><p>&emsp;&emsp;在上一小节中，我们讲解了init函数与匿名函数的知识点，在这一小节中，我们会承接上一小节中的匿名函数的知识，进而引入这一小节的闭包的概念。介绍完闭包的概念后，我们再初步讲解作用域的几个细节以及defer关键字的用法。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>&emsp;&emsp;闭包是一种可以读取到其他函数内部变量的函数。在前几节我们讲到：程序在运行时会给每个函数分配栈内存，而不同内存之间的变量的地址是不同的，因此通过普通的方式是无法在一个函数中调用另一个函数内的局部变量的。而如果希望调用，则需要使用到闭包的概念。笼统而简单地讲，闭包就是一个函数与其需要的环境资源的集合体。 </p><p>&emsp;&emsp;在上一小节中，我们说到了匿名函数，也讲解了匿名函数赋给函数变量时的调用方式。同时我们也曾讲解过函数作为一个参数进行传递，同理，函数也可以作为另一个函数的返回值。我们在接下来的这个案例中就用到了函数作为返回值的情况。因此在读函数签名以及返回值时需要稍作注意。我们先讲解外层函数的签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的这个函数定义的含义为：有一个名字叫做adder的函数，这个函数没有参数，且返回值是另一个函数。返回值的函数是匿名的，且参数为一个整数，返回值为一个整数。相信这个不难理解。我们将函数写完：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        y++</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;函数定义我们已经讲解过了，我们分析函数体：首先在函数体中定义一个y变量且初始化其值为10，接下来我们返回一个匿名函数，在这个匿名函数的函数体中我们让y自增后，返回参数x与y的加和。接下来我们看主函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := adder()</span><br><span class="line">    fmt.Println(f(<span class="number">1</span>))</span><br><span class="line">    fmt.Println(f(<span class="number">2</span>))</span><br><span class="line">    fmt.Println(f(<span class="number">3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在主函数中，我们先调用adder函数，并将其返回的函数赋给f变量。然后我们通过f进行调用并参数传递。有人可能会猜测输出的三个值分别是12，13，和14。因为y等于10，然后y自增变成11，再加传入的1变成12，其他两个是同一个过程得到13和14。然而输出的结果是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这三个结果出现的原因其实是这样的：在adder函数中，局部变量y与其返回的匿名函数构成了一个闭包。在这个闭包中，y的变量相对于其匿名函数而言<strong>相当于</strong>是一个全局变量。因此函数内部修改值会直接影响到函数外的这个”全局变量”上。因此，第一输出为12是不需要解释的，我们跟踪一下第二个输出的过程，当我们再一次传入2的时候，y的值由于在第一次调用后已经自增了，所以y的初始值是11而不是10。因此再进入匿名函数后y已经自增变成了12，因此其结果输出为14。同理，在调用f(3)的时候，y的初始值经过了两次自增后变成12，进入函数后再自增是13，因此最后输出16。 </p><p>&emsp;&emsp;这个知识点其实只要理解了函数与其他变量的相关性就不会觉得难理解了，闭包的概念在其他的许多语言中都有或多或少的支持，例如：javascript、python、Java8等。接下来，我们做一个小案例来加强一下对闭包的理解： </p><p>&emsp;&emsp;首先指定一个文件的扩展名，例如png、txt等，再传入一个文件名，判断如果这个文件名是以这个扩展名为结尾则输出原串，否则输出文件名+扩展名，程序采用闭包完成。 </p><p>&emsp;&emsp;我们将这个案例套在上面的那段程序中，我们可以分析道：其核心是有两个函数，外层函数可以用一个变量接收传入的扩展名，匿名函数可以接收传入的文件名，并返回最终的结果，因此其函数构成可以写为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setExtension</span> <span class="params">(extension <span class="keyword">string</span>)</span> <span class="title">func</span> <span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们写函数体，内层匿名函数中我们采用strings包的HasSuffix函数来判断一个字符串是否以另一个字符串结尾：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setExtension</span><span class="params">(extension <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> strings.HasSuffix(name, extension) &#123;</span><br><span class="line">            <span class="keyword">return</span> name</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name + extension</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := setExtension(<span class="string">".png"</span>)</span><br><span class="line">    fmt.Println(f(<span class="string">"demo.png"</span>))</span><br><span class="line">    fmt.Println(f(<span class="string">"demo"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在主函数中我们采用了同样的调用方式，得到的结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">demo.png</span><br><span class="line">demo.png</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上就是闭包的说明，在实际开发中，其实闭包用到的不多，但是在资格考试等等却是一个重点与难点。当然能够用闭包完成的功能不用闭包是完全可以完成的。例如上述举的文件名和扩展名的例子，我们完全可以将文件名和扩展名作为两个参数传入到同一个函数中。闭包的优势就在与函数中可以调用其他函数中的变量，且能保存这个变量的现有的值，一旦没有这个需求，就不需要闭包了。</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>&emsp;&emsp;defer作为Go语言中的关键字，也是有十分广泛的作用的。它可以与init函数的作用相反，init函数是想在引入包或执行main函数之前完成某些初始化工作，defer则是在函数执行结束后进行关闭资源等等的收尾工作。例如在程序中打开文件，则需要在结尾处关闭文件，或连接数据库，进行查询过后需要释放连接，这些工作就可以在defer中使用。依旧，我们先举一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"第一条输出"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"第二条输出"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"第三条输出"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"第四条输出"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的这一段程序中，输出结果毫无疑问：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一条输出</span><br><span class="line">第二条输出</span><br><span class="line">第三条输出</span><br><span class="line">第四条输出</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在我们将其中的两条语句用defer进行修饰：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"第一条输出"</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"第二条输出"</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"第三条输出"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"第四条输出"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时其输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一条输出</span><br><span class="line">第四条输出</span><br><span class="line">第三条输出</span><br><span class="line">第二条输出</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述输出结果我们可以发现，defer的作用是将该语句延迟执行，我们将第二条和第三条都用defer修饰了，因此这两条会延迟到main函数执行结束后再执行，不仅如此，我们还可以发现，第二条输出与第三条输出的顺序是相反的。因此，在用defer修饰语句时，会将该语句压入<strong>栈</strong>中，我们姑且称之为defer栈。 </p><p>&emsp;&emsp;由于程序自上到下执行，先遇到了第二条输出，因此先压入栈中，然后才遇到了第三条输出，再压入栈中。当函数执行结束后，他们依次出栈，在栈顶的先出，在栈底的后出。我们再举一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"defer中的num:"</span>, num)</span><br><span class="line">    num++</span><br><span class="line">    fmt.Println(<span class="string">"main函数中的num:"</span>, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据上述的分析，我们可以知道，输出结果一定先是main函数中的num那句，然后才是defer中的num那句，现在问题是：输出时num的结果分别是多少。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main函数中的num: <span class="number">11</span></span><br><span class="line"><span class="keyword">defer</span>中的num: <span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以发现，尽管defer修饰的语句会最后再执行，但是其中所涉及到的值是不受后续程序影响的，换句话说在压入defer栈的时候，num的赋值就已经发生了。因此defer的作用不是仅仅将该语句简单地移动到程序的最后面，而是带有当时的数据环境的。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>&emsp;&emsp;作用域这个概念其实我们已经接触过很多次了，我们对它也是应该有一些了解了。我们之前所说的一个函数无法访问另一个函数的变量，其实就是作用域的问题。在这里我们简单地概述一下各个场景下作用域的用法。</p><h5 id="1-分支结构、循环结构中定义的变量"><a href="#1-分支结构、循环结构中定义的变量" class="headerlink" title="1. 分支结构、循环结构中定义的变量"></a>1. 分支结构、循环结构中定义的变量</h5><p>&emsp;&emsp;我们讲到在分支结构中是可以进行数据定义的，这个数据是只能够在分支结构中进行使用，一旦超出了其结构再使用，程序就会报错了，例如我们希望知道当跳出循环时，某个变量是多少：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span> ;i++ &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的这段程序是不行的，因为i这个变量是在for结构中定义的，出了这个大括号，就不能够再被访问了，如果我们希望访问这个i，就只能将i的定义提出到for结构之外：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因为此时的i变量的定义位置与使用它的位置处于同一个层级，因此是可以进行调用的。</p><h5 id="2-函数内部定义的变量"><a href="#2-函数内部定义的变量" class="headerlink" title="2. 函数内部定义的变量"></a>2. 函数内部定义的变量</h5><p>&emsp;&emsp;对于这种变量，我们可以称之为局部变量，局部变量顾名思义，只能在局部位置中使用，在其他的位置就无法使用了。这个问题我们之前就提及过了，这里我们就不做更多的讲解了。</p><h5 id="3-Go文件中定义的变量"><a href="#3-Go文件中定义的变量" class="headerlink" title="3. Go文件中定义的变量"></a>3. Go文件中定义的变量</h5><p>&emsp;&emsp;这个概念我们之前其实也提到过了，在Go文件中定义的变量被称之为全局变量，这种变量可以在整个Go文件中的任意一个函数中，任意一个位置使用。且在函数中对该变量进行修改会直接影响到该变量的值。</p><h4 id="整体规律"><a href="#整体规律" class="headerlink" title="整体规律"></a>整体规律</h4><p>&emsp;&emsp;在同一个Go文件中的变量定义中，我们可以总结出一条规律，即与变量定义位置同级以及下级的位置可以使用该变量，该位置的上级是不能使用的。换句话说，进入大括号可以使用，出了大括号就不能用了。</p><h4 id="包之间的变量调用"><a href="#包之间的变量调用" class="headerlink" title="包之间的变量调用"></a>包之间的变量调用</h4><p>&emsp;&emsp;假如一个包中的函数需要调用另一个包中的变量，则需要用包名.变量名的方式进行调用。且变量名的规则与函数名的规则是相同的：即首字母大写说明可以被其他包所使用，而首字母小写则只能够在本包中使用，否则会出现该变量无法导出的错误类型。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们集中讲解了闭包的概念、defer关键字的用法、以及变量作用域的规则。到这里对函数的知识的讲解就可以告一段落了，在下一小节中，我们将集中介绍几个Go语言中常用的字符串相关、日期相关的函数，对后期的编程可能会有所帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-27-gt-闭包、defer与作用域&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-27-gt-闭包、defer与作用域&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;27&amp;gt; 闭
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;26&gt; init函数与匿名函数</title>
    <link href="http://yoursite.com/2020/02/29/26-init%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/02/29/26-init%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</id>
    <published>2020-02-29T07:12:03.000Z</published>
    <updated>2020-02-29T07:13:26.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-26-gt-init函数与匿名函数"><a href="#Go语言从入门到放弃系列-lt-26-gt-init函数与匿名函数" class="headerlink" title="Go语言从入门到放弃系列&lt;26&gt; init函数与匿名函数"></a>Go语言从入门到放弃系列&lt;26&gt; init函数与匿名函数</h2><p>&emsp;&emsp;在很久之前我们曾说主函数是程序的入口且最先执行，当时我们在后面附了一句这个说法不是十分正确。在这个小节中，我们将介绍一个在主函数执行之前的函数:init函数，同时我们也会对匿名函数做出一定的讲解。整体来说，这个小节的知识点难度不大，读者可以很轻松地领会。</p><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>&emsp;&emsp;已经说明了main函数可以不是最先执行，那么先于main函数执行的有：全局变量的定义，以及init函数。同时当我们使用import命令来引入其他的包的过程中，执行顺序的先后就会相对更复杂一点，我们由浅入深开始讲解。</p><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>&emsp;&emsp;在之前的所有的案例中，我们所定义的变量可以说都是局部变量，可以理解为都是在函数内部定义的变量。这种变量的特点是只能在本函数，甚至本语句块之中可以使用。一旦超出了这个使用范围就会报出变量未定义的错误。全局变量与局部变量不同，他们是在包之内、函数之外定义的，因此这些变量或常量是可以在本包的任何一个函数中使用，我们举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNum</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    getNum()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很显然，这段代码一定是错误的，我们在getNum函数中想要调用main函数中的num变量，由于num是一个main函数中的局部变量，因此只可以在main函数中使用。现在我们将num这个变量改为全局变量，再从两个函数中分别使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNum</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num += <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">    getNum()</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的这段代码中，我们将num的定义放在了函数的外面，这个变量就成为了全局变量，在各个函数中均可以使用，不仅如此，在getNum函数中，我们对num变量的值进行了修改，在main函数进行输出，我们可以发现两次输出结果是不相同的。输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><h4 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h4><p>&emsp;&emsp;经过对上述全局变量的使用的介绍，我们可以发现：全局变量的定义是先于main函数执行的，因为这个定义过程并不在main中，而main函数使用这个变量却没有问题。这里我们再介绍一个先于main函数执行的函数，init函数。 </p><p>&emsp;&emsp;在一些情况下，我们希望在真正进行逻辑操作时，首先对程序进行一定的初始化操作。例如多个人进行协同编程时，每个人都有自己的分工，但是每个人所需要提交的代码只是逻辑部分，数据定义部分可能是通过网络接收到的数据。当开发者在测试环境下希望初始化一些数据，且提交时不需要将代码分离时，init函数可以是一个比较合适的选择。我们通过案例来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"init()函数执行了"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"main()函数执行了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们对上述的这段程序进行编译运行，会发现”init()函数执行了”这个字符串先被输出出来，而“main()函数执行了”这个字符串是后被输出来的。因此我们可以说，init函数是先于main函数被执行的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init()函数执行了</span><br><span class="line">main()函数执行了</span><br></pre></td></tr></table></figure><h4 id="全局变量定义与init函数先后关系"><a href="#全局变量定义与init函数先后关系" class="headerlink" title="全局变量定义与init函数先后关系"></a>全局变量定义与init函数先后关系</h4><p>&emsp;&emsp;既然两种操作均先于main函数，我们就需要对这两种操作顺序进行排序。我们此时可以想到，我们可能在main函数中使用全局变量，我们当然也有需求在init函数中使用全局变量，因此全局变量的定义也是早于init函数的，我们通过下面这个例子来验证这个关系：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span> = initNum()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initNum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"为全局变量赋值"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"init()函数执行了"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"main()函数执行了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们定义了一个全局变量num，且通过initNum这个函数进行初始化，在这个函数中我们输出了为全局变量赋值这个字符串，我们只需要看”为全局变量赋值”这个字符串和”init()函数执行了”这个字符串的先后关系，就可以明确其顺序了。执行结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为全局变量赋值</span><br><span class="line">init()函数执行了</span><br><span class="line">main()函数执行了</span><br></pre></td></tr></table></figure><h4 id="import其他包时的执行顺序"><a href="#import其他包时的执行顺序" class="headerlink" title="import其他包时的执行顺序"></a>import其他包时的执行顺序</h4><p>&emsp;&emsp;现在我们对刚刚的问题进行扩展，如果我们希望引入一个包，且使用这个包中的变量，那么这两个包中两个全局变量定义、两个init函数、以及一个main函数的执行顺序又是什么呢，我们通过下面这个例子来讲解。 </p><p>&emsp;&emsp;在这个例子中我们依旧采取demo包和test包，文件系统与对包的讲解的那一小节是相同的，即src下两个文件夹，每个文件夹都有一个go文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">demo文件夹下main包：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">package</span> main</span><br><span class="line">    <span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"test"</span></span><br><span class="line">    )  </span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = initNum()</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initNum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"main包中全局变量赋值"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"main包中init函数执行"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"main包中main函数执行了"</span>)</span><br><span class="line">        fmt.Println(test.Num)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">test文件下test包：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">package</span> test</span><br><span class="line">    <span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line">    <span class="keyword">var</span> Num <span class="keyword">int</span> = setNum()</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setNum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"test包中的全局变量赋值"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"test包中的init函数执行"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的这段程序中出现了我们所说的五个全部的过程，我们根据执行结果可以判断出在引用包的时候各个操作的执行先后顺序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test包中的全局变量赋值</span><br><span class="line">test包中的init函数执行</span><br><span class="line">main包中全局变量赋值</span><br><span class="line">main包中init函数执行</span><br><span class="line">main包中main函数执行了</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上述的执行结果，我们可以发现：在引入其他的包的时候，最先执行的是其他包中的全局变量定义，其次是其他包的init函数，然后才是本包中的全局变量定义，init函数以及main函数。相应地，我们根据这个规律进行扩展，main包中引用了A包和B包、main包中引用了A包，同时A包中引用了B包： </p><p><img src="/2020/02/29/26-init%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/1.png" alt></p><p>&emsp;&emsp;一个包调用多个包的情况</p><p><img src="/2020/02/29/26-init%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/2.png" alt></p><p>&emsp;&emsp;多个包相调用的情况</p><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><h4 id="一次性调用"><a href="#一次性调用" class="headerlink" title="一次性调用"></a>一次性调用</h4><p>&emsp;&emsp;匿名函数的思想其实十分的简单，即定义一个没有名字的函数，这个函数之所以不需要名字，是因为我们希望它只被调用一次，且是函数定义时直接调用。调用过后这个函数就被遗弃再也不调用了。这个语言上的特点在很多种语言中均存在，但是用到的不是很多。在Android开发过程中用到的比较多的也就是匿名内部类，因此这个知识点稍作了解即可，其难度也不是很大。我们看下面的案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result := <span class="function"><span class="keyword">func</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2</span><br><span class="line">    &#125;(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">    fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将上述的代码与正常的函数相比较，我们可以发现如下几个特点：func后直接加参数列表，即没有函数名。函数体与正常函数完全一致。在函数定义过后就直接传入相应的参数后使用，通过变量接收其结果。在后续的程序中只能使用其结果而无法再调用这个函数。</p><h4 id="匿名函数赋给函数变量"><a href="#匿名函数赋给函数变量" class="headerlink" title="匿名函数赋给函数变量"></a>匿名函数赋给函数变量</h4><p>&emsp;&emsp;这个用法相比而言就与普通函数没有什么区别了，在前几节中我们讲到函数可以作为一种数据类型也可以作为函数参数进行传递。因此，匿名函数当然也可以被赋值给函数变量，案例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myFunc := <span class="function"><span class="keyword">func</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(myFunc(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的这段程序中，我们将一个匿名函数赋给了myFunc这个函数变量，且在后续的程序中通过myFunc这个变量进行了函数的调用。由于我们可以通过变量进行调用，因此这个函数是可以在后续被调用的，因此说与正常函数没有什么区别。不过这里需要注意的是，我们是通过变量进行函数调用，而不是通过函数名进行调用，尽管这两者在使用上几乎没有任何的区别。</p><h4 id="匿名函数赋给全局函数变量"><a href="#匿名函数赋给全局函数变量" class="headerlink" title="匿名函数赋给全局函数变量"></a>匿名函数赋给全局函数变量</h4><p>&emsp;&emsp;这个小标题就更容易理解了，既然变量可以有全局变量，那么函数变量当然可以是全局变量了。这个时候，该函数变量可以被本包中的所有函数使用，也就意味着该函数可以被任意一个函数调用。相比于上一段程序，myFunc函数的作用域更大了。我们不详细说明了，只举一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">var</span> myFun = <span class="function"><span class="keyword">func</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(myFun(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们集中讲解了全局变量的含义与用法、init函数的执行顺序、以及匿名函数的三种使用方式。整体上而言，这个小节的知识点相对简单，且init函数用到的情况远比匿名函数多。对于init函数而言， 由于是编译器调用的函数，因此函数名、参数列表为空、无返回值这三个条件必须满足。而匿名函数用到的地方相对较少，能做到在真正遇到的时候想起匿名函数的概念与调用方式即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-26-gt-init函数与匿名函数&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-26-gt-init函数与匿名函数&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;26&amp;gt; ini
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
