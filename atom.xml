<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>云钰的亭轩阁</title>
  
  <subtitle>Running water never goes stale, so you gotta just keep on flowing.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-30T14:17:18.366Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Devin DENG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;52&gt; channel管道入门</title>
    <link href="http://yoursite.com/2020/03/30/52-channel%E7%AE%A1%E9%81%93%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2020/03/30/52-channel%E7%AE%A1%E9%81%93%E5%85%A5%E9%97%A8/</id>
    <published>2020-03-30T14:16:29.000Z</published>
    <updated>2020-03-30T14:17:18.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-52-gt-channel管道入门"><a href="#Go语言从入门到放弃系列-lt-52-gt-channel管道入门" class="headerlink" title="Go语言从入门到放弃系列&lt;52&gt; channel管道入门"></a>Go语言从入门到放弃系列&lt;52&gt; channel管道入门</h2><p>&emsp;&emsp;在上个小节中，我们通过资源竞争问题简要地介绍了Go语言中的全局互斥锁的使用方式，以及引出了channel的快速入门案例。在这个小节中，我们将针对Go语言中的channel变量进行更多的介绍，并相应地配合入门案例完成对应的讲解。</p><h3 id="channel基本介绍"><a href="#channel基本介绍" class="headerlink" title="channel基本介绍"></a>channel基本介绍</h3><p>&emsp;&emsp;相比于之前我们介绍的简单的或者复合的变量，channel形式的变量又显得比较特殊。channel其本质是一种队列的数据结构。在上个小节我们举了一个ATM取款的例子，当有人使用提款机时，后面的其他人需要排队等待，这种数据结构经过抽象后就是队列。 </p><p>&emsp;&emsp;再次类比上面的例子，当一个人最先到达，他会排在队列的前面，同时他也将会成为候补人选的第一个人。因此队列的逻辑形式是先入先出FIFO（first in first out）。队列中还有两个属性：长度与容量。容量是一个队列可以容纳的最多数据的个数，而长度则是指当前队列中究竟有几个元素。我们举一个例子：我们首先定义一个容量为10的队列，将1,3,5,2,4按顺序插入队列中，此时的队列为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">2</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;队列的容量是10，队列的长度为5。此时我们从队列中提取一个元素，因为队列是先入先出，因此提取出来的值是队列中的第一个值：1。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>  <span class="number">5</span>  <span class="number">2</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时队列的容量依旧为10，但是长度变为了4。假如此时我们再向队列中插入一个值10，因为后出入的值会排在最后面，因此此时的队列为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>  <span class="number">5</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;channel的本质是一个队列，因此channel中的数据也满足先入先出的思想，同时channel是线程（协程）安全的，当多个goroutine访问同一个channel时不需要加锁，也不会出现读写的资源竞争问题。接下来我们将通过代码案例完成channel的各个知识点的讲解。</p><h3 id="channel的定义与声明"><a href="#channel的定义与声明" class="headerlink" title="channel的定义与声明"></a>channel的定义与声明</h3><p>&emsp;&emsp;在Go语言中使用变量之前往往需要定义与声明，channel也需要先定义才可以继续向下使用。而channel的基本定义方式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 <span class="keyword">chan</span> 数据类型</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上述的声明结构，我们可以发现channel的声明由三部分构成：变量名，chan（指定变量为channel），以及channel中装载的数据类型。我们举几个案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> stringChan <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> mapChan <span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> classChan <span class="keyword">chan</span> StuInfo</span><br><span class="line"><span class="keyword">var</span> pointerChan <span class="keyword">chan</span> *StuInfo</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;解释一下上面的定义方式：第一个channel名为intChan，且channel中只能存放int类型的整数。同理其他的几个定义中channel只可以存放string，map[int]int，StuInfo类，StuInfo对象指针。 </p><p>&emsp;&emsp;channel在定义过后还需要注意的几点是：channel自身是一个引用类型，因此在函数或方法传递过程中会受到函数方法内的改变的影响。同时正因为其引用类型的特性，channel是需要初始化才可以写入数据的，即make操作过后才可以使用。还有一个特性是：channel是有数据类型的，一旦channel定义中出现int，那么该channel中只能写入整数int。当然我们已经介绍过了面向对象的多态与接口，因此在一定意义上可以用空接口解决多个类型存入的问题。</p><h3 id="Channel初始化与数据操作"><a href="#Channel初始化与数据操作" class="headerlink" title="Channel初始化与数据操作"></a>Channel初始化与数据操作</h3><p>&emsp;&emsp;在上个部分中我们提到，Go语言中channel变量需要make过后才可以使用。对于channel变量的make函数而言需要两个参数。分别为channel变量及存储的数据类型以及channal管道的容量。与切片slice和映射map不同的是，channel的容量是固定的，一经定义好，就不可以改变了。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上述的初始化过后，内存中就已然分配了一个容量为5，长度为0的管道，其本质就是一个容量为5的队列。经过初始化后，就可以向管道内插入和提取数据了。Go语言中向管道内插入数据与提取数据采用的是”&lt;-“符号（小于号和一个减号）。我们通过下面的案例来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    intChan &lt;- <span class="number">1</span></span><br><span class="line">    intChan &lt;- <span class="number">2</span></span><br><span class="line">    intChan &lt;- <span class="number">3</span></span><br><span class="line">    intChan &lt;- <span class="number">4</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(intChan))</span><br><span class="line">    num1 := &lt;-intChan</span><br><span class="line">    num2 := &lt;-intChan</span><br><span class="line">    fmt.Println(num1, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们初始化了一个容量为5的管道，并向管道中依次插入四个整数。然后我们输出了该管道当前的长度。之后我们再将管道中的前两个整数提取出来，最后将这两个整数输出到控制台终端。上述代码的输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们再测试一下当插入数据超出了channel所规定的容量时发生的情况。我们依旧初始化一个容量为5的channel，并依次向里面插入6个数，最后再使用输出channel的长度：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    intChan &lt;- <span class="number">1</span></span><br><span class="line">    intChan &lt;- <span class="number">2</span></span><br><span class="line">    intChan &lt;- <span class="number">3</span></span><br><span class="line">    intChan &lt;- <span class="number">4</span></span><br><span class="line">    intChan &lt;- <span class="number">5</span></span><br><span class="line">    intChan &lt;- <span class="number">6</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(intChan))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当程序执行到intChan&lt;-6这条语句时，插入数据已然超出了规定的最大的容量了。<strong>在单协程的情况下</strong>，程序会报出运行时错误。因为此时只有一个主协程，而主协程中管道已然满了而添加不进去新的数据，因此主协程被阻塞了。同时没有其他的协程从管道中提取数据，主协程将会一直阻塞，因此出现了致命错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同理，我们再测试当channel中暂时为空，而没有数据的前提下，我们从channel中提取数据。我们依旧初始化一个channel，不向其中插入数据，直接提取数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    num := &lt;-intChan</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的这段程序依旧会出现死锁的问题，其原因也是十分类似的：此时只有一个主协程，主协程中等待着其他协程向channel中插入数据，只有channel中有数据才可以提取出来。因此主协程被阻塞在提取的步骤上了，而没有其他的协程插入，因此编译器发现所有的协程都处于阻塞状态（虽然只有一个主协程），就报出了致命错误。错误类型是相同的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因此可以讲，channel的作用是在不同的协程中起到通信的作用，而且channel中的数据是一种动态的数据。如同水管一般，水是在水管中是流动的，正如数据在channel中流动。在一个协程中单独使用channel，或者channel中数据不流动往往是不合适的。 </p><h3 id="主协程等待子协程方式"><a href="#主协程等待子协程方式" class="headerlink" title="主协程等待子协程方式"></a>主协程等待子协程方式</h3><h4 id="channel阻塞机制"><a href="#channel阻塞机制" class="headerlink" title="channel阻塞机制"></a>channel阻塞机制</h4><p>&emsp;&emsp;既然channel在多协程的情况下提取空数据或者添加满数据时会发生阻塞，我们就可以利用这个特性让主协程等待所有的子协程执行结束后再退出了。假如程序将启动8个协程，每个协程在结束的时候向channel中写入一个true，主协程中循环8次提取channel中的bool值。当提取不满8次时，主协程阻塞；当第八次提取到了true时，说明所有子协程都结束了，主协程可以继续向下执行。 </p><p>&emsp;&emsp;现在我们通过案例来说明上述的场景，我们启动8个协程，在每个协程中0到10随机Sleep一段时间，当所有协程均结束后，主协程结束：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomDelay</span><span class="params">(channel <span class="keyword">chan</span> <span class="keyword">bool</span>, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s := rand.Intn(<span class="number">10</span>)</span><br><span class="line">    time.Sleep(time.Duration(s) * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"协程"</span>, i, <span class="string">"等待"</span>, s, <span class="string">"秒"</span>)</span><br><span class="line">    channel &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> randomDelay(channel, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">        &lt;-channel</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"主协程结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面的代码中，我们首先在主协程中确定了随机种子的值，然后初始化了容量为8的管道。在randomDelay中，我们随机生成一个0到10的整数，并让该函数阻塞对应长的时间，阻塞过后输出结果。同时在主协程中我们逐个将channel中的数据取出。由于channel中的数据只起到标志位的作用，因此能够取出数据就是我们希望的结果，而对于取出来的数据我们并不关心，因此可以不赋值给其他变量。最终，取出8次数据之后，主协程结束。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">协程 <span class="number">1</span> 等待 <span class="number">0</span> 秒</span><br><span class="line">协程 <span class="number">7</span> 等待 <span class="number">2</span> 秒</span><br><span class="line">协程 <span class="number">6</span> 等待 <span class="number">2</span> 秒</span><br><span class="line">协程 <span class="number">3</span> 等待 <span class="number">2</span> 秒</span><br><span class="line">协程 <span class="number">5</span> 等待 <span class="number">4</span> 秒</span><br><span class="line">协程 <span class="number">4</span> 等待 <span class="number">5</span> 秒</span><br><span class="line">协程 <span class="number">0</span> 等待 <span class="number">7</span> 秒</span><br><span class="line">协程 <span class="number">2</span> 等待 <span class="number">8</span> 秒</span><br><span class="line">主协程结束</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过这种方式，我们可以利用channel在多协程中的阻塞机制，让主协程强行等待最后一个子协程的结束后自己再结束。同时，channel变量自身就是线程（协程）安全的，不会出现资源共享时的竞争问题，因此在多协程通讯的时候，channel的作用可以说是十分重要的。 </p><p>&emsp;&emsp;除了这种方式之外，还有一种方式是利用管道关闭的性质完成主协程等待子协程的操作，具体的方法及细节我们将在下个小节中详细讲解。</p><h4 id="计数器模式"><a href="#计数器模式" class="headerlink" title="计数器模式"></a>计数器模式</h4><p>&emsp;&emsp;除了上述channel阻塞模式之外，我们还可以利用sync包中的WaitGroup类来完成该需求。其本质即是一个计数器：当我们开启一个协程时让计数器增加1，当某个协程结束时令计数器减少1，在计数器归零之前程序处于阻塞的状态，当计数器归零，程序就可以继续向下执行了。</p><p>&emsp;&emsp;在WaitGroup类中，主要被用到的只有三个方法：Add方法，Done方法和Wait方法。当我们希望在程序运行过程中对计数器进行增加操作时，我们就调用Add方法。Done方法与Add方法相反，程序每次调用Done方法都会令计数器自减。而Wait方法则是程序在调用其位置进行阻塞，直到计数器归零。  </p><p>&emsp;&emsp;在这里需要明确的是：WaitGroup既然是一个类，那么其对象即满足值类型的本质，当WaitGroup对象作为函数参数传递时，是需要复制一份副本进行传递，这样在函数方法内部就无法对计数器本身进行修改。因此在函数参数的传递过程中大多数还是要传递WaitGroup<strong>指针</strong>，否则计数器不归零程序将持续阻塞。我们举例完成上述同样的需求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomDelay</span><span class="params">(wg *sync.WaitGroup, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s := rand.Intn(<span class="number">10</span>)</span><br><span class="line">time.Sleep(time.Duration(s) * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"协程"</span>, i, <span class="string">"等待"</span>, s, <span class="string">"秒"</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> randomDelay(wg, i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"主协程结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在程序中，我们每启动一个goroutine，都令WaitGroup对象（wg）自增1，当每个goroutine结束的时候，我们都让计数器减1（Done方法），最后我们在程序的结尾处调用Wait方法，使得主协程开始阻塞等待所有协程的结束。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们首先介绍了队列数据结构的基本思路，进而说明了channel的核心就是一个队列。然后我们又简要介绍了Go语言中channel的定义方式以及channel中数据类型的多样性。随后我们又初始化channel，并说明了向管道写入以及从管道内取出数据的方法以及异常情况的阻塞机制。最后我们通过这种阻塞机制说明了主协程等待子协程的方法。 </p><p>&emsp;&emsp;在下个小节中，我们将集中针对channel数据类型讲解其各个细节，并通过一段代码综合地讲解goroutine和channel的配合。在这之后，读者应该可以完成一定的多协程开发与协程交互的任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-52-gt-channel管道入门&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-52-gt-channel管道入门&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;52&amp;gt; cha
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;51&gt; 资源竞争与管道</title>
    <link href="http://yoursite.com/2020/03/29/51-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E4%B8%8E%E7%AE%A1%E9%81%93/"/>
    <id>http://yoursite.com/2020/03/29/51-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E4%B8%8E%E7%AE%A1%E9%81%93/</id>
    <published>2020-03-29T14:13:21.000Z</published>
    <updated>2020-03-29T14:14:08.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-51-gt-资源竞争与管道"><a href="#Go语言从入门到放弃系列-lt-51-gt-资源竞争与管道" class="headerlink" title="Go语言从入门到放弃系列&lt;51&gt; 资源竞争与管道"></a>Go语言从入门到放弃系列&lt;51&gt; 资源竞争与管道</h2><p>&emsp;&emsp;在计算机语言中，对硬盘的读写和对内存空间的读写往往是不可避免的。在单线程单协程的环境下由于对资源的访问是顺序的，因此读写的问题并不能被表露出来。然而到了多协程程序设计中，我们并不能得出一个明确的结论哪一个协程先执行完，哪一个协程后执行完。且有极大的可能性多个协程共同执行完，那么当多个协程同时想读写一个文件时，就会出现资源的冲突。 </p><p>&emsp;&emsp;在这个小节中，我们将首先通过一个简单的案例引出Go语言中资源竞争的问题，同时将给出两种解决该问题的方式：全局互斥锁与管道channel。然后再对channel的知识点进行快速入门介绍。</p><h3 id="资源竞争问题"><a href="#资源竞争问题" class="headerlink" title="资源竞争问题"></a>资源竞争问题</h3><p>&emsp;&emsp;资源竞争往往出现在对内存或硬盘的写操作上，我们举一个日常的例子：假如只有一本书和多个人，这本书可以被多个人分享，且多个人可以同时读这一本书，每个人读到的内容不会出现不同，因此读操作是不会出现资源竞争的。相反，假如只有一个笔记本和多个人，多个人同时希望向一个本子上写一页的东西，这就出现了问题，因为当一个人在写东西的时候，其他人只能在一旁观看而不能同时写，因此在写的过程中出现了资源竞争。（这里我们不谈Google Doc等应用的实现方式） </p><p>&emsp;&emsp;我们接下来通过一段程序来说您这个问题，程序的需求如下：我们需要计算1到20的各个数字的阶乘，将阶乘结果保存到一个map中，在程序的最后将map输出到终端，要求通过协程技术来完成。基于现有的知识掌握，我们可以通过以下的思路来解决该问题：首先定义一个全局变量map，同时在自定义函数中完成阶乘操作与写入，然后在主函数中协程形式调用该函数，Sleep一小段时间后（这个问题我们会在这个小节解决），输出最终的map到控制台终端。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    myMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multi</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    result := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        result *= i</span><br><span class="line">    &#125;</span><br><span class="line">    myMap[n] = result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> multi(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"map[%d] = %d \n"</span>, i, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果我们采用如上的代码来完成这个需求，且按原来的方式进行编译运行，在一定的情况下可能会出现错误，因为多个协程同时请求了同一个map资源，因此会出现并发的写操作。这个问题有时候可能不会出现，因为我们只启动了20个协程，且阶乘操作用的时间不同，因此在20个的前提下还是存在不出现资源竞争的可能的。但是一旦我们需要计算1-200的阶乘，那么出现这个问题的概率就极大了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fatal error: concurrent <span class="keyword">map</span> writes</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">20</span> [running]:</span><br><span class="line">runtime.throw(<span class="number">0x4c56f0</span>, <span class="number">0x15</span>)</span><br><span class="line">  c:/<span class="keyword">go</span>/src/runtime/<span class="built_in">panic</span>.<span class="keyword">go</span>:<span class="number">608</span> +<span class="number">0x79</span> fp=<span class="number">0xc000097f60</span> sp=<span class="number">0xc000097f30</span> pc=<span class="number">0x429de9</span></span><br><span class="line">runtime.mapassign_fast64(<span class="number">0x4a8a40</span>, <span class="number">0xc000070240</span>, <span class="number">0x2</span>, <span class="number">0x0</span>)</span><br><span class="line">  c:/<span class="keyword">go</span>/src/runtime/map_fast64.<span class="keyword">go</span>:<span class="number">172</span> +<span class="number">0x2f1</span> fp=<span class="number">0xc000097fa0</span> sp=<span class="number">0xc000097f60</span> pc=<span class="number">0x40f2c1</span></span><br><span class="line">main.multi(<span class="number">0x2</span>)</span><br><span class="line">  E:/GoProject/src/demo/demo.<span class="keyword">go</span>:<span class="number">17</span> +<span class="number">0x6b</span> fp=<span class="number">0xc000097fd8</span> sp=<span class="number">0xc000097fa0</span> pc=<span class="number">0x490c9b</span></span><br><span class="line">runtime.goexit()</span><br><span class="line">  c:/<span class="keyword">go</span>/src/runtime/asm_amd64.s:<span class="number">1333</span> +<span class="number">0x1</span> fp=<span class="number">0xc000097fe0</span> sp=<span class="number">0xc000097fd8</span> pc=<span class="number">0x4519d1</span></span><br><span class="line">created by main.main</span><br><span class="line">  E:/GoProject/src/demo/demo.<span class="keyword">go</span>:<span class="number">22</span> +<span class="number">0x5f</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果希望更明确地看到这个问题的出现，我们在编译过程中可以通过 -race 的方式进行编译，然后再正常执行。这个结果我们就不做演示了，是可以得到具体哪几个协程发生了冲突的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build -race demo.<span class="keyword">go</span></span><br><span class="line">demo.exe (这个命令不同系统是不同的)</span><br></pre></td></tr></table></figure><h3 id="全局互斥锁"><a href="#全局互斥锁" class="headerlink" title="全局互斥锁"></a>全局互斥锁</h3><p>&emsp;&emsp;基于上述的问题，我们采取的第一种解决方式就是通过全局互斥锁的方式解决数据访问冲突。资源竞争的核心就是多个协程同时向同一个资源进行写操作，而操作系统与语言底层并没有某种机制来解决这个问题。在Go语言中，我们可以通过加锁的方式来完成。 </p><p>&emsp;&emsp;依旧首先举一个显式的例子：在一些ATM机取钱时，往往会有一个小的安全空间，每次只能让取款的人进入，而其他的取款人需要在门外排队等待。正在取款的人需要将们锁住代表目前这个ATM机的操作权限归他所有，当他取款过后，需要将门解锁后出来，后面的下一个人才能进入，这个例子其实就锁的机制。 </p><p>&emsp;&emsp;我们将这个例子应用到以上的程序中，我们可以采用如下的解决过程：首先定义一个全局的互斥锁，在程序中当一个协程需要写资源时，这个协程需要申请这个锁，如果没有任何其他协程拥有这个锁，这个协程就可以完成写的操作。且当该线程进行写操作时，其他写操作的协程需要等待。同理，当一个协程完成了写操作之后，这个锁就会被队列中的下一个协程所拥有。 </p><p>&emsp;&emsp;在程序设计中，我们采用的是sync包中的Mutex类，该类中存在两个方法分别是Lock方法和Unlock方法，接下来我们通过这个技术修改上述的程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    myMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    lock sync.Mutex</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multi</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    result := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        result *= i</span><br><span class="line">    &#125;</span><br><span class="line">    lock.Lock()</span><br><span class="line">    myMap[n] = result</span><br><span class="line">    lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过以上的改动之后，我们在全局变量处定义了一个Mutex锁，在对map写入之前进行Lock操作，写入之后进行Unlock操作。这次再像往常一般执行代码，就不会出现资源竞争的问题了。因为代码中的map同一时刻下只能被一个协程所拥有，其他协程需要在队列中等待。 </p><p>&emsp;&emsp;即便如此，我们通过加锁的方式解决了concurrent map writes的问题，但是协程之间的通讯问题依旧没有解决。换句话说我们依旧需要time.Sleep方法让主协程强行等待一个固定的时间，但这个做法十分不明智。如果当协程结束之后能够通过某种机制让主协程知道，在这之前，主协程处于阻塞的状态才是一种合适的解决方案。同时，因为Go语言中存在着Channel的解决机制，全局互斥锁的方法也被称为初等级的解决资源冲突的方案，用到该技术的时间其实并不多。 </p><h3 id="Channel引出"><a href="#Channel引出" class="headerlink" title="Channel引出"></a>Channel引出</h3><p>&emsp;&emsp;在前一个部分中我们使用全局变量加锁同步的方式来解决goroutine的通讯问题，但是依旧不完美，主要的原因有以下几点：主协程等待所有协程全部完成的时间无法估计，使得主协程的运行与各个子协程的运行相互脱节，在实际开发环境中不适合；不同的业务逻辑处理的问题不同，相应的需要的时间也不同，仅设置一个固定的时间会出现错误；通过全局变量加锁的机制其实依旧不利于多个协程对全局变量的读写操作。因此在这个小节中，我们引出Go语言中channel的用法，并用channel的方式解决上述问题。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mapChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">20</span>)</span><br><span class="line">    myMap  = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multi</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    result := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        result *= i</span><br><span class="line">    &#125;</span><br><span class="line">    m[n] = result</span><br><span class="line">    mapChan &lt;- m</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> multi(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ &#123;</span><br><span class="line">        temp := &lt;-mapChan</span><br><span class="line">        <span class="keyword">for</span> key, value := <span class="keyword">range</span> temp &#123;</span><br><span class="line">            myMap[key] = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(myMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码通过channel的方式完成了多协程计算阶乘的功能。在这里我们只是稍微地引出了Go语言中channel的使用方式。如果现阶段暂时没能理解上述代码是没有关系的。后续的几个小节将详细地讲解channel管道的使用方式与注意事项。届时可以反过来重新看上述的代码，想必可以完全理解了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们首先通过一个案例引出了Go语言全局变量的资源竞争问题。然后又简要地讲解了全局互斥锁的概念与简单的使用，同时我们也提及了全局互斥锁是一个相对初级的解决资源竞争的方案。最后我们引出了channel的概念，并通过channel的方式解决了上述的资源竞争的问题。在下个小节中，我们将开始针对Go语言中的channel进行相对详细地讲解，并通过代码案例来说明各个知识点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-51-gt-资源竞争与管道&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-51-gt-资源竞争与管道&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;51&amp;gt; 资源竞争与管道&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;50&gt; Goroutine入门</title>
    <link href="http://yoursite.com/2020/03/27/50-Goroutine%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2020/03/27/50-Goroutine%E5%85%A5%E9%97%A8/</id>
    <published>2020-03-27T08:17:33.000Z</published>
    <updated>2020-03-27T08:18:43.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-50-gt-Goroutine入门"><a href="#Go语言从入门到放弃系列-lt-50-gt-Goroutine入门" class="headerlink" title="Go语言从入门到放弃系列&lt;50&gt; Goroutine入门"></a>Go语言从入门到放弃系列&lt;50&gt; Goroutine入门</h2><p>&emsp;&emsp;在上个小节中我们从概念上讲解了进程、线程、协程的关系，以及并发和并行的区别与联系。同时我们也针对了线程协程的执行效率做了简要的讨论。</p><p>&emsp;&emsp;在这个小节中，我们将开始通过简单的代码来讲解Go语言中协程的特性与注意事项。如果说前面的各个章节中的知识点的讲解中，如果代码相同，我们都可以得到同样的答案（除了物理地址），那么对于协程的使用而言，同样的代码的执行结果大家的可能就不甚一致了，而且更多的情况中是非常不一致的。因此在这个小节中我们所展示出来的执行结果只是诸多可能的结果中的一个。 </p><h3 id="Goroutine快速入门"><a href="#Goroutine快速入门" class="headerlink" title="Goroutine快速入门"></a>Goroutine快速入门</h3><p>&emsp;&emsp;在上个小节中，我们提到：协程是一种逻辑上的概念而不是物理上的概念，同时我们在举例的时候也曾将协程的本质比作为一个函数。在Go语言的实现中，协程确实就是一个函数，它的内容与普通函数没有什么本质上的区别，只是在函数的调用过程中进行多协程、多线程的调用而已。 </p><p>&emsp;&emsp;基于上述的讲解，我们假设一种简单的需求：在Go语言主线程中每隔1秒输出一句”我在主线程X”，同时我们也需要在一个协程中每隔一秒输出一句”我在协程中X”，上述过程重复10次，X为当前所在的次数。如果我们不使用协程，因为顺序结构的存在，这两个过程就需要具有先后顺序。我们先完成顺序结构的代码的编写，进而再修改为协程的模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inRoutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">"我在协程中"</span>, i)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inRoutine()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">"我在主线程"</span>, i)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们定义了一个名为inRoutine的函数，在函数中我们循环10次，每次输出一个字符串并等待1秒钟。在主函数中我们首先调用了这个函数，然后再执行另一个循环，循环中输出10次我在主线程。那么根据之前我们所讲解的顺序结构，我们可以直接分析出执行结果：即先输出10次”我在协程中”，然后再输出10次”我在主线程”，且这个结果是一定的，不会有任何的例外。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我在协程中 <span class="number">1</span></span><br><span class="line">我在协程中 <span class="number">2</span></span><br><span class="line">...</span><br><span class="line">我在协程中 <span class="number">10</span></span><br><span class="line">我在主线程 <span class="number">1</span></span><br><span class="line">...</span><br><span class="line">我在主线程 <span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个结果是毋庸置疑的，而且通过运行过程我们也可以发现大致运用了20秒的时间，因此这两个过程是串行的，并没有达到我们的要求。现在我们就将上述的串行过程修改为并行的过程，改动的地方其实只有一个，将调用函数的部分修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> inRoutine()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时修改过后的程序就成为并行的形式了，可以看做为”我在主线程”的输出与”我在协程中”的输出是同时发生的。但是因为我们需要在屏幕上输出，而屏幕的输出是有顺序的，因此屏幕输出的时候是无法同时输出两个字符串的。反过来说，我们此时也无法通过屏幕输出的先后确定哪个字符串先输出了，宏观上我们认为是同时。 </p><p>&emsp;&emsp;既然输出的先后关系与发生的同时相悖，所以在同时发生的前提下，究竟谁会先输出是一个不可知的情况，因此大家的输出结果可能不相同。因此在一些测试中，往往不会在程序编写的题目中涉及多线程或多协程的概念，因为一旦涉及了这些概念，输出结果可能就是未知的了，我们下面列举出一个可能的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">我在主线程 <span class="number">1</span></span><br><span class="line">我在协程中 <span class="number">1</span></span><br><span class="line">我在协程中 <span class="number">2</span></span><br><span class="line">我在主线程 <span class="number">2</span></span><br><span class="line">我在主线程 <span class="number">3</span></span><br><span class="line">我在协程中 <span class="number">3</span></span><br><span class="line">我在协程中 <span class="number">4</span></span><br><span class="line">我在主线程 <span class="number">4</span></span><br><span class="line">我在协程中 <span class="number">5</span></span><br><span class="line">我在主线程 <span class="number">5</span></span><br><span class="line">我在主线程 <span class="number">6</span></span><br><span class="line">我在协程中 <span class="number">6</span></span><br><span class="line">我在主线程 <span class="number">7</span></span><br><span class="line">我在协程中 <span class="number">7</span></span><br><span class="line">我在协程中 <span class="number">8</span></span><br><span class="line">我在主线程 <span class="number">8</span></span><br><span class="line">我在协程中 <span class="number">9</span></span><br><span class="line">我在主线程 <span class="number">9</span></span><br><span class="line">我在协程中 <span class="number">10</span></span><br><span class="line">我在主线程 <span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过该结果来看，输出的先后顺序确实没有什么规律，而且再一次运行上述代码所得到的结果与上述结果可能还是不同的。但是有一点是可以确定的：在一个协程中的输出结果是有顺序的，比如协程中1就会在协程中2的前面，但是协程中1却无法保证在主线程1的后面。因此可以讲，协程之间没有确定的先后关系，但是协程之中还是满足顺序结构且具备先后关系的。</p><h3 id="MPG模型简介"><a href="#MPG模型简介" class="headerlink" title="MPG模型简介"></a>MPG模型简介</h3><p>&emsp;&emsp;可以说Go语言具备一次性启动上千的协程的能力都归功于其实现的MPG模型，在这个部分中我们对MPG模型做出简要的说明。M所指的是Machine，每个M一般直接关联一个内核线程，是物理级的且受操作系统管理；P指的是Processor，代表了M执行所需要的上下文环境。G代表Goroutine，其本质也是个轻量级线程，受到P的调度与对接。 </p><p>&emsp;&emsp;一般来说，P的数量往往取决于机器的核心数，例如我们的机器是4核的机器，那么它就会被设定为4。当然我们也可以通过GOMAXPROCS手动设定，在新版本Go中默认就是机器所具备的核数。Goroutine可以有许多个且存在于多个队列中，每个P都会将G从一个队列中取出执行，其他的G处于等待的状态。同时在多个P的情况下，通常每一个P都负责一个队列以减少资源锁的竞争。 </p><p><img src="/2020/03/27/50-Goroutine%E5%85%A5%E9%97%A8/1.jpg" alt></p><p>​                                                                     (图片来源于网络)<br>&emsp;&emsp;因此MPG的关系可以如上图表示：每一个M上挂载一个P，每一个P维护一个G的队列；在某一个时间点上，每个P上只有一个G在运行，其他的G处在队列中等待。因此可以讲，每启动一个Goroutine，都会在某个队列的末尾加入一个G，一旦P运行直到调度点的时候，某个G就会从队列中弹出，设定堆栈等后就开始执行。 </p><p>&emsp;&emsp;那么有些人可能会想：为什么需要这个P，直接把G队列绑定在M上不可以么。答案是不可以的，因为P存在的目的就是进行协程与线程之间的调度。例如在系统调用systemcall的时候，一个线程无法做到同时执行代码和系统调用。因此这个时候当前线程就不得不放弃当前的上下文。假设当前M0维护了一个协程队列，此时M0所执行的G0发生了系统调用，那么M0就必须要等待G0的系统调用的结束，在等待的这段时间中，系统会创建（或借用）一个M1线程，并将P以及P所维护的G队列都挂载在M1上继续进行。 </p><p><img src="/2020/03/27/50-Goroutine%E5%85%A5%E9%97%A8/2.jpg" alt></p><p>&emsp;&emsp;从图中可以看出，此时在系统调用的时候，M0上只有G0，那么当系统调用结束后，M0上就没有P了，它会选择偷一个P过来运行。如果没有多余的P可偷，那么G0就会被放入全局的队列中并被均衡负载在其他的队列中，而M0则进入线程缓存以等待下一个调用的来临。 </p><p>&emsp;&emsp;不仅如此，每个P会定期检查全局队列中是否有剩余的G，以便本M执行完队列中所有的G的时候有事可做。一旦全局G队列中没有多余的G的话，该P会在其他的P中借来一些G去运行。往往当P去借其他的P的时候，它会直接借取其他P的一半的队列。所以说，在多线程多协程的代码中，因为负载均衡，因为系统调用等多个因素，多个协程的执行先后顺序是完全无法被确定的，因此代码的执行结果也是无法预料的。 </p><h3 id="Go语言中线程与协程的关系"><a href="#Go语言中线程与协程的关系" class="headerlink" title="Go语言中线程与协程的关系"></a>Go语言中线程与协程的关系</h3><p>&emsp;&emsp;在之前的小节中，我们介绍到线程是存在于进程中的，协程是存在于线程中的，因此在Go语言中一旦主线程启动了协程之后，程序就会遵循如下的规律：当协程结束时，主线程不受影响；当主线程结束时，协程不论运行到什么状态都要停止且消失。对此我们做一个实验来证明：我们首先将协程中等待1秒改为等待0.5秒，这样协程就会先结束。然后我们令协程中等待1秒，而主线程中等待0.5秒，此时主线程会先结束。我们看最终的输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">我在主线程 <span class="number">1</span></span><br><span class="line">我在协程中 <span class="number">1</span></span><br><span class="line">我在协程中 <span class="number">2</span></span><br><span class="line">我在协程中 <span class="number">3</span></span><br><span class="line">我在主线程 <span class="number">2</span></span><br><span class="line">我在协程中 <span class="number">4</span></span><br><span class="line">我在主线程 <span class="number">3</span></span><br><span class="line">我在协程中 <span class="number">5</span></span><br><span class="line">我在协程中 <span class="number">6</span></span><br><span class="line">我在主线程 <span class="number">4</span></span><br><span class="line">我在协程中 <span class="number">7</span></span><br><span class="line">我在协程中 <span class="number">8</span></span><br><span class="line">我在主线程 <span class="number">5</span></span><br><span class="line">我在协程中 <span class="number">9</span></span><br><span class="line">我在协程中 <span class="number">10</span></span><br><span class="line">我在主线程 <span class="number">6</span></span><br><span class="line">我在主线程 <span class="number">7</span></span><br><span class="line">我在主线程 <span class="number">8</span></span><br><span class="line">我在主线程 <span class="number">9</span></span><br><span class="line">我在主线程 <span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们会发现：协程先结束的情况下，主线程依旧执行直到结束，我们再看主线程先结束的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我在主线程 <span class="number">1</span></span><br><span class="line">我在协程中 <span class="number">1</span></span><br><span class="line">我在主线程 <span class="number">2</span></span><br><span class="line">我在协程中 <span class="number">2</span></span><br><span class="line">我在主线程 <span class="number">3</span></span><br><span class="line">我在主线程 <span class="number">4</span></span><br><span class="line">我在协程中 <span class="number">3</span></span><br><span class="line">我在主线程 <span class="number">5</span></span><br><span class="line">我在主线程 <span class="number">6</span></span><br><span class="line">我在协程中 <span class="number">4</span></span><br><span class="line">我在主线程 <span class="number">7</span></span><br><span class="line">我在主线程 <span class="number">8</span></span><br><span class="line">我在协程中 <span class="number">5</span></span><br><span class="line">我在主线程 <span class="number">9</span></span><br><span class="line">我在主线程 <span class="number">10</span></span><br><span class="line">我在协程中 <span class="number">6</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们会发现，主线程结束后，协程还未运行完的情况下也就结束了。当然此时的”我在协程中 6”出现的原因是屏幕输出并发的原因，而不是主线程结束后协程依旧执行完6才结束的。 </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们讲解了Goroutine的入门程序，简单体验了一下Go语言中多协程编程的过程。在入门案例过后，我们又简单介绍了Go语言中MPG模型，也简单介绍了Go语言中G队列的调度方式。最后我们也说明了线程和协程的执行关系。到目前为止，我们尚只能通过在主线程中延时的方式（time.Sleep）等待协程结束，在下个小节中，我们将介绍Go语言协程中资源竞争的现象与管道Channel的用法，使得主线程以及协程之间可以互相通信。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-50-gt-Goroutine入门&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-50-gt-Goroutine入门&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;50&amp;gt; Gor
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;49&gt; Goroutine概念简介</title>
    <link href="http://yoursite.com/2020/03/26/49-Goroutine%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2020/03/26/49-Goroutine%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/</id>
    <published>2020-03-26T08:31:38.000Z</published>
    <updated>2020-03-26T08:32:30.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-49-gt-Goroutine概念简介"><a href="#Go语言从入门到放弃系列-lt-49-gt-Goroutine概念简介" class="headerlink" title="Go语言从入门到放弃系列&lt;49&gt; Goroutine概念简介"></a>Go语言从入门到放弃系列&lt;49&gt; Goroutine概念简介</h2><p>&emsp;&emsp;在之前的所有章节中，我们讲解的技术都是基于单线程的，换句话说我们的所有的操作都是在一条时间线上按规定的顺序执行。然而现如今，我们大多数人的机器都不是单核的，而是四核、八核乃至于更多，那么将所有的函数功能全部都集中在一个核上运行不仅浪费时间，还浪费了计算能力。 </p><p>&emsp;&emsp;因此从这个小节开始，我们将开始讲解Go语言中的多线程（协程）编程，尽最大的可能充分利用计算机的有限的资源。同时我们也将讲解到Go语言中管道（channel）的用法，讲解协程之间的通讯方式。在这之前，我们需要说明并区分几个概念，分别是：进程、线程、与协程；以及并行和并发的操作。最后我们还会基于线程协程的使用的几点讨论。 </p><h3 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h3><p>&emsp;&emsp;这三个概念和操作系统底层具备一定的关系，在这里我们并不希望通过硬件的讲解来说明这几个概念，只是大致通过具象的案例来说明。在大多数的计算机语言中，我们可能接触到的更多的是进程与线程的概念，而协程这个概念相对较少。协程并不是Go语言所独有的，但是Go语言对协程的实现也是这个语言的一大亮点。 </p><h4 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h4><p>&emsp;&emsp;进程这个概念也是由来已久了，这个概念在60年代初就已然出现了。狭义上讲，进程就是正在运行的程序实例，举个最简单的例子就是：当我们在Windows上打开了一个exe文件，那么系统中就会多一个程序实例，也就是多了一个进程。再比如说，当我们切出任务管理器，进入到进程的这个栏目中，我们所能看到的所有的都是进程，当我们将一个程序关闭时，在任务管理器中这个进程也就消失了，当我们通过任务管理器结束某个进程时，对应的程序也同样结束。 </p><p>&emsp;&emsp;在任务管理器中不是所有的进程都能够在桌面（控制台）可见，因为有许多的进程都是后台进程。比如系统的更新服务，各个硬件的驱动程序，系统中断服务等。 </p><p>&emsp;&emsp;广义上来说，进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动（源自百科）。在传统的操作系统中，进程是一个基本的分配单元，也是一个一个基本的执行单元。每一个进程都有自己的地址空间，一般情况下地址空间中包含代码段、数据段、和堆栈段。代码段存储处理器执行的代码、数据段存储变量和执行期间使用的内存、堆栈段则维护活动过程中的指令和本地变量。 </p><p>&emsp;&emsp;简而言之，进程可以被理解为一个在操作系统中正在运行的程序，每打开一个程序，系统中就会多一个（甚至几个）进程。一个操作系统中可以包含多个进程，进程之间相互独立，其可以同时运行。</p><h4 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h4><p>&emsp;&emsp;在上面说进程是操作系统中最小的资源管理单元，那么线程就是操作系统中最小的执行单元。不论是进程还是线程，都是由操作系统底层所管理的。线程是被包含在进程之中，是进程的实际运作单位，一个线程就是进程中的一个单一顺序的控制流，一个进程可以并发多个线程。 </p><p>&emsp;&emsp;线程是独立调度和分派的基本单位，线程可以分为操作系统内核所调度的线程，以及用户进程自行调度的用户线程。在多核或多CPU中使用多线程程序设计的好处是显而易见的：多线程提高了程序的执行吞吐率， 在单核CPU上使用多线程可以将I/O处理、人机交互等延时操作与计算分开执行。例如在一些网络游戏中，往往会分出一个线程用来做网络交互、一个线程做游戏控制、一个线程做界面输出。 </p><p>&emsp;&emsp;一个进程可以具备多个线程，如果将进程理解为操作系统，那么线程的地位就是相当于操作系统的进程。因此线程可以被理解为一个轻量级的进程，它也是独立调度和分配的基本单元。同时线程可以并发执行且共享进程资源。 </p><p>&emsp;&emsp;那么既然说起共享资源，那就不得不提出多线程的一个主要难题：资源冲突，即多个线程公用一个资源时就很容易出现这个问题，例如两个并发线程中，一个线程读取一个文件，另一个线程写入这个文件，那么此时就出现了资源问题。那么其解决方式就是添加同步锁等，这个行为是比较消耗计算资源的，同时在线程之间的互相切换过程中，也是消耗系统资源的。不仅如此，因为线程是由操作系统所调度的，所以就如同打开软件多了系统会卡顿一样，当一个程序启动的线程多了，操作系统和该软件也会卡顿。因此，即便线程是轻量级的进程，但是对于一些应用来说，它还是相对重一点。</p><h4 id="3-协程"><a href="#3-协程" class="headerlink" title="3. 协程"></a>3. 协程</h4><p>&emsp;&emsp;协程相比于线程，就如线程相比于进程。协程可以理解为更为轻量级的线程，只是协程不由操作系统所接管，而是由程序进行控制其挂起和运行等操作的。因此，可以将协程理解为一个特殊的函数，这种函数可以在某个地方挂起，也可以在挂起处继续运行。一个线程可以具备多个协程，换句话说，一个线程内可以具备多个类似的特殊的函数。 </p><p>&emsp;&emsp;协程具备自己的寄存器以及上下文，协程在调度切换时，是将寄存器等保存在其他地方，当从挂起的地方继续执行时，会将保存下来的资源恢复。协程相比于线程有一个本质上的区别，线程是操作系统中最小的执行单元，归根结底线程还是在操作系统的控制之中的，其并发调度运行是物理级别的。而协程看作为一种特殊的函数，是通过线程的程序所调度的，因此此时的并发操作是逻辑上的，内存级别的，没有像线程调度一般需要系统资源。 </p><p>&emsp;&emsp;一个线程可以具备多个协程，反过来说多个协程是存在于一个线程中的。由于只有一个线程，因此它不存在同时写变量的冲突。在协程中控制共享资源不加锁，只需要判断状态即可（但会出现资源竞争问题），因此其执行效率比多线程效率高。那么既然协程是在一个线程中执行，多核CPU并行操作则是采用进程+协程的方式完成的，这既充分利用了多核操作，又充分发挥了协程的高效率，性能会有较大的提升。</p><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>&emsp;&emsp;这两个概念也比较容易混淆，也确实有时候比较难以分辨两个词的区别。本质上来说，这两个词都代表了多个任务”同时”完成的情况，但具体区别则是单核与多核的区别。 </p><h4 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h4><p>&emsp;&emsp;并发在操作系统中是指某一个时间段中，有几个程序都处于启动的状态下。这几个程序都是在同一个计算单元上运行，但是任何一个时间点上其实只有一个程序在计算单元上运行。CPU分配时间片给每个程序，让每一个程序都有机会快速地运行，在视觉效果上，就像是多个程序同时执行。 </p><p>&emsp;&emsp;用一个比较具象化的例子来说就是写作业的过程：假设一个学生需要完成数学、语文、英语、物理四门课的作业。有一种写作业的办法就是：按顺序做完每一科作业，做完数学作业再开始做物理作业。第二种方式则是数学做一点，语文做一点，英文做一点，物理做一点，之后再数学做一点，一直到所有的作业都做完。其实两种写作业所用的时间相差无几，但是在视觉效果上看，这个学生好像四科作业同时在做。 </p><p>&emsp;&emsp;对于计算机的并发而言，无非就是将上述第二种写作业的方式的运行时间极大缩短，假如说做了10毫秒的数学之后立刻做10毫秒的语文。这样在极短的时间下，不仅视觉上还是感觉上都像是多个任务同时发生了。 </p><h4 id="2-并行"><a href="#2-并行" class="headerlink" title="2. 并行"></a>2. 并行</h4><p>&emsp;&emsp;并行则是计算机系统中同时执行两个或多个处理的计算方法。其主要目的是节省大型和复杂问题的解决时间，对代码工作做出一定的优化。将多个相互独立的任务分配给计算机的不同的CPU核中使之同时完成。但是并行并不能保证一定会加速。理论上来说，在n个并行处理的执行速度的最好结果是在单一处理器上执行的速度的n倍，但往往达不到这个比例。 </p><p>&emsp;&emsp;我们依旧采用上述写作业的例子来说明并行，假如这个学生依旧需要完成这四门功课。这时，这个学生又找来了三个朋友，并让这三个朋友帮助自己，使每一个人各做一门功课。这样在外人的眼中看来，这四门课才是真正的同时完成的，且也是真正节省了时间的。 </p><h4 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h4><p>&emsp;&emsp;并行与并发概念十分相似，但是又有所区别：并行的概念是指多个事件在同一时刻发生，而并发的概念则是多个事件在同一时间间隔内发生。在多程序的前提下，并发是指一段时间内宏观上有多个任务同时运行，但是在微观上则是只有一个任务分时交替进行。在计算机中若有多个处理器，任务被分配到不同的核心上，实现并行执行，此时多个任务是真正地同时进行。 </p><h3 id="基于多线程（协程）思想的几点讨论"><a href="#基于多线程（协程）思想的几点讨论" class="headerlink" title="基于多线程（协程）思想的几点讨论"></a>基于多线程（协程）思想的几点讨论</h3><p>&emsp;&emsp;在大多数情况下，我们都会说多线程多协程会节省时间，但是这个节省时间也是有一定条件的，这个条件就是I/O密集。在介绍并发的概念时我们所举的例子中，我们可能会发现每个作业做一点直到做完和按顺序做完每一科作业似乎没什么区别，甚至在并发的时候不断地换作业册反而更浪费时间。对于计算机而言其实也是一样的，线程、协程之间的调度也是需要时间和资源的，如果用并发模式来解决作业的问题显然是不可取的。 </p><p>&emsp;&emsp;现在我们换一种方式来理解，假如对于各个单科作业而言，每做完一小部分都需要家长核查一下答案，如果答案正确才可以继续进行。在这个前提下，如果按顺序完成单科作业的话，学生则会需要很多的等待时间。这个等待时间如果被利用下来去做其他科目的作业，那么学生和家长就可以好好地配合起来了。对于计算机而言，CPU和I/O可以被认为两种相对独立的任务，且CPU中运算速度是比I/O执行速度要快的多。例如当前的任务是打开一个文件，读取文件中的两个数，相加并写进这个文件中。那么这个任务所用的时间绝大多数都花在了打开文件和写入文件上。当I/O在完成这两个步骤时CPU其实是空闲的。 </p><p>&emsp;&emsp;因此可以讲，对于并发模式的使用而言，I/O密集的任务更为适合。而对于那种数学计算等任务，绝大多数运算都在CPU中，而没有文件操作，那么并发模式不仅没有节省时间，反而浪费了更多的时间。 </p><p>&emsp;&emsp;那么对于并行模式而言，虽然它可以真切地减少运行时间，但是能够应用并行模式的算法不多。只有同一个层面上相互独立的任务才有机会使用并行的模式。当多个函数之间存在先后关系，即后一个函数需要前一个函数的结果时，并行模式就不是很适用了。对于一个算法而言，一定会有可以并行运行的部分和必须要串行运行的部分。因此来说，即便是4核、8核的CPU，程序运行效率也无法达到4倍或8倍。 </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们介绍了进程、线程、和协程的概念，同时也区分了并行模式和并发模式的区别。在最后我们也针对并行和并发模式做出了几点讨论。可以说在这个小节中我们没有涉及到任何的代码操作，只是在思路上和概念上进行了一定的科普。在下个小节中，我们将介绍Go语言中Goroutine的语法以及其需要注意的各个事项。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-49-gt-Goroutine概念简介&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-49-gt-Goroutine概念简介&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;49&amp;gt;
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;48&gt; JSON与序列化</title>
    <link href="http://yoursite.com/2020/03/25/48-JSON%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://yoursite.com/2020/03/25/48-JSON%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2020-03-25T15:44:23.000Z</published>
    <updated>2020-03-25T15:45:03.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-48-gt-JSON与序列化"><a href="#Go语言从入门到放弃系列-lt-48-gt-JSON与序列化" class="headerlink" title="Go语言从入门到放弃系列&lt;48&gt; JSON与序列化"></a>Go语言从入门到放弃系列&lt;48&gt; JSON与序列化</h2><p>&emsp;&emsp;在上个小节中，我们讲解了Go语言中文件的各个基本操作。在这个小节中，我们将对Go语言中的序列化与反序列化的方式进行讲解，同时也对JSON数据格式进行提及。这个小节的核心其实就是两个函数的使用，其他的基本都是针对这两个函数进行细节的讲解。首先我们先简要介绍JSON的数据格式。</p><h3 id="JSON数据格式"><a href="#JSON数据格式" class="headerlink" title="JSON数据格式"></a>JSON数据格式</h3><p>&emsp;&emsp;JSON是一种轻量级的数据交换格式，易于人的阅读与机器的解析和生成。JSON是JavaScript Object Notation的简写。其层次结构简洁清晰，因此迅速成为了一种流行且理想的数据交换语言。在JS语言中一切均是对象，所以任何对象都可以通过JSON来表示，字符串、数组、数字、对象等均可以表示。在这里我们并不需要掌握JS语言，也不需要理解JS与JSON到底有什么关系，我们目前所关心的只是这种交互数据格式。 </p><p>&emsp;&emsp;我们举一个数据交互的例子：假如我们用Go语言写出了即时通讯的客户端与服务器（类比于QQ），当用户之间进行通信时，就需要一个客户端将信息发送给服务器，服务器将信息转交给另一个客户端。那么客户端到底发出了什么消息，这个就是交互数据。同理假如我们通过网页访问服务器，例如CRM系统后台，我们依旧需要从浏览器发出一个HTTP请求，请求中带有需要交互的数据。 </p><p>&emsp;&emsp;可以说交互数据就是双方的一种协议，双方规定好数据如何传输，某一个键到底对应了什么值。一旦这些规定都完成后，前后台就可以基本完全地分离，甚至双方所用的技术语言都可以不同，只要他们按规定传输数据、按规定解析数据即可。 </p><p>&emsp;&emsp;既然是规定协议，那么JSON就需要遵循几个规则，其规则如下：</p><h4 id="1-大括号保存对象"><a href="#1-大括号保存对象" class="headerlink" title="1.大括号保存对象"></a>1.大括号保存对象</h4><p>&emsp;&emsp;所有JSON对象都是存在于一对大括号之间的，大括号可以进行嵌套。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="2-键值对表示对象"><a href="#2-键值对表示对象" class="headerlink" title="2.键值对表示对象"></a>2.键值对表示对象</h4><p>&emsp;&emsp;键值对的概念我们曾经在map映射部分进行过提及，因此这里不对键值对的概念再做什么说明。键与值之间用冒号进行连接，不同数据之间用逗号分隔。例如我们想传输某个学生的信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Devin"</span>,<span class="string">"age"</span>:<span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="3-中括号保存数组"><a href="#3-中括号保存数组" class="headerlink" title="3.中括号保存数组"></a>3.中括号保存数组</h4><p>&emsp;&emsp;一旦一个JSON对象需要传输多组数据，那么就需要用中括号来保存数组。数组中的每一个元素均遵循大括号保存对象与键值对表示对象的原则，例如我们希望传输两个学生的信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="string">"name"</span>:<span class="string">"DENG"</span>,<span class="string">"age"</span>:<span class="number">25</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"YANG"</span>,<span class="string">"age"</span>:<span class="number">24</span>&#125;]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个JSON字符串中，我们可以发现，中括号中具有两个部分，每个部分都是一个对象，即分别由大括号包裹，每个大括号中又分别有name和age两个属性。 </p><p>&emsp;&emsp;不仅如此，JSON字符串中还可以保存普通的数组，甚至普通的基本数据，可以讲JSON确实是便于传输的数据格式，在AJAX框架中，JSON就是其专门的传输格式。当然上面说的这些也不重要，只需要能够看懂即可（相信大多数人一下子就都能看懂），同时我们也基本不会要求手写JSON数据，因为这种数据的生成往往是靠程序完成的。因此接下来我们将介绍在Go语言中JSON字符串的生成与解析。</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>&emsp;&emsp;理论上来说，序列化与JSON是没有关系的，只是说在Go语言中JSON是序列化的一个良好的形式。序列化是将对象的状态信息转换成可以存储或可以传输的形式的过程。我们举一个例子，假如我们的程序中有Student类，类中有Name和Age属性，在main函数中我们定义了一个数组，数组中包含5个Student对象，现在我们希望将这5个学生对象存在硬盘中，以备在程序关闭后下次执行的时候读取它，也就是一个保存的过程。 </p><p>&emsp;&emsp;面对这个需求，我们可能会想出如下的一个保存方式：将5个学生的信息整合成为一个字符串，属性之间用空格隔开，不同的对象之间用回车隔开，然后用IO存在本地的记事本中。这个过程其实包含了两个步骤，一个时Student对象的序列化，一个是序列化后的持久化。我们按时不看持久化过程，只看序列化过程，我们将信息整合成为一个字符串之后，就可以存储在本地，或者将这个字符串发送给其他客户端或服务器。而如果不进行序列化，对象只是在内存中的一段空间而已，是无法存储或传输的。 </p><p>&emsp;&emsp;当然，序列化不仅仅是整合成为一个字符串那么简单，它还可以整合成为其他的形式，有其他的协议规定。因此我们说JSON是一个序列化的一种合适的形式，xml文件也可以成为一种序列化的形式，我们这里只介绍JSON。 </p><h4 id="1-类的序列化"><a href="#1-类的序列化" class="headerlink" title="1.类的序列化"></a>1.类的序列化</h4><p>&emsp;&emsp;由于JSON数据的基本格式是键值对，因此类属性的定义刚好就天然地满足了键值对的格式，因此我们就先从类的序列化开始。首先我们定义一个Student类，包含Name属性和Age属性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后我们在main函数中实例化一个Student类，并为之赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s Student = Student&#123;<span class="string">"DENG"</span>, <span class="number">25</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在数据已经准备好了，我们接下来就开始对s进行序列化，我们首先需要引入一个包：encoding/json，然后使用该包中的Marshal()函数，我们将s对象传入，并得到两个返回值，分别为序列化后的数据data和error对象。得到的data数据是是个byte切片，我们在输出时将其转换为string类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s Student = Student&#123;<span class="string">"DENG"</span>, <span class="number">25</span>&#125;</span><br><span class="line">    data, err := json.Marshal(s)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"序列化失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行了上述程序之后，我们将会发现其结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"Name"</span>:<span class="string">"DENG"</span>,<span class="string">"Age"</span>:<span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们发现这个JSON字符串中的key值刚好就是Student类中的两个属性名，字符串中的value值则是我们为之赋值的数据。 </p><p>&emsp;&emsp;在这段程序中，我们会发现一个问题，在多人协作开发的过程中，往往需要key值都是小写的，如果我们将属性名的首字母变为小写，序列化的结果就是空的。这是因为我们是使用其他包中的函数，如果我们定义的属性是小写，则属性对于其他包是不可导出的，那么json包中当然就读不到对应的属性了，这个解决办法就是为属性添加tag利用反射的方式完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">    Age <span class="keyword">int</span>  <span class="string">`json:"age"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们加入了tag之后（数字1的左面的键，tab的上面的键），相当于告诉了json包，在序列化的过程中，将Name的key变为name，将Age这个key变为age，就完成了对应的功能。具体实现原理暂时不做解释，我们将会在反射的章节中详细说明。</p><h4 id="2-map映射的序列化"><a href="#2-map映射的序列化" class="headerlink" title="2.map映射的序列化"></a>2.map映射的序列化</h4><p>&emsp;&emsp;在Go语言中，不仅类属性满足于键值对的形式，map映射依旧满足于这个形式，在这个部分中，我们将举例讲解map的序列化的方式。 </p><p>&emsp;&emsp;我们首先定义一个map映射，map中的key是字符串类型，map中的value是空接口类型(interface{})，（回忆一下接口的实现原理：一个数据类型实现了接口中定义的方式则认为实现了该接口，同时该数据可以将指针赋值给接口实例）因为接口是空的，没有定义任何的方法，因此也可以说一切都实现了空接口，也就是一切都能作为map的值。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    m[<span class="string">"name"</span>] = <span class="string">"DENG"</span></span><br><span class="line">    m[<span class="string">"age"</span>] = <span class="number">25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时name所对应的value是字符串”DENG”，age所对应的value是整数25，现在我们将map映射进行序列化操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    m[<span class="string">"name"</span>] = <span class="string">"DENG"</span></span><br><span class="line">    m[<span class="string">"age"</span>] = <span class="number">25</span></span><br><span class="line">    data, err := json.Marshal(m)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"序列化错误"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们会发现，其结果是类似的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"age"</span>:<span class="number">25</span>,<span class="string">"name"</span>:<span class="string">"DENG"</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="3-切片的序列化"><a href="#3-切片的序列化" class="headerlink" title="3.切片的序列化"></a>3.切片的序列化</h4><p>&emsp;&emsp;根据之前的理解，切片中存储这多个同类型的数据，因此其序列化的结果应当是一个数组结合，在接下来的案例中，我们将实例化两个Student对象，并将对象放入切片中，最后序列化该切片，切片技术等都已然讲解过，因此直接通过代码体现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]Student, <span class="number">0</span>)</span><br><span class="line">    stu1 := Student&#123;<span class="string">"DENG"</span>, <span class="number">25</span>&#125;</span><br><span class="line">    stu2 := Student&#123;<span class="string">"YANG"</span>, <span class="number">24</span>&#125;</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">append</span>(s, stu1)</span><br><span class="line">    s = <span class="built_in">append</span>(s, stu2)</span><br><span class="line"></span><br><span class="line">    data, err := json.Marshal(s)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"序列化错误"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们会发现，其结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="string">"name"</span>:<span class="string">"DENG"</span>,<span class="string">"age"</span>:<span class="number">25</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"YANG"</span>,<span class="string">"age"</span>:<span class="number">24</span>&#125;]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同理，假如我们切片中存储的是map映射，其结果依旧类似，我们就不在这里赘述了。</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>&emsp;&emsp;作为序列化的逆过程，反序列化似乎就不难理解了。假如当我们从网络或者从文本文件中读取到了一个JSON字符串，我们想将其反过来赋值给一个map，一个类，或者一个切片，所用到的技术就是就反序列化技术。</p><h4 id="1-反序列化为类对象"><a href="#1-反序列化为类对象" class="headerlink" title="1. 反序列化为类对象"></a>1. 反序列化为类对象</h4><p>&emsp;&emsp;作为类的序列化的逆过程，我们需要首先具备JSON字符串，以及需要类的定义，然后才能通过该技术获取对象，我们通过案例来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">`&#123;"name":"DENG","age":25&#125;`</span></span><br><span class="line">    <span class="keyword">var</span> s Student</span><br><span class="line">    err := json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;s)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"反序列化失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在代码中，首先需要说明的一点是：我们在定义字符串的过程中采用了反引号（`），这是因为我们希望在字符串中保留双引号，否则我们需要通过转义的形式保留双引号。反引号的使用可以使其原样保存。 </p><p>&emsp;&emsp;第二点需要说明的是，我们传入Unmarshal函数的是Student对象指针，因为我们需要在Unmarshal函数中改变s内的值（直接传入s对象是错误的）。这段代码的结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;DENG <span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里还需要注意的一点是：假如此时我们的Student类中的Age属性（加了tag）的数据类型改为int8，反序列化依旧能够成功，因为在类型转换的时候没有出现问题。现在假如我们将25变为225，并将Age的类型改为int8，由于类型转换有误，所以输出结果为：反序列化失败。通过这个问题我们可以发现：JSON反序列化的本质就是字符串转换为其他类型而已，与生成JSON字符串的原类型无关。</p><h4 id="2-反序列化为map"><a href="#2-反序列化为map" class="headerlink" title="2. 反序列化为map"></a>2. 反序列化为map</h4><p>&emsp;&emsp;如果我们将Student类定义看成一个模板，将JSON字符串看做为内容，反序列化的工作就是将内容向模板上填充。反序列化为map也是一样的，我们定义一个map作为数据模板，然后将内容填充进去：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">`&#123;"name":"DENG","age":25&#125;`</span></span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    err := json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;m)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"反序列化失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, m[<span class="string">"age"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述程序中，我们定义了一个map，map的key是string类型，值是空接口，然后我们将str对应的byte切片和m指针传入。同时，我们又数据了m[“age”]所对应的数据类型:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[name:DENG age:<span class="number">25</span>]</span><br><span class="line"><span class="keyword">float64</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过结果我们可以发现：反序列化的结果是正确的，且JSON中的key值成为了map中的key，JSON中的键值变为了map中的value。同时我们还可以发现的是，在Unmarshal函数中对数字空接口类型的解读统一为float64。</p><h4 id="3-反序列化为切片"><a href="#3-反序列化为切片" class="headerlink" title="3. 反序列化为切片"></a>3. 反序列化为切片</h4><p>&emsp;&emsp;同理，我们定义一个切片，切片中保存的是Student类，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">`[&#123;"name":"DENG","age":25&#125;,&#123;"name":"YANG","age":24&#125;]`</span></span><br><span class="line">    <span class="keyword">var</span> s []Student</span><br><span class="line">    err := json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;s)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"反序列化失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此处我们依旧可以发现，切片s在程序中是不需要make函数的，因为在Unmarshal函数中已然帮我们make过了，上述的程序的输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;DENG <span class="number">25</span>&#125; &#123;YANG <span class="number">24</span>&#125;]</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p> &emsp;&emsp;在这个小节中，我们讲解了JSON数据类型的构成及其遵循的格式。同时，我们也讲解了Go语言中序列化与反序列化的方式方法，同时也简单说明了在这两个过程中需要注意的几个小点。序列化与反序列化在文件开发与网络开发中起着十分重要的作用，现在xml格式与json格式是传输数据中最为常用的两种模式，xml的序列化方式在encoding/xml包中，读者如果有兴趣可以自行自学尝试一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-48-gt-JSON与序列化&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-48-gt-JSON与序列化&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;48&amp;gt; JSON与序列化&quot;
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;47&gt; 文件与IO&lt;二&gt;</title>
    <link href="http://yoursite.com/2020/03/24/47-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/03/24/47-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%BA%8C/</id>
    <published>2020-03-24T10:16:50.000Z</published>
    <updated>2020-03-24T10:18:12.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-47-gt-文件与IO-lt-二-gt"><a href="#Go语言从入门到放弃系列-lt-47-gt-文件与IO-lt-二-gt" class="headerlink" title="Go语言从入门到放弃系列&lt;47&gt; 文件与IO&lt;二&gt;"></a>Go语言从入门到放弃系列&lt;47&gt; 文件与IO&lt;二&gt;</h2><p>&emsp;&emsp;在上个小节中，我们介绍了Go语言中文件的几个基本操作，包括创建文件、移动文件、删除文件、裁剪文件、以及获取文件信息所对应的函数和方法。在这个小节中，我们依旧针对Go语言中文件的读取和写入进行讲解，包括具备缓冲以及不具备缓冲的读写方式，同时也将对文件的打开模式进行简要的介绍。</p><h3 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h3><p>&emsp;&emsp;在Go语言中，文件的打开有两个函数，分别是Open函数和OpenFile函数，这两个函数的参数是不同的。简而言之，Open函数是OpenFile函数函数的简化，OpenFile函数提供了更多的自由度，可以让开发者自己指明打开方式。</p><h4 id="1-Open函数"><a href="#1-Open函数" class="headerlink" title="1.Open函数"></a>1.Open函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(file *File, err error)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Open函数的入参依旧是希望打开的文件所在的文件路径，相对路径与绝对路径均可以。函数的返回值是File实例指针和一个error实例。通过Open函数打开的文件只可以用于读取，具备O_RDONLY模式（这个模式后面会提及），如果读取出错，将会返回*PathError类型的实例。 </p><p>&emsp;&emsp;在这个部分中，我们首先向text文件中写入三行数据包括英文和中文，接下来我们打开该文件，并通过bufio中的Reader进行读取，将读取到的信息打印到控制台中。对于Reader的穿件和使用，我们曾经在输入字符串的小节中提及过，在这里我们依旧可以通过Reader读取文件中的信息。我们就通过这个案例进行快速入门：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">"text.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"打开文件失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    reader := bufio.NewReader(file)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        info, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"读取失败"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Print(info)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们首先通过Open函数打开文件，然后判断打开是否成功，延迟关闭文件。再定义Reader，使之读取文件中的内容，读取过程中按行读取，直到读取到文件的末尾：EOF（End Of File）停止读取。具体的bufio读取方式我们会在后面集中讲解。</p><h4 id="2-OpenFile函数"><a href="#2-OpenFile函数" class="headerlink" title="2.OpenFile函数"></a>2.OpenFile函数</h4><p>&emsp;&emsp;OpenFile函数相对复杂一点，其函数参数比较多，函数声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(file *File, err error)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以发现，在OpenFile函数中需要三个参数，第一个参数和Open一样，都是希望打开的文件所在的文件路径。第二个参数是一个int类型的参数，它代表着打开文件的模式，例如只读模式打开，只写模式打开，追加模式打开等，具体枚举如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    O_RDONLY <span class="keyword">int</span> = syscall.O_RDONLY <span class="comment">// 只读模式打开文件</span></span><br><span class="line">    O_WRONLY <span class="keyword">int</span> = syscall.O_WRONLY <span class="comment">// 只写模式打开文件</span></span><br><span class="line">    O_RDWR  <span class="keyword">int</span> = syscall.O_RDWR  <span class="comment">// 读写模式打开文件</span></span><br><span class="line">    O_APPEND <span class="keyword">int</span> = syscall.O_APPEND <span class="comment">// 写操作时将数据附加到文件尾部</span></span><br><span class="line">    O_CREATE <span class="keyword">int</span> = syscall.O_CREAT <span class="comment">// 如果不存在将创建一个新文件</span></span><br><span class="line">    O_EXCL  <span class="keyword">int</span> = syscall.O_EXCL  <span class="comment">// 和O_CREATE配合使用，文件必须不存在</span></span><br><span class="line">    O_SYNC  <span class="keyword">int</span> = syscall.O_SYNC  <span class="comment">// 打开文件用于同步I/O</span></span><br><span class="line">    O_TRUNC <span class="keyword">int</span> = syscall.O_TRUNC <span class="comment">// 如果可能，打开时清空文件</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第三个参数是指打开文件时的权限控制，这个在Windows操作系统中不起作用，而是在例如Linux系列或Unix系列操作系统等中会起作用。在linux操作系统中，一个文件针对用户具备三种权限，分别为r可读权限（4），w可写权限（2），以及x可执行权限（1）。同时一个文件针对本用户，用户组，其他用户的权限是不同的。 </p><p>&emsp;&emsp;例如我们在Linux终端中用ls -l命令，我们在第一列可能发现好多的dwrxwrxwrx，这里面d指代的是目录（-指代文件），第一组rwx表示对于该文件所属的主人是否具备读写执行权限，第二组rwx指对该用户所在的组的权限，最后一组代表该文件对其他用户的权限。因此，假如该文件对属主有读写执行权限，对于组内用户有读写权限，对于其他用户没有权限，则该权限为： -rwxrw—-。如果对于所有用户都有读写权限，那么我们就可以使用0666作为FileMode的值（三个组都是4+2）。由于这个涉及操作系统，因此我们不在这里详细说明了。 </p><p>&emsp;&emsp;在上一个小节中，我们也说到了在使用Create函数时，创建的文件权限就是0666，当然在OpenFile过程中，FileMode<strong>对Windows操作系统不起作用</strong>，因此写0666或者其他的0233其实都没有影响。现在我们通过OpenFile形式打开文件，其他的代码不变：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.OpenFile(<span class="string">"text.txt"</span>, os.O_RDONLY, <span class="number">0233</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时我们是通过只读的方式打开的文件，现在假如我们通过只写的方式打开文件，其他代码不变，会出现什么效果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.OpenFile(<span class="string">"text.txt"</span>, os.O_WRONLY, <span class="number">0233</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出结果为：读取失败，并return跳出程序，因为针对只写的文件，不可以读取。 </p><p>&emsp;&emsp;在flag中，我们不仅可以指明一种文件的打开模式，我们还可以指明多种组合打开方式，中间用”|”来分割。需要注意的是，组合中各个模式不可以互斥，例如通过只写模式和只读模式组合打开，那程序依旧无法读取文件中的内容。</p><h3 id="带缓冲区的读写"><a href="#带缓冲区的读写" class="headerlink" title="带缓冲区的读写"></a>带缓冲区的读写</h3><h4 id="1-读取"><a href="#1-读取" class="headerlink" title="1. 读取"></a>1. 读取</h4><p>&emsp;&emsp;在文件正确地且模式正确地打开过后，就可以向文件中写入或读取数据了，我们首先介绍的是具备缓冲区的读写方式。即通过bufio包中的newReader函数和newWriter函数获取对应的实例进行操作。由于获取Reader这个操作我们之前多次提及过了，因此我们就简单地说明一下而不举例了。 </p><p>&emsp;&emsp;在上面读取文件的代码中，我们是通过逐行读取的方式进行的，逐行读取的特点是按行读取，即每读到一个换行符（’\n’）就停止了此次的读取。值得注意的是读取到info的字符串末尾是含有’\n’的，因此我们在输出的时候就不需要Println了，而是采用的Print。在读取字符串过后，我们需要判断返回的err情况：如果err为EOF，说明读到了文件的末尾；除此之外err如果不为空，则说明读取失败（例如以只写的方式开发文件）。最后我们再进行处理info字符串。 </p><p>&emsp;&emsp;在读取过程中有人可能会遇到这样的一种情况：打开记事本后发现，最后一行没有输出出来。其原因是如果是最后一行，err会出现EOF现象，因此程序在未处理info的情况下就直接退出了。修改的方法可以是让程序先处理info字符串，再判断err，但是这样一旦读取失败，处理子串的工作就会出错。因此我们可以直接在记事本中最后一行后敲击回车，这样最后一行可以被读取，且由于换行的存在，err不会出现EOF。或者就在判断EOF的分支中做最后一次的字符串处理。</p><h4 id="2-写入"><a href="#2-写入" class="headerlink" title="2.写入"></a>2.写入</h4><p>&emsp;&emsp;写入和读取是一组逆过程，换句话说程序是如何读取的，就可以同理联想到如何写入。在这里我们举一个例子进行快速入门：向text.txt中写入10句Hello World！：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.OpenFile(<span class="string">"text.txt"</span>, os.O_WRONLY, <span class="number">0233</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"打开文件失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    writer := bufio.NewWriter(file)</span><br><span class="line">    info := <span class="string">"Hello World !\n"</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        writer.WriteString(info)</span><br><span class="line">    &#125;</span><br><span class="line">    writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们依旧打开text.txt文件，然后以只写的形式打开，然后通过bufio包中的NewWriter得到输出流，并通过该Writer向记事本中写十句话。这里尤其需要注意的一点是：由于Writer是具备缓存的，因此我们所使用的WriteString其实是向缓存中写入了十句话，而没有向文件中写。最后要用Flush方法将缓存中的数据写入硬盘，如果不调用这个方法，数据是无法写入的。 </p><p>&emsp;&emsp;需要说明一下换行的问题，传说在早期的电传打字机中，每秒可以打印10个字符，但是打完一行之后换行的时间0.2秒中刚好丢失两个字节，因此研究人员想了一个方法，就是在每行后面规定两个表示结束的字符：一个是回车，一个是换行。后来计算机发明之后，这个概念也就应用到了计算机上，但是在计算机上结尾加两个字符有些浪费，加一个字符其实就可以了，因此出现了这样的一个（坑爹的）分歧： </p><p>&emsp;&emsp;Unix操作系统中，每行的结尾是换行’\n’； </p><p>&emsp;&emsp;Windows操作系统中，每行的结尾是换行+回车’\r\n’； </p><p>&emsp;&emsp;Mac系统中，每行结尾是回车。 </p><p>&emsp;&emsp;其后果就是在Unix/Mac系统中的文件在Windows下打开，可能所有的字都变成了一行；Windows系统的文件在Unix/Mac系统下打开，会多一个莫名其妙的符号。因此，不同的平台下的换行需要自行注意一下。</p><h3 id="一次性读写"><a href="#一次性读写" class="headerlink" title="一次性读写"></a>一次性读写</h3><p>&emsp;&emsp;在上面的介绍中，我们讲解了带有缓冲的读写方式，这种方式可以将一个文件按行、按块地分批地读写。还有一种读写的方式是将文件一次性地读取写出，当文件的大小超过了内存所能容纳的大小，就会出现问题。所以在编程过程中还是相对推荐有缓存的方法的，当然如果文件都比较小，两种方式都差不多。 </p><h4 id="1-一次性读入"><a href="#1-一次性读入" class="headerlink" title="1. 一次性读入"></a>1. 一次性读入</h4><p>&emsp;&emsp;一次性读入的函数所在io/ioutil包中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;函数的参数是希望读入的文件的路径，可以是相对路径或绝对路径。返回值有两个，第一个是存储文件内容的byte切片，第二个返回值是在读取过程中是否出现了错误。我们通过案例代码进行快速入门：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    info, err := ioutil.ReadFile(<span class="string">"text.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"读取错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要说明的一点就是，ReadFile函数是在io/ioutil包中（理解成文件夹就是io文件夹下的ioutil文件夹中），因此单独引入io包是没有用的，即便是io文件夹是ioutil文件夹的父文件夹。第二点说明的是，其返回值是byte切片，因此直接输出将会是一些数字，我们需要将其以字符的形式输出，同样地byte切片对于中文的支持十分不友好，因此我们在输出的时候需要将其转为字符串输出。最后一点说明是文件打开关闭都已然封装在了函数中，因此不需要显式的打开和关闭文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Print(<span class="keyword">string</span>(info))</span><br></pre></td></tr></table></figure><h4 id="2-一次性写入"><a href="#2-一次性写入" class="headerlink" title="2. 一次性写入"></a>2. 一次性写入</h4><p>&emsp;&emsp;作为读取文件的逆过程，一次性写入的函数WriteFile也在io/ioutil包中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(filename <span class="keyword">string</span>, data []<span class="keyword">byte</span>, perm os.FileMode)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;函数参数依旧是写入文件的路径；希望写入的byte切片；以及文件权限。如果当前文件不存在将会以对应的FileMode创建该文件并写入，如果文件已然存在则会先清空文件再写入。这里不多做说明了，直接通过案例演示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">"Hello 世界! \n"</span></span><br><span class="line">    err := ioutil.WriteFile(<span class="string">"aaa.txt"</span>, []<span class="keyword">byte</span>(str), <span class="number">233</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"写入失败"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过WriteFile函数依旧不需要打开或关闭文件，这两个过程都被封装在函数中。在写入的时候需要将字符串转换为byte切片再传入函数中。最后文件模式同打开文件中所介绍的一样，对于Windows操作系统不起作用，对于Linux等系统需要进行修改（一般是0666或0777）。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们主要讲解了Go语言中文件的打开关闭函数，以及具有缓存和不具有缓存的读写方式。这个小节其实只是对入门开发者进行简要的介绍，当然Go语言API文档中还提供了例如读取当前文件路径等函数，因此对于那些熟练开发的程序员来说，这篇文章其实不甚适合，直接在API文档中寻找对应方法或函数方为上策。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-47-gt-文件与IO-lt-二-gt&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-47-gt-文件与IO-lt-二-gt&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;47&amp;gt;
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;46&gt; 文件与IO&lt;一&gt;</title>
    <link href="http://yoursite.com/2020/03/22/46-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%B8%80/"/>
    <id>http://yoursite.com/2020/03/22/46-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%B8%80/</id>
    <published>2020-03-22T12:38:41.000Z</published>
    <updated>2020-03-22T12:39:50.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-46-gt-文件与IO-lt-一-gt"><a href="#Go语言从入门到放弃系列-lt-46-gt-文件与IO-lt-一-gt" class="headerlink" title="Go语言从入门到放弃系列&lt;46&gt; 文件与IO&lt;一&gt;"></a>Go语言从入门到放弃系列&lt;46&gt; 文件与IO&lt;一&gt;</h2><p>&emsp;&emsp;在之前的几个章节中，我们分别介绍了Go语言中面向过程的部分与面向对象的部分的知识点。在这个小节中，我们将开始讲解Go语言中的文件操作，包括文件的创建、删除、读取、写入等操作。同时也就以上的几个知识点做出相对详细的讲解，并通过简单的案例完成入门代码。</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>&emsp;&emsp;在之前的各个章节的讲解中，我们经常会提到指针、内存等概念，但一直没有提到文件的使用。之前不论是通过键盘输入的还是通过计算得到的数据都是存储在内存中的。那么数据为什么不能够一直存储在内存中呢，其一个原因就是程序在关闭的时候、函数在结束的时候、乃至于出现故障突然掉电的情况下，对应区域内的内存数据会被清空而无法再次被寻找到。 </p><p>&emsp;&emsp;而文件的存在是处在硬盘中的，它具备掉电依旧保存的能力，因此我们将需要持久保存的数据写入文件中，以备出现故障等情况，亦或是在软件开发过程中就有写入文件的需求。从某种意义上讲，这个过程可以被称为持久化。一些具备丰富开发经验的人可能会想，在开发过程中往往会把数据存储在数据库这种服务软件中，其实究其本质，数据库中的数据存储方式依旧是通过文件所完成的。 </p><p>&emsp;&emsp;文件可以有很多种，而且不同的操作系统的文件也有所不同，但是不论怎样，计算机中的文件本质都是二进制。不论是音频数据、视频数据、亦或是文本数据，我们都可以以文件的形式进行操作。文件同时也具备读、写、执行等操作，只读的文件不可以被修改，只写的文件不可以被读等（当然可以通过一些操作修改其读写属性）。 </p><p>&emsp;&emsp;在Go语言中，对文件的操作基本都在于os包中，且核心结构体（类）为File类。下图是Golang文档中对于File相关的函数和方法的列表，我们将会针对其中几个进行讲解。 </p><p> <img src="/2020/03/22/46-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%B8%80/1.png" alt><br>&emsp;&emsp;在上图中，我们可以发现，前五个是Go语言中的函数，而后续的多个均是File类所对应的方法，在使用的过程中需要注意。 </p><h3 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h3><p>&emsp;&emsp;在这个部分中，我们集中讲解文件的创建、裁剪、移动（重命名）、删除、和文件信息的获取。 </p><h4 id="1-创建文件"><a href="#1-创建文件" class="headerlink" title="1.创建文件"></a>1.创建文件</h4><p>&emsp;&emsp;在Go语言中，创建文件的所采用的是os包中的Create函数，其函数参数为希望创建的文件的路径，返回值为文件指针以及错误类型。创建模式为0666，权限模式为任何人可以读写不可以执行。值得说明的是，此处所使用的文件路径既可以是相对路径，也可以是绝对路径。相对路径是希望创建的位置与当前Go文件的相对关系，例如我们希望在当前路径的上一级创建文件，则可以使用”../xxx.txt”的方式。绝对路径则是从根目录（Windows中从对应盘符）开始逐级向下明确指明位置，最后进行创建。 </p><p>&emsp;&emsp;因此创建文件的方式相对容易，通过Create函数创建，再通过error类型判断是否创建成功即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> file *os.File</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    file, err = os.Create(<span class="string">"text.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"创建失败"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(file)</span><br><span class="line">    file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们首先定义了file变量用来承接File指针，也定义了error变量。然后通过这两个变量作为Create函数的返回值。然后我们判断err是否为空，如果err不为空（说明有错误）则输出创建失败。然后我们输出了file的值，最后关闭文件。 </p><p>&emsp;&emsp;此时我们创建的text.txt是相对路径，相对于当前目录下创建了一个空的名为text的文本文件。然后在控制台中输出的是file指针所对应的地址。需要注意的一点是创建文件的时候，文件所存储的目录一定需要存在，即在文件系统中真实存在这个目录，否则文件创建会失败，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file, err = os.Create(<span class="string">"aaa/text.txt"</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于当前Go文件所在的目录下并没有aaa的文件夹，因此文件创建是失败的。还有一点需要注意的是如果当前文件已经存在，则会将已存在的文件清空，因此在创建文件的时候需要十分注意，以免影响到原有的文件。</p><h4 id="2-文件裁剪"><a href="#2-文件裁剪" class="headerlink" title="2.文件裁剪"></a>2.文件裁剪</h4><p>&emsp;&emsp;文件裁剪采用os包下Truncate函数来完成，其核心功能是将文件裁剪到对应的大小。函数参数是一个int64类型的数，指明将文件裁剪到固定的大小。例如我们在第一个小点中创建了一个text文件，此时该文件的大小是0字节，里面没有任何的内容，此时我们通过这个函数将其裁剪为100字节：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := os.Truncate(<span class="string">"text.txt"</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时我们再看文件的属性，发现此时该文本文件为100字节，且其中的内容为100个空字符。那么假如一个文件原有大小为200字节，我们将其裁剪为100字节，则超出的100字节全部<strong>舍弃</strong>；假如文件不足100字节，则不足的字节均由空值所占据。如果没有text这个文件，则直接创建100个字节的该文件。</p><h4 id="3-移动（重命名文件）"><a href="#3-移动（重命名文件）" class="headerlink" title="3.移动（重命名文件）"></a>3.移动（重命名文件）</h4><p>&emsp;&emsp;在Go语言中，移动文件和重命名一个文件所采用的的方式是相同的，均是通过Rename函数完成的。既然是移动文件，函数参数当然是两个文件文件路径，且返回值为移动（重命名）是否成功。这个函数并不难理解，因此我们直接通过代码进行快速入门：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    oldFile := <span class="string">"text.txt"</span></span><br><span class="line">    newFile := <span class="string">"newText.txt"</span></span><br><span class="line">    err := os.Rename(oldFile, newFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"移动失败"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个函数中，新旧文件的文件路径可以是相同的，但是旧文件必须是可以被找到的，否则在运行时会报错。同理因为新文件相当于是创建文件，因此新文件所处在的文件路径依旧需要是存在的，否则也会运行时报错。</p><h4 id="4-删除文件（目录）"><a href="#4-删除文件（目录）" class="headerlink" title="4. 删除文件（目录）"></a>4. 删除文件（目录）</h4><p>&emsp;&emsp;当文件已经存在时，可以通过Remove函数来完成文件或目录的删除工作。同理，Remove函数的参数为希望删除的文件或目录的路径，包括相对路径和绝对路径。返回值依旧是error对象，来验证删除是否成功。此时我们将当前文件夹中的newText文件删除：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file := <span class="string">"newText.txt"</span></span><br><span class="line">    err := os.Remove(file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"删除失败"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Go语言中还有一个RemoveAll函数，这两个函数的区别为：RemoveAll函数可以删除指定path的文件，或者目录<strong>以及它下属的所有文件或目录</strong>。因此它会尝试删除所有的东西，直到出现错误。</p><h4 id="5-获取文件信息"><a href="#5-获取文件信息" class="headerlink" title="5. 获取文件信息"></a>5. 获取文件信息</h4><p>&emsp;&emsp;一个文件可以有许多的属性，例如文件位置，文件大小，文件权限等等。这些属性可以通过Go语言中Stat函数（方法）来完成。之所以这样讲是因为Go语言在os包中提供了Stat函数，同时也在File类中提供了Stat方法，这两种获取方式结果是大致相似的。其获取结果FileInfo类定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="keyword">string</span>    <span class="comment">// 文件的名字（不含扩展名）</span></span><br><span class="line">    Size() <span class="keyword">int64</span>    <span class="comment">// 普通文件返回值表示其大小；其他文件的返回值含义各系统不同</span></span><br><span class="line">    Mode() FileMode   <span class="comment">// 文件的模式位</span></span><br><span class="line">    ModTime() time.Time <span class="comment">// 文件的修改时间</span></span><br><span class="line">    IsDir() <span class="keyword">bool</span>    <span class="comment">// 等价于Mode().IsDir()</span></span><br><span class="line">    Sys() <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 底层数据来源（可以返回nil）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以发现，Stat函数（方法）的返回值是error变量和一个接口，通过这个接口实例可以调用相应的方法，得到文件名、文件大小、文件权限、修改时间等。我们经常通过这个函数来判断文件是否存在：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fileInfo, err := os.Stat(<span class="string">"text.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">            fmt.Println(<span class="string">"文件不存在"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(fileInfo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们主要讲解了Go语言中的文件的概念，使用场景，以及文件的基本操作，如创建、删除、移动等函数。在下个小节中，我们依旧针对文件的读写、拷贝等方式进行讲解。可以说，文件这两小节中我讲解的并不多，只是一些基本的操作方法，其实Go语言开发者为我们提供了更多的文件方法与函数。如果在日常开发中遇到文件相关的操作，API文档将会是一个更好的选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-46-gt-文件与IO-lt-一-gt&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-46-gt-文件与IO-lt-一-gt&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;46&amp;gt;
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;45&gt; 面向对象-多态</title>
    <link href="http://yoursite.com/2020/03/21/45-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2020/03/21/45-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/</id>
    <published>2020-03-21T07:08:16.000Z</published>
    <updated>2020-03-21T07:09:07.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-45-gt-面向对象-多态"><a href="#Go语言从入门到放弃系列-lt-45-gt-面向对象-多态" class="headerlink" title="Go语言从入门到放弃系列&lt;45&gt; 面向对象-多态"></a>Go语言从入门到放弃系列&lt;45&gt; 面向对象-多态</h2><p>&emsp;&emsp;在前几个小节中，我们分别讲解了Go语言中的继承概念与接口概念，同时我们也曾提及：Go语言的多态特性是通过接口的形式反映出来的。因此我们先讲解了接口的概念与语法，进而再讲解Go语言中面向对象的另一大特性：多态。在这个小节中，我们将首先讲解Go语言中继承与接口的不同点、多态的引出、以及类型断言的用法。在这之后，Go语言中面向对象部分的讲解就基本结束了。</p><h3 id="继承与接口的区别"><a href="#继承与接口的区别" class="headerlink" title="继承与接口的区别"></a>继承与接口的区别</h3><p>&emsp;&emsp;通过前几个小节的讲解，有人可能会疑惑，Go语言中既然支持了多重继承，又具备接口实现，这两种技术有一定的交叉点，概念上也有些类似，那么出现两种技术的意义又何在。在这个部分中，我们将着重讲解Go语言中继承与接口实现的关系。 </p><p>&emsp;&emsp;我们首先基于一个童话来引入这个问题，相信大家都曾经听过老虎向猫咪学艺的故事，在这个童话中出现了两种生物：猫和老虎。如果两种生物没有任何交集，那么小虎继承于老虎、小猫继承与大猫是不需要怀疑，且是天然存在的继承关系。但在故事中老虎想向猫学习一些本领，例如说爬树，此时在小虎的“固有人设”上就会发生变化。小虎不仅有老虎的所有的属性与行为，它还希望具备猫身上的一种行为，这个过程就是实现接口。我们通过案例来说明这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span> <span class="title">climbTree</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"我会爬树"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Tiger <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tiger)</span> <span class="title">attack</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"我会进攻"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样地，我们依旧定义了虎类与猫类，类中不含属性，且每个类具备一个方法。现在我们假设一只小虎想要学爬树，我们可能有两种做法：第一种做法是将爬树这个行为作为接口，让小虎实现这个接口；第二种方式就是让小虎继承于虎类，同时继承于猫类。这两种办法在代码实现的层面上讲，都可以完成代码任务，但是在实际层面上讲，第二种方法简直荒谬，因为这样做的结果就是小虎的多继承破坏了虎类的继承树，使得虎的祖先不仅有虎还有猫（我们不谈生物现象）。因此我们说，为了实现某个功能而进行多重继承不是一个合理的选择，而是应该通过接口实现的方式为一个类添加方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LikeCat <span class="keyword">interface</span> &#123;</span><br><span class="line">    climbTree()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> LittleTiger <span class="keyword">struct</span> &#123;</span><br><span class="line">    Tiger</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LittleTiger)</span> <span class="title">climbTree</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"小虎会爬树了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，由于Go语言实现接口是通过实现方法的特性，我们也可以说：猫类实现了LikeCat接口具备了爬树行为，小虎类也实现了LikeCat接口与爬树行为。 </p><p>&emsp;&emsp;那么接口与继承的意义究竟何在，我们通过前几个小节的侧重点发现：继承的价值在于<strong>代码复用与维护性</strong>，而接口的意义则在于<strong>代码编写过程中规范的设计</strong>。接口的使用实际上是比继承更为灵活且轻量，继承关系一旦确立，则需要继承父类所有的属性与所有的方法，而接口则只需要实现对应的方法即可。由于我们所举的例子都十分简单，因此体会不到接口的轻量，假如虎类和猫类都有上百种行为，而小虎只需要具备猫类中爬树的行为，那么多重继承的重量性就不言而喻了。 </p><p>&emsp;&emsp;那么我们再思考这样一个问题：为什么我们写了LikeCat接口，如果我们不写这个接口而直接在小虎类中添加一个ClimbTree方法，程序其实也是没有错误的。但是此时假如在代码中有一个切片，让会爬树的动物都添加到切片中，此时小虎是做不到的，因为数据类型不一致。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>&emsp;&emsp;讲解了接口的概念与使用过后，多态的概念就十分简单了。多态按字面的意思理解就是多个状态，那么到目前为止我们在什么情况下接触到一种“实例”可以对应多个类型，答案就是在接口的介绍过程中，接口的多种不同的实现类的实例可以赋值给接口变量。换句话说，一个接口变量可以具备很多不同的类型，而这些类型都是实现了该接口的类。“多态性是允许你将父对象设置成为一个子对象相等的技术，赋值过后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作”（摘自Delphi4编程技术内幕）。这句话有些专业且不易理解，我们用一个简单的方式表述就是：将实现类的指针赋值给接口变量指针。 </p><p>&emsp;&emsp;对于有十分丰富的编程经历的开发者而言，这里尤其需要注意的是：Go语言中不支持将子类对象指针赋值给父类对象指针，因为变量类型不匹配。在Java中存在向上转型的概念，但是在Go语言中子类父类是不能相互赋值的，例如在刚刚的案例中我们如下写就会报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t Tiger = LittleTiger&#123;&#125;</span><br><span class="line">cannot use LittleTiger literal (<span class="keyword">type</span> LittleTiger) as <span class="keyword">type</span> Tiger in assignment</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们回到具体的案例中，多态是同一个行为具备不同表现形式或形态的能力，根据传入的实例不同，程序具备不同的相应。例如在现实中，我们经常使用的ctrl+c组合是指复制的功能，然而在命令行中同样的组合则代表强制结束当前的执行过程，因此同一个行为在不同的情况下具备不同的响应。 </p><p>&emsp;&emsp;我们在通过USB接口的案例继续说明多态的技术点：除了键盘与鼠标实现了USB接口规范之外，手机类Phone也实现了USB接口规范，现在我们有一个需求：将实现了USB接口的设备统一放置于一个切片中，遍历这个切片，调用每一个切片元素的Start方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Mouse <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mouse)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"鼠标开始工作"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Keyboard <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k *Keyboard)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"键盘开始工作"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Phone)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"手机开始工作"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m Mouse</span><br><span class="line">    <span class="keyword">var</span> k Keyboard</span><br><span class="line">    <span class="keyword">var</span> p Phone</span><br><span class="line">    usbSlice := <span class="built_in">make</span>([]USB, <span class="number">0</span>)</span><br><span class="line">    usbSlice = <span class="built_in">append</span>(usbSlice, &amp;m)</span><br><span class="line">    usbSlice = <span class="built_in">append</span>(usbSlice, &amp;k)</span><br><span class="line">    usbSlice = <span class="built_in">append</span>(usbSlice, &amp;p)</span><br><span class="line">    <span class="keyword">for</span> _, device := <span class="keyword">range</span> usbSlice &#123;</span><br><span class="line">        device.Start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码我们在讲解接口的时候已经提及过了，此处也就不再过多赘述了。它反映出来的一个思想就是：切片中每一个“USB实例”的Start方法所得到的结果均是不同的。</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>&emsp;&emsp;在上一个部分中，我们讲解的是将实现类的实例赋值给接口变量，使得接口实例可以通过同一个方法调用得到不同的结果。这个小部分中我们所讲解的过程是上一个部分的逆过程，在实际编码过程中，不仅需要让实现类进行“向上转型”，还需要让接口变量进行“向下转型”。 </p><p>&emsp;&emsp;我们回到USB的例子中，假设Mouse类不仅具备Start方法，还具备独特的按键点击Click方法，Keyboard类依旧具备Start方法。根据刚刚的描述，我们可以将Mouse实例和Keyboard实例赋给USB实例，他们都可以调用Start方法，但是此时我们希望如果是Mouse实例的话，同时再调用Click方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mouse <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mouse)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"鼠标启动"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mouse)</span> <span class="title">Click</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"鼠标点击"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m Mouse</span><br><span class="line">    <span class="keyword">var</span> usb USB = &amp;m</span><br><span class="line">    usb.Start()    <span class="comment">//可以调用</span></span><br><span class="line">    usb.Click()    <span class="comment">//编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们在main函数中将一个Mouse实例赋值给USB实例，并通过USB实例调用Start方法和Click方法。在调用Start方法时（假如Click方法被注释），程序是可以成功完成调用的。但是在调用Click方法时，会出现编译错误的情况，因为USB接口中没有对应的Click方法，Click方法是Mouse类所独有的方法，所以通过接口实例是不能调用接口外的方法的。 </p><p>&emsp;&emsp;但是我们确实是将Mouse实例赋给了usb对象，所以理论上它还是具备调用Click方法的能力的，如果想要调用这个方法，我们就需要使用类型断言，其格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接口实例.(类的类型)</span><br><span class="line">convertM := usb.(*Mouse)</span><br><span class="line">convertM.Click()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，我们通过类型断言（和强制转换不同）将usb“实例”重新返回给了Mouse对象指针，此时convertM就相当于是Mouse实例了，因此就可以调用其本身的Click方法了。 </p><p>&emsp;&emsp;这里需要注意的是：在使用类型断言的时候，如果出现了类型断言的错误，程序会抛出panic并跳出。例如我们将Mouse指针赋给了USB实例，却使用了Keyboard指针作为类型断言，程序在编译过程是不会报错的，但是在执行过程中会出现如下的panic:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> conversion: main.USB is *main.Mouse, not *main.Keyboard</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因此在使用类型断言的时候，我们往往通过两个变量进行接收结果：第一个变量是类型转换过后的实例类型，第二个则是在转换过程中是否出现了错误。我们通过后一个变量接收是否出现panic，并判断是否为true，这样就可以避免程序在执行过程中跳出了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Keyboard代码省略，和之前的一样</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m Mouse</span><br><span class="line">    <span class="keyword">var</span> usb USB = &amp;m</span><br><span class="line">    usb.Start()</span><br><span class="line">    convertM, err := usb.(*Keyboard)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">true</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"类型转换错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    convertM.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的程序中，我们留一个彩蛋，希望读者自行验证一下。笔者暂时不清楚上述代码结果的原因，是这种独特的设计还是后续版本会更新。在代码中，我们首先定义了Mouse实例并赋给了usb对象，然后我们通过usb实例进行调用Start，此时输出毋庸置疑，是：鼠标启动。然后我们将usb转换成为Keyboard，此时当然是类型不匹配，因此“类型转换错误”是一定会输出的。<strong>然后，convertM的Start方法会输出什么？</strong> </p><p>&emsp;&emsp;其输出结果是：键盘启动。换句话就是转换过程中报出了panic，但是转换是成功的，Keyboard由于也实现了USB接口，所以也具备Start方法。程序依旧可以正常执行，而没有出现运行时错误。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们介绍了Go语言面向对象特点中的多态特点。多态特性的显示是通过接口完成的，由于接口实例的存在，使得通过接口实例调用的方法可以根据实现类的实现方法而不同。同时，我们也讲解了Go语言中继承和接口实现的不同点，以及Go语言中“向下转型”的方式：类型断言的使用。 </p><p>&emsp;&emsp;到此Go语言的面向对象部分就已经介绍完了，在后续的章节中，我们将开始介绍Go语言中的文件操作以及I/O的使用方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-45-gt-面向对象-多态&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-45-gt-面向对象-多态&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;45&amp;gt; 面向对象-多态&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;44&gt; 面向对象-接口细节讨论</title>
    <link href="http://yoursite.com/2020/03/19/44-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/03/19/44-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/</id>
    <published>2020-03-19T04:21:41.000Z</published>
    <updated>2020-03-19T04:22:29.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-44-gt-面向对象-接口细节讨论"><a href="#Go语言从入门到放弃系列-lt-44-gt-面向对象-接口细节讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;44&gt; 面向对象-接口细节讨论"></a>Go语言从入门到放弃系列&lt;44&gt; 面向对象-接口细节讨论</h2><p>&emsp;&emsp;在上个小节中，我们通过案例讲解了Go语言中接口的概念，并在最后也简单介绍了Go语言中对接口实现的独特方式。与传统面向对象语言相比，Go语言中接口的实现并不依赖于关键字，而是依赖于接口方法的实现与否。在这个小节中，我们将针对接口的使用规则与细节进行更为详细的描述。</p><h4 id="1-接口不创建实例，但可以接收实例，接收的实例必须实现该接口"><a href="#1-接口不创建实例，但可以接收实例，接收的实例必须实现该接口" class="headerlink" title="1. 接口不创建实例，但可以接收实例，接收的实例必须实现该接口"></a>1. 接口不创建实例，但可以接收实例，接收的实例必须实现该接口</h4><p>&emsp;&emsp;这句话可能相对难以理解，我们根据上一章节中所举的USB接口为例来说明这个问题。在之前的代码中，Computer的Work方法的形式参数是一种USB所指代的实例，而在主函数中传入的却是Mouse和Keyboard，以及Printer类的实例。因此我们说：USB接口并不创建实例，因为代码中并没有如下的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> usb USB</span><br><span class="line">usb.Start()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的写法在运行过程中会报错，因为此时声明的usb“对象”是一个抽象的概念，通过这个抽象的概念来完成Start方法的调用会引发panic：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: runtime error: invalid memory address or <span class="literal">nil</span> pointer dereference</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是假如我们将USB接口与其实现类绑定，换句话说此时的接口就具备的一个实体，这个实体可以完成Start方法。再通俗一些理解就是：USB接口是一种规范，要求实现该接口的硬件都要有Start方法；这个规范是一种抽象的、虚构的存在，但是实现了该接口的硬件却是一种实际的物体，可以进行工作。因此接口不能创建实例，但是接口可以接收实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m *Mouse</span><br><span class="line"><span class="keyword">var</span> usb USB = m</span><br><span class="line">usb.Start()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，我们声明了一个usb引用，且让该引用指向一个Mouse实例，此时usb就从虚无变成了存在了，因此它就可以调用接口中的方法了。 </p><p>&emsp;&emsp;那么这种语法存在的意义是什么，假如我们在写一个游戏，这个游戏中具备多个角色子类，每种角色有不同的技能。此时我们需要统计一下具有某一种技能的所有角色有哪些，并将该角色存入到一个切片中。在之前的讲解中，我们说到切片与数组都是同一种数据类型的集合体。那么现在不同角色是不同的结构体类型，是不可以放到同一个切片中的。为了解决这个问题，我们可以通过定义接口切片的形式来完成：</p><p>&emsp;&emsp;既然一个对象实例可以赋给一个接口，那么只要实现了该接口的所有类的实例就都可以赋给该接口，这样相当于所有的类都是“同一种数据类型”了，我们通过代码说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Run <span class="keyword">interface</span> &#123;</span><br><span class="line">    Move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Attack <span class="keyword">interface</span> &#123;</span><br><span class="line">    Attack()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Role <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Role)</span> <span class="title">Move</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"行动"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Role)</span> <span class="title">Attack</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"攻击"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r Role = Role&#123;<span class="string">"DENG"</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> runSlice = <span class="built_in">make</span>([]Run, <span class="number">0</span>)</span><br><span class="line">    runSlice = <span class="built_in">append</span>(runSlice, r)</span><br><span class="line">    fmt.Println(runSlice)</span><br><span class="line">    <span class="keyword">var</span> attackSlice = <span class="built_in">make</span>([]Attack, <span class="number">0</span>)</span><br><span class="line">    attackSlice = <span class="built_in">append</span>(attackSlice, r)</span><br><span class="line">    fmt.Println(attackSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们在程序中定义了两个接口，并让Role类实现了两个接口，在主函数中，我们分别声明了两个不同类型的切片：Run接口类型的切片和Attack接口类型的切片。实例化一个Role之后，将该对象追加到两个切片中，程序正常运行且正确输出。这是一种向上转型的思想，可以理解为一个类实现的某个接口，那么这个类就是这个接口实例。</p><h4 id="2-实现接口需要实现接口中所有方法，且接口中方法没有方法体"><a href="#2-实现接口需要实现接口中所有方法，且接口中方法没有方法体" class="headerlink" title="2. 实现接口需要实现接口中所有方法，且接口中方法没有方法体"></a>2. 实现接口需要实现接口中所有方法，且接口中方法没有方法体</h4><p>&emsp;&emsp;既然接口定义的方法是一种规则的制定，那么在接口中制定的方法就不需要被实现。因为不同的类实现该接口的时候会覆盖重写该方法。就如同USB接口规则的制定者并不需要说明这个接口如何实现它，只需要指定入参是什么，返回值是什么，方法名是什么。实现者才需要考虑具体的实现方式，手机有手机的实现方式，鼠标有鼠标的实现方式。 </p><p>&emsp;&emsp;那么对于Go语言的接口定义而言，直接实现对应的方法会报错，其原因即是上述所讲：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Run <span class="keyword">interface</span> &#123;</span><br><span class="line">    Move()&#123;</span><br><span class="line">        fmt.Println(<span class="string">"Hello"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">syntax error: unexpected &#123;, expecting semicolon or newline or &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;除了所有方法都没有方法体之外，当一个类实现了某个接口时，需要覆盖实现接口中所有的方法。反过来说也是成立的，如果一个类没有实现一个接口中的所有方法，那么这个类就没有实现该接口。在Go语言中不通过implements关键字指定实现关系，因此只能通过检测一个类是否实现全部方法来判定是否实现了接口。 </p><p>&emsp;&emsp;有时在多人开发过程中，每个人可能制定了自己的接口规则，也存在这种两个人定义的接口名不同，但是方法签名都相同的可能性。那么此时一个类实现了其中的一个接口，实现了接口中所有的方法，那么这个类也就同时实现了另一个接口了。 </p><p>&emsp;&emsp;这种接口实现方式说实话不同人有不同的看法。有些开发者认为这个隐式实现的特性非常好，这是一种松耦合的体现。但是也有人会感到这种方式比较怪异，当程序量比较大之后，一旦对接口中的方法签名发生了修改，或添加了一个方法，由于没有明确的实现关系，因此编译器并不能提示开发者哪些类需要作出相应的修改。如果类中没有相应的方法更新或实现，那么编译器就直接认为放弃了接口的实现。</p><h4 id="3-一个自定义类型可以实现多个接口"><a href="#3-一个自定义类型可以实现多个接口" class="headerlink" title="3. 一个自定义类型可以实现多个接口"></a>3. 一个自定义类型可以实现多个接口</h4><p>&emsp;&emsp;在这个小标题中包含了两个知识点，第一个知识点是在Go语言中只要是自定义类型，不仅仅局限于结构体，都可以实现接口。第二个知识点是一个结构体类可以实现多个接口。 </p><p>&emsp;&emsp;在之前介绍方法的时候我们就提及过，一个自定义类型就可以存在方法。我们也通过为一个自定义整数（Integer）类型添加判断奇偶性的方法来举例。对于接口实现而言，这个现象依旧通用，我们依旧可以为整数等等类实现接口。由于在Go语言中是通过实现方法来实现接口的，而自定义类具备方法这个特性我们已然讲解过，那么自定义数据类型当然顺理成章就可以实现接口了。 </p><p>&emsp;&emsp;对于多个接口的实现，Go语言乃至于传统面向对象语言是都支持的。在前文中我们也提到了：如果两个接口中的方法名，那么一个类实现了一个接口的同时就自动实现了另一个接口，当然多接口实现不仅仅于此，我们通过一个案例来说明： </p><p>&emsp;&emsp;假如我们的投影仪不仅仅有VGA接口，还有HDMI接口，那么一个投影仪就需要实现两个接口。我们用代码说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> VGA <span class="keyword">interface</span> &#123;</span><br><span class="line">    StartVGA()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> HDMI <span class="keyword">interface</span> &#123;</span><br><span class="line">    StartHDMI()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Projector <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Projector)</span> <span class="title">StartVGA</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"VGA start"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Projector)</span> <span class="title">StartHDMI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"HDMI start"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *Projector</span><br><span class="line">    <span class="keyword">var</span> vga VGA = p</span><br><span class="line">    <span class="keyword">var</span> hdmi HDMI = p</span><br><span class="line">    vga.StartVGA()</span><br><span class="line">    hdmi.StartHDMI()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们定义了两个接口，分别为VGA和HDMI接口。两个接口中规定的方法不同，然后我们又定义了一个Projector结构体类，并让这个类实现了两个方法。最后在主函数中我们实例化了一个Projector，同时用两个接口接收了p对象。最后通过两个接口来调用方法，程序的数据结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VGA start</span><br><span class="line">HDMI start</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上个小节中我们讲到，只有一个类实现了对应接口，才可以将该类的对象赋给接口对象。而在上述程序中，p对象成功地被分配给了两个接口，且程序正常输出，因此这个类确实实现了多个接口。</p><h4 id="4-接口可以继承接口，但是不能实现接口"><a href="#4-接口可以继承接口，但是不能实现接口" class="headerlink" title="4. 接口可以继承接口，但是不能实现接口"></a>4. 接口可以继承接口，但是不能实现接口</h4><p>&emsp;&emsp;在这之前我们讲解了接口与实现类的关系，那么其实接口与接口之间也可以存在关系。在第2个知识点中，我们说到接口中定义的方法是不可以被实现的，是抽象方法。同时如果一个类实现了一个接口，就需要实现接口中所有的方法。因此接口实现接口这个命题从根本上就是矛盾的，一方面接口中方法不可以实现，另一方面实现了方法才实现了接口，因此接口之间是没有实现关系的。 </p><p>&emsp;&emsp;但是接口之间是存在继承关系的，其继承模式与类的继承的表现形式是相同的。都是通过匿名的方式完成。例如，一个组织定义了一种接口形式以及接口方法，但是随着时代的推进，原来的方法不足以满足所有的需求，于是基于原来的接口出现了新的接口，这个形式就是接口的继承。 </p><p>&emsp;&emsp;接口的继承规定了子接口中的方法完全继承了父接口的方法，因此如果一个类想要实现该接口，则需要实现该接口中的所有方法，以及父接口中的所有方法。此处不通过代码说明了，读者可以自己验证一下。 </p><p>&emsp;&emsp;值得说明的是，在接口的继承中一定要注意一个问题：父接口中的方法名一定不要和子接口新增的方法名相同，即便是返回值不同，参数不同也不可以。因为归根结底接口中的方法声明在实现类中都是方法，而Go语言不支持方法重载，所以同名是不可以的，这个接口也就不可能被实现了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们针对Go语言的接口的各个细节进行了说明，讲解了接口实例与实现类对象的关系，接口中方法规定，多接口实现以及接口的继承的概念。在这个小节中其实知识点含量较多，初学者可以自行通过写代码去练习，接口在Go语言中的用处还是十分地大的。 </p><p>&emsp;&emsp;在下个小节中，我们将集中说明Go语言通过继承与接口实现的方式对于多态概念的实现，以及接口与继承的比较关系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-44-gt-面向对象-接口细节讨论&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-44-gt-面向对象-接口细节讨论&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;44&amp;gt; 面向对
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;43&gt; 面向对象-接口</title>
    <link href="http://yoursite.com/2020/03/17/43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2020/03/17/43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-03-17T04:10:38.000Z</published>
    <updated>2020-03-17T04:11:29.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-43-gt-面向对象-接口"><a href="#Go语言从入门到放弃系列-lt-43-gt-面向对象-接口" class="headerlink" title="Go语言从入门到放弃系列&lt;43&gt; 面向对象-接口"></a>Go语言从入门到放弃系列&lt;43&gt; 面向对象-接口</h2><p>&emsp;&emsp;在这之前，我们已然介绍了面向对象编程部分的抽象思想，封装思想，和继承技术。在接下来的几个小节中我们将开始介绍面向对象的另一个特性-多态。然而就目前而言，直接介绍多态相对复杂，因此我们先介绍接口的技术，然后通过接口和继承的技术来说明多态的特性。在这个小节中，我们将通过案例引入接口的概念以进行快速入门程序的书写。</p><h3 id="接口引入"><a href="#接口引入" class="headerlink" title="接口引入"></a>接口引入</h3><p>&emsp;&emsp;在日常生活中，接口的概念十分广泛。比如我们都十分熟悉的USB接口，TypeC接口，HDMI接口，VGA接口等。在面向对象语言中，也存在接口的概念。我们通过物理的接口为例来了解Go语言的接口：现在我们的计算机基本都有USB接口，手机可以通过USB接口连入计算机，打印机可以通过USB接口连入计算机。不同的设备通过同一种接口连入计算机，却能够拥有不同的响应，换句话说：接口可以根据连入的设备不同自动判断对应的执行结果。 </p><p>&emsp;&emsp;在好多年前的计算机中，鼠标和键盘与计算机的连接都不是通过USB接口的，而是有各自的具体的接口，且不同的接口是连不上的。这也意味着曾经计算机需要为不同的硬件专门设计不同的接口。我们通过简化的代码来模拟这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mouse <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Mouse)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"鼠标开始工作"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Keyboard <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k Keyboard)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"键盘开始工作"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们定义了两个类分别为鼠标类和键盘类，且类中没有属性只有方法。向鼠标和键盘类分别绑定各自的不同的Start方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Computer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Computer)</span> <span class="title">MouseWork</span><span class="params">(m *Mouse)</span></span> &#123;</span><br><span class="line">    m.Start()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Computer)</span> <span class="title">KeyboardWork</span><span class="params">(k *Keyboard)</span></span> &#123;</span><br><span class="line">    k.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们接下来又定义了一个计算机类，在计算机类中依旧没有任何的属性，且计算机类需要分别为鼠标和键盘绑定一个方法。此时我们调用不同的方法以将鼠标或键盘连接到计算机上，我们用主函数模拟：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Computer</span><br><span class="line">    <span class="keyword">var</span> m Mouse</span><br><span class="line">    <span class="keyword">var</span> k Keyboard</span><br><span class="line">    c.MouseWork(&amp;m)</span><br><span class="line">    c.KeyboardWork(&amp;k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在主函数中，我们声明了一个计算机实例，鼠标实例，和键盘实例，并通过计算机实例的两个不同的接口完成设备的连入。此时程序的输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">鼠标开始工作</span><br><span class="line">键盘开始工作</span><br></pre></td></tr></table></figure><h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>&emsp;&emsp;在这种当前的解决方案下，即使程序可以正常执行，结果可以正确输出，但是这种做法的扩展性相对较低。例如我们再定义一个打印机类，打印机类具备自己的驱动方法，自己的执行方式。同时我们需要修改计算机类，让计算机类为打印机留出一个接口。程序修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Printer <span class="keyword">struct</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Printer)</span> <span class="title">Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Computer)</span> <span class="title">PrinterWork</span><span class="params">(p *Printer)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种修改方式实在过于繁琐，且随着硬件的增多，程序会变得非常的大，而且代码十分重复。不仅如此，假如不同的硬件厂商的设计理念不同，生产出的硬件不兼容，计算机只好为不同厂商的同一种硬件做不同的适配，这无疑会增加更多的工作量。 </p><p>&emsp;&emsp;除此之外，即便是我们可以为所有的不同种类的硬件都预留出对应的接口，还是会出现一定的问题。一般情况下，计算机外设只有鼠标和键盘，但对于一些人来说可能需要打印机，对于开发人员来说，需要各种手机的连入接口。换句话说，不同的使用者更倾向于不同的特定的功能，而其他的预留接口都被浪费了。 </p><p>&emsp;&emsp;因此，如果存在着一种规定，不同的硬件厂商在生产的时候都遵循这个规定，计算机只接受实现了这个规定的硬件。这样的话，计算机只需要预留出几个接口就可以了，需要什么功能的硬件直接插入即可。因为规定都是相同的，协议都是一致的，在Go语言中，接口就可以起到这个功能。</p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>&emsp;&emsp;对于上述问题的解决方式可以分为以下几个步骤：<br>&emsp;&emsp;1. 制定一种规定，设计一种接口；<br>&emsp;&emsp;2. 让鼠标和键盘实现这种规定；<br>&emsp;&emsp;3. 让计算机拥有这个接口。<br>&emsp;&emsp;因此，我们首先定义一个接口，这个接口中有一个抽象方法，即只有实现了这个方法，才算是实现了这个接口，然后我们让鼠标和键盘分别实现这两个方法，最后在计算机类的方法中注入这个接口实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span>&#123;</span><br><span class="line">    Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于我们在之前的代码中已然为Mouse和Keyboard类绑定了Start方法，因此这两个类不需要做出改动。如果之前写的方法名不是Start的话，则需要改为Start方法。 </p><p>&emsp;&emsp;接下来我们修改Computer类，这个类不再需要为每一个硬件都预留方法，因此将其他方法删除，而是需要把USB接口传入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Computer)</span> <span class="title">Work</span><span class="params">(usb USB)</span></span> &#123;</span><br><span class="line">    usb.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后在main函数中定义一个Computer类，Mouse类，和Keyboard类。并将Mouse和Keyboard传入到Computer类中的Work方法中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Computer</span><br><span class="line">    <span class="keyword">var</span> m Mouse</span><br><span class="line">    <span class="keyword">var</span> k Keyboard</span><br><span class="line">    c.Work(&amp;m)</span><br><span class="line">    c.Work(&amp;k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的代码中，我们可以发现，在定义Work方法的时候定义的参数是USB实例，但是我们传入的是Mouse和Keyboard对象指针。即便如此，并没有出现参数不匹配的现象，反而根据传入对象的不同输出结果不同，这就是一种多态的体现。 </p><p>&emsp;&emsp;现在假设我们又添加了一个新的打印机类，只要这个类实现了Start方法，它就可以被传入到Work方法中，并完成程序的调用。对于Computer类而言，则完全不需要进行修改。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们主要通过USB接口的案例来说明Go语言中的接口的概念，并通过该案例引入了Go语言接口实现的方式。在一些面向对象的语言中，接口的实现是通过implements关键字完成的，并且直接指明了实现关系。但是在Go语言中并没有这个关键字，接口的实现完全是靠实现接口定义的方法完成的。假如程序中定义了两个接口，且接口中定义的抽象方法是相同的，那么一个类实现其中一个接口的同时也就实现了另一个接口。 </p><p>&emsp;&emsp;在下个小节中，我们将针对Go语言中接口的使用方式和需要注意的细节进行相对深入的讨论。在讨论过程中也会通过代码案例来完成相应的说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-43-gt-面向对象-接口&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-43-gt-面向对象-接口&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;43&amp;gt; 面向对象-接口&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;42&gt; 面向对象-继承细节讨论</title>
    <link href="http://yoursite.com/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/</id>
    <published>2020-03-16T15:43:52.000Z</published>
    <updated>2020-03-16T15:44:39.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-42-gt-面向对象-继承细节讨论"><a href="#Go语言从入门到放弃系列-lt-42-gt-面向对象-继承细节讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;42&gt; 面向对象-继承细节讨论"></a>Go语言从入门到放弃系列&lt;42&gt; 面向对象-继承细节讨论</h2><p>&emsp;&emsp;在上个小节中，我们通过银行账户的例子引入了Go语言中面向对象中继承的概念，并用代码演示了继承的实现方式。在入门案例中，我们通过将父类的结构体以匿名的方式嵌入到子类结构体中完成了子类对父类的属性和方法的继承。在这个小节中，我们将针对Go语言中继承的概念的一些细节做出更为详细的讨论。</p><h4 id="1-Go语言中继承关系是通过匿名结构体完成的"><a href="#1-Go语言中继承关系是通过匿名结构体完成的" class="headerlink" title="1. Go语言中继承关系是通过匿名结构体完成的"></a>1. Go语言中继承关系是通过匿名结构体完成的</h4><p>&emsp;&emsp;在传统面向对象语言中，例如Java，继承关系是通过extends关键字完成的，且子类与父类之间有着明确的继承关系。父类中的属性和方法是有选择性地被子类所继承。然而在Go语言中，继承关系是通过匿名结构体的方式完成的，且在Go语言中继承与组合的关系变得不是那么的明确。继承可以讲是一种“is-a”的关系，例如VIP账户继承了账户类，那么VIP账户自身就是一个账户。而组合关系则是一种“has-a”的关系，例如一辆车具备车轮，一只猫有四条腿，而不是一辆车是车轮，一只猫是四条腿。我们通过代码来说明这个问题： </p><p>&emsp;&emsp;假如我们事先定义好了一个Account类，并在VIPAccount类中继承这个类，那么代码会是以下的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> VIPAccount <span class="keyword">struct</span>&#123;</span><br><span class="line">    Account</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码中反映的就是一种继承关系。接下来我们再通过代码讲解一下组合的关系，我们保留Account类不变，我们修改一下VIPAccount类的构成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> VIPAccount <span class="keyword">struct</span>&#123;</span><br><span class="line">    a Account</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，Account类的一个实例成为了VIPAccount类中的一个属性，因此我们讲此时VIPAccount拥有了一个Account变量。当然此时我们在主函数调用VIP实例的时候依旧需要通过“变量.属性.属性”的形式完成。在这个角度上看，Go语言中继承与组合的关系十分密切，甚至可以讲，Go语言中的继承关系就是通过组合关系的形式完成的。</p><h4 id="2-父类中的全部属性和方法均被继承"><a href="#2-父类中的全部属性和方法均被继承" class="headerlink" title="2. 父类中的全部属性和方法均被继承"></a>2. 父类中的全部属性和方法均被继承</h4><p>&emsp;&emsp;在传统面向对象语言中，父类中的private修饰的属性是不可以被子类所继承的，包括private修饰的方法也是不可以被继承的。然而在Go语言中，这个规则不再被继续遵循。父类的所有属性和方法（不论首字母大小写）均会被子类所继承。我们依旧采用Account类为例，我们设定Name属性为公有，balance属性为私有，Query方法为公有，withdraw方法为私有，最后再用VIPAccount类继承：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name     <span class="keyword">string</span></span><br><span class="line">    balance   <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">Query</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.Name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">withdraw</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    a.balance -= money</span><br><span class="line">    fmt.Println(<span class="string">"余额为："</span>, a.balance)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VIPAccount <span class="keyword">struct</span>&#123;</span><br><span class="line">    Account</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们在当前的包中的主函数中分别为两个属性赋值并调用两个不同的方法。如果子类完全继承了父类的全部属性和方法，那么父类中首字母小写的也可以正确地被表示出来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> vipa VIPAccount</span><br><span class="line">    vipa.Account.Name = <span class="string">"DENG"</span></span><br><span class="line">    vipa.Account.balance = <span class="number">10000</span></span><br><span class="line">    vipa.Account.withdraw(<span class="number">500</span>)</span><br><span class="line">    vipa.Account.Query()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们在主函数中声明了一个VIP账户，并为该账户的用户名和初始余额赋值，接下来我们通过私有方法withdraw模拟取出一些余额，最后在通过公有方法输出剩余的余额值。程序的输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">余额为： <span class="number">9500</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述结果可知，通过子类对象是可以调用父类的属性和方法，且不论父类的属性方法是公有的还是私有的，全部可以被继承下来。这个点上是与传统面向对象语言完全不同的。不过即便是子类继承了父类的所有属性和方法，但是继承得到的作用域还是不变的。即父类中withdraw是私有的，不可以在其他包中使用，那么子类中的withdraw也是私有的，同样不可以在其他的包中使用。</p><h4 id="3-子类中调用属性和方法可以简化"><a href="#3-子类中调用属性和方法可以简化" class="headerlink" title="3. 子类中调用属性和方法可以简化"></a>3. 子类中调用属性和方法可以简化</h4><p>&emsp;&emsp;在上个小节的快速入门和这个小节的前面一部分中，我们都是通过子类对象.匿名结构体.属性/方法的方式来完成调用的，这种调用方式是可以在任何情况下都适用的。不过在一些情况下，为了简便操作，我们可以将匿名结构体所省略。可以理解为：子类中继承了父类的所有属性，因此子类相当于有了同样的属性，所以，我们可以直接通过子类对象.属性/方法的方式来调用。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> vipa VIPAccount</span><br><span class="line">    vipa.Account.Name = <span class="string">"DENG"</span></span><br><span class="line">    vipa.Account.balance = <span class="number">10000</span></span><br><span class="line">    vipa.Account.withdraw(<span class="number">500</span>)</span><br><span class="line">    vipa.Account.Query()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的代码中我们使用的方式就是原始的方式，我们可以对上述代码修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> vipa VIPAccount</span><br><span class="line">    vipa.Name = <span class="string">"DENG"</span></span><br><span class="line">    vipa.balance = <span class="number">10000</span></span><br><span class="line">    vipa.withdraw(<span class="number">500</span>)</span><br><span class="line">    vipa.Query()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是这种简化方式并不是任何时候都通用的，当出现属性或者方法名冲突的时候，就需要明确指定具体的属性或方法了。</p><h4 id="4-当子类和匿名结构体有同样的属性或字段时就近原则"><a href="#4-当子类和匿名结构体有同样的属性或字段时就近原则" class="headerlink" title="4. 当子类和匿名结构体有同样的属性或字段时就近原则"></a>4. 当子类和匿名结构体有同样的属性或字段时就近原则</h4><p>&emsp;&emsp;在一些情况下，子类中的属性和父类中的属性可能会相互冲突，例如马车既继承与马，又继承与车，而马和车都可以移动，这样马车在继承了两个父类的情况下，它的移动行为的继承就是相互冲突的。我们通过例子来说明这个问题。首先我们假设如下两个类：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述代码中我们可以看出，我们首先声明了一个Person类，且Person类中包含Name和Age属性。接下来我们又定义了Child类，Child类不仅继承了Person类，还又定义了一个Name属性。此时在Child类中就具备了两个Name属性，我们依旧在main函数中进行声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Child</span><br><span class="line">    c.Name = <span class="string">"DENG"</span></span><br><span class="line">    c.Person.Name = <span class="string">"YANG"</span></span><br><span class="line">    fmt.Println(c.Name)</span><br><span class="line">    fmt.Println(c.Person.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DENG</span><br><span class="line">YANG</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们分别采用子类对象.属性和子类对象.匿名结构体.属性进行了赋值和输出，通过运行结果可以发现，这两种不同的赋值方法所得到的结果是不同的。当父类和子类都有同名的属性时，且当直接子类对象.属性时，访问的是子类的属性。我们再举一个例子，假设A类中有Name属性，B类继承于A类，且B类中自己又定义一个Name属性，再之后C类继承于B类。假如主函数中C类有一个实例c，此时c.Name访问的是B类中的Name属性，c.B.A.Name才是A类中的Name属性。 </p><p>&emsp;&emsp;换句话说，当我们简化调用时，会根据继承树逐级向上找，直到找到距离调用点最近的属性为止，如果找遍了继承树都没有找到对应的属性，就会报错。此外，方法的冲突也是同一个道理。</p><h4 id="5-多重继承导致的属性-方法冲突，必须要明确匿名结构体"><a href="#5-多重继承导致的属性-方法冲突，必须要明确匿名结构体" class="headerlink" title="5. 多重继承导致的属性/方法冲突，必须要明确匿名结构体"></a>5. 多重继承导致的属性/方法冲突，必须要明确匿名结构体</h4><p>&emsp;&emsp;在第四个小点中，我们讲解的情况是子类中新定义了父类中存在的属性或方法，在这个小点中，我们将讲解子类继承了多个父类，且多个父类中存在相同的属性。当直接使用子类对象访问属性时，会根据继承树找到最近的属性，然而当两个父类中的属性同样近的时候，则必须需要指明，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">struct</span> &#123;</span><br><span class="line">    A</span><br><span class="line">    B</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c C</span><br><span class="line">    c.Name = <span class="string">"DENG"</span></span><br><span class="line">    fmt.Println(c.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们可以发现，A类和B类中都具备Name属性，且C继承了A和B两个类，此时我们通过c.Name来访问属性则会出现模糊的问题。因为C类中没有Name属性，因此需要根据继承树向上查找，且找到了A类和B类均有Name属性，此时错误结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ambiguous selector c.Name</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们在代码中所写的c.Name编译器并不能确定具体是哪个父类的属性，因此就会报错。此时我们再访问属性的时候，就需要指明具体哪个父类的匿名结构体中的属性了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c C</span><br><span class="line">    c.A.Name = <span class="string">"DENG"</span></span><br><span class="line">    fmt.Println(c.A.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们通过代码和概念更为深入地讲解了Go语言中继承技术的细节点，并讲解了在属性访问过程中的几个原则。Go语言中具备多继承的理念即一个子类继承多个父类，但在日常开发中这个理念并不提倡，因为在多继承的过程中十分容易出现属性或方法名的冲突，使得开发者不得不需要指定对应的父类匿名结构体来调用。这个过程相对而言不是很方便。最后我们在小节中出一道简单的测试，来证明是否完全理解了本节的知识点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span> <span class="title">sayName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(a.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    A</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">sayName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b.A.Name = <span class="string">"GUO"</span></span><br><span class="line">    fmt.Println(b.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b B</span><br><span class="line">    b.Name = <span class="string">"DENG"</span></span><br><span class="line">    b.A.Name = <span class="string">"YANG"</span></span><br><span class="line">    b.A.sayName()</span><br><span class="line">    b.sayName()</span><br><span class="line">    b.A.sayName()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序的最终输出结果是什么？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-42-gt-面向对象-继承细节讨论&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-42-gt-面向对象-继承细节讨论&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;42&amp;gt; 面向对
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;41&gt; 面向对象-继承</title>
    <link href="http://yoursite.com/2020/03/15/41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2020/03/15/41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/</id>
    <published>2020-03-15T12:06:23.000Z</published>
    <updated>2020-03-15T12:06:53.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-41-gt-面向对象-继承"><a href="#Go语言从入门到放弃系列-lt-41-gt-面向对象-继承" class="headerlink" title="Go语言从入门到放弃系列&lt;41&gt; 面向对象-继承"></a>Go语言从入门到放弃系列&lt;41&gt; 面向对象-继承</h2><p>&emsp;&emsp;在上个小节中，我们讲解了面向对象特征其中的一个-封装的概念，封装是贯穿面向对象的一个思想而不是某些技术点，因此需要在日常开发中自行学习和加强。在这个小节中，我们将开始介绍Go语言中面向对象中的另一个特性-继承。Go语言对于继承有着独特的解决方式，与传统的面向对象语言的实现方式完全不同。如果有其他语言的开发经验，可能会对Go语言的继承的实现表示出费解，这是语言层面上的设计问题，开发者最好还是需要适应这种独特的方式。 </p><h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>&emsp;&emsp;在日常生活中，继承的概念随处可见，继承的关系往往涉及两个或多个个体类。例如，一个孩子的长相性格大多继承于父母，孩子也会有自己的独特的个性；在面向对象程序设计中，也经常会出现类似的问题。比如我们上一个小节提到的Account的例子，可以分为个人用户，企业用户，VIP用户等。每一个类型的用户都有其独特的特点，但是他们又同时都有存取款，查询转账等功能。因此可以说，不同类型的用户继承于Account大类。 </p><p>&emsp;&emsp;我们现在就针对这个问题举个简化的例子：假如我们需要一个普通账户和一个VIP账户，这两种账户都具备存款，查询，取款的功能。普通用户一次可以取10k，VIP用户一次可以取出50k。如果采用之前介绍的抽象等方式，我们需要建立两个结构体，分别为NormalAccount和VIPAccount。（暂时不考虑封装的问题）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NormalAccount&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> VIPAccount&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来，我们分别实现对应的方法，存钱取钱的方法为了简便暂时就不考虑密码的匹配，只是为了说明一下继承的问题。取钱的方法需要判断对应的取钱上限，以及余额是否少于需要取出的钱。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(na *NormalAccount)</span> <span class="title">QueryAccount</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(na.Balance)</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(na *NormalAccount)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    na.Balance += money</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(na *NormalAccount)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> money &gt; <span class="number">10000</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"超出上限"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> na.Balance &lt; money &#123;</span><br><span class="line">        fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    na.Balance -= money</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vipa *VIPAccount)</span> <span class="title">QueryAccount</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(vipa.Balance)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vipa *VIPAccount)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    vipa.Balance += money</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vipa *VIPAccount)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> money &gt; <span class="number">50000</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"超出上限"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> vipa.Balance &lt; money &#123;</span><br><span class="line">        fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    vipa.Balance -= money</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承实现"><a href="#继承实现" class="headerlink" title="继承实现"></a>继承实现</h3><p>&emsp;&emsp;在上述的代码实现中，虽说可以完成对应的功能，但是依旧有许多可以解决的问题。比如说，NormalAccount和VIPAccount的属性十分相似（在本例中完全相同），还有两种账户除了最高取款限额不同之外，其他的也十分类似。如果以当前的实现形式进行发展，那么企业账户，附属账户等需要再大致一模一样地再实现一遍，一旦账户中需要多加一个功能，则需要每一个账户类型都新写一个方法，这对大型程序来说十分不利。 </p><p>&emsp;&emsp;那么我们是否可以像类的构建中的抽象一般，将几个类中公有的属性再次抽象出来，形成一个父类，让所有继承于父类的子类都具备和父类一样的属性和方法，同时在子类中可以随意覆盖父类中的方法。基于这样一个思想，我们将继承的话题引入到讲解中。 </p><p>&emsp;&emsp;经过再次抽象后，我们发现在本例中每一个账户都需要姓名和账户余额，因此这两个属性可以被提取出来成为父类所共有的属性。同理，我们也发现每一个账户都存在取款，存款和查询功能。在取款过程中，我们可以通过传入一个参数来规定取款的最高限额，因此这三个方法都可以被写入到父类中。此时，父类Account可以被归纳如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">QueryAccount</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(a.Balance)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    a.Balance += money</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>, limit <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> money &gt; limit &#123;</span><br><span class="line">        fmt.Println(<span class="string">"超出上限"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> a.Balance &lt; money &#123;</span><br><span class="line">        fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    a.Balance -= money</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;建立了父类Account之后，我们就可以将两个账户类型定义出来了，由于两个账户均继承于父类Account，因此，父类中的属性以及行为可以直接被子类所拥有，此时在子类中就不需要再次定义了。对于取钱这个问题，我们可以重写父类的方法，将取款上限传入。我们首先写NormalAccount：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NormalAccount <span class="keyword">struct</span> &#123;</span><br><span class="line">    Account</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(na *NormalAccount)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    na.Account.WithdrawAccount(money, <span class="number">10000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们通过将Account父类嵌入到NormalAccount子类的方式，令子类继承了Account父类。在重写WithdrawAccount方法中，我们在子类的方法中调用了父类的方法进行了一次包装，就完成了子类的重写工作。同理对于VIPAccount类而言，做法也是类似的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> VIPAccount <span class="keyword">struct</span> &#123;</span><br><span class="line">    Account</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vipa *VIPAccount)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    vipa.Account.WithdrawAccount(money, <span class="number">50000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时，两个子类的代码就都编写完成了。接下来，我们讲解一下如何在函数中使用上述两个子类。在主函数中，我们将分别实例化两个子类，为之赋值，并调用三个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> na NormalAccount = NormalAccount&#123;Account&#123;<span class="string">"DENG"</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">var</span> vipa VIPAccount</span><br><span class="line">    vipa.Account.Name = <span class="string">"YANG"</span></span><br><span class="line">    vipa.Account.Balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    na.SaveAccount(<span class="number">1000</span>)</span><br><span class="line">    na.WithdrawAccount(<span class="number">300</span>)</span><br><span class="line">    na.QueryAccount()</span><br><span class="line"></span><br><span class="line">    vipa.SaveAccount(<span class="number">50000</span>)</span><br><span class="line">    vipa.WithdrawAccount(<span class="number">100000</span>)</span><br><span class="line">    vipa.QueryAccount()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在主函数中，我们通过初始化直接赋值的方式实例化了NormalAccount，也通过先创建后赋值的方式实例化了VIPAccount，接下来我们用两个对象分别进行继承得到的方法，并进行输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">700</span></span><br><span class="line">超出上限</span><br><span class="line"><span class="number">50000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;得到了上述的结果，与预期的结果相同，也进而说明了我们的代码实现是没有问题的，继承的结果也是正确的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们通过一个案例引出了继承的概念，并通过代码的方式进行了快速入门。在案例中，我们可以发现，在Go语言中的面向对象继承，是通过嵌入匿名结构体的方式完成的。且作为父类的匿名结构体中的属性和方法均被子类所继承到，子类拥有了方法继承后可以通过子类的实例调用对应的方法。 </p><p>&emsp;&emsp;在传统面向对象继承中，往往是通过extends关键字的方式完成的，在Go语言中并没有这个关键字。Go语言中类的组合与继承的关系也不如传统面向对象语言那般分明，因此我们需要适应这种独特的继承方式。在下个小节中，我们将针对继承中的一些细节，例如访问修饰，属性冲突，多重继承等细节进行详细地介绍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-41-gt-面向对象-继承&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-41-gt-面向对象-继承&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;41&amp;gt; 面向对象-继承&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;40&gt; 面向对象-封装</title>
    <link href="http://yoursite.com/2020/03/14/40-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/"/>
    <id>http://yoursite.com/2020/03/14/40-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/</id>
    <published>2020-03-14T15:15:50.000Z</published>
    <updated>2020-03-14T15:17:27.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-40-gt-面向对象-封装"><a href="#Go语言从入门到放弃系列-lt-40-gt-面向对象-封装" class="headerlink" title="Go语言从入门到放弃系列&lt;40&gt; 面向对象-封装"></a>Go语言从入门到放弃系列&lt;40&gt; 面向对象-封装</h2><p>&emsp;&emsp;在面向对象部分的介绍中，我们自始至终地都在强化一种思想，即是抽象的思想。我们在定义一个结构体(类)的时候，实际上就是将一类事物所共有的属性和行为提取出来，建立一个物理模型，就成为了一个类。在这其中,             共有的属性以字段的形式存在，行为以方法的形式存在。这个提取的过程就是抽象的思想，因此我们所说的抽象并不涉及技术上的实现，而是贯穿整个面向对象的一种解决问题的方法。 </p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>&emsp;&emsp;作为面向对象的特性之一，封装的概念在Go语言中也有所体现。封装就是将抽象出来的字段和对字段的操作封装在一起，将数据在内部保护起来，其他的程序只可以通过放出的方法接口来对属性字段进行操作。就如同我们在讲解工厂模式的时候举的例子：学生的年龄只可以读取而不可以在其他包中修改。我们说在这个例子中，我们将年龄这个属性与读取的方法封装在了一起。 </p><p>&emsp;&emsp;通过封装的概念，使得程序员在基于他人的代码进行二次开发过程中不需要完全了解其代码实现，只需要了解一个方法应当如何输入，其返回值是什么，对于程序中其他的属性是否存在关联的变动。而这三个方面往往都会在用户的开发文档中或代码注释中标明。 </p><p>&emsp;&emsp;举一个很典型的例子：我们普通用户并不需要知道电视机的成像原理，不需要知道其内部的集成电路是如何工作的，也不需要知道红外线控制器的协议过程。我们只需要知道对于一个电视机，哪些按键是开关，哪些按键控制频道，哪些按键控制音量。而一旦电视机出现问题，我们只需要联系维修人员即可。同理，对于其他人的代码，我们只需要知道输入格式，输出格式，而代码中出现bug，则需要联系开发人员，或通过其他途径完成自己的开发需求。</p><h3 id="案例讲解"><a href="#案例讲解" class="headerlink" title="案例讲解"></a>案例讲解</h3><p>&emsp;&emsp;假设一个银行在写管理系统，并且我们负责系统中个人账户的部分，要求用户可以查询余额，存钱取钱，且单次取钱额度不超过10k，以及用户之间互相转账的功能，单次转账也不超过50k。我们通过这个小案例进行封装的入门。当然真实的开发操作要比这个复杂地多得多，而且还需要进行加锁操作，数据库操作等等，我们在这里只是针对这个案例进行一个简单的分析和实现而已，只是介绍一下封装的使用方式，对于实现方式就当做一个代码篇来看吧。 </p><h3 id="1-属性行为分析"><a href="#1-属性行为分析" class="headerlink" title="1. 属性行为分析"></a>1. 属性行为分析</h3><p>&emsp;&emsp;在代码编写之前，我们往往需要首先分析一下一个类的构成。在这个案例中，我们可以清楚地知道：转账过程需要对方的用户名和本人的密码，查询余额和存钱取钱需要余额的显示，其他的暂时先不需要了。因此我们可以将在Account类中包含三个属性，分别为用户名，密码，和余额。 </p><p>&emsp;&emsp;接下来，我们继续分析这个类的行为。根据需求描述，我们可以知道需求中存在着如下的几个行为：查询，存储，取出，转账这四个行为，且这四个行为均是账户管理中的行为。因此对于类的设计中我们可以采用如下的类定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">    UserName <span class="keyword">string</span></span><br><span class="line">    Password <span class="keyword">string</span></span><br><span class="line">    Balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">QueryAccount</span><span class="params">(password <span class="keyword">string</span>)</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">Transfer</span><span class="params">(to *Account, money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="2-权限控制修改"><a href="#2-权限控制修改" class="headerlink" title="2. 权限控制修改"></a>2. 权限控制修改</h4><p>&emsp;&emsp;在对工厂模式的讲解中，我们介绍到了私有类的访问方式，以及私有属性的访问方式。在大多数情况下，我们将类名以及属性名的首字母小写，使之成为私有，可见性只针对于本包。此时我们需要为之添加一个公有类型的工厂函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> account <span class="keyword">struct</span> &#123;</span><br><span class="line">    userName <span class="keyword">string</span></span><br><span class="line">    password <span class="keyword">string</span></span><br><span class="line">    balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAccount</span><span class="params">(userName <span class="keyword">string</span>, password <span class="keyword">string</span>)</span> *<span class="title">account</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;account&#123;</span><br><span class="line">        userName: userName,</span><br><span class="line">        password: password,</span><br><span class="line">        balance: <span class="number">0.0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述程序中，我们添加了NewAccount函数，且需要两个入参分别为用户名和密码，在函数中为本类中的userName和password赋值，同时我们设定balance的初始值为0。</p><h4 id="3-方法的实现"><a href="#3-方法的实现" class="headerlink" title="3. 方法的实现"></a>3. 方法的实现</h4><p>&emsp;&emsp;我们首先完成余额查询的功能。在这个功能中我们需要首先判断输入的密码是否与account中的密码相匹配，如果匹配则输出对应的balance属性的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *account)</span> <span class="title">QueryAccount</span><span class="params">(password <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> password == a.password &#123;</span><br><span class="line">        fmt.Println(a.balance)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"密码错误！"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们完成存款的实现，首先依旧是判断输入密码是否与account中密码相同，如果相同则将balance加上对应的金额：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *account)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> password == a.password &#123;</span><br><span class="line">        a.balance += money</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"密码错误！"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来是取钱的操作，它与存钱的区别便是一次性取钱不能超过10k，且余额不能小于0。 在密码得以匹配和上述条件均满足的情况下，balance的值减少对应的money金额：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *account)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> password == a.password &#123;</span><br><span class="line">        <span class="keyword">if</span> money &gt;= <span class="number">10000</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"超出额度"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> money &gt; a.balance &#123;</span><br><span class="line">            fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        a.balance -= money</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"密码错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后是转账操作的实现，一次转账操作可以相当于两个行为：一方的取出操作和另一方的存入操作。取出操作依旧遵循上述的判断过程，存入操作不需要什么其他的限制：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *account)</span> <span class="title">Transfer</span><span class="params">(to *account, money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> password == a.password &#123;</span><br><span class="line">        <span class="keyword">if</span> money &gt;= <span class="number">50000</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"超出额度"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> money &gt; a.balance &#123;</span><br><span class="line">            fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        a.balance -= money</span><br><span class="line">        to.balance += money</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"密码错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> acc1 = test.NewAccount(<span class="string">"DENG"</span>, <span class="string">"123456"</span>)</span><br><span class="line">    <span class="keyword">var</span> acc2 = test.NewAccount(<span class="string">"YANG"</span>, <span class="string">"654321"</span>)</span><br><span class="line">    acc1.SaveAccount(<span class="number">5000</span>, <span class="string">"123456"</span>)</span><br><span class="line">    acc1.WithdrawAccount(<span class="number">2000</span>, <span class="string">"123456"</span>)</span><br><span class="line">    acc1.Transfer(acc2, <span class="number">1000</span>, <span class="string">"123456"</span>)</span><br><span class="line">    acc1.QueryAccount(<span class="string">"123456"</span>)</span><br><span class="line">    acc2.QueryAccount(<span class="string">"654321"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最终我们在demo文件下的main包中进行功能的测试，我们只写了简单的几个过程，并没有将所有的功能全部都测试完全，代码也只是作为demo说明而已。其结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2000</span></span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这两个数值的输出也一定程度上证实了主要功能的正确，对于其他的错误的输出没有做任何的测试。</p><h3 id="封装规则"><a href="#封装规则" class="headerlink" title="封装规则"></a>封装规则</h3><p>&emsp;&emsp;在Go语言的开发过程中，其实并没有特别强调封装的概念。Go语言说起来并没有对面向过程或面向对象有着明显的倾向性，它对于面向对象的实现也有着自己一套的灵活的实现方式。它与Java语言，C/C++语言不同，不能以传统的面向对象的语法特性看待Go语言。Go语言本身而言对面向对象的概念是做了一定的简化的。 </p><p>&emsp;&emsp;相较于传统面向对象的开发习惯，Go语言的封装规则可以总结为一下的几个步骤： </p><p>&emsp;&emsp;1. 将结构体和属性字段的首字母小写，将其变为私有属性，在其他包中不可导出，类似于传统面向对象中的private属性。 </p><p>&emsp;&emsp;2. 为结构体所在包提供一个工厂函数，函数的首字母大写，该函数可以在其他包中被调用，导出结构体实例指针。 </p><p>&emsp;&emsp;3. 为私有属性提供首字母大写的SetXXX方法，在该方法中对属性进行判断与赋值。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *XXX)</span> <span class="title">SetYYY</span> <span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line">    ...  <span class="comment">//数据验证等操作</span></span><br><span class="line">    x.YYY = 参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;4. 为私有属性提供首字母大学的GetXXX方法，在该方法中返回该属性的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *XXX)</span> <span class="title">GetYYY</span> <span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.YYY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们讲解了Go语言中面向对象概念中的封装，并通过一个案例讲解了封装思路。可以说，封装是一种思想而不是一种技术，因此开发人员需要在日常开发中多多积累相应经验。由于它是思想，因此不同的人对这个思想的理解倾向性不同，因此很难辨明孰是孰非。针对于同一个需求，开发的思路也不同。笔者开发经验也不多，在一些问题上考虑地也并不完善，说的不到的地方希望见谅。 </p><p>&emsp;&emsp;在下一个小节中，我们将开始讲解面向对象特性中的另一个概念，继承。继承与封装不太相似，继承是一个技术点，因此具备一定的语法规则，我们会在下几节中详细地说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-40-gt-面向对象-封装&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-40-gt-面向对象-封装&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;40&amp;gt; 面向对象-封装&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;39&gt; 面向对象-方法细节与工厂模式</title>
    <link href="http://yoursite.com/2020/03/13/39-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/13/39-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-03-13T11:02:37.000Z</published>
    <updated>2020-03-13T11:05:05.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-39-gt-面向对象-方法细节与工厂模式"><a href="#Go语言从入门到放弃系列-lt-39-gt-面向对象-方法细节与工厂模式" class="headerlink" title="Go语言从入门到放弃系列&lt;39&gt; 面向对象-方法细节与工厂模式"></a>Go语言从入门到放弃系列&lt;39&gt; 面向对象-方法细节与工厂模式</h2><p>&emsp;&emsp;在上一个小节中，我们简单讲解了Go语言面向对象部分中的方法的概念，同时我们也通过简单的案例进行了快速入门的讲解。方法不论在定义上与使用上都与函数十分的类似，包括方法的传参机制也与函数如出一辙。除此之外，我们也对其他的自定义数据类型的方法做出了一定的讲解，并说明了Go语言中String方法的作用。 </p><p>&emsp;&emsp;在这个小节中，我们依旧对Go语言的方法进行讲解，主要说明方法在使用过程中的一些注意事项，以及Go语言中的工厂模式。</p><h3 id="方法的细节与注意事项"><a href="#方法的细节与注意事项" class="headerlink" title="方法的细节与注意事项"></a>方法的细节与注意事项</h3><h4 id="1-Go语言中的方法不支持重载"><a href="#1-Go语言中的方法不支持重载" class="headerlink" title="1. Go语言中的方法不支持重载"></a>1. Go语言中的方法不支持重载</h4><p>&emsp;&emsp;在传统面向对象语言中，方法是可以被重载的，即多个方法函数名相同，返回值相同，但是函数参数不同。例如，当初始化一个学生类的时候需要调用initStudent方法，且我们可以传入学生的姓名与学号。当用户只传入学号时则只初始化学号，当用户只传入姓名时则只初始化姓名，如果两个都输入则全部初始化。 </p><p>&emsp;&emsp;由于方法中定义的参数类型不同，参数个数不同，传统面向对象语言可以根据这两个特点寻找到用户需要调用哪一个初始化方法，并能够成功地完成操作。然而这个特性在Go语言中并不存在，一旦两个方法或函数的名字相同的时候，在编译过程中就会报错，且报错的内容为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method redeclared: xxx</span><br></pre></td></tr></table></figure><h4 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h4><p>&emsp;&emsp;当初在介绍到包的概念的时候我们提及过作用域的一些问题，在Go语言中存在两种作用域分别为共有的和私有的。当变量的首字母大写的时候是可以在其他包中访问到该变量的，当变量首字母是小写的时候则无法在其他包中访问。函数与方法也遵循这个原则：当函数名或方法名首字母大写的时候才可以在其他包中调用函数或方法，方法名首字母小写则只能在本包中使用，具体便不再举例了。</p><h4 id="3-接收者的类型"><a href="#3-接收者的类型" class="headerlink" title="3. 接收者的类型"></a>3. 接收者的类型</h4><p>&emsp;&emsp;接收者即指明的从属类，我们在之前的案例中都使用的是类的对象，也可以某种程度上理解为传入的一个参数为一个对象。由于struct是值传递，因此传入对象之后在方法中无法改变对象中的值，这个特性对于熟悉面向对象编程的开发者来说十分不友好，因此接收者不仅可以是类的对象，也可以是一个指针，我们举两个例子进行对比：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s stu)</span> <span class="title">setName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    s.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> student stu = stu&#123;<span class="string">"DENG"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    student.setName(<span class="string">"YANG"</span>)</span><br><span class="line">    fmt.Println(student.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在第一个例子中，我们在方法的接收者部分使用的是struct变量，且在setName方法中我们将stu中对应的name属性赋值。在main函数中我们首先为student的name赋值为”DENG”，然后通过setName方法进行修改，最后再进行输出。由于结构体的值类型的属性，传入到setName方法中的student是另一段内存，调用过后就释放了，因此输出结果为：DENG </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stu)</span> <span class="title">setName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    s.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> student stu = stu&#123;<span class="string">"DENG"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    student.setName(<span class="string">"YANG"</span>)</span><br><span class="line">    fmt.Println(student.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个例子中，我们将方法的接收者改为一个stu指针，这样传入的就是一个student的引用，方法中的name修改直接影响到调用者的属性，因此此时的输出为：YANG </p><p>&emsp;&emsp;值得最后一次一提的是：我们只将stu改为了*stu，而其他的部分均没有发生变化，因此在上述的程序中我们使用了非常多的编译优化的特性，且这种特性对Java等开发者十分友好。如果读者已经完全明白引用与值的关系，在以后的编程过程中可以活用这个编译特性，本人在这里以及以后也对读者不做任何的限制了。</p><h4 id="4-编译器优化指针"><a href="#4-编译器优化指针" class="headerlink" title="4. 编译器优化指针"></a>4. 编译器优化指针</h4><p>&emsp;&emsp;在之前的介绍中，我们提到了Go语言的编译器对指针类型与数值类型的使用进行了优化，即根据函数参数的类型自动判断其应当传入的指针或数值类型。这种编译器优化只针对于方法，而不针对于函数。假如在函数的使用过程中出现了不匹配的情况，在编译过程中将直接报出错误。 </p><p>&emsp;&emsp;首先我们举一个函数的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showName</span><span class="params">(stu *student)</span></span> &#123;</span><br><span class="line">    fmt.Println(stu.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu student = student&#123;</span><br><span class="line">        name: <span class="string">"DENG"</span>,</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//showName(stu)  //cannot use stu (type student) as type *student in argument to showName</span></span><br><span class="line">    showName(&amp;stu)  <span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们首先定义了一个结构体，然后又定义了一个showName的函数，由于它并没有绑定对象，因此它只是一个函数而非方法。最后在主函数中我们实例化一个结构体，并分别通过结构体对象和结构体对象指针进行showName的调用。由于在showName函数定义中，我们采用了student指针作为入参。因此在通过对象实例进行传参的时候出现了参数不匹配的情况。而采用实例指针进行传参的时候，程序可以正确执行并输出相应的结果。 </p><p>&emsp;&emsp;因此对于普通函数来说，<strong>编译器并没有对普通函数参数检查进行指针优化</strong>。 </p><p>&emsp;&emsp;接下来，我们将showName函数改为student类的一个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span> <span class="title">showName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(s.name)    <span class="comment">//正确</span></span><br><span class="line">    fmt.Println((*s).name)  <span class="comment">//正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu student = student&#123;</span><br><span class="line">        name: <span class="string">"DENG"</span>,</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    (&amp;stu).showName()  <span class="comment">//正确</span></span><br><span class="line">    stu.showName()    <span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，我们将showName方法绑定到student类上，并在主函数中通过stu对象调用了showName方法。在主函数中，我们实例化了student类成为一个对象，并分别通过对象的方式和对象指针的方式调用了方法。同时，在方法中，我们通过传入的指针参数调用了s对象指针的name属性。在运行结果中，都可以正确地完成姓名的输出。 </p><p>&emsp;&emsp;因此，对于方法而言，<strong>编译器对方法进行了指针的优化</strong>。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>&emsp;&emsp;在这个部分中，我们将对Go语言中的工厂模式进行阐述，这种代码模式在日常开发中还是十分常见的。而且在多人代码合作中，这个模式用到地就更为常见了。 </p><h4 id="1-工厂模式引入"><a href="#1-工厂模式引入" class="headerlink" title="1. 工厂模式引入"></a>1. 工厂模式引入</h4><p>&emsp;&emsp;在之前的讲解中，我们提到标识符首字母的大小写是控制其可见性的一个标准。当标识符首字母大写的时候，我们可以通过其他包访问到这个变量或函数。如果标识符首字母小写的话，我们只可以在本包中访问对应的变量。然而在程序开发过程中，将所有的属性、方法都设定为共有是及其不可取的做法，这样做意味着其他的开发者可以在其他包中任意修改本包的数据。而将属性方法设定为私有的话，其他开发者又完全没有办法读取本包数据。因此，我们采用工厂模式来完成对应的优化。 </p><p>&emsp;&emsp;我们依旧采用demo包和test包举例，在test包中存在一个student的类，在demo包中完成对student对象属性的调用。首先我们假设Student类中有两个属性：Name和Age：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">test.<span class="keyword">go</span>：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">package</span> test</span><br><span class="line">    <span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        Age <span class="keyword">int8</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">demo.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">package</span> main</span><br><span class="line">    <span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"test"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> stu = test.Student&#123;</span><br><span class="line">            Name: <span class="string">"DENG"</span>,</span><br><span class="line">            Age: <span class="number">18</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(stu.Name)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码实现当然是没有问题，因为Student的首字母是大写的，Student类中所有属性的首字母也都是大写的，因此Student类是完全共有的，不会出现属性访问的问题。那么假如两个包是由两个不同的人开发，且每个人都希望保护自己的代码，将Student的首字母小写成为student，那么当前的做法就会报错了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;修改过后，此时demo中会报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cannot refer to unexported name test.student</span><br><span class="line">undefined: test.student</span><br></pre></td></tr></table></figure><h4 id="2-解决方式"><a href="#2-解决方式" class="headerlink" title="2. 解决方式"></a>2. 解决方式</h4><p>&emsp;&emsp;既然类已经被限定在本包中使用而其他包无法创建，那么就让该类的实例化过程出现在该类对应的包中：在一个公有的函数中完成类的实例化，并将该对象通过指针的形式返回出去。这个公有的函数可以具备一些形式参数来完成对象的初始化，类似于构造函数。基于上述的案例，我们将test包中的代码修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">student</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">        Name: name,</span><br><span class="line">        Age: age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们在test包中通过NewStudent函数做了student类的实例化操作，并将该对象的指针通过返回值返回给调用者，由于NewStudent函数是公有的，因此其他包可以通过这个函数来完成实例化操作。对应的demo包中代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"test"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu = test.NewStudent(<span class="string">"DENG"</span>, <span class="number">18</span>)</span><br><span class="line">    fmt.Println(stu.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-属性权限控制"><a href="#3-属性权限控制" class="headerlink" title="3. 属性权限控制"></a>3. 属性权限控制</h4><p>&emsp;&emsp;完成了私有类的实例化操作后，对象中属性也可能会出现私有的现象。例如：希望student类中的Age属性只可以在其他包中读取，但是不可以在其他包中修改。完成这个操作的思路其实和类的实例化非常相似，唯一的区别是属性的权限控制可以通过方法来完成。我们直接通过代码说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">student</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">        Name: name,</span><br><span class="line">        age: age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span> <span class="title">GetAge</span><span class="params">()</span> <span class="title">int8</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们修改了age的访问权限（首字母变为小写），这样在其他的包中就无法访问了，同时我们又添加了一个公有的方法GetAge，在这个方法中访问age属性。由于其他包中可以通过NewStudent函数得到对象，又可以通过对象得到属性，因此这种实现方式相当于间接访问到了age属性，但不可以修改它。 </p><p>&emsp;&emsp;此时demo.go中代码变为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main    </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"test"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu = test.NewStudent(<span class="string">"DENG"</span>, <span class="number">18</span>)</span><br><span class="line">    <span class="comment">//stu.age = 20  //stu.age undefined (cannot refer to unexported field or method age)</span></span><br><span class="line">    fmt.Println(stu.GetAge())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p> &emsp;&emsp;在这个小节中，我们继续讲解了Go语言中方法的概念以及注意事项，同时我们也针对Go语言中工厂模式进行了讲解，解决了私有属性的访问权限控制以及类的实例化的函数。在下几个小节中，我们将针对面向对象中的抽象和封装两个概念进行讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-39-gt-面向对象-方法细节与工厂模式&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-39-gt-面向对象-方法细节与工厂模式&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;39&amp;g
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;38&gt; 面向对象-方法</title>
    <link href="http://yoursite.com/2020/03/12/38-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/12/38-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95/</id>
    <published>2020-03-12T15:16:11.000Z</published>
    <updated>2020-03-12T15:16:41.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-38-gt-面向对象-方法"><a href="#Go语言从入门到放弃系列-lt-38-gt-面向对象-方法" class="headerlink" title="Go语言从入门到放弃系列&lt;38&gt; 面向对象-方法"></a>Go语言从入门到放弃系列&lt;38&gt; 面向对象-方法</h2><p>&emsp;&emsp;在上两个小节中，我们讲解了Go语言中面向对象部分的结构体的概念及使用。在结构体中，我们涉及到的最多的都是各种属性，例如一个人的类的结构体中会具备眼睛、鼻子、耳朵、嘴等属性，但是这些属性相对于面向对象而言更为”静态”。即它只说明了一个结构体中、一个类中具备什么样的性质，而没有指明这个类对应的实例能够做什么，例如一个人可以行走、可以观察等，这些相对”动态”的行为是由面向对象中的方法完成的。 </p><h3 id="方法快速入门"><a href="#方法快速入门" class="headerlink" title="方法快速入门"></a>方法快速入门</h3><p>&emsp;&emsp;在Go语言的面向对象体系中，有一个和函数十分类似的概念，我们称之为方法。在一些完全面向对象的计算机语言中，函数和方法是通用的，函数主要是指面向过程中的程序单元，方法主要是指面向对象中的类行为。可以说函数的说法是先于方法的，面向对象语言的发展是基于面向过程的，因此对于Java、PHP等语言来说函数和方法是等价的，而对于C++、Go等既包含面向过程部分也包含面向对象部分的语言来说，函数和方法是两个十分相似但是本质不同的概念。 </p><p>&emsp;&emsp;我们在方法的引出过程中也提及到了：方法(method)是针对于某一个类甚至是某几个类而言的，不同的类方法是可以不相同的，例如对于人类来说，我们可以具备使用工具、计算、行走等行为，但是对于鸟类来说他们具备飞行等行为，同理在Go语言中，每一个方法的出现往往会指定某一个类型作为”接收者”，即在某种情况下这个方式仅仅隶属于某一个类。在这里我们依旧沿用上一节中举的例子：学生类</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int</span></span><br><span class="line">    friends []stu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个类中，我们仅仅指明了一个学生结构体中具备姓名、年龄、以及朋友三个属性，而对于学生类的实例具体能做什么没有任何的说明。接下来我们假设一个学生实例可以完成计算两个数的加和的行为，此时根据上述的分析，方法在定义中需要指明某一个行为属于某一个类，那么此时计算的行为可以如下表示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s stu)</span> <span class="title">calculate</span><span class="params">(n1, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的程序段就可以称为一个方法，我们可以发现方法和函数不仅在概念上十分的相似，在定义方式上也是十分的相像。既然方法也是为了完成某一个目的而进行了抽象，那么方法的定义中也可以存在参数或者返回值，它与函数的唯一区别就是它需要指明这个方法归属于哪个类，在上述的方法定义中指明了归属于stu。 </p><p>&emsp;&emsp;在一些面向对象语言中，方法的定义是在class类中，和属性的定义相平行，这样的做法使方法得以访问到类中所定义的属性。在Go语言中，方法的实现是不相同的，它的方法是定义在struct结构体之外的，通过字段的指定来确定方法的归属。因此方法的调用是需要通过对应的类的实例来完成的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> student stu = stu&#123;&#125;</span><br><span class="line">    fmt.Println(student.calculate(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先通过学生类实例化一个对象，然后通过这个student对象来完成计算方法的调用。一个类具备某种行为，由该类实例化得到的个体对象当然也具备该方法的使用能力，因此此时可以通过”.”来完成从属关系的调用。</p><h3 id="方法的”传参”机制"><a href="#方法的”传参”机制" class="headerlink" title="方法的”传参”机制"></a>方法的”传参”机制</h3><p>&emsp;&emsp;在这个小部分中，我们所说的传参可以分为两部分来理解，一部分是方法的参数中的真的参数，另一部分则是方法归属类的抽象实例。方法的参数与函数的参数是相同的，即传入的数据类型是值类型的时候是在内存中复制一份原有数据再传入，传入的数据与原数据没有关系；当传入的数据类型为引用类型或指针时，则复制一份指向的地址传入，函数、方法中对数据的修改会影响到原数据。这个似乎不难理解，我们在函数的讲解中已经十分详细地介绍过了。 </p><p>&emsp;&emsp;现在我们回到Go语言对于面向对象特性的实现方式上，其他语言可以在方法中调用到类中的属性，那么在Go语言中这个特性也应该可以完成。由于方法的定义中已然指明了它所归属的类，所以此时<strong>假如</strong>我们再传入一个该类所对应的实例（对象），通过该对象来访问实例中的属性数据就可以了。在Go语言中也确实就是如此设计的，方法在指明对应类的同时直接传入一个抽象的实例，传入的方式和函数的传参一致，而又由于结构体本身是值类型，因此对应的抽象实例也就是和值传递相同。 </p><p>&emsp;&emsp;我们换一种理解方式：假如在一个函数中需要传入一个对象，在函数中输出对象所对应的一个属性，我们可能会采用如下的方式来完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span> <span class="params">(student stu)</span></span>&#123;</span><br><span class="line">    fmt.Println(student.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时的student对象是作为函数参数传入的，且传入的方式为值传递，我们通过该对象完成了name属性值的输出。那么对于方法而言，已然指出的类的归属，那么就可以如下来完成了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(student stu)</span> <span class="title">method</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(student.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个方法的定义中，student依然是值传递的方式传入的，从某种程度上讲，上述两种不同的函数与方法的实现方式，在理解过程中可以认为是相同的，即类的从属的指定作为方法的另一个参数。</p><h3 id="自定义类型的方法"><a href="#自定义类型的方法" class="headerlink" title="自定义类型的方法"></a>自定义类型的方法</h3><p>&emsp;&emsp;在Go语言中可以说通过type关键字所修饰的都是自定义数据类型，包括结构体的声明也可以被归结为自定义数据类型，因为不同的属性名、属性的数据类型、属性的个数所确定的结构体类型是完全不同的。既然Go语言中方法是作用于指定的数据类型上，那么只要是自定义类型，就都可以有方法，我们举一个例子： </p><p>&emsp;&emsp;现在我们的需求是为一个整数（int）添加一个方法，如果这个整数是奇数则返回false，是偶数则返回true。在此之前我们在程序中需要整数时直接定义一个int类型的变量，也不曾听说过整数类的概念，此时添加方法的途径就是将其变为一个自定义的数据类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Integer)</span> <span class="title">isEven</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num Integer = <span class="number">10</span></span><br><span class="line">    fmt.Println(num.isEven())</span><br><span class="line">    num++</span><br><span class="line">    fmt.Println(num.isEven())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如同声明结构体数据类型一般，我们通过type的方式将一个int类型自定义为Integer，此处的Integer数据类型就可以添加方法了，不仅如此，我们在main函数中将Integer变量进行自加操作，程序依旧可以完成对应的加法。由此可见：通过type的方式可以借助一些内置数据类型来自定义一些类型，这些类型可以添加方法，同时也同样具备数据本身的属性，如数学运算等。 </p><p>&emsp;&emsp;需要注意的一点是：我们通过type的方式为int类型自定义了一个Integer类型，如果在程序中有两个变量分别由int和Integer类型所定义，这两个变量的数据类型是不同的，在相互转化的时候需要进行强制转化。因此通过int定义的变量，是不具备isEven方法的，但是将其强转成Integer类型时就可以使用该方法了。</p><h3 id="String-方法"><a href="#String-方法" class="headerlink" title="String()方法"></a>String()方法</h3><p>&emsp;&emsp;在Go语言中我们经常通过fmt.Println()函数来完成数据向屏幕的输出，那我们可能会想了：当输出一个整数变量时编译器输出对应的值，当输出数组时编译器将数组中所有值都输出了，当输出引用类型的map时，编译器输出了指向的内存中的key和value的所有值，那么这个输出究竟遵循什么原则。 </p><p>&emsp;&emsp;在Go语言中一个数据类型如果实现了String()方法，那么当执行fmt.Println()时，输出到屏幕上的就是String()方法的返回值，我们举个例子：假如我们还是使用stu结构体，现在要求当我们使用fmt.Println(stu对象)的时候输出为：xxx(stu对象中的name属性)是个好人。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int</span></span><br><span class="line">    friends []stu</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s stu)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.name + <span class="string">"是个好人"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> student stu = stu&#123;<span class="string">"DENG"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    fmt.Println(student)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DENG是个好人</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样地我们也可以采用String方法来完成一些基本数据类型的其他形式的输出，当然前提条件是通过type关键字根据基本数据类型完成自定义类型的创建，然后再覆盖String方法，此处也不再做举例了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们引入了面向对象编程的另一个组成部分：方法，同时我们也通过一个入门案例完成了对方法的介绍。如果读者在之前掌握了Go语言中函数的概念与使用方式，那么对于方法的理解就轻而易举了，二者也有十分多的相似之处。最后我们又介绍了Go语言中独特的自定义数据类型的方法调用方式，以及String方法对一个数据类型的作用。 </p><p>&emsp;&emsp;在下个小节中，我们将继续讲解面向对象中方法的细节与注意事项，同时也会在下个小节中插入代码篇部分，简单针对几个小需求举几个方法的例子并进行简要地讲解。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-38-gt-面向对象-方法&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-38-gt-面向对象-方法&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;38&amp;gt; 面向对象-方法&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;37&gt; 结构体细节讨论</title>
    <link href="http://yoursite.com/2020/03/11/37-%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/03/11/37-%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/</id>
    <published>2020-03-11T11:00:25.000Z</published>
    <updated>2020-03-11T11:01:19.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-37-gt-结构体细节讨论"><a href="#Go语言从入门到放弃系列-lt-37-gt-结构体细节讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;37&gt; 结构体细节讨论"></a>Go语言从入门到放弃系列&lt;37&gt; 结构体细节讨论</h2><p>&emsp;&emsp;在上一个小节中，我们引入了结构体的概念，讲解了Go语言中结构体内存对齐的原理，同时也简要提及了面向对象与面向过程的区别，准确地说Go语言并不是一个严格的面向对象的语言，但是它具备着面向对象的许多的特点。在这个小节中，我们依旧暂时不去讲解面向对象的其他特性，而是依旧针对于结构体进行一些细节上的讲解。 </p><h3 id="结构体的声明方式"><a href="#结构体的声明方式" class="headerlink" title="结构体的声明方式"></a>结构体的声明方式</h3><p>&emsp;&emsp;在Go语言中，结构体声明与使用可以由四种方式来完成，分别对应于熟悉不同开发语言的用户。在实际运用中均十分地常见，在这个部分中，我们将分别介绍这四种方式。首先我们先声明一个如下结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int</span></span><br><span class="line">    friends []stu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们定义了一个学生结构体，结构体中三个属性分别是指学生的姓名、学生的年龄、以及学生对应的朋友切片，切片的元素类型依旧是stu类型。由于上一个小节我们已经讲解了内存对齐的问题，因此在这里我们也就不再说这个结构体占据多大的内存空间了。接下来就是四种使用方式：</p><h4 id="1-先定义再赋值"><a href="#1-先定义再赋值" class="headerlink" title="1. 先定义再赋值"></a>1. 先定义再赋值</h4><p>&emsp;&emsp;这种方式与我们入门案例程序中的使用方式是相同的，即将其想象成为一个普通的数据类型，用同样的方式进行定义变量，之后再为每个属性进行赋值。值得说明的是：属性中的map映射需要进行make操作才能够正常使用，对于slice而言，如果直接用append操作就可以不用make了。我们举一个例子说明即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 stu</span><br><span class="line">stu1.name = <span class="string">"Devin"</span></span><br><span class="line">stu1.age = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> stu2 stu</span><br><span class="line">stu1.friends = <span class="built_in">append</span>(stu1.friends, stu2)</span><br><span class="line">fmt.Println(stu1)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们定义了一个stu结构体变量，之后我们再分别为每一个属性进行赋值，在为friends赋值时，我们又定义了一个新的变量，并将新的变量加入到切片中，由于stu2只进行了定义而没有做任何赋值，因此stu2的各个属性默认值均为其零值，即数字类型为0，字符串为空串，切片等引用类型及指针为nil。</p><h4 id="2-定义时初始化"><a href="#2-定义时初始化" class="headerlink" title="2. 定义时初始化"></a>2. 定义时初始化</h4><p>&emsp;&emsp;就如同普通变量在定义时直接赋值成为初始化一样，结构体在定义的时候也可以直接赋值进行初始化。其实通过上述的例子可以发现，当我们没有显式初始化而是只定义的情况下，编译器其实是通过属性对应的零值进行了初始化操作。如果我们不想使用其初值而是使用自己赋给的值时，可以直接进行初始化操作，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 stu = stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">fmt.Println(stu1)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于了解面向对象编程的读者而言，可以将其理解为stu类的构造函数，虽然在Go语言中并不存在构造函数的概念，同时也不支持函数的重载。但是这种定义方式可以直接为类中所有的变量进行数据的初始化，那么既然可以为所有的数据进行初始化，那么对某一部分属性进行初始化也应该是可以完成的。 </p><p>&emsp;&emsp;例如我们只希望初始化stu的对象中的name和age属性，而其他属性则保持其默认的零值。解决办法则是在结构体初始化过程中指明需要初始化哪个属性，不需要初始化的属性不予体现即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student stu = stu&#123;</span><br><span class="line">    name: <span class="string">"DENG"</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;既然我们在程序中指明了哪些属性需要初始化，且初始化的值也一一对应了，那么在运行时编译器就可以为特定的值进行赋值了。在这里需要尤其注意的一点是：在这种初始化过程中，每指定一对属性和值之后都有一个逗号，即便是对属性赋值这个操作是最后一个（age:25后面有一个逗号），如果没有逗号则会编译错误。 </p><h4 id="3-new函数实现内存分配"><a href="#3-new函数实现内存分配" class="headerlink" title="3. new函数实现内存分配"></a>3. new函数实现内存分配</h4><p>&emsp;&emsp;第三种方式可以说对于熟悉Java等语言的开发者十分地友好，因为开发者往往需要通过new关键字来完成对象的创建。Go语言的开发者考虑到类似的需求，便为结构体创建实例添加了这个方式。只是在Go语言中，new并不是其中的关键字，而是一个内建函数，其返回值也不是结构体变量，而是指向结构体变量的指针，我们通过程序来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 = <span class="built_in">new</span>(stu)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, stu1)</span><br><span class="line">(*stu1).name = <span class="string">"Devin"</span></span><br><span class="line">stu1.age = <span class="number">25</span></span><br><span class="line">fmt.Println(*stu1)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果运行上述的程序，我们可以看到第二行对应的输出结构为*main.stu，其含义为main包下的stu类的指针，因此new函数的返回值是一个结构体指针。既然它是一个指针变量，当然就需要遵守指针的原则，即先取出指针所指向的结构体，再进行成员操作。由于运算符的优先级中成员符号要高于取值符号，因此我们在取出对应的结构体时需要用括号进行修饰，即(*stu1).name。假如不使用括号进行修饰，则.运算符先进行运算，虽然Go语言底层对于指针进行了优化操作，将指针的成员默认为指针对应结构体成员，但是对一个变量做*运算依旧是错误的，因此括号是必须要加的。 </p><p>&emsp;&emsp;说起Go语言对底层的优化，我们在之前的小节中也有相应的讲解，上述代码中也运用到了这个优化操作，即stu1.age = 25这一行代码。对指针进行成员操作是无意义的，因此编译器就自动翻译成为了取值后再做成员操作。如果读者对于什么是指针、什么是值、什么时候应该怎样的操作都十分熟悉了，那么当然就可以利用这个优化进行简要的操作了。</p><h4 id="4-初始化时返回指针"><a href="#4-初始化时返回指针" class="headerlink" title="4. 初始化时返回指针"></a>4. 初始化时返回指针</h4><p>&emsp;&emsp;准确地说这个方式不算是一个特殊的方式，它只是将方式2中的结构体初始化结果以指针形式进行返回，当然其定义部分的数据类型也当然就是指针，这种方式在程序开发中也是十分常用，由于其只是方式2的变形，我们就只举个例子，不再过多说明了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 *stu = &amp;stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">fmt.Println(*stu1)</span><br></pre></td></tr></table></figure><h3 id="结构体的赋值"><a href="#结构体的赋值" class="headerlink" title="结构体的赋值"></a>结构体的赋值</h3><p>&emsp;&emsp;在之前的各个章节中，我们均介绍到了各个数据类型是值类型还是引用类型，在这个部分中，我们将针对结构体的性质进行讲解。我们采用的结构体声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name   <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int</span></span><br><span class="line">    class   *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-结构体是值类型"><a href="#1-结构体是值类型" class="headerlink" title="1. 结构体是值类型"></a>1. 结构体是值类型</h4><p>&emsp;&emsp;在Go语言中，结构体是值类型而不是引用类型，这也就说明了一旦将一个结构体变量赋值给另一个结构体变量，其内部属性的所有值将会全部复制，在内存中出现一个完全新的结构体变量，两者之间并不互相影响，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 stu = stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="keyword">var</span> stu2 stu = stu1</span><br><span class="line">stu2.name = <span class="string">"RuoShui"</span></span><br><span class="line">fmt.Println(stu1)</span><br><span class="line">fmt.Println(stu2)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们定义了一个结构体变量stu1，且将该变量直接赋值给另一个变量stu2，此时内存中存在着两个地址不同但内容相同的结构体变量。接下来我们将stu2的name属性修改后，分别输出两个结构体观察结果，最后可以发现，对stu2的修改并不影响stu1的属性。 </p><p>&emsp;&emsp;在这个特性上Go语言与Java语言是不同的，Java秉承了没有显式指针的思想，但核心是全部都是指针，因此熟悉Java的读者在使用Go语言结构体赋值的时候可能会不甚适应，那么如何让一个结构体变量的修改影响到另一个结构体，我们可以采用如下指针的方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 *stu = &amp;stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="keyword">var</span> stu2 *stu = stu1</span><br><span class="line">stu2.name = <span class="string">"RuoShui"</span>    <span class="comment">//这里采用了编译器优化</span></span><br><span class="line">fmt.Println(*stu1)</span><br><span class="line">fmt.Println(*stu2)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们通过指针进行直接赋值，stu2也同样指向了结构体变量，就如同一个机器具备两个控制源，任何一个控制源发布命令，机器都会做出响应。这种实现方式可能更适合于熟悉Java开发的人们。 </p><h4 id="2-深浅拷贝"><a href="#2-深浅拷贝" class="headerlink" title="2. 深浅拷贝"></a>2. 深浅拷贝</h4><p>&emsp;&emsp;我们在这里介绍的概念在笔试乃至于面试中经常出现，即深拷贝与浅拷贝的区别，这两种拷贝方式并不局限于Go语言，而是适用于每一个编程开发语言，只是不同的语言可能采用着不同的拷贝策略，既然Go语言中结构体的赋值是将一个结构体在内存中完全复制、新建、粘贴，那么在这个过程中它究竟是深拷贝还是浅拷贝。 </p><p>&emsp;&emsp;首先我们介绍一下什么是深拷贝，什么是浅拷贝。这两种拷贝方式的区别十分简单：深拷贝就是完全复制，首先对外层对象进行拷贝，对内层引用也进行拷贝；而浅拷贝则是只复制了对象本身，其内部的引用其他对象不做复制，只做引用。 </p><p>&emsp;&emsp;用一个通俗的例子来讲便是，假如我们有一个收纳盒（结构体），盒子中有一个遥控器（引用），这个遥控器可以控制房间内的电视机（指针指向的值）。现在我们希望再建立一个收纳盒，且保持其中的物品不变，将这个收纳盒送给其他人（结构体赋值）。深拷贝的做法就是用一个新的收纳盒，装载一个新的遥控器，控制一个新的电视机，将这三样物品全部交给其他人；浅拷贝的做法就是用一个新的收纳盒，复制那个遥控器，电视机不做任何改动，将收纳盒与遥控器交给其他人，这两个遥控器均可以控制该屋子中的电视机。 </p><p>&emsp;&emsp;那么在Go语言中结构体的赋值是哪一种拷贝方式，我们做一个简单的验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> stu1 *stu = &amp;stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, &amp;a&#125;</span><br><span class="line"><span class="keyword">var</span> stu2 *stu = stu1</span><br><span class="line">fmt.Println(*stu1)</span><br><span class="line">fmt.Println(*stu2)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的程序中，我们依旧将stu1直接赋值给stu2，在最后的输出中，我们会将stu1与stu2中的class属性的地址直接输出。通过对结果的检验，我们可以发现两个结构体变量中class所指向的地址是相同的，因此可以验证得到Go语言中结构体的直接赋值过程是一个浅拷贝过程。 </p><p>&emsp;&emsp;通过这个结果我们可以想象到：当一个结构体中存在一个引用类型或者指针类型时，即便是结构体本身是值类型，其复制得到的结构体变量中的引用是不变的，从这个角度来说通过一个结构体变量修改引用类型或指针类型数据时是会影响到另一个结构体变量的，但是这与结构体值类型中两个结构体内存无关联是不相矛盾的。</p><h4 id="3-结构体类型强转"><a href="#3-结构体类型强转" class="headerlink" title="3. 结构体类型强转"></a>3. 结构体类型强转</h4><p>&emsp;&emsp;在我们之前讲解到的基本数据类型中，我们讲解过基本数据类型之间的相互转化，那么作为数据类型集合的结构体数据类型也可以发生强制转化。例如我们案例中的学生结构体是由姓名、年龄、班级所构成的，假如存在一个person类，且person类中的三个属性分别为姓名、年龄、以及性别（假如性别使用整数来表示），那么stu类与person类是否可以强制互相转化。 </p><p>&emsp;&emsp;在Go语言中，数据类型是十分严格的，即便是同一种数据类型精度不同也不可以不作声明地直接转化，结构体变量也是相同的。如果希望从一个结构体强制转换成另一个结构体，需要满足一个条件：两个结构体需要有完全相同的字段，完全相同是指属性的名字、个数、类型完全相同。我们举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> per <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">    class *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> stu1 stu = stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, &amp;a&#125;</span><br><span class="line">    <span class="keyword">var</span> per1 per = per(stu1)</span><br><span class="line">    fmt.Println(per1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们又新建了一个结构体叫做per，它也是由三个属性构成的，分别为name，age，和class。在主函数中，我们定义了一个stu类型的变量，且将该变量强制类型转换成为per类型赋给per1，最后输出per1，这段程序在编译以及运行过程中均不会报错，也就证明了强制类型转化是成功的。现在我们将per结构体做一些改变：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> per <span class="keyword">struct</span> &#123;</span><br><span class="line">    name   <span class="keyword">string</span></span><br><span class="line">    age    <span class="keyword">int</span></span><br><span class="line">    gender   *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时由于两个结构体的字段（属性）并不是完全一致的，主函数中的程序是无法编译通过的，其报错的信息为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert stu1 (<span class="keyword">type</span> stu) to <span class="keyword">type</span> per</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在本章节中，我们深入Go语言的结构体进行了深入的讲解，包括结构体的四种定义方式：两种返回值、两种返回指针，结构体值类型的特性以及结构体赋值时的浅拷贝特性，再有就是不同结构体之间做类型转换的条件与错误类型。 </p><p>&emsp;&emsp;在下个小节中，我们将不再针对结构体的属性进行讲解，而是进入到面向对象的另一个小部分：成员方法的讲解。在讲解的过程中，我们也将会详细说明一个类中的方法的概念、使用方式、以及它与函数的区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-37-gt-结构体细节讨论&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-37-gt-结构体细节讨论&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;37&amp;gt; 结构体细节讨论&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;36&gt; 面向对象-结构体</title>
    <link href="http://yoursite.com/2020/03/10/36-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://yoursite.com/2020/03/10/36-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%93%E6%9E%84%E4%BD%93/</id>
    <published>2020-03-10T12:00:42.000Z</published>
    <updated>2020-03-10T12:01:25.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-36-gt-面向对象-结构体"><a href="#Go语言从入门到放弃系列-lt-36-gt-面向对象-结构体" class="headerlink" title="Go语言从入门到放弃系列&lt;36&gt; 面向对象-结构体"></a>Go语言从入门到放弃系列&lt;36&gt; 面向对象-结构体</h2><p>&emsp;&emsp;在这个小节之前，可以说我们一直在讨论面向过程的各个知识点。不论是否理解什么是面向过程，我们到目前为止所想到的解决办法都是基于过程的，即分析出解决问题所需要的所有步骤，通过函数逐一进行实现，最后再一个一个地依次调用，以达到解决问题的目的。这种编程思想的需求便是要对过程有着清楚的了解，对过程逻辑有较好的实现，但是在大型程序的后期维护上相对较难。 </p><p>&emsp;&emsp;从这个小节中，我们将开始介绍Go语言中面向对象思想以及Go语言的独特的面向对象的实现方式。由于我们是从面向过程部分开始讲解的，因此一开始可能会相对难从面向过程的思想中跳出，而转变这个编程思路的唯一方式就是多思考、多编程而已。</p><h3 id="面向对象概念"><a href="#面向对象概念" class="headerlink" title="面向对象概念"></a>面向对象概念</h3><p>&emsp;&emsp;准确地说，不同人对于面向对象的理解都不太一致，直接复制粘贴其他人的或者维基百科的理解并不能加深个人对面向对象思想的理解。况且面向对象只是一种思想，不同的语言对于这个思想的实现方式不同，其侧重点也不甚相同，在这个小节中，我也只是讲述的是我个人对面向对象思想的理解、以及Go语言前提下独特的对面向对象的实现。  </p><p>&emsp;&emsp;首先，我们举一个相对容易理解的例子来说明面向过程：贪食蛇游戏的开发。首先初始化地图与蛇身，之后判断蛇的运动方向，进行蛇移动操作，判断是否吃到食物，判断是否撞到障碍，判断是否游戏结束，之后再一次进行同样的循环。把以上的各个需求分别用函数完成，最后再以上述的顺序连接就完成了游戏的开发。 用这种方式思考得出结果的过程就是面向过程的思想。</p><p>&emsp;&emsp;如果采用面向对象的方式来解决这个问题，考虑的方式则完全不同。这个需求可以分为几个大的部分：1. 蛇的部分，它具备位置与是否死亡等多种属性，具备向四个方向移动、成长等多种行为；2. 食物的部分：它具备自己的自然属性即碰到后身体加长、随机生成初始位置等行为；3. 地图的部分：控制游戏的开始与结束行为，完成蛇头与墙壁、石头的碰撞逻辑等。最后通过一定的方式将不同部分的不同属性、行为联系在一起完成程序的开发。换句话说，就是几个实体之间的行为与属性的联系。</p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>&emsp;&emsp;在了解面向对象的各个特点之前，我们首先需要介绍一下对象的概念，对象就是指现实世界或虚拟世界中存在的任何的所有的事物实体，可以讲：一切均是对象。整体来说，对象可以由两部分构成：属性与行为。 </p><p>&emsp;&emsp;属性是用来描述某个抽象物体的特征的，例如我们将一个人作为对象来看，她的身高、体重、国籍、甚至家庭住址都是这个人的属性。属性是是对象的静态的一面，虽说身高体重等都可以发生改变，但是这些依旧是可以通过数值等来形容的。而行为则是对象中属于动态的一面，我们依旧以一个人为例：这个人可以跑、可以跳、会算数、能长大。这些动态的行为就是面向对象的方法，而类之中的方法往往是服务于类中的属性的。 </p><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>&emsp;&emsp;那么什么是类：具备同种属性的对象称之为类，这是个相对抽象的概念，具象地理解可以理解为模板。例如：人就是一个类，而具体到你我他都是人类所对应的对象。人类具备两个眼睛、两个耳朵、一个鼻子等，而具体到每个人都具备这些属性。因此来说，类就相当于一个模板，这个模板定义了对象们应该有的属性、公共特征以及行为功能，而对象则是类的一个实例化。我们在编写程序的时候经常会将一个类实例化，并且使用该对象，就类比于某个人会弹琴，而不是人类会弹琴。 </p><h4 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h4><p>&emsp;&emsp;面向对象编程中有三大特性，分别为继承、封装、多态。在这里我们先不做过多的讲述，因为这三个特性在后续的讲解中均是重点知识，而且Go语言对这三个特性的实现也与其他很多语言都不同。 </p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>&emsp;&emsp;现在我们回到技术层面来考虑问题，在Go语言中是如何实现面向对象编程的。在之前所讲解的map映射中我们一直在回避一个问题，这个问题就是一个学号对应一个学生姓名，但是往往并不是仅仅如此，我们需要存储更多的信息，例如学生姓名、学生性别、学生住址等。当输入学生的学号时，将对应学生的信息都打印出来，这个需求该如何去完成。如果采用之前讲解到的技术，可能为值为map类型的map映射： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stuInfo <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">stuInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">stuInfo[<span class="number">10001</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">stuInfo[<span class="number">10001</span>][<span class="string">"name"</span>] = <span class="string">"Devin"</span></span><br><span class="line">stuInfo[<span class="number">10001</span>][<span class="string">"gender"</span>] = <span class="string">"Male"</span></span><br><span class="line">stuInfo[<span class="number">10001</span>][<span class="string">"address"</span>] = <span class="string">"Melbourne"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(stuInfo[<span class="number">10001</span>][<span class="string">"gender"</span>])</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种实现方式虽然可以完成上述需求，但是这种方式实在是过于繁琐，假如需要根据平均分等指标进行排序就又会更复杂。因此我们可能会想在Go语言中是否存在这样一种数据结构：它可以是多个数据类型的集合，在逻辑上可以被看做一个整体，这样在做管理的时候会十分地方便。 </p><p>&emsp;&emsp;结构体就刚好可以满足上述的要求，它更贴近于类的概念。在之前我们的设想中采用多个数组分别存储这些属性，根据数组的下标值进行管理，可以讲这种方式是一种横向的方式，各个属性是相互分立的。而结构体则是一种纵向的方式，将一个对象的各个属性集合在一起，不同的对象是相互分立的。采用结构体完成上述需求的入门案例为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stuInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    gender <span class="keyword">string</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu stuInfo</span><br><span class="line">    stu.name = <span class="string">"Devin"</span></span><br><span class="line">    stu.gender = <span class="string">"Male"</span></span><br><span class="line">    stu.address = <span class="string">"Melbourne"</span></span><br><span class="line">    fmt.Println(stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们首先定义了一个结构体，即定义了一个数据模板，目前这个结构体中只含有三个属性。在主函数中，我们根据这个类实例化了一个对象stu，在这之后所有的操作都是针对对象stu的，为stu中三个属性进行赋值，最后再进行输出。</p><h3 id="结构体中内存对齐"><a href="#结构体中内存对齐" class="headerlink" title="结构体中内存对齐"></a>结构体中内存对齐</h3><p>&emsp;&emsp;在Go语言的结构体中，存在着一种叫做内存对齐的情况，熟悉旧版C语言但是没有接触过内存对齐的人可能会对这个问题比较陌生。我们举一个例子：假如一个结构体中按顺序含有一个byte，一个int64，两个bool，和一个float32数据，那么这个结构体在内存中占用了多大的空间。结构体体定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> str <span class="keyword">struct</span> &#123;</span><br><span class="line">    byte_field <span class="keyword">byte</span></span><br><span class="line">    int64_field <span class="keyword">int64</span></span><br><span class="line">    bool1    <span class="keyword">bool</span></span><br><span class="line">    float_field <span class="keyword">float32</span></span><br><span class="line">    bool2    <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在标准C语言的思想中，我们可能会想：byte是1个字节、int64是8个字节、bool是1个字节、float32是4个字节，所以这个结构体总共占据1+8+1+1+4=15个字节的空间，这种问题往往还会在考试中考。然而如果我们采用”unsafe”包中的Sizeof函数来测量这个结构体在内存中的空间时，其输出结构竟然是32个字节，而不是我们分析得到的15个字节。 </p><p>&emsp;&emsp;出现这个差异的原因就是Go语言中的结构体实行了内存对齐。计算机以及一些嵌入式设备在读取内存的时候往往不是一个字节一个字节的地读，而是一块一块地读。对于64位的机器而言，计算机一次读取8个字节的内存，对于32位机器而言则是读取4个字节。假如所有数据都是两两相邻的，例如一个bool变量和一个int64变量，计算机在读取的时候（64位机器），是先读取8个字节的空间，发现里面有bool变量，但是当计算机读取int64变量的时候，它需要先读取前8个字节并取其中的后7个字节，然后再读取后8个字节取其中的第一个字节，最后再将两部分拼接起来，这样读取速度就会受到影响。 </p><p>&emsp;&emsp;因此内存对齐的作用就体现出来了，其思想便是利用空间换取时间，让第一个bool单独占据8个字节的位置，然后int64占据8个字节，这样读取效率就会提升。不仅如此，在对齐的最后还会让结构体的空间再对齐，使得结构体数组中任意两个结构体的读取更快捷。Go语言结构体中内存对齐有两个原则：1. 每个变量相对于结构体地址的偏移量应该成为该数据类型所占字节的整数倍，例如int16相对于起始位置需要是2的整数倍，float64相对于起始位置需要是8的整数倍。对于数组等集合型数据类型，按其中元素的数据类型来算。 2.结构体整体占据的空间需要是4的整数倍（32位机器）或8的整数倍（64位机器）。 </p><p>&emsp;&emsp;因此针对于题目中的结构体我们需要做如下的分析：<br>&emsp;&emsp;&emsp;&emsp;1. 首先第一个属性是一个byte，其占据一个字节的空间。目前的内存为：     </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|x</span><br><span class="line">(x表示有数据，.表示空余)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;2. 第二个属性是一个int64数据，其占据8个字节，然而假如将其直接加在后面，其偏移量不是8的整数倍，因此对于这个变量需要进行内存对齐，对齐的方式是中间空余7个位置，内存表示如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;3.第三个属性是bool变量，应该占据1个字节，由于任何数都是1的整数倍，因此直接加在后面是满足于条件1的，内存表示如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|x</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;4. 第四个属性是float32类型变量，占据4个字节，如果直接加在bool的后面，其偏移量为17,而17并不是4的整数倍，因此需要进行内存对齐，对齐位置应该是偏移量为20的位置，内存如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|x...xxxx|</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;5. 最后一个变量还是bool类型，同理它可以直接加入到任何一个变量的后面，所以这个变量直接加在float32后面。此时的内存如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|x...xxxx|x</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;6. 此时结构体内部的各个变量的位置已经分好了，即每一个属性的位置都满足于条件1，而整个结构体此时的字节数为25，然而25并不是8的整数倍，其最近的整数倍为32，所以最终这个结构体在内存中的分布为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|x...xxxx|x.......|</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述的解释中，我们可以发现：其实在第一个字节中有效位置只有一个二进制位，而浪费了七个二进制位，对于最后一个字节依旧是如此。那么在结构体的设计上，我们明明可以将两个bool变量定义到一起去，这样不仅第一个字节利用率变高，最后一个字节也不需要整体内存对齐，对于结构体的空间占用就减少了1/4。而解决办法，其实只是将属性定义的顺序修改一下即可。</p><p>&emsp;&emsp;但是一般的算法优化并不会针对结构体的设计方面进行优化，因为相比于主流的时间空间复杂度的优化方式，这种优化所得到的收益实在是太低了。因此，内存对齐的优化方式并不主流，但也不失为一种简单而有效的优化方式。</p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>&emsp;&emsp;在这个地方为了加强对内存对齐的理解，我们假设存在这样的一个结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int64</span></span><br><span class="line">    isAdult <span class="keyword">bool</span></span><br><span class="line">    grades [<span class="number">3</span>]<span class="keyword">float32</span> <span class="comment">//假设只有三门课</span></span><br><span class="line">    friends []stu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么请问，这个结构体变量在内存中会占据多大的空间。答案是64  ，读者可以自行分析。（注：string类型占16字节、切片占24字节，具体原因我们在前面都讲解过）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|xxxxxxxx|xxxxxxxx|xxxxxxxx| x...xxxx|xxxxxxxx|xxxxxxxx|xxxxxxxx|xxxxxxxx|</span><br><span class="line">|<span class="keyword">string</span>           |<span class="keyword">int64</span>   |<span class="keyword">bool</span>|[<span class="number">3</span>]<span class="keyword">float32</span>   |[]stu                     |</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们初步讲解了面向对象编程思想与面向过程编程思想的区别，同时引入了Go语言中结构体这种数据类型，并对结构体数据类型做了一个简单的快速入门举例。最后我们讲解了Go语言结构体中的内存对齐的现象，说明了这种语言与其他某些语言的不同点。 </p><p>&emsp;&emsp;在下一个小节中，我们依旧将针对于结构体数据类型的四种声明以及初始化方式进行讲解，并集中提及在代码实现过程中需要注意到的问题和细节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-36-gt-面向对象-结构体&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-36-gt-面向对象-结构体&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;36&amp;gt; 面向对象-结构体&quot;
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;35&gt; map映射的细节讨论</title>
    <link href="http://yoursite.com/2020/03/09/35-map%E6%98%A0%E5%B0%84%E7%9A%84%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/03/09/35-map%E6%98%A0%E5%B0%84%E7%9A%84%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/</id>
    <published>2020-03-09T12:04:59.000Z</published>
    <updated>2020-03-09T12:05:49.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-35-gt-map映射的细节讨论"><a href="#Go语言从入门到放弃系列-lt-35-gt-map映射的细节讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;35&gt; map映射的细节讨论"></a>Go语言从入门到放弃系列&lt;35&gt; map映射的细节讨论</h2><p>&emsp;&emsp;在上一小节中，我们对Go语言中的map映射进行了引入，同时也讲解了map的定义初始化方式以及对其中数据的增删改查操作的方式。在这个小节中，我们依旧针对map映射的其他特性进行相对深入的讲解，以及在程序编写过程中需要注意的几个问题进行提及。 </p><h3 id="键值对类型"><a href="#键值对类型" class="headerlink" title="键值对类型"></a>键值对类型</h3><p>&emsp;&emsp;在上一个小节中，我们提到map映射中数据的存储方式是以键-值的方式存储的，同时每一个键都对应于一个值。在上一节的入门案例中，我们只使用了整数类型以及字符串类型作为map的键值，在这一部分中我们将介绍其他的可以作为键值的数据类型。 </p><p>&emsp;&emsp;到目前为止，我们已经讲解过的数据类型有：整数类型、浮点类型、布尔类型、字符串类型、数组、切片、函数类型、以及正在讲解的映射类型。那么这些数据类型是否全部都可以作为map的键值类型呢，答案是否定的。在Go语言中切片、映射、和函数是不可以作为map的键的类型的。 </p><p>&emsp;&emsp;对于这个规定的理解，我们可以想象一下如下的过程，当我们希望通过一个键来查找值的时候，map中是维护了一个键的列表的。当在这个列表中存在着当前键的时候，才将值进行输出，同时判断两个键值是否相同的方式只有通过==的方式。到目前为止我们所演示的所有案例中，均没有出现过判断两个切片是否相等、两个映射是否相等、以及两个函数是否相等。从某种意义上来说可以判断是否相等的两个值大小需要是固定的，而slice以及map刚好不满足，而function作为一个map的键一般来说也是没有意义的。 </p><p>&emsp;&emsp;那么对于map的值类型是否也存在着某些限制，理论上来说，map映射对于value的数据类型是没有限制的，即slice等不可以作为key的类型但是是可以作为value的类型的。不论某个数据类型是值类型还是引用类型，它在内存中都是可以被另一个指针所指向的，因此value的类型是可以任意的。我们通过两小段程序来说明这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sys <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">sys[<span class="string">"1"</span>] = slice</span><br><span class="line">fmt.Println(sys)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一段程序是可以成功编译运行的，这个map映射的key类型为string字符串，value类型为一个int切片。我们接下来为这个切片赋值，再添加到map中，最终的结果可以成功输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sys <span class="keyword">map</span>[[]<span class="keyword">int</span>]<span class="keyword">string</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[[]<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">sys2[slice] = <span class="string">"1"</span></span><br><span class="line">fmt.Println(sys)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第二段程序就无法编译通过了，因为他的key类型是一个int切片，由于int切片是无法通过==或!=来判断的，因此这个map是无法构成的。在编译过程中，会报出：invalid map key type []int的错误。</p><h3 id="map的无序性"><a href="#map的无序性" class="headerlink" title="map的无序性"></a>map的无序性</h3><p>&emsp;&emsp;在我们之前所接触到的多数据集合的类型中，例如数组切片等都是有序的集合，即先输入的数据排在前方而后输入的数据排在后方。我们也可以采用某些数据结构或独特的排序方式使之成为有序的状态，例如插入排序、堆排序等。而在Golang的map映射中，这两种特性均不存在，也就是说当遍历map中的数据时，往往不会遵循数据的大小规律以及输入的先后规律。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sys := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="string">"one"</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">"two"</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="string">"three"</span>,</span><br><span class="line">    <span class="number">4</span>: <span class="string">"four"</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">"five"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(sys)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中我们输出了10次map映射，在这里我就不将执行结果写出来了，因为不同的人在执行这样同一段代码的时候，其结果可能完全不同。但是可以保证的是：map映射中会存在5个数据，且这5个数据均是正确显示的，只是输出的顺序是不同的。 </p><p>&emsp;&emsp;出现这个效果的原因是每一次key的遍历顺序不同，而这个不同则是Go语言的设计者的有意为之（虽说我不太理解这个做法）。在其他语言中程序员对于map的遍历时往往依赖于其key的稳定输出顺序，在Go语言中是完全不可以的。不过奇怪的是：在早版本的golang中，输出的key并非是随机化的，无序这个特性是设计者在后续版本中加入的一个特性。 </p><p>&emsp;&emsp;再需要提及的一个问题是：map中的值的存储是不连续的，即不像是数组那样两个元素是相连的。在Go语言中键与值的对应关系满足哈希算法，即通过键的值经过某种计算直接得到值的物理地址，从而可以快速查找。因此值的存储是不连续的，不仅如此，value的访问是不可以通过指针访问的，即便是我们知道了value的物理地址，也不能通过*运算来访问。因为当map扩容时，所有的数据可能会采用新的hash算法进行计算，之前的物理地址可能就不再指向原来的数据了。</p><h3 id="map的排序"><a href="#map的排序" class="headerlink" title="map的排序"></a>map的排序</h3><p>&emsp;&emsp;既然map的key的遍历是无序的，value的输出也是无序的，当遇到了对map排序的需求时就需要对其做一些变通。此时我们需要用一个数组或切片进行辅助排序。我们就首先遍历map中的键，并将每一个遍历到的键加入到一个切片中。然后对这个切片进行排序，最后按排序后的key进行对应值的查找，进而完成按key的大小排序，程序如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sort"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sys := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="number">1</span>: <span class="string">"one"</span>,</span><br><span class="line">        <span class="number">2</span>: <span class="string">"two"</span>,</span><br><span class="line">        <span class="number">3</span>: <span class="string">"three"</span>,</span><br><span class="line">        <span class="number">4</span>: <span class="string">"four"</span>,</span><br><span class="line">        <span class="number">5</span>: <span class="string">"five"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> keys []<span class="keyword">int</span> = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> key, _ := <span class="keyword">range</span> sys &#123;</span><br><span class="line">        keys = <span class="built_in">append</span>(keys, key)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(keys)</span><br><span class="line">    <span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        fmt.Println(sys[key])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="键的唯一性"><a href="#键的唯一性" class="headerlink" title="键的唯一性"></a>键的唯一性</h3><p>&emsp;&emsp;这个特性是相对好理解的，因为在日常生活中处处存在类似的例子。例如，在一所学校中不会出现两个相同学号的学生，不会出现两个相同身份证号的人。因此这个特性就决定了map映射中每一个key都需要是不同的，而对于value则完全没有要求。例如“信用卡-用户”这个键值对，每个信用卡都可以独特地对应一个人，但是一个人可能对应的不止一个信用卡。对于键的唯一性我们通过代码举例说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">stu[<span class="number">1</span>] = <span class="string">"Devin"</span></span><br><span class="line">stu[<span class="number">2</span>] = <span class="string">"RuoShui"</span></span><br><span class="line">stu[<span class="number">3</span>] = <span class="string">"RuoShui"</span></span><br><span class="line">stu[<span class="number">1</span>] = <span class="string">"Evelyn"</span></span><br><span class="line">fmt.Println(stu)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们声明了一个map映射，并向其中插入了四条数据，在这四条数据中，我们验证了在Go语言中map的键、值是否可以重复。stu2和stu3的值是相同的，而Devin和Evelyn的键是相同的。通过结果我们可以发现：stu2和stu3是可以共存的，而stu1的Devin值是被Evelyn所覆盖了，因为根据哈希算法，通过一个键值的计算所得到的物理地址是一定的，因此对应于同一个键，只能存在一个值，也就是最后覆盖的那个值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="number">3</span>:RuoShui <span class="number">1</span>:Devin <span class="number">2</span>:Evelyn]</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们针对Go语言中的map映射进行了相对具体的讲解，并介绍了map的键类型与值类型的限制，以及map内key的遍历的无序性和对应的排序方式，最后我们也提及了map映射中键的唯一性。 </p><p>&emsp;&emsp;从下个小节开始，我们将开始进入面向对象的部分，讲解Go语言中面向对象的特性以及实现方式，同时也将针对Go语言对面向对象的几大特性的独特的设计理念进行讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-35-gt-map映射的细节讨论&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-35-gt-map映射的细节讨论&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;35&amp;gt; map映射
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;34&gt; map映射</title>
    <link href="http://yoursite.com/2020/03/08/34-map%E6%98%A0%E5%B0%84/"/>
    <id>http://yoursite.com/2020/03/08/34-map%E6%98%A0%E5%B0%84/</id>
    <published>2020-03-08T13:19:27.000Z</published>
    <updated>2020-03-08T13:20:08.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-34-gt-map映射"><a href="#Go语言从入门到放弃系列-lt-34-gt-map映射" class="headerlink" title="Go语言从入门到放弃系列&lt;34&gt; map映射"></a>Go语言从入门到放弃系列&lt;34&gt; map映射</h2><p>&emsp;&emsp;在之前的几个小节中，我们分别讲解了数组与切片两种相对复杂的数据类型，并讲解了其使用方式和注意事项。在这个小节中，我们将进入对下一个话题的讨论-map映射。在这几小节中，我们也将延续之前的讲解模式，以案例驱动快速入门程序，然后针对使用方式进行讲解，最后再面向一些使用细节做出更深入的讨论。 </p><h3 id="map映射引入"><a href="#map映射引入" class="headerlink" title="map映射引入"></a>map映射引入</h3><p>&emsp;&emsp;map映射与之前介绍到的数组等数据结构完全不同，数组包括切片都是同一种数据的有序集合，而map则是以键值对的形式进行数据存储，每一个键（key）对应于一个值（value）成对出现。 </p><p>&emsp;&emsp;首先我们举一个例子，在日常生活中具备很多的一对一键值的例子。例如：每一个公民都具备一个独一无二的身份证号码，且这个号码可以唯一且精确地代表这个人。再例如在某个班级或者学校中，每个学号可以对应于每一个人，且依旧是唯一且精确地代表。假如我们希望完成一个如下需求的程序：写一个小的管理系统，系统中需要存储用户的身份证号以及姓名，且需要通过身份证号来直接查找到用户。 </p><p>&emsp;&emsp;如果采用之前我们提及的各个技术来完成这个需求，其实还是比较有难度的，因为之前我们所介绍的名字与值唯一相对的只有变量名与变量值的相对关系，然而定义多个变量的方式很不现实，使用切片的方式也相对麻烦，我们实现一下： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ids []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> names []<span class="keyword">string</span> = []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    ids = <span class="built_in">append</span>(ids, <span class="number">10001</span>)</span><br><span class="line">    names = <span class="built_in">append</span>(names, <span class="string">"Devin"</span>)</span><br><span class="line">    ids = <span class="built_in">append</span>(ids, <span class="number">10002</span>)</span><br><span class="line">    names = <span class="built_in">append</span>(names, <span class="string">"RuoShui"</span>)</span><br><span class="line">    fmt.Println(ids)</span><br><span class="line">    fmt.Println(names)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们定义了两个切片分别来存储身份id以及用户姓名，当添加新的用户时，需要对两个切片进行append操作，通过id查找姓名时需要先查找id所在数组（切片）中的下标，然后再提取names切片中对应下标的元素，当删除时，同样需要先找到对应下标后再进行切片的删除。因此通过切片来完成这个需求只能说可以达到目的，但是这个实现方式非常的繁琐。 </p><p>&emsp;&emsp;所以我们进而引入map映射的概念，map映射有两个组成部分，分别是key和value，且每个键都需要唯一对应一个值，在上述的这个需求中，用户的身份id刚好可以唯一指定一个用户的用户名，因此是十分适用的。我们利用map的方式来完成上述的需求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sys <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    sys[<span class="number">10001</span>] = <span class="string">"Devin"</span></span><br><span class="line">    sys[<span class="number">10002</span>] = <span class="string">"RuoShui"</span></span><br><span class="line">    fmt.Println(sys[<span class="number">10002</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们定义且初始化了一个map映射，然后向该映射中添加了两组数据，分别是两个用户的身份id以及用户姓名，当通过id进行查找姓名时，可以直接通过map中的键得到对应的值，相比于用两个切片来保存，使用映射的技术更为合适。</p><h3 id="map的使用方式"><a href="#map的使用方式" class="headerlink" title="map的使用方式"></a>map的使用方式</h3><p>&emsp;&emsp;在这个小节中，我们不准备介绍map映射的内存构成，因为其构成方式十分的复杂，其核心是采用hashmap的算法方式进行的分布存储，且数据结构也包含了数组配合链表，且采用红黑树的原则进行存储。因此在没有讲解数据结构与算法相关知识之前，直接介绍map的内存构成不是一个好的选择，这对初学者来说也并不十分友好，因此就直接跳过这部分进而对map的使用进行讲解。 </p><h4 id="make函数的使用"><a href="#make函数的使用" class="headerlink" title="make函数的使用"></a>make函数的使用</h4><p>&emsp;&emsp;关于make函数，我们在讲解切片的时候就已然提及过了，我们曾用这个函数为切片分配空间。同理，在map映射中，我们依旧需要这个函数对映射进行初始化，否则该map只是一个空指针，输出时会出现nil。 </p><p>&emsp;&emsp;make函数在初始化map映射时有两种写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(映射类型,初始大小)</span><br><span class="line"><span class="built_in">make</span>(映射类型)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述两个方式中，唯一区别就是是否需要为map分配初始大小。如果省略该参数，编译器会自动为map分配默认的大小，而如果指定大小的话则会分配对应的空间，其特性与切片大致相似：当为map插入数据时一旦溢出该空间则会自动增长。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> , <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="1-先声明再初始化最后赋值"><a href="#1-先声明再初始化最后赋值" class="headerlink" title="1. 先声明再初始化最后赋值"></a>1. 先声明再初始化最后赋值</h4><p>&emsp;&emsp;同切片数据类型一样，map映射的使用方式也是这三个步骤。接下来我们将针对这三个步骤分别进行讲解：首先是声明部分，由于映射需要键的数据类型与值的数据类型两个部分，再加上变量名等等，因此map的声明方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 <span class="keyword">map</span>[键的数据类型]值的数据类型 = <span class="keyword">map</span>[键的数据类型]值的数据类型</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如采用上述的需求：用户的id号为整数类型，用户的姓名为字符串类型，因此其声明方式为：map[int]string。再举一个例子：我们需要存储用户的email以及用户的年龄，且email值可以唯一指定这个用户的年龄。因此此时的声明方式中键的类型为string，值的类型为int：map[string]int。 </p><p>&emsp;&emsp;在map映射声明后，我们暂时还无法使用它，因为此时它只是一个指向nil的指针类型，是没有分配空间的，因此声明过后需要通过make函数为map分配空间与资源：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> , <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个地方需要注意的问题是：在make函数中传入的参数类型要与map声明的类型相同，例如map的声明类型为键是字符串、值为整数，则传入的参数的类型也是需要是这个类型不可以改变。 </p><p>&emsp;&emsp;在为map分配的内存空间资源后，它就可以进行赋值等使用操作了，在后面我们将针对map结构的增加、删除、修改、查找分别进行举例讲解，所以在这里我们暂时不提map的使用。</p><h4 id="2-直接make初始化后再赋值"><a href="#2-直接make初始化后再赋值" class="headerlink" title="2. 直接make初始化后再赋值"></a>2. 直接make初始化后再赋值</h4><p>&emsp;&emsp;经过了前面多个小节的讲解，想必对Go语言中直接将声明和初始化合称为一条语句的做法都不陌生了，所以map映射也是可以在定义时直接初始化空间的，同理对于变量的类型自动推导也不难理解，此处就举一个例子而不全部讲解了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sys <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">sys := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="3-直接赋值初始化"><a href="#3-直接赋值初始化" class="headerlink" title="3. 直接赋值初始化"></a>3. 直接赋值初始化</h4><p>&emsp;&emsp;正如基本数据类型变量的初始化一样，map映射也可以直接在定义的时候初始化其初始值。初始化的方式与切片的初始化方式十分相似，其不同点就是map初始化的时候需要采用键：值的方式进行初始化。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sys := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="number">10001</span>: <span class="string">"Devin"</span>,</span><br><span class="line">        <span class="number">10002</span>: <span class="string">"RuoShui"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(sys)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面的这段程序中，类型自动推导sys的数据类型，且声明键为int，值为string的map过后直接用大括号进行初始化。初始化过程中的键和值的类型需要与定义完全一致。这里需要注意的一个地方就是初始化过程中的最后一个逗号，一般来说逗号是分割两组数组的符号，因此在最后一个数据后是没有逗号的，但是，在map的初始化过程中，这个逗号是必要的不可以被省略。 </p><h3 id="map映射的增删改查"><a href="#map映射的增删改查" class="headerlink" title="map映射的增删改查"></a>map映射的增删改查</h3><h4 id="1-增加数据与修改数据"><a href="#1-增加数据与修改数据" class="headerlink" title="1. 增加数据与修改数据"></a>1. 增加数据与修改数据</h4><p>&emsp;&emsp;之所以将这两个部分放在一起来讲是因为其使用形式是一样的，都是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名[键]=值</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当map中不存在当前的这个键时，执行上述形式的代码可以将对应的键和值加入到map中，即添加数据。当map中已经存在了这个键，则将新的value覆盖掉原来对应的值，即修改数据。具体的案例我们在入门程序中已然有所提及。 </p><h4 id="2-查询数据"><a href="#2-查询数据" class="headerlink" title="2. 查询数据"></a>2. 查询数据</h4><p>&emsp;&emsp;在执行网络编程等程序中，我们可能并不知道map中究竟含有什么数据，因此需要对数据进行通过键来查找。同样地，此时也会出现两种情况：键存在与键不存在。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value值, 键是否存在 = 变量名[键]</span><br><span class="line">value, exist = sys[<span class="number">10003</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的调用方式中，如果在map中存在希望查找的键，则exist的值为true，value就是map中对应的值，当map中不存在对应的键时，exist的返回值为false。 </p><p>&emsp;&emsp;除此之外，我们有时候不仅需要通过键来寻找对应的值，而是希望得知值中是否包含某个值，此时就需要对map进行遍历，然而map只支持通过键来得到值，因此map的遍历其实就是对key的遍历。当得到了key后，其value就自然可以得到了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sys := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="number">10001</span>: <span class="string">"Devin"</span>,</span><br><span class="line">        <span class="number">10002</span>: <span class="string">"RuoShui"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> key, value := <span class="keyword">range</span> sys &#123;</span><br><span class="line">        fmt.Println(key, <span class="string">" "</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3. 删除数据"></a>3. 删除数据</h4><p>&emsp;&emsp;既然查询数据是需要通过键来完成，那么删除数据当然也是需要通过键来完成。在map数据的删除中，我们使用的是系统内建函数:delete。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>名，键)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;即从指定的map中删除对应的键和值，这个调用方式与切片的追加append函数调用方式相同，只是append函数需要通过一个切片进行接收，而delete函数是可以不用变量来接收。 </p><p>&emsp;&emsp;在删除数据的过程中，当需要删除的键存在时，直接在map中删除对应的键和值，当需要删除的键不存在时，则什么都不做，程序运行过程中不会报错。 </p><p>&emsp;&emsp;在Go语言中，不存在一个函数用来完全清空一个map映射，如果用户希望清空一个map，则需要对map进行遍历，在遍历的同时逐个进行删除。亦或使用make函数为该map重新分配一个空间，而抛弃原有的空间，此时原有的空间可以被垃圾回收机制gc所回收，新的空间是空的，也算是另一种意义上的清空。 </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们对Go语言中的另一种数据类型map映射进行了引入，并使用它完成了一个简单的需求案例。除此之外我们也讲解了map映射的三种定义及使用方式以及在代码中对map进行数据增删改查的操作方式。在下一小节中我们将会依旧针对于map映射深入讲解一些细节以及注意事项。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-34-gt-map映射&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-34-gt-map映射&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;34&amp;gt; map映射&quot;&gt;&lt;/a&gt;Go语言
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;33&gt; 切片使用细节</title>
    <link href="http://yoursite.com/2020/03/07/33-%E5%88%87%E7%89%87%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/"/>
    <id>http://yoursite.com/2020/03/07/33-%E5%88%87%E7%89%87%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/</id>
    <published>2020-03-07T13:00:02.000Z</published>
    <updated>2020-03-07T13:00:53.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-33-gt-切片使用细节"><a href="#Go语言从入门到放弃系列-lt-33-gt-切片使用细节" class="headerlink" title="Go语言从入门到放弃系列&lt;33&gt; 切片使用细节"></a>Go语言从入门到放弃系列&lt;33&gt; 切片使用细节</h2><p>&emsp;&emsp;在上一个小节中，我们通过案例引入了切片的概念，同时也讲解了切片的定义方式、使用方式、独特的追加元素与拷贝的方式。不仅如此，我们也讲解了切片的内存构成，并得到一个结论是切片是一个引用类型，且引用的底层就是一个Go语言中的数组。在这个小节中，我们将继续针对Go语言中的切片数据类型进行深入的讲解，并对其使用过程中的注意事项进行讲解。 </p><h3 id="len与cap函数"><a href="#len与cap函数" class="headerlink" title="len与cap函数"></a>len与cap函数</h3><p>&emsp;&emsp;在上一小节中，我们在对切片的内存进行图解的讲解时，我们在图中不仅画出了切片所指向的数组的物理地址，我们还在其后画出了两个值，分别为：切片的长度与切片的容量。首先我们通过一个入门程序来通过这两个函数的调用完成切片的长度与容量的获取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice))</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从程序中，我们可以发现len函数和cap函数都是系统内建函数，是不需要引入任何的包的。同时len函数的返回值为切片的长度，cap函数的返回值为切片的容量。那么为什么会在切片的结构体中定义这两个变量，是因为切片的长度是可以动态变化的。 </p><p>&emsp;&emsp;如果我们将视角返回到数组中，如果我们有一个需求为当前已经满了的数组添加一个数字，我们可以能采用两种方式：第一种为将数组改变成为链表，这样就可以随意地添加、删减元素，但是此时数据的快速查找就变得非常不容易；第二种方式为：每当需要插入一个数据，就新申请一个长度+1的数组，并将原数组中的所有值复制给新的数组，并在最后加入新值，这种方式保存了数组的元素快速查找的特性，但是对于频繁增加数据的情况下就十分地浪费资源，因为做了极多次的申请与复制操作。 </p><p>&emsp;&emsp;而对于切片而言，由于其底层就是一个数组，因此将数组改为链表这个方式就基本不可能了，而每次都申请长度+1的数组又太过频繁了。因此解决方式是当数组元素个数已经满了，申请新的数组时就多申请一部分的空间以备用。当申请结束后新数组的长度成为切片的容量，新数组中存在元素的个数成为切片的长度，我们举一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice[<span class="number">0</span>])</span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice[<span class="number">0</span>])</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice))</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述程序中，我们定义了一个切片，且指定了长度为5，容量为10，此时由于切片定义后未修改值，所以输出的slice结果为：[0 0 0 0 0]，且输出了数组中第0个元素的物理地址，本次本机输出值为：0xc00008e000。然后我们为slice切片追加一个元素1，再一次输出该切片的元素，此时切片的长度变为了6，输出结果为：[0 0 0 0 0 1]，此时再次输出数组中的第0个元素的物理地址，本次本机为0xc00008e000。最后输出切片的长度为6，容量为10。 </p><p>&emsp;&emsp;从上述的输出结果中，我们可以总结出以下几点：每次执行append函数时，切片的长度会变为两个参数切片（或者可变参数）的长度的和，因为此时只追加一个元素，所以长度变为+1后的值；切片的容量在长度不超过容量数时不发生变化，一旦超出了我们下面会继续讲解；两次输出的切片所对应的数组的首地址是相同的，因此可以断定追加前与追加后是同一个数组，物理地址没有发生变化。 </p><p>&emsp;&emsp;上面的例子是追加元素后没有超出容量的情况，下面我们再举一个超出容量的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice[<span class="number">0</span>])</span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice[<span class="number">0</span>])</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice))</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序与上述程序的唯一区别就是：将切片定义时的容量由10变为5，所以最初状态就是切片的长度为5，且只能容纳5个值，即底层的数组处于满员的状态。此时再添加一个元素，由于原数组已经无法容纳这些值了，所以需要申请一个新的数组，其输出结果可以证明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"><span class="number">0xc000080060</span></span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"><span class="number">0xc000092000</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述的输出结果中，我们可以看出：数组的首地址是不相同的，所以当追加数据时数据溢出的情况下底层会新申请一个数组。不仅如此，新申请的数组的长度（切片的容量）由5变成了10。</p><h3 id="切片注意事项与细节说明"><a href="#切片注意事项与细节说明" class="headerlink" title="切片注意事项与细节说明"></a>切片注意事项与细节说明</h3><p>&emsp;&emsp;在接下来的部分中，我们将针对于切片的使用细节以及注意事项作出简要的说明，这些细节可能在之前的部分中有所提及，可以一并回忆一下之前的知识点。 </p><ol><li><p>切片通过数组初始化时var slice = array[start:end] 是从数组下标为start开始到end为止（不含）的截取，且截取方式为：<strong>左闭右开</strong>。 </p><p>&emsp;&emsp;例如：取出数组中的全部元素成为切片是array[0:len(array)]而不是array[0:len(array)-1]。</p></li><li><p>切片初始化时依然不可以越界，其范围依旧在0到len(array)之间（左闭右开），但是是可以动态增长的。在数组的截取过程中，有一些截取部分的简化操作：</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = array[<span class="number">0</span>:end]        ==&gt;  <span class="keyword">var</span> slice = array[:end]</span><br><span class="line"><span class="keyword">var</span> slice = array[start: <span class="built_in">len</span>(array)]  ==&gt;  <span class="keyword">var</span> slice = array[start:]</span><br><span class="line"><span class="keyword">var</span> slice = array[<span class="number">0</span>: <span class="built_in">len</span>(array)]    ==&gt;  <span class="keyword">var</span> slice = array[:]</span><br></pre></td></tr></table></figure><ol start="3"><li>cap是一个内置函数，不需要引入任何的包，用于统计切片的最大容量，在数据追加过程中，如果追加后长度没有超出容量则不变，一旦超出容量则新申请数组后容量变为二倍。在这里不做演示了，只放置一个示例程序，读者可以自行运行后观察数据规律：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"长度为：%d，容量为：%d\n"</span>, <span class="built_in">len</span>(nums), <span class="built_in">cap</span>(nums))</span><br><span class="line">    nums = <span class="built_in">append</span>(nums, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>切片的核心其实就是底层的数组，因此切片可以继续切片。</p></li><li><p>切片是引用类型，即作为函数参数传递时，被调用者对切片数据进行修改时会影响到调用者函数中的值。 </p><p>&emsp;&emsp;针对这个特性我们举一个例子：利用一个字符（整数）切片存储多个字符，并且在自定义函数中将该切片中所有大写字母转换成对应的小写字母。</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> info []<span class="keyword">byte</span> = []<span class="keyword">byte</span>&#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'L'</span>, <span class="string">'O'</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(info); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, info[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    change(info)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(info); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, info[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(slice []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> delta = <span class="string">'a'</span> - <span class="string">'A'</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> slice[i] &gt;= <span class="string">'A'</span> &amp;&amp; slice[i] &lt;= <span class="string">'Z'</span> &#123;</span><br><span class="line">            slice[i] += <span class="keyword">byte</span>(delta)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="string类型与切片"><a href="#string类型与切片" class="headerlink" title="string类型与切片"></a>string类型与切片</h3><p>&emsp;&emsp;在Go语言中，string类型是一种相对特殊的基本数据类型。说其特殊是因为它也是引用了某一个底层数组而存在的。可以说，string类型的底层就是一个byte数组，但是这个数组是不能够通过单个字符修改方式进行访问或修改，在string的引用中，依旧无法对其进行修改。 </p><p>&emsp;&emsp;那么既然string的底层是byte数组，而切片底层也可以是byte数组，所以string和切片可以有一些异曲同工之妙，同时string字符串类型是可以进行切片操作的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> info <span class="keyword">string</span> = <span class="string">"Hello World"</span></span><br><span class="line"><span class="keyword">var</span> slice = info[:<span class="number">6</span>]</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们之前只通过裁剪的方式对数组进行操作，而上述的程序中是可以直接通过裁剪的方式对string字符串进行操作的，这也侧面反映出了string的核心就是一个数组。 </p><p>&emsp;&emsp;除此之外，字符串类型是一种常量，一旦定义初始化后就不可以进行修改了，在数组中，我们可以通过a[i] = 10的方式对数组中任意一个元素进行修改，但是在string类型中，我们不可以通过str[0] = ‘a’的方式进行修改。这个是常量的属性所规定的。 </p><p>&emsp;&emsp;但有些时候可能就会出现类似如下的需求：输入一个字符串后，需要对每一个字符进行操作，例如把所有的大写字母转换成小写字母（程序核心实现函数已在上面的代码中提及）。既然string类型是常量无法被修改，我们只能通过将其转换成为一个切片来操作，我们只举一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> info <span class="keyword">string</span> = <span class="string">"Hello World"</span></span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">byte</span> = []<span class="keyword">byte</span>(info)</span><br><span class="line">...</span><br><span class="line">info = <span class="keyword">string</span>(slice)</span><br><span class="line">fmt.Println(info)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述程序中，我们首先定义了一个字符串string，然后将其强转成为一个byte切片（如果字符串中含有中文，需要转换成为rune切片），接下来对切片进行某种处理后，我们再将切片强转回string类型，这个过程结束后才相当于对字符串中的某些元素进行了操作。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们集中讲解了slice切片中的两个函数：len函数与cap函数的含义以及注意事项，同时也讲解了当执行append操作后slice中len和cap发生的变化，以及底层数组发生的相应的改变。除此之外，我们还讲解了slice类型在程序编写的过程中需要注意的问题，最后我们讲解了string基本数据类型与slice引用类型的相互关系。 </p><p>&emsp;&emsp;在下一个小节中，我们将开始介绍Go语言中map的含义以及使用方式，并将map这种数据类型与数组、切片等数据类型相结合做出相对具体的讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-33-gt-切片使用细节&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-33-gt-切片使用细节&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;33&amp;gt; 切片使用细节&quot;&gt;&lt;/a&gt;G
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
