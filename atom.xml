<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>云钰的亭轩阁</title>
  
  <subtitle>Running water never goes stale, so you gotta just keep on flowing.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-01T12:02:44.614Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Devin DENG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;27&gt; 闭包、defer与作用域</title>
    <link href="http://yoursite.com/2020/03/01/27-%E9%97%AD%E5%8C%85%E3%80%81defer%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2020/03/01/27-%E9%97%AD%E5%8C%85%E3%80%81defer%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2020-03-01T12:01:39.000Z</published>
    <updated>2020-03-01T12:02:44.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-27-gt-闭包、defer与作用域"><a href="#Go语言从入门到放弃系列-lt-27-gt-闭包、defer与作用域" class="headerlink" title="Go语言从入门到放弃系列&lt;27&gt; 闭包、defer与作用域"></a>Go语言从入门到放弃系列&lt;27&gt; 闭包、defer与作用域</h2><p>&emsp;&emsp;在上一小节中，我们讲解了init函数与匿名函数的知识点，在这一小节中，我们会承接上一小节中的匿名函数的知识，进而引入这一小节的闭包的概念。介绍完闭包的概念后，我们再初步讲解作用域的几个细节以及defer关键字的用法。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>&emsp;&emsp;闭包是一种可以读取到其他函数内部变量的函数。在前几节我们讲到：程序在运行时会给每个函数分配栈内存，而不同内存之间的变量的地址是不同的，因此通过普通的方式是无法在一个函数中调用另一个函数内的局部变量的。而如果希望调用，则需要使用到闭包的概念。笼统而简单地讲，闭包就是一个函数与其需要的环境资源的集合体。 </p><p>&emsp;&emsp;在上一小节中，我们说到了匿名函数，也讲解了匿名函数赋给函数变量时的调用方式。同时我们也曾讲解过函数作为一个参数进行传递，同理，函数也可以作为另一个函数的返回值。我们在接下来的这个案例中就用到了函数作为返回值的情况。因此在读函数签名以及返回值时需要稍作注意。我们先讲解外层函数的签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的这个函数定义的含义为：有一个名字叫做adder的函数，这个函数没有参数，且返回值是另一个函数。返回值的函数是匿名的，且参数为一个整数，返回值为一个整数。相信这个不难理解。我们将函数写完：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        y++</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;函数定义我们已经讲解过了，我们分析函数体：首先在函数体中定义一个y变量且初始化其值为10，接下来我们返回一个匿名函数，在这个匿名函数的函数体中我们让y自增后，返回参数x与y的加和。接下来我们看主函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := adder()</span><br><span class="line">    fmt.Println(f(<span class="number">1</span>))</span><br><span class="line">    fmt.Println(f(<span class="number">2</span>))</span><br><span class="line">    fmt.Println(f(<span class="number">3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在主函数中，我们先调用adder函数，并将其返回的函数赋给f变量。然后我们通过f进行调用并参数传递。有人可能会猜测输出的三个值分别是12，13，和14。因为y等于10，然后y自增变成11，再加传入的1变成12，其他两个是同一个过程得到13和14。然而输出的结果是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这三个结果出现的原因其实是这样的：在adder函数中，局部变量y与其返回的匿名函数构成了一个闭包。在这个闭包中，y的变量相对于其匿名函数而言<strong>相当于</strong>是一个全局变量。因此函数内部修改值会直接影响到函数外的这个”全局变量”上。因此，第一输出为12是不需要解释的，我们跟踪一下第二个输出的过程，当我们再一次传入2的时候，y的值由于在第一次调用后已经自增了，所以y的初始值是11而不是10。因此再进入匿名函数后y已经自增变成了12，因此其结果输出为14。同理，在调用f(3)的时候，y的初始值经过了两次自增后变成12，进入函数后再自增是13，因此最后输出16。 </p><p>&emsp;&emsp;这个知识点其实只要理解了函数与其他变量的相关性就不会觉得难理解了，闭包的概念在其他的许多语言中都有或多或少的支持，例如：javascript、python、Java8等。接下来，我们做一个小案例来加强一下对闭包的理解： </p><p>&emsp;&emsp;首先指定一个文件的扩展名，例如png、txt等，再传入一个文件名，判断如果这个文件名是以这个扩展名为结尾则输出原串，否则输出文件名+扩展名，程序采用闭包完成。 </p><p>&emsp;&emsp;我们将这个案例套在上面的那段程序中，我们可以分析道：其核心是有两个函数，外层函数可以用一个变量接收传入的扩展名，匿名函数可以接收传入的文件名，并返回最终的结果，因此其函数构成可以写为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setExtension</span> <span class="params">(extension <span class="keyword">string</span>)</span> <span class="title">func</span> <span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们写函数体，内层匿名函数中我们采用strings包的HasSuffix函数来判断一个字符串是否以另一个字符串结尾：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setExtension</span><span class="params">(extension <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> strings.HasSuffix(name, extension) &#123;</span><br><span class="line">            <span class="keyword">return</span> name</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name + extension</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := setExtension(<span class="string">".png"</span>)</span><br><span class="line">    fmt.Println(f(<span class="string">"demo.png"</span>))</span><br><span class="line">    fmt.Println(f(<span class="string">"demo"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在主函数中我们采用了同样的调用方式，得到的结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">demo.png</span><br><span class="line">demo.png</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上就是闭包的说明，在实际开发中，其实闭包用到的不多，但是在资格考试等等却是一个重点与难点。当然能够用闭包完成的功能不用闭包是完全可以完成的。例如上述举的文件名和扩展名的例子，我们完全可以将文件名和扩展名作为两个参数传入到同一个函数中。闭包的优势就在与函数中可以调用其他函数中的变量，且能保存这个变量的现有的值，一旦没有这个需求，就不需要闭包了。</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>&emsp;&emsp;defer作为Go语言中的关键字，也是有十分广泛的作用的。它可以与init函数的作用相反，init函数是想在引入包或执行main函数之前完成某些初始化工作，defer则是在函数执行结束后进行关闭资源等等的收尾工作。例如在程序中打开文件，则需要在结尾处关闭文件，或连接数据库，进行查询过后需要释放连接，这些工作就可以在defer中使用。依旧，我们先举一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"第一条输出"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"第二条输出"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"第三条输出"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"第四条输出"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的这一段程序中，输出结果毫无疑问：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一条输出</span><br><span class="line">第二条输出</span><br><span class="line">第三条输出</span><br><span class="line">第四条输出</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在我们将其中的两条语句用defer进行修饰：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"第一条输出"</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"第二条输出"</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"第三条输出"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"第四条输出"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时其输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一条输出</span><br><span class="line">第四条输出</span><br><span class="line">第三条输出</span><br><span class="line">第二条输出</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述输出结果我们可以发现，defer的作用是将该语句延迟执行，我们将第二条和第三条都用defer修饰了，因此这两条会延迟到main函数执行结束后再执行，不仅如此，我们还可以发现，第二条输出与第三条输出的顺序是相反的。因此，在用defer修饰语句时，会将该语句压入<strong>栈</strong>中，我们姑且称之为defer栈。 </p><p>&emsp;&emsp;由于程序自上到下执行，先遇到了第二条输出，因此先压入栈中，然后才遇到了第三条输出，再压入栈中。当函数执行结束后，他们依次出栈，在栈顶的先出，在栈底的后出。我们再举一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"defer中的num:"</span>, num)</span><br><span class="line">    num++</span><br><span class="line">    fmt.Println(<span class="string">"main函数中的num:"</span>, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据上述的分析，我们可以知道，输出结果一定先是main函数中的num那句，然后才是defer中的num那句，现在问题是：输出时num的结果分别是多少。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main函数中的num: <span class="number">11</span></span><br><span class="line"><span class="keyword">defer</span>中的num: <span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以发现，尽管defer修饰的语句会最后再执行，但是其中所涉及到的值是不受后续程序影响的，换句话说在压入defer栈的时候，num的赋值就已经发生了。因此defer的作用不是仅仅将该语句简单地移动到程序的最后面，而是带有当时的数据环境的。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>&emsp;&emsp;作用域这个概念其实我们已经接触过很多次了，我们对它也是应该有一些了解了。我们之前所说的一个函数无法访问另一个函数的变量，其实就是作用域的问题。在这里我们简单地概述一下各个场景下作用域的用法。</p><h5 id="1-分支结构、循环结构中定义的变量"><a href="#1-分支结构、循环结构中定义的变量" class="headerlink" title="1. 分支结构、循环结构中定义的变量"></a>1. 分支结构、循环结构中定义的变量</h5><p>&emsp;&emsp;我们讲到在分支结构中是可以进行数据定义的，这个数据是只能够在分支结构中进行使用，一旦超出了其结构再使用，程序就会报错了，例如我们希望知道当跳出循环时，某个变量是多少：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span> ;i++ &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的这段程序是不行的，因为i这个变量是在for结构中定义的，出了这个大括号，就不能够再被访问了，如果我们希望访问这个i，就只能将i的定义提出到for结构之外：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因为此时的i变量的定义位置与使用它的位置处于同一个层级，因此是可以进行调用的。</p><h5 id="2-函数内部定义的变量"><a href="#2-函数内部定义的变量" class="headerlink" title="2. 函数内部定义的变量"></a>2. 函数内部定义的变量</h5><p>&emsp;&emsp;对于这种变量，我们可以称之为局部变量，局部变量顾名思义，只能在局部位置中使用，在其他的位置就无法使用了。这个问题我们之前就提及过了，这里我们就不做更多的讲解了。</p><h5 id="3-Go文件中定义的变量"><a href="#3-Go文件中定义的变量" class="headerlink" title="3. Go文件中定义的变量"></a>3. Go文件中定义的变量</h5><p>&emsp;&emsp;这个概念我们之前其实也提到过了，在Go文件中定义的变量被称之为全局变量，这种变量可以在整个Go文件中的任意一个函数中，任意一个位置使用。且在函数中对该变量进行修改会直接影响到该变量的值。</p><h4 id="整体规律"><a href="#整体规律" class="headerlink" title="整体规律"></a>整体规律</h4><p>&emsp;&emsp;在同一个Go文件中的变量定义中，我们可以总结出一条规律，即与变量定义位置同级以及下级的位置可以使用该变量，该位置的上级是不能使用的。换句话说，进入大括号可以使用，出了大括号就不能用了。</p><h4 id="包之间的变量调用"><a href="#包之间的变量调用" class="headerlink" title="包之间的变量调用"></a>包之间的变量调用</h4><p>&emsp;&emsp;假如一个包中的函数需要调用另一个包中的变量，则需要用包名.变量名的方式进行调用。且变量名的规则与函数名的规则是相同的：即首字母大写说明可以被其他包所使用，而首字母小写则只能够在本包中使用，否则会出现该变量无法导出的错误类型。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们集中讲解了闭包的概念、defer关键字的用法、以及变量作用域的规则。到这里对函数的知识的讲解就可以告一段落了，在下一小节中，我们将集中介绍几个Go语言中常用的字符串相关、日期相关的函数，对后期的编程可能会有所帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-27-gt-闭包、defer与作用域&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-27-gt-闭包、defer与作用域&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;27&amp;gt; 闭
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;26&gt; init函数与匿名函数</title>
    <link href="http://yoursite.com/2020/02/29/26-init%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/02/29/26-init%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</id>
    <published>2020-02-29T07:12:03.000Z</published>
    <updated>2020-02-29T07:13:26.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-26-gt-init函数与匿名函数"><a href="#Go语言从入门到放弃系列-lt-26-gt-init函数与匿名函数" class="headerlink" title="Go语言从入门到放弃系列&lt;26&gt; init函数与匿名函数"></a>Go语言从入门到放弃系列&lt;26&gt; init函数与匿名函数</h2><p>&emsp;&emsp;在很久之前我们曾说主函数是程序的入口且最先执行，当时我们在后面附了一句这个说法不是十分正确。在这个小节中，我们将介绍一个在主函数执行之前的函数:init函数，同时我们也会对匿名函数做出一定的讲解。整体来说，这个小节的知识点难度不大，读者可以很轻松地领会。</p><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>&emsp;&emsp;已经说明了main函数可以不是最先执行，那么先于main函数执行的有：全局变量的定义，以及init函数。同时当我们使用import命令来引入其他的包的过程中，执行顺序的先后就会相对更复杂一点，我们由浅入深开始讲解。</p><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>&emsp;&emsp;在之前的所有的案例中，我们所定义的变量可以说都是局部变量，可以理解为都是在函数内部定义的变量。这种变量的特点是只能在本函数，甚至本语句块之中可以使用。一旦超出了这个使用范围就会报出变量未定义的错误。全局变量与局部变量不同，他们是在包之内、函数之外定义的，因此这些变量或常量是可以在本包的任何一个函数中使用，我们举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNum</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    getNum()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很显然，这段代码一定是错误的，我们在getNum函数中想要调用main函数中的num变量，由于num是一个main函数中的局部变量，因此只可以在main函数中使用。现在我们将num这个变量改为全局变量，再从两个函数中分别使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNum</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num += <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">    getNum()</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的这段代码中，我们将num的定义放在了函数的外面，这个变量就成为了全局变量，在各个函数中均可以使用，不仅如此，在getNum函数中，我们对num变量的值进行了修改，在main函数进行输出，我们可以发现两次输出结果是不相同的。输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><h4 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h4><p>&emsp;&emsp;经过对上述全局变量的使用的介绍，我们可以发现：全局变量的定义是先于main函数执行的，因为这个定义过程并不在main中，而main函数使用这个变量却没有问题。这里我们再介绍一个先于main函数执行的函数，init函数。 </p><p>&emsp;&emsp;在一些情况下，我们希望在真正进行逻辑操作时，首先对程序进行一定的初始化操作。例如多个人进行协同编程时，每个人都有自己的分工，但是每个人所需要提交的代码只是逻辑部分，数据定义部分可能是通过网络接收到的数据。当开发者在测试环境下希望初始化一些数据，且提交时不需要将代码分离时，init函数可以是一个比较合适的选择。我们通过案例来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"init()函数执行了"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"main()函数执行了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们对上述的这段程序进行编译运行，会发现”init()函数执行了”这个字符串先被输出出来，而“main()函数执行了”这个字符串是后被输出来的。因此我们可以说，init函数是先于main函数被执行的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init()函数执行了</span><br><span class="line">main()函数执行了</span><br></pre></td></tr></table></figure><h4 id="全局变量定义与init函数先后关系"><a href="#全局变量定义与init函数先后关系" class="headerlink" title="全局变量定义与init函数先后关系"></a>全局变量定义与init函数先后关系</h4><p>&emsp;&emsp;既然两种操作均先于main函数，我们就需要对这两种操作顺序进行排序。我们此时可以想到，我们可能在main函数中使用全局变量，我们当然也有需求在init函数中使用全局变量，因此全局变量的定义也是早于init函数的，我们通过下面这个例子来验证这个关系：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span> = initNum()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initNum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"为全局变量赋值"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"init()函数执行了"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"main()函数执行了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们定义了一个全局变量num，且通过initNum这个函数进行初始化，在这个函数中我们输出了为全局变量赋值这个字符串，我们只需要看”为全局变量赋值”这个字符串和”init()函数执行了”这个字符串的先后关系，就可以明确其顺序了。执行结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为全局变量赋值</span><br><span class="line">init()函数执行了</span><br><span class="line">main()函数执行了</span><br></pre></td></tr></table></figure><h4 id="import其他包时的执行顺序"><a href="#import其他包时的执行顺序" class="headerlink" title="import其他包时的执行顺序"></a>import其他包时的执行顺序</h4><p>&emsp;&emsp;现在我们对刚刚的问题进行扩展，如果我们希望引入一个包，且使用这个包中的变量，那么这两个包中两个全局变量定义、两个init函数、以及一个main函数的执行顺序又是什么呢，我们通过下面这个例子来讲解。 </p><p>&emsp;&emsp;在这个例子中我们依旧采取demo包和test包，文件系统与对包的讲解的那一小节是相同的，即src下两个文件夹，每个文件夹都有一个go文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">demo文件夹下main包：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">package</span> main</span><br><span class="line">    <span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"test"</span></span><br><span class="line">    )  </span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = initNum()</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initNum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"main包中全局变量赋值"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"main包中init函数执行"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"main包中main函数执行了"</span>)</span><br><span class="line">        fmt.Println(test.Num)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">test文件下test包：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">package</span> test</span><br><span class="line">    <span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line">    <span class="keyword">var</span> Num <span class="keyword">int</span> = setNum()</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setNum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"test包中的全局变量赋值"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"test包中的init函数执行"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的这段程序中出现了我们所说的五个全部的过程，我们根据执行结果可以判断出在引用包的时候各个操作的执行先后顺序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test包中的全局变量赋值</span><br><span class="line">test包中的init函数执行</span><br><span class="line">main包中全局变量赋值</span><br><span class="line">main包中init函数执行</span><br><span class="line">main包中main函数执行了</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上述的执行结果，我们可以发现：在引入其他的包的时候，最先执行的是其他包中的全局变量定义，其次是其他包的init函数，然后才是本包中的全局变量定义，init函数以及main函数。相应地，我们根据这个规律进行扩展，main包中引用了A包和B包、main包中引用了A包，同时A包中引用了B包： </p><p><img src="/2020/02/29/26-init%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/1.png" alt></p><p>&emsp;&emsp;一个包调用多个包的情况</p><p><img src="/2020/02/29/26-init%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/2.png" alt></p><p>&emsp;&emsp;多个包相调用的情况</p><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><h4 id="一次性调用"><a href="#一次性调用" class="headerlink" title="一次性调用"></a>一次性调用</h4><p>&emsp;&emsp;匿名函数的思想其实十分的简单，即定义一个没有名字的函数，这个函数之所以不需要名字，是因为我们希望它只被调用一次，且是函数定义时直接调用。调用过后这个函数就被遗弃再也不调用了。这个语言上的特点在很多种语言中均存在，但是用到的不是很多。在Android开发过程中用到的比较多的也就是匿名内部类，因此这个知识点稍作了解即可，其难度也不是很大。我们看下面的案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result := <span class="function"><span class="keyword">func</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2</span><br><span class="line">    &#125;(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">    fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将上述的代码与正常的函数相比较，我们可以发现如下几个特点：func后直接加参数列表，即没有函数名。函数体与正常函数完全一致。在函数定义过后就直接传入相应的参数后使用，通过变量接收其结果。在后续的程序中只能使用其结果而无法再调用这个函数。</p><h4 id="匿名函数赋给函数变量"><a href="#匿名函数赋给函数变量" class="headerlink" title="匿名函数赋给函数变量"></a>匿名函数赋给函数变量</h4><p>&emsp;&emsp;这个用法相比而言就与普通函数没有什么区别了，在前几节中我们讲到函数可以作为一种数据类型也可以作为函数参数进行传递。因此，匿名函数当然也可以被赋值给函数变量，案例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myFunc := <span class="function"><span class="keyword">func</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(myFunc(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的这段程序中，我们将一个匿名函数赋给了myFunc这个函数变量，且在后续的程序中通过myFunc这个变量进行了函数的调用。由于我们可以通过变量进行调用，因此这个函数是可以在后续被调用的，因此说与正常函数没有什么区别。不过这里需要注意的是，我们是通过变量进行函数调用，而不是通过函数名进行调用，尽管这两者在使用上几乎没有任何的区别。</p><h4 id="匿名函数赋给全局函数变量"><a href="#匿名函数赋给全局函数变量" class="headerlink" title="匿名函数赋给全局函数变量"></a>匿名函数赋给全局函数变量</h4><p>&emsp;&emsp;这个小标题就更容易理解了，既然变量可以有全局变量，那么函数变量当然可以是全局变量了。这个时候，该函数变量可以被本包中的所有函数使用，也就意味着该函数可以被任意一个函数调用。相比于上一段程序，myFunc函数的作用域更大了。我们不详细说明了，只举一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">var</span> myFun = <span class="function"><span class="keyword">func</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(myFun(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们集中讲解了全局变量的含义与用法、init函数的执行顺序、以及匿名函数的三种使用方式。整体上而言，这个小节的知识点相对简单，且init函数用到的情况远比匿名函数多。对于init函数而言， 由于是编译器调用的函数，因此函数名、参数列表为空、无返回值这三个条件必须满足。而匿名函数用到的地方相对较少，能做到在真正遇到的时候想起匿名函数的概念与调用方式即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-26-gt-init函数与匿名函数&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-26-gt-init函数与匿名函数&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;26&amp;gt; ini
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;25&gt; 函数使用细节&lt;二&gt;</title>
    <link href="http://yoursite.com/2020/02/28/25-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/02/28/25-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%BA%8C/</id>
    <published>2020-02-28T06:02:24.000Z</published>
    <updated>2020-02-28T06:03:29.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-25-gt-函数使用细节-lt-二-gt"><a href="#Go语言从入门到放弃系列-lt-25-gt-函数使用细节-lt-二-gt" class="headerlink" title="Go语言从入门到放弃系列&lt;25&gt; 函数使用细节&lt;二&gt;"></a>Go语言从入门到放弃系列&lt;25&gt; 函数使用细节&lt;二&gt;</h2><p>&emsp;&emsp;在上一小节中，我们讲解了函数的底层调用机制以及函数的嵌套调用、递归调用等知识点，同时也对Go语言中函数的使用细节做了初步的介绍。在这一小节中，我们将承接上一小节未能完全讲解完的使用细节进行相对深入的讲解。在本小节中讲解到的各个知识点在日常开发中也会经常使用到。</p><h5 id="1-基本数据类型和数组在函数参数传递中是以值形式传递，因此普通传递方式不能改变调用者栈区内的值。"><a href="#1-基本数据类型和数组在函数参数传递中是以值形式传递，因此普通传递方式不能改变调用者栈区内的值。" class="headerlink" title="1. 基本数据类型和数组在函数参数传递中是以值形式传递，因此普通传递方式不能改变调用者栈区内的值。"></a>1. 基本数据类型和数组在函数参数传递中是以值形式传递，因此普通传递方式不能改变调用者栈区内的值。</h5><p>&emsp;&emsp;根据底层调用的图解，我们可以得知在函数调用的过程中，栈区会开辟一段新的内存用来处理函数的各个操作。同时调用者传入的参数也是通过数值的拷贝进入到被调用者的，因此调用者内部的变量与函数中的变量是相互独立且不相互影响的。我们通过程序举一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temp <span class="keyword">int</span> = num1</span><br><span class="line">    num1 = num2</span><br><span class="line">    num2 = temp</span><br><span class="line">    fmt.Println(<span class="string">"In the swap function, num1 is"</span>, num1, <span class="string">"num2 is"</span>, num2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">20</span></span><br><span class="line">    swap(num1, num2)</span><br><span class="line">    fmt.Println(<span class="string">"In the main function, num1 is"</span>, num1, <span class="string">"num2 is"</span>, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的这段程序中，我们在主函数中定义了两个整数变量并传入到swap函数中，swap函数的函数体将传入的两个参数值相互交换，并且将交换后的值输出。在swap函数执行过后返回主函数，我们再次输出主函数中的两个变量，我们的到的执行结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In the swap function, num1 is <span class="number">20</span> num2 is <span class="number">10</span></span><br><span class="line">In the main function, num1 is <span class="number">10</span> num2 is <span class="number">20</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上述结果可以发现主函数中定义的变量并没有因为函数中的交换操作而受到任何的影响，因此值类型通过参数直接进行传递时，调用者是不会受到任何影响的。</p><h5 id="2-如果希望在函数中改变值类型，可以通过指针形式进行传递。（类似于引用）"><a href="#2-如果希望在函数中改变值类型，可以通过指针形式进行传递。（类似于引用）" class="headerlink" title="2. 如果希望在函数中改变值类型，可以通过指针形式进行传递。（类似于引用）"></a>2. 如果希望在函数中改变值类型，可以通过指针形式进行传递。（类似于引用）</h5><p>&emsp;&emsp;在这里，我们首先简要回顾一下指针的几个相关知识点：首先，指针本质就是内存地址，可以指代的是变量在内存中的物理地址，第二，*在变量定义的过程中代表该变量为指针变量，在变量的使用过程中代表取出该地址中的值，第三，&amp;符号在使用过程中代表取出该变量的物理地址。如果这三个概念没有完全想起来，可以返回到对应小节进行一些了解。 </p><p>&emsp;&emsp;现在我们可以通过这几个运算符进行指针传递了，我们依旧采用上述的代码段进行演示，同时需要注意一下下面的这段程序与值传递时所用到的程序的几个细微的差别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(num1, num2 *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temp <span class="keyword">int</span> = *num1</span><br><span class="line">    *num1 = *num2</span><br><span class="line">    *num2 = temp</span><br><span class="line">    fmt.Println(<span class="string">"In the swap function, num1 is"</span>, *num1, <span class="string">"num2 is"</span>, *num2)</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">20</span></span><br><span class="line">    swap(&amp;num1, &amp;num2)</span><br><span class="line">    fmt.Println(<span class="string">"In the main function, num1 is"</span>, num1, <span class="string">"num2 is"</span>, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们集中说明一下差别：首先在swap函数定义中，我们定义的两个形式参数为整数类型的<strong>指针</strong>，在函数体中对num1和num2的使用是通过获取指针所指向的值的方式进行的。在主函数中，调用swap函数的时候传入的实际参数是主函数中定义的num1和num2的物理地址。这段程序的运行结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In the swap function, num1 is <span class="number">20</span> num2 is <span class="number">10</span></span><br><span class="line">In the main function, num1 is <span class="number">20</span> num2 is <span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这里我们可以发现，函数中的交换数据的行为直接影响到了主函数中变量的值，这是因为参数传递的是地址而不是值。我们举一个易于理解的例子，我们将参数看作为一台电视机，值传递的意思就是我们保持这台电视机不动，买了另外一台同样型号电视机送给其他人，遥控器不同，两台电视机互相不影响。传递指针的时候，相当于电视机不同，我们又额外配了一个遥控器，并把这个新配的遥控器送给了其他人。当其他人通过遥控器变换频道的时候，唯一的电视机会进行响应。我们通过一个图解进行解释：<br> <img src="/2020/02/28/25-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%BA%8C/1.png" alt></p><h5 id="3-函数可以作为一种数据类型，也可以作为参数进行传递"><a href="#3-函数可以作为一种数据类型，也可以作为参数进行传递" class="headerlink" title="3. 函数可以作为一种数据类型，也可以作为参数进行传递"></a>3. 函数可以作为一种数据类型，也可以作为参数进行传递</h5><p>&emsp;&emsp;这个特性看起来似乎比较难以理解，因为这个点不论是在Go语言中还是在其他语言中都不是十分常用。我在这里也就是介绍一下函数作为一种数据类型的使用方式，当然这个知识点在后面讲解闭包的概念的时候还会被提及，因此在这个小节中需要对这个特性有所了解。我们首先看一段程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">20</span></span><br><span class="line">    funcVar := getSum</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, funcVar)</span><br><span class="line">    fmt.Println(funcVar(num1, num2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，getSum函数与之前的代码是相同的，不同点在于主函数中funcVar := getSum这里，这条语句的意思便是将getSum函数交个了一个名为funcVar的函数型变量。并且在后面的函数调用时就直接使用funcVar变量即可。我们可以简单地将其认为把一个函数的调用过程拆分成了两个：为函数变量赋值、通过该变量调用。程序的结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;讲解完了函数作为数据类型后，我们接下来讲解函数作为参数进行传递的过程。正如我们所知，在函数定义过程中，我们需要提供输入参数数数量和数据类型，因此当函数作为参数的时候也是需要指明参数类型的。对于一类函数而言，函数的签名（参数列表和返回值列表）可以唯一确定这一类的函数，因此当函数作为参数时，所需要提供的类型就是这样。我们看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testGetSum</span><span class="params">(testVar <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">num1</span> <span class="title">int</span>, <span class="title">num2</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> testVar(num1, num2)</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">20</span></span><br><span class="line">    fmt.Println(testGetSum(getSum, num1, num2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面的这段程序中，我们在主函数中调用了testGetSum函数，同时testGetSum函数的形式参数中就存在着一个func类型的参数。当调用的时候，我们传入的实际参数就是getSum函数的函数名，这也验证了函数是可以作为参数的。同时我们也可以向下联想到：但凡满足于两个整数参数且返回值为整数的所有函数均可以传入到testGetSum函数中，因为形式参数并没有指定调用哪个函数，而是根据输入的函数名而定的。</p><h5 id="4-Go语言中函数支持可变参数列表"><a href="#4-Go语言中函数支持可变参数列表" class="headerlink" title="4. Go语言中函数支持可变参数列表"></a>4. Go语言中函数支持可变参数列表</h5><p>&emsp;&emsp;由于Go语言中不支持函数的重载，因此当出现希望用同一个函数名来但具备不同参数列表的需求时候，就会比较困难。因此我们在这里引出对可变参数的讲解。首先我们看一个需求：写出一个名为getSum的函数，要求传入几个值就计算几个值的和。如果采用原来的方式，我们可能需要写多个函数，且函数名还不可以一致。当然这个需求可以通过传入切片来完成，但是目前我们还没有介绍到切片，就先介绍可变参数了。我们先看如下的一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(nums ...<span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        result += nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(getSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们从上述程序中可以发现，在getSum函数的参数列表中，我们使用了”…”的方式来定义可变参数。其使用规则为：变量名会被视为一个切片（这个我们会和数组一起讲解），且被”…”所修饰的类型为该切片中所具有数据的类型，在使用的时候可以通过nums[i]来表示传入的参数中的第i个值。通过解释后这个函数的意思就显而易见了：即遍历每一个传入的参数，将该参数累加到result中，最后返回。在主函数调用的过程中，我们传入了5个参数作为测试，当然也可以传入任意个数的参数。 </p><p>&emsp;&emsp;在使用可变参数的时候，我们需要注意以下几个问题： </p><ol><li>一个函数中只能出现一个可变参数，不可以出现多个，例如：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(nums ...<span class="keyword">int</span>, strs ...<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        fmt.Println(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(strs); j++ &#123;</span><br><span class="line">        fmt.Println(strs[j])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们定义getSum函数的参数列表时定义了两个可变参数，分别遍历输出，但是这段程序在编译时会发生错误，其错误类型为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">can only use ... with final parameter in list</span><br><span class="line">cannot use <span class="string">"Hello"</span> (<span class="keyword">type</span> <span class="keyword">string</span>) as <span class="keyword">type</span> <span class="keyword">int</span> in argument to getSum</span><br></pre></td></tr></table></figure><ol start="2"><li><p>参数列表中可以出现正常参数与可变参数混用的情况，但是可变参数必须要放在参数列表的最后面。 </p><p>&emsp;&emsp;编译器当看到可变参数后，会将在这之后的所有的参数均看做为可变参数的一部分，所以可变参数必须在最后，其前面有任何的普通参数均没有任何问题，我们举几个例子：</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(nums ...<span class="keyword">int</span>, extra <span class="keyword">int</span>)</span>    //错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(extra <span class="keyword">int</span>, nums ...<span class="keyword">int</span>)</span>    //正确</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(extra <span class="keyword">int</span>, str <span class="keyword">string</span>, nums ...<span class="keyword">int</span>)</span>    //正确</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(extra <span class="keyword">int</span>, nums ...<span class="keyword">int</span>, str <span class="keyword">string</span>)</span>    //错误</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们继续讲解了Go语言中函数的四个使用细节，分别为函数的两种参数传递方式，可变参数列表，和函数作为变量与参数。在下一小节中，我们将会针对init函数、匿名函数、闭包特点以及defer的使用进行详细的讲解，也会部分运用到这个小节的知识点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-25-gt-函数使用细节-lt-二-gt&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-25-gt-函数使用细节-lt-二-gt&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;25&amp;g
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;24&gt; 函数使用细节&lt;一&gt;</title>
    <link href="http://yoursite.com/2020/02/27/24-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%B8%80/"/>
    <id>http://yoursite.com/2020/02/27/24-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%B8%80/</id>
    <published>2020-02-27T12:52:08.000Z</published>
    <updated>2020-02-27T12:52:50.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-24-gt-函数使用细节-lt-一-gt"><a href="#Go语言从入门到放弃系列-lt-24-gt-函数使用细节-lt-一-gt" class="headerlink" title="Go语言从入门到放弃系列&lt;24&gt; 函数使用细节&lt;一&gt;"></a>Go语言从入门到放弃系列&lt;24&gt; 函数使用细节&lt;一&gt;</h2><p>&emsp;&emsp;在上一小节中，我们集中讲述了函数在调用过程中的底层实现，以及根据其底层实现方式引出了函数的嵌套调用以及递归调用两个知识点。在函数的调用过程中，被调用的函数会在栈区内存中得到分配，且当函数执行结束后，该段内存会被回收无法再使用。可以说，在前两节中均没有介绍到函数在定义以及使用时候的种种细节，在这个小节中，我们将针对这些细节进行讲解。</p><h3 id="无返回值无参数函数"><a href="#无返回值无参数函数" class="headerlink" title="无返回值无参数函数"></a>无返回值无参数函数</h3><p>&emsp;&emsp;这种模式的函数是相比而言最为简单的函数了，这种函数与其他的函数之间基本没有任何的关联。除了被调用之外，这种函数既不需要其他程序向其输入一些值，也不需要这个函数返回什么值。比如说，在进行开发的时候往往会出现列表选项界面，来询问用户想选取哪个功能。这个列表的展现工作就可能是无参数、无返回值的，只需要将写好的字符串输出出来，具体用户输入了什么可能会在其他函数中获取。其定义方式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">()</span></span> &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们举个例子，假如有这样一种需求：用户选择了列表项中的一个，且程序完成了对应的功能之后，这个列表项再次出现以供用户来选择。此时代码可以如下来写（伪代码）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        printMenu()</span><br><span class="line">        <span class="keyword">var</span> choice <span class="keyword">int</span> </span><br><span class="line">        fmt.Scanln( &amp;choice )</span><br><span class="line">        <span class="keyword">switch</span> choice &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMenu</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"欢迎进入XXX管理系统"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"1.登录系统"</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的一段伪代码中，我们可以发现printMenu函数的作用只是向屏幕输出一些字符串。在主函数中每次循环的起始位置都要输出一次这个列表。这个列表不包含其他的例如输入验证、进入不同模块的任何的作用。其函数执行也不会对main函数中任何一个值产生影响。可以说，无参数、无返回值的函数在程序开发中其实还是比较常见的。</p><h3 id="有参数无返回值函数"><a href="#有参数无返回值函数" class="headerlink" title="有参数无返回值函数"></a>有参数无返回值函数</h3><p>&emsp;&emsp;虽说无参无返回值在程序中比较常见，但是这种函数相比而言还是少了些许的交互性。一个函数和其他程序完全没有关系毕竟还是少数，因此有参数的函数是需要掌握的。例如我们希望通过一个函数计算两个整数的加和并输出，但是这个加和的值在主函数中并不需要。这种函数的定义格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数列表)</span></span> &#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个使用方式的其他部分与无参均相同，只是多了一个参数列表。既然说起是列表，那么这个参数的个数可以是多个。现在我们站在函数的角度来看问题，假如我们需要接收一些数据，我们不仅需要知道要接收多少个数据，还需要知道每个数据的数据类型是什么。因此在参数列表中，我们要需要对每一个形式参数都指明其类型。在这里我们多举几个例子： </p><ol><li>输入一个整数：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span> <span class="params">(num1 <span class="keyword">int</span>)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>输入两个不同类型的数据，例如num1为整数，num2为浮点数：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span> <span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">float32</span>)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>当传入的多个参数数据类型相同时，可以简写，例如传入两个整数：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span> <span class="params">(num1 <span class="keyword">int</span> , num2 <span class="keyword">int</span>)</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span> <span class="params">(num1,num2 <span class="keyword">int</span>)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>最后举一个多个参数的例子，传入两个整数，两个浮点型以及一个字符串</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span> <span class="params">(num1, num2 <span class="keyword">int</span>, num3, num4 <span class="keyword">float32</span>, info <span class="keyword">string</span>)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p> &emsp;&emsp;这里需要注意的是，参数列表中出现的各个变量在函数体中均可以直接使用而无需定义，因为在函数的调用过程中，这些变量已经定义好了，且这些变量的值也已经赋好了。例如求两个整数的和：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addNum</span> <span class="params">(num1, num2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(num1 + num2)          <span class="comment">//num1和num2无需再定义，直接使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有返回值的函数"><a href="#有返回值的函数" class="headerlink" title="有返回值的函数"></a>有返回值的函数</h3><p>&emsp;&emsp;函数的返回值的作用是将函数中的某个或某些值再反过来赋给调用者，否则当函数执行结束后，该段内存就会被释放且无法找到了。我们可以理解为参数列表的作用是调用者将数据传给函数的，返回值是将数据返回赋给调用者的。此时函数的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名 <span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span> &#123;</span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Go语言中，我们更习惯于将其称之为返回值列表，而在其他的函数中我们只会说返回值。这是因为在Go语言中是支持返回多个值的，这个特性在其他的语言中很少见。当然，此时我们站在调用者的角度来看，当有函数传数据给我们的时候，我们依旧需要知道有多少个数据，且每种数据是什么类型。因此返回值列表的写法与参数列表的写法也就如出一辙了。在需要返回的地方，用return关键字返回相应的变量。此处有些需要注意的几个点： </p><ol><li>当只有一个返回值时候，我们可以将返回值列表中的括号省略，例如：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span> <span class="params">(num1 <span class="keyword">int</span> ,num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的函数中，我们希望返回的是一个整数，在函数体中我们将两个整数相加之后进行返回。</p><ol start="2"><li>当函数具备多个返回值的时候，返回值列表的括号不可以省略，且return关键字后面的变量数需要相同，且顺序相同。例如我们对函数输入两个整数，然后返回两个数的和和差：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSumAndSub</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2, num1 - num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line">    c, d := getSumAndSub(a, b)</span><br><span class="line">    fmt.Println(c, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>返回值列表可以与参数列表相似，以变量-类型形式定义，此时return关键字可以直接返回对应的变量，例如：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSumAndSum</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span><span class="params">(sum <span class="keyword">int</span>, sub <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    sum = num1 + num2</span><br><span class="line">    sub = num1 - num2</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这种定义方式中，与参数列表相似，返回值列表中定义的变量也是可以直接使用的，同时在return的时候，默认就将返回值列表中的变量全部按顺序返回。</p><h3 id="函数的注意事项-lt-一-gt"><a href="#函数的注意事项-lt-一-gt" class="headerlink" title="函数的注意事项&lt;一&gt;"></a>函数的注意事项&lt;一&gt;</h3><p>&emsp;&emsp;在明确了几种函数的定义方式之后，我们对函数在使用的过程中可能出现的问题进行详细地讲解，在日常开发中可能会遇到类似的情况。同时接下来所列举的可能在前几节中提及过，我们就再一次地总结一下。 </p><ol><li><p>函数的命名规范遵循标识符的命名规范，首字母不可以是数字，大小写敏感。且函数名的首字母大写则可以被本包和其他包调用，相当于是public的，当函数名的首字母小写时，则只能在本包（文件夹）下使用，类似于private的属性。 </p><p>&emsp;&emsp;我们在对包的使用那一节所举的例子中，我们特殊地用括号强调了那个函数的首字母大写的规范，这样在main包中才可以调用到test包中方法，读者可以自行将函数名的首字母改为小写，然后看此时会报出什么错误。 </p></li><li><p>函数中定义的变量是局部的，在函数外不生效，我们在底层原理的那一节可以知道，当调用函数的时候是另外分配独立的空间的，两段空间基本没有关联，因此函数内部定义的变量在函数外是无法访问的。例如：</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo()</span><br><span class="line">    fmt.Println(num)    <span class="comment">//此处调用了demo函数中的num，会编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Go语言不支持函数的重载，换句话说两个函数的函数名相同但是参数列表不相同是不可以的，我们可以直接记成在同一个包中不可以出现同名的函数。例如：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span></span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(num1, num2, num3 <span class="keyword">int</span>)</span></span>&#123;...&#125;</span><br><span class="line">程序会报编译错误</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;由于篇幅的原因，在这个小节中我们只针对三个函数的细节进行了说明，在下一小节中，我们会对剩余的一些特性与注意事项进行讲解。在这一小节中，我们分别针对是否有参数、是否有返回值的函数定义方式进行了讨论，并对可能出现的几种参数列表与返回值列表的样式进行了讲解。下一个小节中，我们不仅会讲解剩余的细节，我们会对值传递与引用传递进行说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-24-gt-函数使用细节-lt-一-gt&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-24-gt-函数使用细节-lt-一-gt&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;24&amp;g
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;23&gt; 函数的调用机制与嵌套调用</title>
    <link href="http://yoursite.com/2020/02/26/23-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/26/23-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8/</id>
    <published>2020-02-26T09:13:19.000Z</published>
    <updated>2020-02-26T09:14:24.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-23-gt-函数的调用机制与嵌套调用"><a href="#Go语言从入门到放弃系列-lt-23-gt-函数的调用机制与嵌套调用" class="headerlink" title="Go语言从入门到放弃系列&lt;23&gt; 函数的调用机制与嵌套调用"></a>Go语言从入门到放弃系列&lt;23&gt; 函数的调用机制与嵌套调用</h2><p>&emsp;&emsp;在上一节中，我们讲解了函数的引入过程，并且也讲解了函数的最基础的定义方式与使用方法。同时也对模块化编程中的包的使用规则进行了阐述。在这一小节中，我们会简要地讲解Go语言中函数调用过程中的底层实现方式，进而通过对这个方式的讲解对函数的嵌套调用与递归调用进行解释说明。</p><h3 id="函数调用的底层实现"><a href="#函数调用的底层实现" class="headerlink" title="函数调用的底层实现"></a>函数调用的底层实现</h3><p>&emsp;&emsp;在讲解这个底层实现之前，我们先明确几个概念：大部分的数据存储等都发生在内存中，且计算都发生在运算器中。且在计算机在逻辑上将内存分为四个部分，分别是栈区，堆区，常量区，以及代码区。这一部分知识可以再计算机原理中得到深入的讲解，在这里我们只是简要地提一下其作用。 </p><p>&emsp;&emsp;栈的特点是先入后出，例如我们向一个杯子中倒入沙土，最先倒进去的沙土在最下面，因此当倒出的时候是最后才被倒出的（如果有机会我会在数据结构部分说起这个知识点）。当程序对基本数据进行创建时，即之前我们所提到的值类型进行创建时，创建的位置处在栈区。不仅是基本数据，函数类型的调用也会在栈区中发生。堆区一般存储的都是引用类型，例如我们后面会学到的切片等数据类型。代码区当然存储的就是可执行的机器码本身，常量区存储的是程序中定义的全局变量与静态变量等。但是这个分类并不是百分百准确的，在Go语言的底层中，存在着内存逃逸的现象，即基本数据类型的变量可能会逃逸到堆区，引用类型也可能会被创建在栈区等。 </p><p>&emsp;&emsp;当然上述的说法如果实在不懂也没有太大的问题，这个对于顶层程序的编写与理解代码的执行没有特别大的相关性，但是如果理解了可能会对日后程序的书写有所帮助。现在我们针对下述的代码进行内存上的分析（我们便只分析栈区，而不看代码区了）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMax</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="params">(max <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num1 &gt;= num2 &#123;</span><br><span class="line">        max = num1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max = num2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num1 <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> num2 <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">    fmt.Println(num1, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于这一段程序相信不需要我过多的进行解释了，需要说明的是，我们定义了findMax函数，但是我们并没有调用这个函数。我们只是在主函数中定义了两个变量并将这个两个变量输出来。这时，栈区内存中与findMax函数是没有任何关系的，我们采用图解的方式来表示： </p><p><img src="/2020/02/26/23-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8/1.png" alt></p><p>&emsp;&emsp;从这个图解中我们可以发现，当程序开始执行的时候，计算机会在栈区内存中为main函数分配一段空间，在这段空间中又分配有两个变量，分别是num1和num2。接下来对这两个整数的输出也发生在main函数中，因此也相当于是在main栈区中提取数据。 </p><p>&emsp;&emsp;接下来我们上述的代码进行修改，在函数中我们将max输出，在main函数中调用findMax函数，修改后的代码如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMax</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="params">(max <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num1 &gt;= num2 &#123;</span><br><span class="line">        max = num1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max = num2</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"在函数中"</span>, max)</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num1 <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> num2 <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">    fmt.Println(<span class="string">"调用函数前"</span>)</span><br><span class="line">    findMax(num1, num2)</span><br><span class="line">    fmt.Println(<span class="string">"调用函数后"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，我们可以发现，此时main函数调用到了findMax函数，那么程序在调用函数的时候内存就会与findMax函数相关了。当程序运行到fmt.Println(“调用函数前”)的时候，内存图依旧与上述的图是一致的，因为还没有调用到findMax函数。 </p><p>&emsp;&emsp;当程序运行到findMax函数的时候，内存中就需要关联这个函数了，在这个函数中存在三个变量，分别是num1、num2、以及max，当程序刚进入到函数的定义部分时，此时的栈区内存图如下所示： </p><p><img src="/2020/02/26/23-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8/2.png" alt></p><p>&emsp;&emsp;我们可以发现当调用到其他函数的时候，编译器会为这个函数分配一块独立的内存，且这段内存中存在着自己三个变量。从这个图中我们也可以发现，findMax栈区所定义的三个变量与main栈区定义的两个变量是没有任何关系的，只是说我们将main栈区的两个变量的值拷贝给了findMax栈区的两个变量。这两个栈区的变量在内存中的地址是不同的，读者可以通过分别输出&amp;num1的方式进行验证。 </p><p>&emsp;&emsp;程序继续向下执行，当执行到函数中的return的时候，此时findMax栈区中的max值已然被得到，且在控制台中也输出了相应的”在函数中 20”。此时程序将会从findMax函数中跳转回main函数，当跳转的时候，在栈区内存中又会发生一件事情：</p><p><img src="/2020/02/26/23-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8/3.png" alt></p><p>&emsp;&emsp;通过这个图我们可以得到一个结论，当一个函数被执行完的时候，分配给这个函数的栈区内存会被回收释放，被释放后的这段内存可以再被分配给其他的函数等。那么可以想到的是，当主函数执行结束后，main函数的栈区内存也会被释放掉。 </p><p>&emsp;&emsp;从这段过程中，我们也可以侧面理解栈的含义：在内存分配的过程中，先分配了main函数的栈区，然后再分配的findMax函数栈区；当函数执行结束进行内存释放的过程中，先是findMax函数内存被释放，然后才是main函数栈区内存被释放。这也体现了先入后出的栈的含义。</p><h3 id="函数的嵌套调用"><a href="#函数的嵌套调用" class="headerlink" title="函数的嵌套调用"></a>函数的嵌套调用</h3><p>&emsp;&emsp;明白了函数的调用的底层含义之后，我们可以对函数的嵌套调用进行讲解。我们依旧类比于分支结构和循环结构的嵌套使用，我们可以得出一个结论：函数的嵌套调用就是在一个函数的函数体中调用了另一个函数。其实话说回来，我们在main函数中调用了findMax函数其实就是一种嵌套调用。 </p><p>&emsp;&emsp;在嵌套调用的过程中（我们依旧以main函数调用findMax函数为例），当main函数执行到调用findMax函数的那条语句时，main函数的执行流程会被阻塞在那条语句上，程序指针跳转到findMax函数中进行顺序执行。当findMax函数的函数体被执行完之后，程序指针又跳回了刚才被阻塞的地方进行继续执行。我们通过上述程序的输出结果可知：</p><pre><code>输出：    调用函数前    在函数中 20    调用函数后</code></pre><p>&emsp;&emsp;通过这个输出结果的顺序，我们可以发现：是先执行了”调用函数前”的那个部分， 然后main函数被阻塞，进入了findMax函数输出了”在函数中”，然后回到了阻塞地方输出了”调用函数后”，通过下述的一个图例可以更为直观地理解：</p><p><img src="/2020/02/26/23-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8/4.png" alt></p><p>&emsp;&emsp;根据对这个图的理解，我们继续向下联想：假如函数的嵌套并不只是这一层，而是呈现了多层，例如在findMax函数中我们又调用了另一个函数，这个图就会像在main函数中阻塞一样，在findMax函数中阻塞，进入另一个函数，当那个函数执行完后回到findMax函数继续执行，当findMax函数执行结束后回到main函数直到结束。 </p><p>&emsp;&emsp;接下来我们对这个概念进行延伸：假如我们在一个函数中调用的不是其他的函数，而是这个函数本身，例如findMax函数中调用findMax函数，这种调用方式就是递归调用。我们首先举一个例子说明：我们希望通过递归调用的方式求出1+2+3+…100的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getSum(index<span class="number">-1</span>) + index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(getSum(<span class="number">100</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的这段程序就是一个典型的递归调用，主函数中只是调用了getSum函数，并且将100这个整数传进去，此时程序指针进入了getSum函数中，进入getSum函数中首先判断index值是否为0，由于我们传入的是100，所以不为0。因此程序进入了getSum(99)，并且程序在这个地方阻塞，一旦getSum(99)执行完了，我们就将这个结果与index（此时为100）相加得到结果。 </p><p>&emsp;&emsp;我们继续向里面分析，当程序进入了getSum(99)的时候，首先判断index是否为0，由于输入的是99，因此不为0，所以进入了getSum(98)，且当getSum(98)执行结束后，将结果与index（此时为99）相加……上述过程往复循环直到出现了getSum(0)这个函数，当进入getSum函数且将0传入的时候，判断index是否为0，此时index刚好就是0，所以程序不会再进入到下一层的getSum函数了。 </p><p>&emsp;&emsp;这个getSum(0)函数结束，返回到getSum(1)函数的阻塞点继续执行，执行结束后返回到getSum(2)的阻塞点……重复上述循环直到返回getSum(100)这个函数的阻塞点。由于是main函数调用了getSum(100)，因此getSum(100)执行结束后就回到了main函数中进行输出，也就完成了整个的程序过程。整个程序的运行过程只是满足于一个公式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getSum(index) = getSum(index<span class="number">-1</span>)+index</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个公式完整地变现了整个递归的关系。我们再举一个例子，我们在三大流程总结的代码篇中实现了斐波那契数列的程序编写，其实这个数列也可以通过递归的方式进行。我们在那一小节中说明了斐波那契数列的数学表达式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fib(n)=Fib(n<span class="number">-1</span>)+Fib(n<span class="number">-2</span>)    (n&gt;=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们发现这个公式与求1到100求和的公式有异曲同工之妙，即想要求当前的值，必须要求前一个乃至于前两个值。那么对于这个数列我们进行程序的书写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fib</span><span class="params">(month <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> month == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> month == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Fib(month<span class="number">-1</span>) + Fib(month<span class="number">-2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(Fib(<span class="number">12</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序似乎不难理解，当第一个月的时候只有1对兔子，当第二个月的时候有2对兔子，在这之后的月数中，当月的兔子对数等于前两个月的兔子对数之和。 </p><p>&emsp;&emsp;对于初学者来说，函数的递归调用是一个非常难以理解的知识点，有时候即便是懂了函数自己调用自己的模式，但是一旦跟踪代码执行情况就又会把自己绕进去，因此当初学者读到这个小节时候，一定要将上述的两个例子琢磨明白。不仅要明白其中的数学表达式，也要清楚在实现递归调用的时候栈区内存中到底发生了什么，这个结果是怎样出来的。 </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节的最后，我们将会留下一个经典的面试题作为本小节的一个练习，面试官是这样问的：在Go语言中，在不使用for关键字的前提下，让程序输出100句”Hello World”。当然如果回答了用goto关键字，这场面试可能就立刻有结果了，面试官可能更希望你回答的是利用递归来完成，那么这个需求的代码请自行练习写一下。如若这段程序能够独立地写出来，那么函数递归这个知识点就可以说初成了。    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-23-gt-函数的调用机制与嵌套调用&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-23-gt-函数的调用机制与嵌套调用&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;23&amp;gt; 函
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;22&gt; 函数入门与包的使用</title>
    <link href="http://yoursite.com/2020/02/25/22-%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E4%B8%8E%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/25/22-%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E4%B8%8E%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-02-25T05:22:01.000Z</published>
    <updated>2020-02-25T05:22:41.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-22-gt-函数入门与包的使用"><a href="#Go语言从入门到放弃系列-lt-22-gt-函数入门与包的使用" class="headerlink" title="Go语言从入门到放弃系列&lt;22&gt; 函数入门与包的使用"></a>Go语言从入门到放弃系列&lt;22&gt; 函数入门与包的使用</h2><p>&emsp;&emsp;从这一小节开始，我们将会进入模块化编程的阶段，与之前的流程控制不甚相同，但是其基础核心依旧在于流程控制编程。可以说模块化编程中的每一个模块都是使用三大流程完成的，且不同模块之间的集成也无非就是顺序、分支或者循环执行。因此，从这一小节之后的讲解中，我们将不会再针对于某段代码的具体实现方式来详细地讲解，而是针对于不同模块的调用顺序、调用的逻辑等着重说明。前面一些章节如果没有十分熟练地掌握可以通过后面的代码强化。</p><h3 id="函数入门"><a href="#函数入门" class="headerlink" title="函数入门"></a>函数入门</h3><h4 id="函数引入"><a href="#函数引入" class="headerlink" title="函数引入"></a>函数引入</h4><p>&emsp;&emsp;说起函数，有的读者可能会立刻想起中学时代所学到的三角函数、二次函数等等。在数学中，函数指的是因变量与自变量的变化关系。类比到计算机中，计算机的函数也可以理解为返回值与自变量的对应关系，但是在计算机中，函数的含义会相对广泛得多。函数是从英文function翻译过来的，也可以理解为功能，因此在计算机中，函数往往都是为了完成某个功能而创立的。 </p><p>&emsp;&emsp;函数这个概念也是由来已久了，在很多的语言中函数的作用都是将一些需要实现的大功能分割成为若干个小函数，并且将其有机整合成一个程序。我们在这之前所写的程序往往是把所有的代码都写在了主函数中，然而这种开发方式在针对大型程序的时候就显得捉襟见肘了。当多个人一起开发一个项目的时候，每个人需要开发的部分不同，当然也就不能全部都在主函数中开发了，而是需要在不同的函数中、不同的包中进行开发。 </p><p>&emsp;&emsp;首先我们通过一个案例来引入函数的使用：例如我们通过流程控制来完成找四个整数的最大值（这里整数初始值就给定了，不做交互输入了）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> num3 <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> num4 <span class="keyword">int</span> = <span class="number">15</span></span><br><span class="line"><span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> num1 &gt;= num2 &#123;</span><br><span class="line">    max = num1</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    max = num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> max &gt;= num3 &#123;</span><br><span class="line">    max = max</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    max = num3</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> max &gt;= num4 &#123;</span><br><span class="line">    max = max</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    max = num4</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(max)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的程序可以正确地完成我们所提到的需求，但是我们会发现，在寻找两个数字中比较大的数的过程被进行了三次，而且这三次的操作都十分地相似，只是比较的数据不同而已。假如我们现在对需求进行修改，我们希望求出四个整数中最小的那个，我们就需要对上述程序中的三个程序段都进行修改。一旦某个程序块疏忽忘记了修改，程序就出现了逻辑错误。 </p><p>&emsp;&emsp;因此我们希望将寻找两个数的最大值这个过程提取出来，让它作为一种模板，一旦需要的时候调用这个模板并将想要比较的数填进去。这样在程序中我们只需要调用三次模板就可以了，而且当需求改变的时候，只将这个模板中的代码进行修改，程序中所调用的地方就相当于都自动修改了。这个提取的结果我们就可以称之为函数。</p><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>&emsp;&emsp;经过了上述的需求分析，我们在这个小部分中就开始介绍这个模板的定义方式，首先我们先介绍函数定义方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名称 <span class="params">(输入参数列表)</span> <span class="params">(返回值列表)</span></span> &#123;</span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span> XXX</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们大致介绍一下上述使用方式中各个部分的含义：首先，func作为Go语言中的一个关键字用来声明下述的程序块是一个函数，函数名称就是一个符合标识符规范的一个名称，在后期调用的时候会使用这个名称。参数列表指的就是我们希望向这个模板中注入哪些数据，返回值列表指的是这个函数希望返回给调用者的执行结果。函数体是函数中处理数据书写逻辑的部分，最后return关键字会将希望得到的变量或者值返回出去，如果没有返回值列表可以不出现。 </p><p>&emsp;&emsp;那么针对寻找两个数的最大值这个需求我们一起写一下函数的定义方式：func关键字这个不需要多说，函数名称只需要满足标识符的规则，我们便取名为findMax，输入列表为两个数，且都是整数，输出列表为一个整数，即最大值。函数体为寻找最大值的逻辑，最后return两个数中的最大值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMax</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="params">(max <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num1 &gt;= num2 &#123;</span><br><span class="line">        max = num1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max = num2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在函数的定义过程中还有很多的细节，在这个小节中我们暂时不详细讲解这些细节，只是先写一段函数的入门程序，并且介绍函数对于模块化编程的好处。</p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>&emsp;&emsp;既然我们所说的模板已经存在了，那么剩下的就是如何去使用这个模板了。函数的调用方式十分的简单，我们只需要根据函数名直接调用即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量... = 函数名(参数列表)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果一个函数具备返回值，那么我们需要对应个数的变量进行接收返回值，或者不用变量接收返回值，如果选择接收但是变量个数与返回值个数不同则会报错，函数名必须是已经存在的函数名，参数列表传入真实的变量即可。例如： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> num3 <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> num4 <span class="keyword">int</span> = <span class="number">15</span></span><br><span class="line"><span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">max = findMax(num1, num2)</span><br><span class="line">max = findMax(max, num3)</span><br><span class="line">max = findMax(max, num4)</span><br><span class="line">fmt.Println(max)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这里我们需要简要说明一下形式参数与实际参数的关系与区别：</p><ol><li>形式参数主要出现在函数的定义中，这些参数不代表具体的值，只代表希望进行的运算。我们可以将其理解为一种抽象，例如在找最大值的参数列表中，两个整型变量不代表任何值，我们只知道这两个数是整数而已。具体哪个数更大是传入的数据才能决定的，因此在函数体中所写的是单纯的逻辑关系。</li><li>实际参数是出现在函数的调用中，这次的参数代表调用过程中传入的真实的值。在找最大值的调用过程中（以第一个调用为例）：传入的两个变量分别是num1和num2，在程序中分别对应的是10和20。 </li></ol><p>&emsp;&emsp;我们举一个更为形象的例子：在数学表达式”y = x^2”中，我们可以知道这个函数的作用是求一个值的二次幂，但是求的具体是哪个值目前不得而知，x是个形式参数。现在我们将x=2带入到函数中，我们知道了要得到的是2的二次幂，这个2就是实际参数。在使用过程中，函数定义的参数列表的参数个数、参数顺序、参数类型需要完全一致，否则会报出错误。</p><h3 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h3><p>&emsp;&emsp;在函数的概念部分我们提到了一种多人开发的模式，即多个人开发一个项目，每个人开发不同的部分。即便如此，每个人都有可能会开发很多的函数，而且极为有可能对函数的命名也是相同的。在这种情况下对于不同部分的集成就会出现很大的不利情况：在同一个包中出现同名的函数编译时会报错，一旦某个人对函数名进行了修改，那么在调用的全部位置都需要进行修改，这又会很麻烦。 </p><p>&emsp;&emsp;因此在这里我们引出包的概念，这个概念我们在解决同一个包的两个go文件分别具有main函数的那一小节中出现过，我们也提及过在Go语言中，包其实就是文件夹。在同一个包中不可以出现同名的函数，但是在不同的包中则可以出现。那么在引用其他包所定义的函数时需要采用如下的方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">包名.函数名(...)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种调用方式也同时解决了同一个函数名的问题，我们指定了在哪个包中定义的函数，程序就会进入对应的包中进行寻找。那么现在的这个问题就成为了：编译器将如何寻找到对应的包。我们在使用fmt包的时候似乎没有任何的问题，同理在使用strconv、bufio等包的时候均没有问题，这是因为这些包都在GOROOT中。那么我们自己定义的包以及函数是不会放在GOROOT中的，即便这是个方法但是没有开发者会这样做。</p><p>&emsp;&emsp;我们在环境变量配置的时候，介绍到了另一个环境变量：GOPATH，编译器会在<strong>GOPATH目录中的src目录下开始找</strong>，我的机器配置的GOPATH为E:\GoProject。现在我的文件系统为:E:\GoProject\src下有两个文件夹，分别为demo和test，在demo文件夹中有一个文件是demo.go，test文件夹中有一个文件是test.go，现在我们开始写测试程序:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">demo.<span class="keyword">go</span>中：</span><br><span class="line">    <span class="keyword">package</span> main</span><br><span class="line">    <span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"test"</span></span><br><span class="line">    )      </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> num1 <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">        <span class="keyword">var</span> num2 <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">        fmt.Println(test.FindMax(num1, num2))</span><br><span class="line">    &#125;</span><br><span class="line">test.<span class="keyword">go</span>中：</span><br><span class="line">    <span class="keyword">package</span> test</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">FindMax</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="params">(max <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> num1 &gt;= num2 &#123;</span><br><span class="line">            max = num1</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = num2</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们首先看test.go这个文件，我们在这个文件中定义其属于test包，且定义一个函数叫做FindMax（注意首字母大写）。然后我们再看demo.go文件，在这个文件中我们声明为main包，且具备main函数。在引入包的时候我们不仅引入了fmt包，我们还引入了上面定义的test包，因为test文件夹和demo文件夹在同一级，且都在src下。test包所处于的位置为：E:\GoProject\src\<strong>test</strong>，引入时从src目录下开始寻找，因此我们只需要引test即可。在主函数中我们调用了test包中的FindMax方法，所得到的值也是正确的。 </p><p>&emsp;&emsp;在上述入门案例中，一旦读者出现了无法访问等情况，请首先检查环境变量中GOPATH是否配置错误，或者在其他包中的函数名的首字母是否为大写。函数名首字母大写代表可以被其他包访问，小写则代表只能在本包中访问。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们主要讲述了Go语言中的函数的概念以及如何调用其他包中所定义的函数。函数的相关的讲解目前只停留在入门的情况下，对包的理解可以做到会写、会使用他人的第三方包的函数即可。在下一小节中，我们将针对函数的定义、调用方式作出详细的讲解，并介绍函数的嵌套调用以及递归调用的相关知识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-22-gt-函数入门与包的使用&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-22-gt-函数入门与包的使用&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;22&amp;gt; 函数入门与包的
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;21&gt; 流程控制代码举例</title>
    <link href="http://yoursite.com/2020/02/24/21-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B/"/>
    <id>http://yoursite.com/2020/02/24/21-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B/</id>
    <published>2020-02-24T07:35:04.000Z</published>
    <updated>2020-02-24T07:36:00.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-21-gt-流程控制代码举例"><a href="#Go语言从入门到放弃系列-lt-21-gt-流程控制代码举例" class="headerlink" title="Go语言从入门到放弃系列&lt;21&gt; 流程控制代码举例"></a>Go语言从入门到放弃系列&lt;21&gt; 流程控制代码举例</h2><p>&emsp;&emsp;在这之前的章节中，我们从Go语言入门程序、环境变量配置、乃至于标识符运算符、到三大流程控制进行了讲解。在讲解过程中更多的则是理论上的说明，而缺少一些代码案例。因此在这一小节中，我们针对三大流程控制、结合之前所提及的一些案例做一些代码上的讲解，并且对一些编程方法进行说明，因此这个小节更类似于一个代码篇，如果对流程控制十分自信就可以直接跳过了。</p><h4 id="1-十进制正整数转换成二进制代码程序"><a href="#1-十进制正整数转换成二进制代码程序" class="headerlink" title="1. 十进制正整数转换成二进制代码程序"></a>1. 十进制正整数转换成二进制代码程序</h4><p>&emsp;&emsp;十进制如何转换成二进制这个问题我们很早之前就已经说明过了，同时对于整数乃至于浮点数的存储方式也有了一些说明。可以说在十进制整数转换为二进制原码的过程中主要运用了除法、取模、字符串拼接、以及循环的知识。我们直接用代码实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span></span><br><span class="line">    fmt.Scanln(&amp;num)</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">string</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">0</span> &#123;</span><br><span class="line">        result = <span class="string">"0"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> num != <span class="number">0</span> &#123;</span><br><span class="line">        result = fmt.Sprint(num%<span class="number">2</span>) + result</span><br><span class="line">        num = num / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，我们首先定义了一个整数用来存储十进制的数字，并定义了result字符串为空串。接下来我们先跳过分支结构，直接看循环结构，循环条件是num不等于0，因为在循环体中我们每次都将num除以2，因此这个循环条件最终是一定会被执行的。在循环体中，我们首先对num进行取模运算，所得到的取模结果就是二进制结果中的一位，同时由于取模结果是整数，而result是字符串，因此我们需要将整数转换成字符串，用到Sprint函数。同时，在转换过程中是逆序输出，所以先得到的结果应该在字符串的后面，因此我们每次得到余数的时候都把它加在字符串的前面。做完上述的运算后，我们将num除以2（向下取整）后将其结果重新赋值给num，直到num为0退出循环。现在我们回过头看分支结构，我们判断初始输入的值是否为0，如果为0则令结果为”0”。如果缺少这部分代码，当输入为0的时候，就不会有结果输出了。</p><pre><code>输入：  10输出：  1010输入：  0输出：  0</code></pre><h4 id="2-打印空心三角形"><a href="#2-打印空心三角形" class="headerlink" title="2. 打印空心三角形"></a>2. 打印空心三角形</h4><p> &emsp;&emsp;这个题目在很多的教材以及循环结构的练习中十分的常见，因为这个需求是一个十分基础的多重循环的体现。对于初学者来说不论是C语言还是Java语言，这个题目应该都曾经遇见过。我们说明一下需求：</p><pre><code>输入： 5输出：      *     * *    *   *   *     *  *********</code></pre><p>&emsp;&emsp;即输入一个大于0的整数n，输出一个n行用星号所表示的的空心三角形。在这个题目中，我们可以发现：只有在第一行以及最后一行输出的星号个数为2*n-1，其他行中输出的都只是两个星号，因此我们先这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">fmt.Scanln(&amp;n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span> || i == n &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">2</span>*i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            fmt.Print(<span class="string">"*"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Print(<span class="string">"*"</span>)</span><br><span class="line">        fmt.Println(<span class="string">"*"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在外层循环（i层）中，我们的目的是从第1行输出到第n行。在针对每层进行输出的时候，当行数为1或者行数为n（最后一行）的时候，我们循环输出2*i-1个星号后换行，在其他行中只输出两个星号，目前来说其结果如下：</p><pre><code>输入：  5输出：      *    **    **    **    *********</code></pre><p>&emsp;&emsp;在当前的条件下，我们可以发现想让其成为三角形，在每一行输出星号之前需要输出一定量的空格，才能将星号推到后面，而需要输出的空格个数则是：n-i。（例如第1行需要输出4个空格），我们将输出空格加进去：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">fmt.Scanln(&amp;n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> space := <span class="number">1</span>; space &lt;= n-i; space++ &#123;      <span class="comment">//输出空格循环</span></span><br><span class="line">        fmt.Print(<span class="string">" "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span> || i == n &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">2</span>*i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            fmt.Print(<span class="string">"*"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Print(<span class="string">"*"</span>)</span><br><span class="line">        fmt.Println(<span class="string">"*"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果为：</p><pre><code>输入：5输出：        *       **      **     **    *********  </code></pre><p>&emsp;&emsp;我们会发现已经成功一半了，剩下的那一半的输出是在除去第一行和最后一行之外的行中，第一个星号与第二个星号之间输出空格，而空格的数量为：(i-1)*2-1=i*2-3:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">fmt.Scanln(&amp;n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> space := <span class="number">1</span>; space &lt;= n-i; space++ &#123;</span><br><span class="line">        fmt.Print(<span class="string">" "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span> || i == n &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">2</span>*i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            fmt.Print(<span class="string">"*"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Print(<span class="string">"*"</span>)</span><br><span class="line">        <span class="keyword">for</span> middle := <span class="number">1</span>; middle &lt;= i*<span class="number">2</span><span class="number">-3</span>; middle++ &#123;</span><br><span class="line">            fmt.Print(<span class="string">" "</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"*"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;到了这里，程序就编写完成了，在处理多重循环的时候，我们需要学会将循环剥离开，分析哪里是外层循环，哪里是内层循环，并针对于不同的位置进行循环的编写。做到大事化小，再将小事大化。</p><h4 id="3-数据简单校验问题"><a href="#3-数据简单校验问题" class="headerlink" title="3. 数据简单校验问题"></a>3. 数据简单校验问题</h4><p>&emsp;&emsp;在这里我们提出一个数据校验的简单的问题：要求用户从控制台输入两个字符串作为用户名和密码并比对，当用户名为admin且密码为123456时验证通过，否则验证失败且只有三次机会。程序难度不是很大，针对这个需求直接书写即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> username <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> password <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> chance <span class="keyword">int</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> chance &gt; <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"输入用户名："</span>)</span><br><span class="line">    fmt.Scanln(&amp;username)</span><br><span class="line">    fmt.Println(<span class="string">"输入密码："</span>)</span><br><span class="line">    fmt.Scanln(&amp;password)</span><br><span class="line">    <span class="keyword">if</span> username == <span class="string">"admin"</span> &amp;&amp; password == <span class="string">"123456"</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"验证成功"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        chance--</span><br><span class="line">        <span class="keyword">if</span> chance == <span class="number">0</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"验证失败且没有机会了"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"验证失败请重新输入"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序中需要注意的一点是break的使用，当验证成功后直接跳出循环，否则还会在下一轮循环中重新输入。</p><h4 id="4-斐波那契数列"><a href="#4-斐波那契数列" class="headerlink" title="4. 斐波那契数列"></a>4. 斐波那契数列</h4><p>&emsp;&emsp;意大利著名数学家斐波那契曾提出一个数学问题：如果一对兔子每月可以繁殖一对小兔子，且小兔子在成长一个月之后可繁殖小兔子，假设没有兔子的死亡，问一对兔子在一年后能变成多少对兔子。</p><p>&emsp;&emsp;对这个问题首先进行分析，我们可以知道第一个月只有一对兔子，在第二个月有两对兔子，在第三个的兔子数量就是第一个月和第二个月的兔子之和，同理在大于两个月的前提下，可以得到这样的一个公式：N(month) = N(month-1)+N(month-2)。因此在计算过程中我们只需要定义三个变量即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f1 <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> f2 <span class="keyword">int</span> = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> f <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= <span class="number">12</span>; i++ &#123;</span><br><span class="line">        f = f1 + f2</span><br><span class="line">        f1 = f2</span><br><span class="line">        f2 = f</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(f2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;解决这个题的思路为：首先定义month-2所对应的变量（f1）为1，定义month-1所对应的变量（f2）为2，定义一个中间变量f。从第三个月开始执行循环，且每层循环的内容是：首先让中间变量f接收f1和f2的求和，将f2的值赋给f1，（此时f1原来的值已经丢失），再将中间变量的值赋给f2，此时f1和f2所表示的数字均向前移动了一个月，进而执行下一轮循环。 </p><p>&emsp;&emsp;由于Go语言支持多变量的赋值，因此在循环过程中我们甚至可以不需要使用循环变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1, f2 = f2, f1+f2</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们用这条语句代替循环体的三行代码，且注释掉对f的定义，其结果是相同的。最后说一个小彩蛋：我们利用斐波那契数列中的第i个值除以第i+1个值，所得到的结果是黄金分割比的小数表现形式，且i的值越大，越精确。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们主要针对几个小问题进行了代码的演示与讲解。在计算机中的三大流程控制我们已经讲完了，因此初学者也是具备一些的开发能力了。在面对问题的时候可以首先考虑这个问题是由哪几部分所组成的，针对每一部分是否还具备更为基础的组成部分，每一部分需要通过什么样的流程结构来实现，不同的部分之间是什么关系、如何将其集成在一起。想明白这些问题后，程序的编写就是非常容易的事情了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-21-gt-流程控制代码举例&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-21-gt-流程控制代码举例&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;21&amp;gt; 流程控制代码举例&quot;
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;20&gt; 嵌套循环结构break和continue</title>
    <link href="http://yoursite.com/2020/02/23/20-%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84break%E5%92%8Ccontinue/"/>
    <id>http://yoursite.com/2020/02/23/20-%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84break%E5%92%8Ccontinue/</id>
    <published>2020-02-23T06:47:50.000Z</published>
    <updated>2020-02-23T06:48:40.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-20-gt-嵌套循环结构break和continue"><a href="#Go语言从入门到放弃系列-lt-20-gt-嵌套循环结构break和continue" class="headerlink" title="Go语言从入门到放弃系列&lt;20&gt; 嵌套循环结构break和continue"></a>Go语言从入门到放弃系列&lt;20&gt; 嵌套循环结构break和continue</h2><p>&emsp;&emsp;在上一小节中，我们介绍了Go语言中循环结构的定义以及形成循环结构所用的关键字for和goto，在这两个关键字中，由于其他的语言的历史原因，goto这个关键字不是十分受到开发者的青睐，所以更多的人还是选择for来完成循环结构。在这一小节中，我们将讲解循环结构的嵌套和break、continue两个关键字的用法及其注意事项。</p><h3 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h3><p>&emsp;&emsp;根据前几节讲到的分支结构的嵌套，我们可以为循环结构的嵌套进行理解。循环的嵌套简单的说就是一个循环的循环体的内容包含了另一个循环结构。之所以单独将这个话题提取出来是因为这个概念虽说非常好理解，但是在真正使用的过程中还是比较难理解的。尤其在遇到其他的关键字相结合的时候，对于初学者来说可能就会比较费解。</p><p>&emsp;&emsp;在双重循环乃至于多重循环中，内层循环先执行，内层循环执行完之后外层循环才进行了一轮的循环。这个说明方式可能比较抽象，我们可以想象钟表的分针与秒针的关系。分针是外层循环，秒针是内层循环。当秒针走完一圈过后分针才走一格，相对应的是内层循环走完全部的循环，外层循环在走一层。我们用伪代码表示一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> minute := <span class="number">0</span> ; minute &lt; <span class="number">60</span> ; minute ++ &#123;</span><br><span class="line">    <span class="keyword">for</span> second := <span class="number">0</span> ; second &lt; <span class="number">60</span> ; second ++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">"过了一秒钟"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"过了一分钟"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"过了一小时"</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以说，单独的循环嵌套难度还不是十分的大，在介绍了break和continue关键字之后初学者可能会觉得相对有一点吃力了。接下来我们将开始讲述这两个关键字的用法。</p><h3 id="break关键字"><a href="#break关键字" class="headerlink" title="break关键字"></a>break关键字</h3><p>&emsp;&emsp;在一些情况中，我们可能会遇到这种需求：我们并不知道循环体究竟会循环多少次才会结束，或者在循环体中满足一定条件的时候就提前结束，因此在循环条件的表达式中就不太容易定量地写。例如：让程序一直输出0-100的随机数，一直到输出的随机数是50为止。由于一直输出的是随机数，那也就很难在编程的情况下确定循环变量。再或者进行网络编程时，一直通过输入输出流进行消息传输，只有当网络连接断开的时候才退出循环。因此我们引出这个break的关键字。</p><p>&emsp;&emsp;break关键字的作用是跳出当前的程序块，包括switch-case中的代码块和循环结构的代码块。并且只会跳出当前一层的代码块。我们举一个例子来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中我们在循环体中嵌套了一个分支结构，在循环中，我们从0输出到9，在分支结构中，我们判断当i等于5的时候，运行break跳出循环。因此，程序的运行结果是0 1 2 3 4（中间是换行）。出现这个现象的原因是，当循环到i等于5的时候，直接从循环中跳出了，后5次的循环都不执行了。</p><p>&emsp;&emsp;现在我们介绍break在多重循环中的使用，我们先看下一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"i="</span>,i,<span class="string">"j="</span>,j)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的二重循环中，我们在内层循环的循环体中进行了分支判断，当j等于2的时候通过break跳出循环。但是刚刚我们提到了，跳出循环只跳出一层的循环，因此这段程序的结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i= <span class="number">0</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">0</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">1</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">1</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">2</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">2</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">3</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">3</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">4</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">4</span> j= <span class="number">1</span></span><br></pre></td></tr></table></figure><p> &emsp;&emsp;从这个结果中，我们可以看到外层循环所定义的i变量从0执行到了4，而内层循环因为break的原因只执行到1。因此break所能跳出的循环只是当前的这层代码块，一旦超出了这一层就只能正常循环执行了。那么我们可能就会出现这样一种需求：我们从十个字符串中找一个字符，一旦找到了就不找了。换句话说我们要在外层循环中控制要搜索哪个字符串，内层循环中搜索当前字符串中是否具有该字符，一旦找到了，就跳出双重循环。在这里我们采用两种实现方式：借助布尔变量、和运用标签的break。</p><h4 id="运用布尔变量"><a href="#运用布尔变量" class="headerlink" title="运用布尔变量"></a>运用布尔变量</h4><p> &emsp;&emsp;这个方法主要是在外层循环中使用一个布尔变量，在执行内存循环的时候一旦需要跳出了就将该布尔变量的值改变然后使用break跳出。每一次执行外层循环的时候都要判断一下该布尔变量是否发生了变化，一旦发生了变化就跳出。</p><p>&emsp;&emsp;我们将上述的需求转换成在循环中寻找i=2,j=3的情况，因为数组我们还没有学习到，这个demo只是为了演示一下如何退出双重循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">            fmt.Println(<span class="string">"i="</span>, i, <span class="string">"j="</span>, j)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">2</span> &amp;&amp; j == <span class="number">3</span> &#123;</span><br><span class="line">                flag = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> flag == <span class="literal">true</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这一段程序我们就不把结果粘贴上来了，读者可以自行将代码键入并看一下其结果。</p><h4 id="运用带标签的break"><a href="#运用带标签的break" class="headerlink" title="运用带标签的break"></a>运用带标签的break</h4><p>&emsp;&emsp;break所带有的标签和普通的标签不同，在goto结构中所需要的标签可以在任何的位置，但是break所搭配的标签一般只能在某个for之前。一旦不在for关键字前，就会报出错误：invalid break label XXX。我们将这个程序写出来：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"开始"</span>)</span><br><span class="line">    LOOP:</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">            fmt.Println(<span class="string">"i="</span>, i, <span class="string">"j="</span>, j)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">2</span> &amp;&amp; j == <span class="number">3</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> LOOP</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，由于break关键字后面具备标签，所以程序会寻找到对应的标签进行跳出，同时LOOP标签所对应的循环是外层循环，当然就可以直接将双重循环甚至是多重循环一并跳出。</p><h3 id="continue关键字"><a href="#continue关键字" class="headerlink" title="continue关键字"></a>continue关键字</h3><p>&emsp;&emsp;continue与上述提到的break的作用基本相似，不过这两个关键字之间有一些细微的区别：break关键字会直接跳出循环，使得后面剩余的几轮循环都不执行，而continue关键字则是<strong>结束本轮循环，直接进行下一轮循环</strong>，我们举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的这段程序中我们只是将break换成了continue，在这段程序的结果输出中，我们会发现其输出为：0 1 3 4（中间为换行），而唯独不见了2。其原因为当i等于2的时候，执行了continue，使得当前这轮循环不执行了，直接去执行i等于3的那一轮循环。</p><h4 id="带标签的continue"><a href="#带标签的continue" class="headerlink" title="带标签的continue"></a>带标签的continue</h4><p>&emsp;&emsp;就如同break可以使用标签一般，continue也是可以使用标签的，且标签的需求和break也十分相似：只可以存在于for语句上，否则会报错。在多重循环中，continue依旧是结束内层循环的一轮进而进行下一轮的内层循环。如果使用了标签，则直接结束标签所标志的那层循环的当前一轮，直接进行下一轮标记层的循环。这个说明可能比较绕，我们举例说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    LOOP:</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">2</span> &amp;&amp; j == <span class="number">3</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span> LOOP</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(<span class="string">"i="</span>, i, <span class="string">"j="</span>, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，当i等于2且j等于3的时候，执行带标签的continue，且标签标示的是最外层的循环，其结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">i= <span class="number">2</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">2</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">2</span> j= <span class="number">2</span></span><br><span class="line">i= <span class="number">3</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">3</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">3</span> j= <span class="number">2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从结果中我们可以看出当i等于2且j等于3的那层循环过后，直接就从外层循环执行了。在实际应用过程中，continue运用的频率远不及break的使用频率，但是这两个关键字的用法与区别需要记住，在一些初学者的考试之中这两个关键字也经常被列为考点，其难度都不大，记住规则就可以完全答对。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在本小节中，我们主要介绍了循环结构的嵌套使用以及带标签的和不带标签的break关键字、continue关键字的使用方式。在日常开发中，break所用到的地方相对较多，因此这一章节中的介绍一定看懂，尽量做到烂熟于心，在日后的开发过程中对其使用能够达到信手拈来的程度。在下一小节中，我们将针对前面这几节所讲的流程控制集中举一些例子，作为一个练习的章节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-20-gt-嵌套循环结构break和continue&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-20-gt-嵌套循环结构break和continue&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;19&gt; 循环结构goto、for的使用</title>
    <link href="http://yoursite.com/2020/02/22/19-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84goto%E3%80%81for%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/22/19-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84goto%E3%80%81for%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-02-22T08:23:00.000Z</published>
    <updated>2020-02-22T08:28:47.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-19-gt-循环结构goto、for的使用"><a href="#Go语言从入门到放弃系列-lt-19-gt-循环结构goto、for的使用" class="headerlink" title="Go语言从入门到放弃系列&lt;19&gt; 循环结构goto、for的使用"></a>Go语言从入门到放弃系列&lt;19&gt; 循环结构goto、for的使用</h2><p>&emsp;&emsp;在上一个小节中，我们讲述了分支结构的两种表示方式，即if系列代码块以及switch-case系列代码块，同时也讲解了这两种表示方式使用过程中的注意事项。我们也讲解了这两种方式的相互的对应关系以及分支结构的嵌套使用。</p><p>&emsp;&emsp;从这一小节开始，我们将进入循环结构部分的讲解，集中讲解for关键字、goto关键字的使用以及break、continue关键字的区别与使用方式。最后我们会单独写一个小节来针对一个例子进行编程过程的讲解。</p><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p>&emsp;&emsp;在讲解循环结构之前，我们首先回忆一下其他的两个流程控制结构。最为初期我们接触到的是顺序结构，函数中代码从上到下，逐条进行执行直到函数结束。然后是前几节所说到的分支结构，代码根据分支结构中的表达式的值选择性执行不同的代码块。如果我们将其使用树型的方式来联想，其过程则是从树根选择树枝再到树叶的执行过程。</p><p>&emsp;&emsp;循环结构作为第三个流程控制也被广泛地应用，在日常生活中也相对常见。在使用计算机的过程中，我们往往需要让计算机重复循环地做一件事，就会用到循环结构。例如：在服务器的开发过程中，每次用户发送了请求，服务器就需要回复一个相应的响应。换句话说服务器所要做的事情就是重复地等待用户的请求，回应用户的请求，并重新等待下一个请求。</p><p>&emsp;&emsp;我们将循环结构利用流程图来表示：</p><p><img src="/2020/02/22/19-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84goto%E3%80%81for%E7%9A%84%E4%BD%BF%E7%94%A8/1.png" alt><br><img src="/2020/02/22/19-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84goto%E3%80%81for%E7%9A%84%E4%BD%BF%E7%94%A8/2.png" alt></p><p>&emsp;&emsp;通过流程图，我们可以看到在循环结构中，当表达式成立的时候有一部分语句块是被循环执行的，当表达式不成立的时候，会跳出循环进而执行后面的代码。接下来我们将会通过代码的方式讲述循环结构。</p><h3 id="goto关键字"><a href="#goto关键字" class="headerlink" title="goto关键字"></a>goto关键字</h3><p>&emsp;&emsp;首先需要明确的是：goto是Go语言中的一个关键字，但是这个关键字的使用频率十分的低，甚至在一些语言中就完全限制了这个关键字的用法。虽说这个关键字在使用过程中不甚受青睐，但是用来介绍循环语句还是十分的方便的。</p><p>&emsp;&emsp;首先我们看一个简单的需求：在程序中输出100句“Hello Devin！”，如果不使用循环结构而是采用之前所讲述的顺序结构的话，这个实现方式就会比较劳神：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"Hello Devin!"</span>)</span><br><span class="line">...此处省略<span class="number">99</span>个</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;而且一旦需求变了，要求输出70个，那我们还要不厌其烦地删掉30个，一旦出了错误多删了几行或少删了几行，程序结果还是错误的。因此我们需要使用循环结构。根据上述的流程图我们可以发现有两个重要的部分，第一个部分为表达式，第二个部分为语句块，我们针对这两个部分分别进行入门开发：  </p><h4 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h4><p>&emsp;&emsp;由于需要循环，所以这里的语句块写的内容是循环一次所需要的语句，针对于上述的需求，我们可以轻而易举地知道，此处的语句块就是输出一句“Hello Devin”：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello Devin"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p>&emsp;&emsp;在流程图中，我们可以发现，表达式是控制循环是否进行的开关，一旦表达式成立则执行循环，表达式不成立则跳出循环执行后面的代码。因此对于上述的需求而言，其表达式的需要反映的内容是是否执行到了100次，我们还需要定义一个整数变量，用来记录输出的次数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">    fmt.Println(<span class="string">"Hello Devin"</span>)</span><br><span class="line">    num++</span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">100</span> &#123;</span><br><span class="line">        <span class="comment">//执行循环</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">（这是个伪代码，不能执行）</span><br></pre></td></tr></table></figure><h4 id="利用goto关键字拼接"><a href="#利用goto关键字拼接" class="headerlink" title="利用goto关键字拼接"></a>利用goto关键字拼接</h4><p>&emsp;&emsp;现在我们对上述的伪代码进行分析，当输出次数小于100的时候，需要执行循环，而这个循环是从输出字符串之前开始，一直到输出次数的自增，最后再判断条件是否成立。换句话说：fmt.Println(“Hello Devin”)语句和num++语句应该处在循环中，而其他的部分应处在循环外。那么我们需要做的就是：当num&lt;100的时候，让程序回到输出字符串前面执行，如果num&gt;=100的时候就放行，让程序正常执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">    LOOP:</span><br><span class="line">    fmt.Println(<span class="string">"Hello Devin"</span>)</span><br><span class="line">    num++</span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">100</span> &#123;</span><br><span class="line">        <span class="comment">//执行循环</span></span><br><span class="line">        <span class="keyword">goto</span> LOOP</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们在输出字符串的语句前加了一个标签，并将这个标签取名为LOOP，当程序进入到if判断且num&lt;100的时候，我们让程序跳回到LOOP标签所在的位置继续执行，直到num&gt;=100的情况下不执行跳转了，循环就结束了。</p><p>&emsp;&emsp;所以说，循环的本质其实就是代码在执行的时候出现了向前跳转的情况，使执行的流程出现了环状结构。一旦程序进入了循环且结束循环的条件永远达不到的时候，就出现了<strong>死循环</strong>的现象，这个问题在程序编写过程中需要尤其地注意。</p><p>&emsp;&emsp;goto关键字可以毫无条件地跳转到程序的任何一个地方，还需要定义许多的标签，因此在维护的时候十分不方便，在Go语言中其实不是十分推荐使用，在一些其他语言中甚至根本不允许使用，因此对于goto关键的讲解以及在循环结构中的使用我们就不再过多讲解了。</p><h3 id="for关键字"><a href="#for关键字" class="headerlink" title="for关键字"></a>for关键字</h3><p>&emsp;&emsp;在Go语言中，实现循环所用的方式就是for关键字，而不是采用goto关键字，for结构可以用下述的方法进行使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环变量初始化;表达式;循环变量步长 &#123;</span><br><span class="line">    语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以说，for由四部分构成，分别是循环变量的初始化，条件表达式，变量步长控制，以及相应的语句块。循环变量可以理解为在循环中控制循环次数的一个变量（当然它远不止这一个作用），条件表达式就是上述所说控制循环是否继续执行的开关，满足条件则继续执行循环，不满足条件则跳出循环。步长控制是针对循环变量而言的，在下一轮循环中，循环变量需要做怎样的处理，最后语句块就是循环体中所需要执行的代码。我们针对上述例子用for结构进行改写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> num := <span class="number">0</span>; num &lt; <span class="number">100</span>; num++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Hello Devin"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，for关键字后面用两个分号分割出了三个部分，第一个部分的num:=0相当于goto代码中的LOOP标签前面的那句定义，num&lt;100相对于if num&lt;100，num++代表的是LOOP标签中的num++。因此可以说，for在循环结构中的使用是十分方便的。</p><h3 id="for-range结构"><a href="#for-range结构" class="headerlink" title="for-range结构"></a>for-range结构</h3><p>&emsp;&emsp;在编程中，有时其需求可能会是遍历某个数组、某个集合、乃至于某个字符串中的每一个元素，这时也是需要使用循环的。其使用结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量<span class="number">1</span>,变量<span class="number">2</span> := <span class="keyword">range</span> 变量<span class="number">3</span> &#123;</span><br><span class="line">    语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们针对这个使用方式进行解释说明：首先变量3所对应的是需要被遍历的数据，如集合、数组、字符串等等。变量1所代表的是当前循环中遍历到了数组中的第几个元素（元素从第0个开始），变量2代表的是当前遍历到的数据。我们举一个例子来说明：循环遍历一个字符串，并将字符串中的每个字符输出来</p><h4 id="方法1：使用for结构"><a href="#方法1：使用for结构" class="headerlink" title="方法1：使用for结构"></a>方法1：使用for结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello Devin!"</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%c\n"</span>, str[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法的核心思想是：定义循环变量i为0，计算出字符串的长度，且控制循环的条件为循环变量不超出字符串的长度，每次循环变量自增1，以表示下一个字符，在循环体中输入当前循环变量（位置）所在的字符。</p><p>&emsp;&emsp;现在我们换一个字符串，让字符串中出现中文，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello 墨尔本"</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们再执行上述的程序，我们会发现输出到汉字的部分出现了乱码。其原因是Go语言中的字符串是以字节的形式组成的，而不是以字符的形式组成的（详见数据类型章节），而一个中文汉字在UTF-8编码中是以3个字节的形式所存储的，因此当遍历到字符串中的中文部分的时候，每个中文的编码都被分成了三部分输出，导致结果成为了乱码。</p><p>&emsp;&emsp;其解决方式为：将字符串转换成为rune类型的切片（我们会在后续讲到，此处只是先行体验）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello 墨尔本!"</span></span><br><span class="line"><span class="keyword">var</span> strSlice = []<span class="keyword">rune</span>(str)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(strSlice); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%c\n"</span>, strSlice[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法2：采用for-range结构"><a href="#方法2：采用for-range结构" class="headerlink" title="方法2：采用for-range结构"></a>方法2：采用for-range结构</h4><p>&emsp;&emsp;根据上述的for-range结构的使用方式，我们需要三个变量以及一个代码块：我们定义index作为变量1代表当前循环到的位置，定义value作变量2代表遍历到的值，变量3为需要被遍历的字符串，循环体是输出语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello 墨尔本!"</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> str &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"第%d个字符为：%c\n"</span>, index, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在for-range结构中，range后面可以加数组、切片等其他的复杂数据类型，由于我们暂时没有讲到这些，因此我们将会在后面讲到这些知识的时候再提起如何进行遍历。</p><h3 id="（while和do-while结构）"><a href="#（while和do-while结构）" class="headerlink" title="（while和do-while结构）"></a>（while和do-while结构）</h3><p>&emsp;&emsp;这个我们又通过括号进行括起来，其表示含义与Go语言中的字符类型一样，也代表的是在Go语言中<strong>不存在</strong>，写这个小标题也是为了给有其他语言的编程经验的人来看的，对于没有接触过其他编程语言的可以直接跳过。在这里我们通过break关键字的的配合，用for来完成while和do-while的逻辑的实现：</p><h4 id="（while）结构的逻辑实现"><a href="#（while）结构的逻辑实现" class="headerlink" title="（while）结构的逻辑实现"></a>（while）结构的逻辑实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> 表达式 &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（do-while）结构的逻辑实现"><a href="#（do-while）结构的逻辑实现" class="headerlink" title="（do-while）结构的逻辑实现"></a>（do-while）结构的逻辑实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    语句块</span><br><span class="line">    <span class="keyword">if</span> 表达式 &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因此在以后的编程乃至于聊天面试的过程中，说起Go语言中的循环只有for结构，而没有while结构和do while结构。这个地方需要尤其地强调一下。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们主要介绍了Go语言的循环结构的含义，利用goto关键字和for关键字实现循环的方式，以及对数组等复杂数据类型的遍历的方式（for-range），在下一个小节中，我们依旧针对循环结构进行讲解，介绍循环结构中break，continue两个关键字的用法和作用，以及在多重循环中程序的执行流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-19-gt-循环结构goto、for的使用&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-19-gt-循环结构goto、for的使用&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;19
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;18&gt; 分支结构-switch case结构</title>
    <link href="http://yoursite.com/2020/02/21/18-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-switch-case%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/02/21/18-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-switch-case%E7%BB%93%E6%9E%84/</id>
    <published>2020-02-21T04:39:46.000Z</published>
    <updated>2020-02-21T04:40:31.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-18-gt-分支结构-switch-case结构"><a href="#Go语言从入门到放弃系列-lt-18-gt-分支结构-switch-case结构" class="headerlink" title="Go语言从入门到放弃系列&lt;18&gt; 分支结构-switch case结构"></a>Go语言从入门到放弃系列&lt;18&gt; 分支结构-switch case结构</h2><p>&emsp;&emsp;在上一小节中，我们介绍了分支结构的概念以及单分支、双分支、和多分支程序的写法。同时我们也介绍了if-else结构在分支结构中的用法。不仅如此，我们还讲解了在使用分支结构时所需要注意的问题。在这一小节中，我们将依旧对分支结构进行讲解，集中说明switch-case结构的用法，以及分支结构的嵌套使用。</p><h3 id="switch-case结构"><a href="#switch-case结构" class="headerlink" title="switch-case结构"></a>switch-case结构</h3><p>&emsp;&emsp;当我们遇到多分支的程序时候，我们可以采用if-else if-else等方式进行分支分割，但是对于更多条件、更多分支的情况而言，使用if系列的结构就稍显复杂了，取而代之的是，此时我们更多地使用switch-case结构，switch case结构的使用方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> 表达式 &#123;</span><br><span class="line">    <span class="keyword">case</span> 结果<span class="number">1</span>：</span><br><span class="line">    语句块<span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> 结果<span class="number">2</span>：</span><br><span class="line">    语句块<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其使用过程为：switch表示进入条件分支结构，表达式往往是一个具有结果的表达式，比如关系表达式、数学表达式、逻辑表达式、甚至于有返回值的函数都可以。case关键字表示进入当前的分支，当表达式的结果与case后面的结果相匹配时，其语句块得以执行。我们可以将其等价为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式 == 结果<span class="number">1</span> &#123;</span><br><span class="line">    语句块<span class="number">1</span>    </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式 == 结果<span class="number">2</span> &#123;</span><br><span class="line">    语句块<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这里我们需要强调说明的是：相比于一些其他编程语言，Go语言针对switch结构有一个极大的不同点，即执行匹配的语句块后直接跳出switch结构，而不需要break关键字。当然如果希望执行匹配的语句块后再继续向下执行其他的语句块，可以通过另一个关键字fallthrough完成。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">"a=1"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    fmt.Println(<span class="string">"a=2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的程序段输出结果为：a=1，这与C语言和Java等语言完全不同。而对于下面的这段程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">"a=1"</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    fmt.Println(<span class="string">"a=2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个时候的输出结果为a=1换行a=2，也就是说fallthrough的用处就是让程序从当前的分支末尾滑向下面的那个分支，使得两个分支都得以执行。这个关键字其实也可以是有用处的，例如我们输入一个月份，让程序输出该月份的天数。我们知道1、3、5、7、8、10、12月份都是31天，那么当我们输入这几个月份中的某一个时，我们可以让他们一直向下滑，滑到12，并在12所匹配的代码块中输出天数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> month <span class="keyword">int</span></span><br><span class="line">    fmt.Scanln(&amp;month)</span><br><span class="line">    <span class="keyword">switch</span> month &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        fmt.Println(month, <span class="string">"月共31天"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(month, <span class="string">"月共28天"</span>)    <span class="comment">//这里不做闰年判断了</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        fmt.Println(month, <span class="string">"月共30天"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于上述的程序而言，输入的值为1、3、5、7、8、10、12中的一个时，程序会向下滑到12，并输出，当输入的值为2时，直接输出，当输入的是剩下的几个值时，程序会滑到11并输出。</p><h3 id="switch-case-default结构"><a href="#switch-case-default结构" class="headerlink" title="switch-case-default结构"></a>switch-case-default结构</h3><p>&emsp;&emsp;在这个结构中，其实前面与switch-case结构是相同的，只是多了一个default关键字，我将其单独列出来只是想说明default关键字并不是必须的，而是说在大多数的情况下我们将default与switch-case结构相搭配。 </p><p>&emsp;&emsp;我们针对输入月份输出天数的代码进行分析，我们会发现一个问题：一旦用户输入的数字超出了1-12的范围，或者误操作输入错误了，程序就不执行了。default关键字的作用就是弥补这个问题，即当所有的case均不匹配的时候，会执行default中的代码块：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> month &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>： </span><br><span class="line">    fmt.Println(<span class="string">"31天"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>：</span><br><span class="line">    fmt.Println(<span class="string">"28天"</span>)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>：</span><br><span class="line">    fmt.Println(<span class="string">"输入错误"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，一旦用户输入了错误的数字，例如13，程序将会响应为：输入错误。如果将其与if系列相类比，default的作用可以理解为if结构中的最后一个else。</p><h3 id="switch结构中的注意点"><a href="#switch结构中的注意点" class="headerlink" title="switch结构中的注意点"></a>switch结构中的注意点</h3><h4 id="1-case后的表达式可以有多个，用逗号分隔"><a href="#1-case后的表达式可以有多个，用逗号分隔" class="headerlink" title="1. case后的表达式可以有多个，用逗号分隔"></a>1. case后的表达式可以有多个，用逗号分隔</h4><p>&emsp;&emsp;程序的执行流程为判断switch后的表达式的值与哪个case相匹配，如果匹配则执行。那么一个case可以有多个入口，例如上面的例子，当输入月份时，有很多的月份数最终会进入到一个case中，我们其实就不需要那么多的fallthrough了，我们将其列举在case后面就可以了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> month <span class="keyword">int</span></span><br><span class="line">    fmt.Scanln(&amp;month)</span><br><span class="line">    <span class="keyword">switch</span> month &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>:</span><br><span class="line">        fmt.Println(month, <span class="string">"月共31天"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(month, <span class="string">"月共28天"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">11</span>:</span><br><span class="line">        fmt.Println(month, <span class="string">"月共30天"</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        fmt.Print(<span class="string">"输入错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样一来，程序就相比而言简单的多了，在一个case中的不同的条件中，其相互的关系是或关系，相当于是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式 == 结果<span class="number">1</span> || 表达式 == 结果<span class="number">2</span> || 表达式 == 结果<span class="number">3</span> ...</span><br></pre></td></tr></table></figure><h4 id="2-各个case后的数据类型需要与switch后的数据类型相同"><a href="#2-各个case后的数据类型需要与switch后的数据类型相同" class="headerlink" title="2. 各个case后的数据类型需要与switch后的数据类型相同"></a>2. 各个case后的数据类型需要与switch后的数据类型相同</h4><p>&emsp;&emsp;switch后面的表达式的结果是具备数据类型的，当然其相与匹配的case的结果的数据类型需要与其相同，否则在编译过程中就会报错，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int32</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int64</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> b:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序段中，我们定义两个不同的整数类型，我们在switch后的表达式中运用的是int32的数据类型，而case中运用的是int64的数据类型。其程序运行结果并不是因为case匹配不上而不执行语句块，而是因为数据类型不匹配所导致的编译错误，错误类型为：invalid case b in switch on a (mismatched types int64 and int32)。</p><h4 id="3-如果case后是常量（字面量）时，case不可以重复"><a href="#3-如果case后是常量（字面量）时，case不可以重复" class="headerlink" title="3. 如果case后是常量（字面量）时，case不可以重复"></a>3. 如果case后是常量（字面量）时，case不可以重复</h4><p>&emsp;&emsp;在case后面可以是变量、也可以是常量（例如直接写成10），当后面是常量的时候，就不可以重复，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">"结果为1"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">"结果还是1"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中具备两个case结果，但是两个case后面的常量值均为1，这时在程序编译的时候会报错：duplicate case 1 in switch。 </p><p>&emsp;&emsp;那么我们将集中的一个换成变量，同时这个变量依旧为1，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">"结果为1"</span>)</span><br><span class="line">    <span class="keyword">case</span> b:</span><br><span class="line">    fmt.Println(<span class="string">"结果还是1"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个时候程序就不报错了，可以正常执行，那么两个case均满足，程序会选择先出现的那个分支，也就是说会匹配到常量1的那个分支，而不是变量b的分支。</p><h4 id="4-switch后可以不接表达式，此时便类似于if-else结构"><a href="#4-switch后可以不接表达式，此时便类似于if-else结构" class="headerlink" title="4. switch后可以不接表达式，此时便类似于if-else结构"></a>4. switch后可以不接表达式，此时便类似于if-else结构</h4><p>&emsp;&emsp;switch后面不加表达式，也就没有了需要被匹配的表达式，这与传统的switch结构就有了很大的不同，此时则更像是if系列结构，同时，case后面的表达式也基本都成为了关系表达式与逻辑表达式，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score <span class="keyword">int</span></span><br><span class="line">fmt.Scanln(&amp;score)</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> score &gt;= <span class="number">80</span> &amp;&amp; score &lt;= <span class="number">100</span>:</span><br><span class="line">    fmt.Println(<span class="string">"成绩为H1"</span>)</span><br><span class="line">    <span class="keyword">case</span> score &gt;= <span class="number">70</span>:</span><br><span class="line">    fmt.Println(<span class="string">"成绩为H2"</span>)</span><br><span class="line">    <span class="keyword">case</span> score &gt;= <span class="number">50</span>:</span><br><span class="line">    fmt.Println(<span class="string">"成绩为H3"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">"不及格"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，switch的出现相当于是进入了分支结构，但是后面没有表达式直接是大括号，那么程序的执行流程是：逐个判断这些case中的表达式的真假，一旦为真，则进入该语句块。</p><h4 id="5-在switch后以及if后的表达式前，均可以出现数据的定义，但作用域只限于分支结构中（不常用）"><a href="#5-在switch后以及if后的表达式前，均可以出现数据的定义，但作用域只限于分支结构中（不常用）" class="headerlink" title="5. 在switch后以及if后的表达式前，均可以出现数据的定义，但作用域只限于分支结构中（不常用）"></a>5. 在switch后以及if后的表达式前，均可以出现数据的定义，但作用域只限于分支结构中（不常用）</h4><p>&emsp;&emsp;这个特性由于用的相对少一些，我就不过多介绍，只是举个例子说明一下现象而已：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> score := <span class="number">80</span>; &#123; </span><br><span class="line">    <span class="keyword">case</span> score &gt;= <span class="number">80</span> &amp;&amp; score &lt;= <span class="number">100</span> :</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种使用方式是没有问题的，但是上述程序中定义的score只能在switch的大括号中才能使用（定义域的问题后面会说明）。一旦出了这个大括号，score就不能够再次使用了。这个方法不是很常用，因此只需要了解一下，当他人提及时知道这种用法是正确的。</p><h4 id="6-分支结构可以嵌套"><a href="#6-分支结构可以嵌套" class="headerlink" title="6. 分支结构可以嵌套"></a>6. 分支结构可以嵌套</h4><p>&emsp;&emsp;这个特性其实很好理解，在分支结构中，往往会出现一个或多个满足不同条件下的语句块。那么我们在这个语句块中再使用分支结构，就可以称之为分支结构的嵌套，例如当一个人年龄超过18岁可以租房，在这个前提下需要根据性别分配宿舍，其程序实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> gender <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> gender == <span class="literal">true</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"分配男寝"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"分配女寝"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"年龄不够"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的程序中，就是根据年龄出现一个分支结构，在第一个语句块中，又出现了根据性别的分支结构，两个分支结构套在一起，就是分支的嵌套。当然根据这小节所讲述的内容，读者可以自行将上述程序改写为switch-case结构作为练习。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们主要介绍了switch-case乃至于default结构的用法以及变形和注意事项，同时也提及了fallthrough关键字的用法，在最后我们也简述了分支结构的嵌套调用。由于在Go语言中的if结构中，大括号是强制需要写的，因此也不需要讲解像C语言中else与if的匹配问题。在下一章节中，我们将会开始介绍计算机中的第三个流程控制结构：循环结构，并讲解其使用方式和注意事项。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-18-gt-分支结构-switch-case结构&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-18-gt-分支结构-switch-case结构&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;17&gt; 分支结构-if条件语句</title>
    <link href="http://yoursite.com/2020/02/20/17-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-if%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2020/02/20/17-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-if%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/</id>
    <published>2020-02-20T06:50:02.000Z</published>
    <updated>2020-02-20T06:51:04.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-17-gt-分支结构-if条件语句"><a href="#Go语言从入门到放弃系列-lt-17-gt-分支结构-if条件语句" class="headerlink" title="Go语言从入门到放弃系列&lt;17&gt; 分支结构-if条件语句"></a>Go语言从入门到放弃系列&lt;17&gt; 分支结构-if条件语句</h2><p>&emsp;&emsp;在之前几个章节中，我们所举的例子，讲的知识点基本都是顺序结构的流程。主函数中的所有语句从上到下，每一条语句依次按顺序执行，且在程序不出现运行时异常时，每一条语句都必定会执行。在这一章中，我们将介绍到第二个流程控制：分支结构，在分支结构中将会出现条件性的判断，以确定某些语句的执行与否。</p><h3 id="单分支结构"><a href="#单分支结构" class="headerlink" title="单分支结构"></a>单分支结构</h3><p>&emsp;&emsp;很多时候，普通的顺序结构已经无法满足程序编写的需要了，例如当进行人机交互时候，用户输入的信息不同，程序会根据这个信息执行不同的功能。换句话说，在这种情况下可能会出现一部分代码在某种条件下不执行而另一部分执行的情况，反之当条件变化时，执行的代码块也将变化。</p><p>&emsp;&emsp;在这里我们首先介绍单分支结构，所用到的关键字为：if，我们也可以称其为if语句。其编程格式可用如下的公式来表示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式 &#123;</span><br><span class="line">语句块<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">语句块<span class="number">2</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们分析一下上述的调用方式，首先if代表该语句块是一个分支结构。在if后面的表达式往往是关系表达式亦或是逻辑表达式（<strong>不可以是赋值表达式</strong>），其特点为表达式的值为布尔类型（只能为真或假）。当表达式的值为真（true）时，执行大括号中的语句块，之后再正常向后执行；当表达式为假（false）时，大括号中的代码不执行，直接向大括号外的部分进行执行。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line">fmt.Scanln(&amp;age)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"已经是成年人了。"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"租房成功"</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们从控制台读取一个整数，并判断这个整数是否大于18，如果大于18，则会输出“已经是成年人了”和“租房成功”，如果不大于18，则会直接执行“租房成功”。读者可以自行尝试。</p><p>&emsp;&emsp;我们用一个流程图来表示单分支结构，其表示方式可如下：</p><p><img src="/2020/02/20/17-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-if%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/1.png" alt></p><h2 id="双分支结构"><a href="#双分支结构" class="headerlink" title="双分支结构"></a>双分支结构</h2><p>&emsp;&emsp;有时候，单分支结构可能无法完好地完成某种操作，而是需要双分支乃至于多分支的结构，我们对上述的例子进行扩展：当一个人大于十八岁时，出国可以自行租房，如果小于等于十八岁，则需要找寄宿家庭。对于这个案例，单分支结构就不能合适地完成这个需求，我们就会使用到双分支的结构。</p><p>&emsp;&emsp;如果说单分支的结构用自然语言来表述可以表述为：“如果…就…”,那么双分支结构则可以表述为：“如果…就…，否则就…”。因此我们在这里引出if结构中的下一个关键字：else，其使用方式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式 &#123;</span><br><span class="line">语句块<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">语句块<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们依旧分析一下上述的使用方式，前面和单分支相同：当表达式为真时，执行语句块1，否则（即表达式值为假时），执行语句块2，之后再正常向下执行其他部分。需要说明的是：语句块1和语句块2一次只能执行其中的一个，而无法全部都执行。我们依旧举上述年龄的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line">fmt.Scanln(&amp;age)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"已成年，可自由租房"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"未成年，需要寄宿家庭"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"租房成功"</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，一个人的年龄区间被划分成两个部分，每个部分对应于一个分支。当输入的值大于等于18时，输出“已成年，可自由租房”以及“租房成功”，当输出的值小于18时，则会输出“未成年，需要寄宿家庭”以及“租房成功”。</p><p>&emsp;&emsp;因此双分支结构可以被看做为单分支结构的一种扩展，当然上述的例子可以使用两个单分支结构来完成，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">18</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果写成这个模式，则相对而言就会浪费一些计算次数，当采用双分支时，无论如何只需要判断一次，但是采用两个双分支结构，无论如何都会判断两次，当判断条件增多以及分支增多时，用多个单分支来完成不是一个合适的做法。</p><p>&emsp;&emsp;我们依旧将双分支的流程图展示在下面：</p><p><img src="/2020/02/20/17-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-if%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/2.png" alt></p><h3 id="多分支结构"><a href="#多分支结构" class="headerlink" title="多分支结构"></a>多分支结构</h3><p>&emsp;&emsp;在某些情况下，双分支结构可能依旧不能满足程序开发的要求，例如在一个列表中，用户输入列表项所对应的编号，计算机根据输入的编号来判断应该执行哪种功能，而这个列表可能具备五个或更多的选项。所以我们有些情况下需要用到多分支的结构。</p><p>&emsp;&emsp;多分支结构是以双分支为基础的结构，其使用方式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span> &#123;</span><br><span class="line">语句块<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式<span class="number">2</span> &#123;</span><br><span class="line">语句块<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//这个else可以没有</span></span><br><span class="line">语句块<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述使用方式的理解与双分支十分类似：当表达式1成立时，执行语句块1，当表达式1不成立且表达式2成立时，执行语句块2，如果都不满足则执行语句块3。当然如果还有更多的条件，我们依旧可以将最后的else换做else if继续向下写，在这里就不写案例了。</p><p>&emsp;&emsp;当然如果分支十分的多的时候，许多的else if的堆叠对于大程序的维护与修改不是十分有利，我们会采取switch case结构来完成更多分支结构的需求，这个结构我们将会在下一个小节中详细说明。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="1-条件表达式的小括号问题"><a href="#1-条件表达式的小括号问题" class="headerlink" title="1. 条件表达式的小括号问题"></a>1. 条件表达式的小括号问题</h4><p>&emsp;&emsp;其实正常来说，这不应该成为一个问题，只是说如果读者之前对C语言、Java语言等有所了解，我们可能会顺手写出 if(age &gt; 18){…}。在Go语言的官方文档中，条件表达式是不需要用小括号所括起来的，当然括起来也不会影响程序的正确执行，只是在使用 go fmt 命令做格式化时，编译器依旧会将小括号去掉，使用liteide保存时，也会将小括号去掉。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt; <span class="number">18</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">if</span> (age &gt;<span class="number">18</span>)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-大括号以及else的位置"><a href="#2-大括号以及else的位置" class="headerlink" title="2. 大括号以及else的位置"></a>2. 大括号以及else的位置</h4><p>&emsp;&emsp;大括号的位置我们在Go语言入门程序中就已然提及了，即左大括号一定要出现在某条语句的结尾，而不可以是单独出现一行。同样的，else所出现的位置只可以在右大括号的后面，而不可以单独一行出现。Go语言对于单独的右大括号的解读为一个程序段的结束，一旦else单独占一行，则会认为if结构已然结束，else不应该出现，将会报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt; <span class="number">18</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//此处会发生错误</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-大括号需要写"><a href="#3-大括号需要写" class="headerlink" title="3. 大括号需要写"></a>3. 大括号需要写</h4><p>&emsp;&emsp;依旧是上述的问题，在某些编程语言中，当语句块只有一条语句时，可以不写大括号。然而在Go语言中，大括号的书写是必须的且是强制的，一旦不写大括号，编译时就会报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt; <span class="number">18</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//编译时会报错，必须要有大括号</span></span><br></pre></td></tr></table></figure><h4 id="4-只会执行一条分支"><a href="#4-只会执行一条分支" class="headerlink" title="4. 只会执行一条分支"></a>4. 只会执行一条分支</h4><p>&emsp;&emsp;在程序开发中，有时候也难免会遇到一个程序满足多个分支的情况，尤其在多个人针对不同层面进行协同开发时会出现这个情况。例如：两个人分别对学习与租房的条件进行限制：大于6岁可以上小学，和大于18岁可以租房。（这个例子举得不好，只是为说明问题而已）就可能会出现这样的程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt; <span class="number">6</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"可以开始义务教育"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> age &gt;<span class="number">18</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"可以租房"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么一个人可能会同时满足这两个分支的条件，此时程序的执行方式是：进入到其满足的第一个分支中，其他分支全部忽略。当然上述说的是指在一个if结构中，各个分支结构是相互独立的，一段程序中可能会出现很多的分支结构。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们对分支结构进行了引出，同时介绍了单分支结构、双分支结构、以及其发展而来的多分支结构。我们也讲解了使用过程中需要注意的几个小点，以避免初学者在分支结构的使用过程中出现一些小错误。</p><p>&emsp;&emsp;在下一个小节中，我们依旧会针对分支结构进行叙述，我们会对另一套的关键字：switch、case、fallthrough进行讲解，同时也会简单提及break关键字的问题，最后我们还会说明分支结构的嵌套使用的场景以及对应的案例。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-17-gt-分支结构-if条件语句&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-17-gt-分支结构-if条件语句&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;17&amp;gt; 分支结
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;16&gt; 输入函数</title>
    <link href="http://yoursite.com/2020/02/19/16-%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/02/19/16-%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0/</id>
    <published>2020-02-19T07:22:48.000Z</published>
    <updated>2020-02-19T07:23:40.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-16-gt-输入函数"><a href="#Go语言从入门到放弃系列-lt-16-gt-输入函数" class="headerlink" title="Go语言从入门到放弃系列&lt;16&gt; 输入函数"></a>Go语言从入门到放弃系列&lt;16&gt; 输入函数</h2><p>&emsp;&emsp;在上几小节中，我们主要说明了Go语言中的多种操作符，并介绍了各种操作符的用法及注意事项。同时我们也按顺序列举出了各个操作符的优先级，也相当于讲解了在一个复杂的表达式中执行顺序的问题。在这一小节中，我们将介绍Go语言中的输入函数，以及对函数的使用规则以及空格字符读取的问题进行讲解。</p><h3 id="Scanf与Scanln函数"><a href="#Scanf与Scanln函数" class="headerlink" title="Scanf与Scanln函数"></a>Scanf与Scanln函数</h3><p>&emsp;&emsp;在之前的多个小节中，我们所用到的数据都是通过写程序时直接写在程序中的方式进行硬编码，因此就失去了与计算机的交互性。然而在更多的情况中，我们会从控制台（cmd）向程序中进行输入，例如：输入一个人的年龄以及姓名，程序根据输入的不同的值做不同的响应，就用到了从控制台输入的函数。</p><p>&emsp;&emsp;由于向控制台输出和从控制台输出都属于标准输入输出，因此这两个函数也在fmt的包中，在使用的时候依旧需要引入这个包。我们将Scanln与Println相类比，将Scanf与Printf相类比，我们可以大致猜到Scanf函数可以对输入的字符串格式进行编辑，Scanln函数直接进行数据的输入。 </p><h4 id="Scanln函数"><a href="#Scanln函数" class="headerlink" title="Scanln函数"></a>Scanln函数</h4><p>&emsp;&emsp;Scanln函数可以从控制台接收到字符串，并自动地转换成接收的变量的数据类型，我们通过下面的几个案例进行快速入门：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;a)</span><br><span class="line">fmt.Scanln(&amp;b)</span><br><span class="line">fmt.Scanln(&amp;c)</span><br><span class="line">fmt.Scanln(&amp;d)</span><br><span class="line">fmt.Println(a, b, c, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">abc</span><br><span class="line">输出：</span><br><span class="line"><span class="number">100</span> <span class="number">3.14</span> <span class="literal">true</span> abc</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上述的案例，我们可以发现，在Scanln函数中，我们通过键盘所输入的值会根据其参数的数据类型而自动转换。一般来说我们通过控制台输入的值都是字符串，当计算机接收到字符串之后会根据不同的类型做自动的转换。现在我们将输入的形式稍作修改：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">100</span> <span class="number">3.14</span> <span class="literal">true</span> abc（将原来的回车改为空格，最后再敲回车）</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们会发现这个结果非常奇怪且是错误的，输出的结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> <span class="number">.14</span> <span class="literal">false</span> e</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;换句话说，在Scanln函数中，结束Scanln函数的标志为回车符号而不是空格符号，如果采用了空格符号作为结束符号，代码运行时不会报错，但是输出err之后我们可以发现，其读取过程还是发生了错误的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> </span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span></span><br><span class="line">_,err1 := fmt.Scanln(&amp;a)</span><br><span class="line">fmt.Println(<span class="string">"err1 is "</span>,err1)</span><br><span class="line">_,err2 := fmt.Scanln(&amp;b)</span><br><span class="line">fmt.Println(<span class="string">"err2 is "</span>,err2)</span><br><span class="line">fmt.Println(a,b)</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line"><span class="number">100</span> abc</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">err1 is  expected newline</span><br><span class="line">err2 is  &lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="number">100</span> bc</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;即在执行第一个Scanln函数时，读取第一个数字时发生了错误，函数一直在等待一个回车代表输入结束，但一直没有等到，导致其读取发生了错误，并影响到了第二数据的读取。</p><p>&emsp;&emsp;我们再看下一组代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span></span><br><span class="line">_, err := fmt.Scanln(&amp;a,&amp;b)</span><br><span class="line">fmt.Println(err)</span><br><span class="line">fmt.Println(a,b)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这一段代码中，我们依旧采用上述两种方式的输入：输入100空格abc后回车，和输入100回车abc回车。通过结果我们会发现，此时此刻第一种输入方式是奏效的，但是第二种方式会报错，其错误信息为：unexpected newline。出现这个问题的原因是，计算机正在等待一并输入两个值，但是输入完一个值后通过回车就结束了Scanln函数，因此第二个数据没有被读取。</p><p>&emsp;&emsp;所以说Scanln函数的用法还是相对苛刻，在多个Scanln函数执行时需要以回车作为分割，在一个Scanln函数中输入多个数的时候，需要以空格进行分割，不可以发生混淆。</p><h4 id="Scanf函数"><a href="#Scanf函数" class="headerlink" title="Scanf函数"></a>Scanf函数</h4><p>&emsp;&emsp;Scanf函数可以大致参考Printf函数的参数形式，在Printf函数中，我们通过一个含有占位符的字符串将输出格式确定下来，在Scanf函数中我们依旧通过这个含有占位符的字符串将输入格式确定，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">string</span></span><br><span class="line">fmt.Scanf(<span class="string">"%d%f%t%s"</span>, &amp;a, &amp;b, &amp;c, &amp;d)</span><br><span class="line">fmt.Println(a, b, c, d)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时，当我们依旧输入上述的几个数据时，我们会发现在相邻的两个数据输入过程中是以空格的形式进行分割，而不能使用回车。当我们将Scanf函数中的样式做修改时，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt,Scanf(<span class="string">"%d,%f,%t,%s"</span>, &amp;a, &amp;b, &amp;c, &amp;d)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们在利用空格作为输入的间隔符就会产生错误的数据了，因此这个时候我们需要按照输入的格式进行输入，在输入格式中，两个数据之间是以逗号作为分割的，甚至我们可以用任何的不同的字符串分割数据。只要输入的时候按照输入格式进行，就可以正确地读取数据。但是一般来说我们并不会在输入格式上进行限制，如果如此就会输入更多的与数据无关的字符。</p><h3 id="bufio输入"><a href="#bufio输入" class="headerlink" title="bufio输入"></a>bufio输入</h3><p>&emsp;&emsp;在前面的几段程序中，不知读者有没有发现，在输入字符串的过程中是无法出现空格的。一方面空格作为分隔符，当编译器发现空格的时候则默认为上一个数据输入完成了，另一方面，即便是空格不做为分隔符的时候，空格后面的字符串也都不见了。然而在写程序的过程中，我们往往需要让字符串中含有空格，例如外国人输入姓名的时候，或者名字里就是带空格，此时采用fmt输入就会丢失信息。因此一般来说，在做字符串读取的时候还是会使用bufio的方式。</p><p>&emsp;&emsp;使用这种方式需要额外引入两个包，分别是bufio包与os包，其原理是通过bufio中的读取器从标准输入（即键盘等）中直接读取数据，而不是先将数据读入到字符串中，再将其分割后放入变量。程序如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">input, err := inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"读入错误"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先解释一下程序：刚进入主函数的时候，我们通过bufio包新建了一个读取器，并且告诉这个读取器是从系统的标准输入读取的。然后用这个读取器进行读取字符串，直到读入’\n’即换行符为止，在这之前的任何字符都可以被读取到。该函数具备两个返回值，第一个返回值是读取到的内容，第二个返回值为错误类型。当判断没有出现错误（错误为空）时输出该字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：Hello I am Devin!(中间有一个\t)</span><br><span class="line">输出：Hello I amDevin!</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样我们就可以解决空格的问题了，当然这个函数基本都是用来读取字符串的，如果我们想将其转换成为其他数据类型如整数等，可以再参考数据类型转换那小节中的各个方法进行转换。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们主要讲述了Go语言中输入的问题，我们介绍了Scanln、Scanf函数以及通过bufio包中的函数进行字符串读取。在程序中，人机交互一般来说比较常见，因此这三个方法所用之处也十分的广泛，在日后的多次使用过程中，我们自然就会记住这几种方式的用法。</p><p>&emsp;&emsp;在下一小结中，我们将正式进入Go语言的下一章节，分支结构的讲解之中，在下一章节中我们将会介绍计算机中的下一个流程结构，介绍Go语言的if等关键字以及与其他的编程语言（如C语言）的细微的差别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-16-gt-输入函数&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-16-gt-输入函数&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;16&amp;gt; 输入函数&quot;&gt;&lt;/a&gt;Go语言从入门
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;15&gt; 运算符-逻辑，位运算，及其他运算符</title>
    <link href="http://yoursite.com/2020/02/18/15-%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%80%BB%E8%BE%91%EF%BC%8C%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%8C%E5%8F%8A%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2020/02/18/15-%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%80%BB%E8%BE%91%EF%BC%8C%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%8C%E5%8F%8A%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2020-02-18T07:53:42.000Z</published>
    <updated>2020-02-18T07:55:03.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-15-gt-运算符-逻辑，位运算，及其他运算符"><a href="#Go语言从入门到放弃系列-lt-15-gt-运算符-逻辑，位运算，及其他运算符" class="headerlink" title="Go语言从入门到放弃系列&lt;15&gt; 运算符-逻辑，位运算，及其他运算符"></a>Go语言从入门到放弃系列&lt;15&gt; 运算符-逻辑，位运算，及其他运算符</h2><p>&emsp;&emsp;在上一小节中，我们集中说明了Go语言中的运算符中的三种，分别是：算数运算符，赋值运算符，以及关系运算符。在这一小节中，我们将继续介绍另外的几种运算符，并且将列举各个运算符的优先级，使读者当面对一个表达式的时候可以准确地计算出该表达式的值。</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>&emsp;&emsp;在Go语言中，逻辑运算符也相对较少，主要用到的是三个，分别为：&amp;&amp;（逻辑与），||（逻辑或），！（逻辑非）。在数学中乃至于电路中这三种逻辑也十分地常见，这三个运算符是针对于布尔值进行运算的，即其符号左右都需要是布尔值变量或者结果为布尔值的表达式。在一些语言中可以将0代替为false，将1代替为true，使之符号左右可以出现整数，但是在Go语言中，这种使用方式是错误的。</p><p>&emsp;&emsp;既然逻辑运算符是针对于布尔值的，而布尔值只有两种值可以取，因此我们可以很容易列举出不同情况下的返回值，我们也可以称之为真值表，根据我们的理解，也可以相对容易地分析出真值表中的各个值：</p><table><thead><tr><th>序号</th><th>p值</th><th>q值</th><th>p与q</th><th>p或q</th><th align="center">非p</th></tr></thead><tbody><tr><td>1</td><td>true</td><td>true</td><td>true</td><td>true</td><td align="center">false</td></tr><tr><td>2</td><td>true</td><td>false</td><td>false</td><td>true</td><td align="center">false</td></tr><tr><td>3</td><td>false</td><td>true</td><td>false</td><td>true</td><td align="center">true</td></tr><tr><td>4</td><td>false</td><td>false</td><td>false</td><td>false</td><td align="center">true</td></tr></tbody></table><p>&emsp;&emsp;当进行逻辑运算的时候可以完全遵循上述的真值表进行计算。从上述的真值表中我们可以发现，在&amp;&amp;（与）逻辑中，当且仅当左右两个表达式的值均为true的时候其结果才为true，在||（或）逻辑中，当且仅当左右两个表达式均为false的时候其结果才为false，在!（非）逻辑中，其结果仅仅是将后面表达式的结果取反。</p><h4 id="短路现象"><a href="#短路现象" class="headerlink" title="短路现象"></a>短路现象</h4><p>&emsp;&emsp;如果我们将上述的那段话换一种说法：在&amp;&amp;（与）逻辑中，只要左右出现了一个false的表达式，其结果一定就是false，同理，在||（或）逻辑中，只要出现了一个true的表达式，其结果一定就是true。也就是说，在列表中的几种情况中，计算机可以只通过一个表达式的值就可以得到整个表达式的真假，因此计算机可以完全不需要对后半部分的值进行判断，即将后半部分短路了。我们举个例子：（用到了if和函数的知识）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retTrue</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"这个函数返回的是true"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retFalse</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"这个函数返回的是false"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> retFalse() &amp;&amp; retTrue() &#123;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"----------------------------"</span>)</span><br><span class="line"><span class="keyword">if</span> retTrue() || retFalse() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述程序中，我们定义了两个自定义函数，分别是retTrue和retFalse，调用这两个函数的返回值分别是true和false，当调用的时候会输出函数中的字符串。因此，在main函数的调用过程中，我们可以根据输出的字符串来判断函数究竟有没有执行。经过运行，我们可以看到如下的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个函数返回的是<span class="literal">false</span></span><br><span class="line">----------------------------</span><br><span class="line">这个函数返回的是<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在程序中的main函数中的横线上方我们是调用了两个函数的，但是结果中只输出了一句话，从中可以判定在&amp;&amp;符号后方的表达式没有被执行。同理在横线下也调用了两个函数，但是也是只输出了一句话，其||符号后的表达式依旧没有执行。</p><p>&emsp;&emsp;具体的分析过程如下：在第一个运算中，计算机调用了retFalse函数之后，发现其返回值为false，然而在与逻辑中只要出现一个false其结果就一定为false，所以后面的表达式是否执行或执行结果对最终结果完全无影响，因此就不需要执行了。在或逻辑中，计算机先调用了retTrue函数且得到了true的返回值，只要出现了一个true其结果一定为true，所以后面的表达式就不需要执行了。</p><p>&emsp;&emsp;短路与和短路或逻辑在使用中需要注意这一点，在小型的计算中这个特性一般不会被体现出来，但是在逻辑极为复杂且用到很多的逻辑运算符时就会很令人费解。例如我们在函数中对某个全局变量的值进行了修改，但是在不同的情况下，这个函数可能会执行，也可能被短路，这样这个全局变量的值就很难追踪了。</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>&emsp;&emsp;位运算符的原理与数据的二进制表示方法有较大的相关性，所以位运算更贴近于计算机底层操作，因此在日常的开发过程中几乎很少能看到这种运算符。但是对于位运算有较好的掌握对于算法的优化、计算的效率的提升会有较大的帮助，因此我们在这里对位运算进行一些简要的讲解。</p><h4 id="gt-gt-（右移）-lt-lt-（左移）运算"><a href="#gt-gt-（右移）-lt-lt-（左移）运算" class="headerlink" title="&gt;&gt;（右移）&lt;&lt;（左移）运算"></a>&gt;&gt;（右移）&lt;&lt;（左移）运算</h4><p>&emsp;&emsp;根据这两种运算符的名称可以看出，这两种运算都是针对于二进制位的移动的，其格式a&gt;&gt;b的含义为将a数据以二进制表示后向右移动b个位置。那么既然位置在移动就难免会出现移动出可表示的区域的情况和新补充进来的数据位的值的判断。在这里我们介绍一个移位运算溢出时的规律：右移过程中溢出数据舍弃，高位根据符号位的值补充，左移过程中高位溢出舍弃，低位补零。我们先用两个例子进行说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">a = a &gt;&gt; <span class="number">1</span></span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;经过运行后，我们可以得到结果为5。这个结果出现的原因为：首先定义一个变量a为10，用二进制表示为（假设8个二进制位）：00001010，现在我们将其向右移动一位，高位补充为符号位的数据，即得到的结果是：00000101，再换算成10进制为5。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">a = a &lt;&lt; <span class="number">2</span></span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序的输出结果为40，其原因类似于上述的过程，首先将10用二进制表示（假设8个字节）：00001010，将其左移2位后，低位补充进去两个0，得到的结果是：00101000，换算成十进制后结果为40。</p><p>&emsp;&emsp;现在我们再举一个负数且会出现数据溢出的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">-11</span></span><br><span class="line">a = a &gt;&gt; <span class="number">2</span></span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;计算结果为-3，分析这个过程会相对复杂一些，不过依旧和二进制与补码的知识十分相关。首先我们将-11用二进制表示，-11的原码为：10001011，但是在计算机中对负数的存储方式是补码的方式，因此需要对其转换成补码的样式：11110101。现在我们将当前的二进制数向右移两个位，且溢出的位丢弃，补充进来的高位与符号位相同，其结果为：11111101，目前得到的结果是个负数且是补码的形式，因此我们在输出的时候将其转回原码形式进行输出：原码格式为：100000011，再按原码形式解读结果为-3。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int8</span> = <span class="number">-100</span></span><br><span class="line">a = a &lt;&lt; <span class="number">1</span></span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;读者可以自己先分写一下这个结果会是多少然后再看下述的分析。首先对-100进行码制转换，-100的原码是：11100100，转换成补码后得到的结果为：10011100。现在将这个值向左移动1位高位溢出，低位补0，得到的结果为：00111000，这时候符号位已经变成了0，所以其表示的是一个正数，正数的原码与补码相同，转换到十进制后结果就是56。</p><p>&emsp;&emsp;在上述的几个例子中，我们似乎可以发现另一个规律，当数据进行左移n位操作的时候，相当于数据乘以2的n次幂，数据进行右移操作的时候，相当于除以2的n次幂。乘法运算中出现数据溢出，除法操作出现向下取整。可以说，这种左移右移运算是计算数据乘以2或除以2时最好的方法。</p><h4 id="按位与、或、异或、与非、按位取反"><a href="#按位与、或、异或、与非、按位取反" class="headerlink" title="按位与、或、异或、与非、按位取反"></a>按位与、或、异或、与非、按位取反</h4><p>&emsp;&emsp;在理解了上述的真值表之后，我们若将二进制中的1替换成true，二进制中的0替换为false，这个小节就会相对容易理解了。这个小节所介绍到的所有操作依旧是针对于二进制的，因此在进行运算时首先要转换为二进制。</p><h5 id="amp-符号（按位与）"><a href="#amp-符号（按位与）" class="headerlink" title="&amp;符号（按位与）"></a>&amp;符号（按位与）</h5><p>&emsp;&emsp;将两个数据全部转换成二进制后，针对每一位进行与操作，只有两个数据的这个位全为1的时候，结果中的该位才为1，任意一个数据该位为0，结果中该位的值也为0，举例说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="number">86</span> &amp; <span class="number">120</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果为80。其原因为：将172转换成二进制：01010110，将120转换为二进制：01111000，将两个数据按位与运算后结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01010110</span></span><br><span class="line"><span class="number">01111000</span></span><br><span class="line">-----------------</span><br><span class="line"><span class="number">01010000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后将01010000转换为十进制后为80。</p><h5 id="符号-按位或"><a href="#符号-按位或" class="headerlink" title="|符号(按位或)"></a>|符号(按位或)</h5><p>&emsp;&emsp;我们将这个符号与上述进行类比，将两个数据转换成二进制后，数据位全部是0的时候结果为0，否则为1，依旧是上述的数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="number">86</span> | <span class="number">120</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">01010110</span></span><br><span class="line"><span class="number">01111000</span></span><br><span class="line">----------------</span><br><span class="line"><span class="number">01111110</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将01111110转换成十进制后，结果为126。</p><h5 id="符号（按位取反、异或）"><a href="#符号（按位取反、异或）" class="headerlink" title="^符号（按位取反、异或）"></a>^符号（按位取反、异或）</h5><p>&emsp;&emsp;当^符号作为单目运算符号时，即运算符前没有数据（例如正负号），此时这个符号的含义为按位取反，即该数据的某二进制位为1，结果中该位为0，反之亦然（包括符号位）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(^<span class="number">86</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">01010110</span></span><br><span class="line">----------------</span><br><span class="line"><span class="number">10101001</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;得到结果为10101001，转换成原码后为：11010111，按源码方式读取后十进制结果为：-87。</p><p>&emsp;&emsp;当该符号作为双目运算符使用时，其代表的含义为异或，换句话说：当两个数据某位不同的时候，结果中该位为1，当位数据相同时，其结果为0（符号位参与运算）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="number">86</span> ^ <span class="number">-120</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">01010110</span></span><br><span class="line"><span class="number">10001000</span>（补码形式）</span><br><span class="line">----------------</span><br><span class="line"><span class="number">11011110</span>===&gt;<span class="number">10100010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出结果为：-34。</p><h5 id="amp-符号（与非）"><a href="#amp-符号（与非）" class="headerlink" title="&amp;^符号（与非）"></a>&amp;^符号（与非）</h5><p>&emsp;&emsp;这个操作相当于是先将第二个数按位取反，然后将这个结果与第一个数做按位与操作，其特性可以记为：第二个操作数的某位为0的时候，结果为第一个操作数的值，当第二个操作数某位为1的时候，结果该位为0。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="number">86</span> &amp;^ <span class="number">120</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">01010110</span></span><br><span class="line"><span class="number">10000111</span>（取反后）</span><br><span class="line">----------------</span><br><span class="line"><span class="number">00000110</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果为：6。</p><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><p>&emsp;&emsp;Go语言中归纳为其他运算符的可以说只有两个，这两个运算符在我们讲解指针的时候提及过，即：&amp;运算符与*运算符。&amp;运算符表示的含义为返回变量的存储地址，*的含义为取出指针变量中所指向的值。具体就不做过多的讲解了，在指针数据类型的小节中有详细的例子与说明。</p><h3 id="运算符的优先级表"><a href="#运算符的优先级表" class="headerlink" title="运算符的优先级表"></a>运算符的优先级表</h3><table><thead><tr><th>分类</th><th>描述</th><th align="center">关联性</th></tr></thead><tbody><tr><td>后缀</td><td>() [] -&gt; . ++ –</td><td align="center">左到右</td></tr><tr><td>一元</td><td>+ - ! ~ ++ – (type) * &amp;</td><td align="center">右到左</td></tr><tr><td>乘法</td><td>* / %</td><td align="center">左到右</td></tr><tr><td>加法</td><td>+ -</td><td align="center">左到右</td></tr><tr><td>移位</td><td>&lt;&lt; &gt;&gt;</td><td align="center">左到右</td></tr><tr><td>关系</td><td>&lt; &lt;= &gt; &gt;=</td><td align="center">左到右</td></tr><tr><td>相等</td><td>== !=</td><td align="center">左到右</td></tr><tr><td>按位AND</td><td>&amp;</td><td align="center">左到右</td></tr><tr><td>按位XOR</td><td>^</td><td align="center">左到右</td></tr><tr><td>按位OR</td><td>&#124;</td><td align="center">左到右</td></tr><tr><td>逻辑AND</td><td>&amp;&amp;</td><td align="center">左到右</td></tr><tr><td>逻辑OR</td><td>&#124;&#124;</td><td align="center">左到右</td></tr><tr><td>条件</td><td>? :</td><td align="center">右到左</td></tr><tr><td>分配</td><td>= += -= *= /= %= &gt;&gt;= &lt;&lt;= &amp;= ^= &#124;=</td><td align="center">右到左</td></tr><tr><td>逗号</td><td>,</td><td align="center">左到右</td></tr></tbody></table><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们继续说明了Go语言中其他种类的几种运算符，包括逻辑运算及其短路现象，位运算的多个运算符的运算规则，以及提到了指针的两个运算法则。同时，我们也列出了运算符的优先级顺序，优先级越高在表达式中越先执行，反之越低则越后执行。</p><p>&emsp;&emsp;在下一个小节中，我们将对人机交互时向计算机输入信息所用的函数以及其包做出简要的介绍，同时对输入时遇到的分隔符以及字符串问题进行解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-15-gt-运算符-逻辑，位运算，及其他运算符&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-15-gt-运算符-逻辑，位运算，及其他运算符&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;l
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;14&gt; 运算符-算数、赋值与比较运算符</title>
    <link href="http://yoursite.com/2020/02/17/14-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%AE%97%E6%95%B0%E3%80%81%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2020/02/17/14-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%AE%97%E6%95%B0%E3%80%81%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2020-02-17T05:14:52.000Z</published>
    <updated>2020-02-17T05:15:45.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-14-gt-运算符-算数、赋值与比较运算符"><a href="#Go语言从入门到放弃系列-lt-14-gt-运算符-算数、赋值与比较运算符" class="headerlink" title="Go语言从入门到放弃系列&lt;14&gt; 运算符-算数、赋值与比较运算符"></a>Go语言从入门到放弃系列&lt;14&gt; 运算符-算数、赋值与比较运算符</h2><p>&emsp;&emsp;在上几节中，我们讲述了Go语言中的多种数据类型，包括整型、浮点型、字符串以及指针类型等。在接下来的几个小节中我们将集中说明Go语言中的运算符的使用。在这一小节中，我们将主要介绍算数运算符、赋值运算符以及比较运算符（关系运算符）。</p><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>&emsp;&emsp;我们最先介绍算数运算符，因为算数运算符在我们日常生活中是最为常用的，在Go语言中算数运算符<br> 主要是进行数学运算的，例如加减乘除取余、正负号、自加自减等等。除此之外，我们将字符串拼接时所用到的加号也算在这个范畴中。我们在下述的表中列出算数运算符、其含义、举例以及案例中的结果：</p><table><thead><tr><th align="left">运算符</th><th align="left">运算</th><th align="left">范例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">正号</td><td align="left">+5</td><td align="center">5</td></tr><tr><td align="left">-</td><td align="left">负号</td><td align="left">-5</td><td align="center">-5</td></tr><tr><td align="left">+</td><td align="left">加法</td><td align="left">5+2</td><td align="center">7</td></tr><tr><td align="left">-</td><td align="left">减法</td><td align="left">5-2</td><td align="center">3</td></tr><tr><td align="left">*</td><td align="left">乘法</td><td align="left">5*2</td><td align="center">10</td></tr><tr><td align="left">/</td><td align="left">除法</td><td align="left">5/2</td><td align="center">2</td></tr><tr><td align="left">%</td><td align="left">取模（求余）</td><td align="left">5%2</td><td align="center">1</td></tr><tr><td align="left">++</td><td align="left">自加</td><td align="left">i=5 i++</td><td align="center">i=6</td></tr><tr><td align="left">–</td><td align="left">自减</td><td align="left">i=5 i–</td><td align="center">i=4</td></tr><tr><td align="left">+</td><td align="left">字符串拼接</td><td align="left">“Hello”+”!”</td><td align="center">“Hello!”</td></tr></tbody></table><p>&emsp;&emsp;在上述表中所列举的数据中，我们将选择几个运算符进行注意事项的讲解。首先表中的前几个运算符：正号、负号、加法、减法、与乘法就不做讲解了，因为这些运算与我们所理解到的数学运算是完全相同的。后面的几个运算符在一定情况下得到的结果与预期值不同，需要做一点讲解。</p><h4 id="除法（-运算）"><a href="#除法（-运算）" class="headerlink" title="除法（/运算）"></a>除法（/运算）</h4><p>&emsp;&emsp;在数学运算中，如果使用不是很小心，除法是最容易出现问题的一个运算法则，我们首先看如下的一段程序，并分析程序的输出结果会是什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">5</span> / <span class="number">2</span></span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在我们的理解中，输出的结果应该是2.5，但是可能令人惊异的是其输出结果是2。其实在上述的代码中出现了两个问题：第一个问题是期望的结果是浮点型但是定义了整型，第二个问题则是整数的运算结果依旧是整数。我们依次对这两个问题进行解决：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">5</span> / <span class="number">2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果只改变了变量a的数据类型，其结果依旧是错误的，也就是说单独地改变结果的数据类型是没有作用的。从中我们可以分析得到，在这一条语句中是存在两个行为的：第一个行为是计算5/2，第二个计算则是将第一个行为的结果赋值给变量a。因此真正出现问题的地方是整数运算结果为整数的规则，所以我们不仅要改变变量a的数据类型，我们还要改变5或者2的数据类型。</p><p>&emsp;&emsp;解决办法有两种：</p><ol><li>对5或者2进行显式类型转换：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="keyword">float32</span>(<span class="number">5</span>) / <span class="number">2</span>or</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">5</span> / <span class="keyword">float32</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>直接将5或2写成浮点型</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">5.0</span> / <span class="number">2</span>or</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">5</span> / <span class="number">2.0</span>or</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">5.0</span> / <span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以说，在Go语言中，整数除以整数得到的结果依旧是整数这个特点可能会使程序运行中出现一定的错误，但是这个特性在很多场景中都得到了很好的应用，因为整数的除法是一种天然的对结果向下取整的运算过程。因此在实际运用中需要注意或利用这个特性。</p><h4 id="取模（-运算）"><a href="#取模（-运算）" class="headerlink" title="取模（%运算）"></a>取模（%运算）</h4><p>&emsp;&emsp;在计算机中也常常会出现取模运算，我们上一次接触到取模运算是在讲解二进制转换的时候。当时十进制转换到二进制的时候各个二进制位都是通过取模运算得到的。在Go语言中取模运算也十分常见，尤其是在出现环路的情况，例如输入任意一个时间数输出它的下一个或几个小时之后的时间。</p><p>&emsp;&emsp;那么我们在最开始学习数学接触到余数的时候往往都是正数的取余运算，其实Go语言中也是支持负数的取模运算的。首先我们看下面一段程序，并考虑其输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">fmt.Println(<span class="number">9</span> % <span class="number">4</span>)</span><br><span class="line">fmt.Println(<span class="number">9</span> % <span class="number">-4</span>)</span><br><span class="line">fmt.Println(<span class="number">-9</span> % <span class="number">4</span>)</span><br><span class="line">fmt.Println(<span class="number">-9</span> % <span class="number">-4</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果为 1、1、-1、-1，从中我们可以看出一个规律：取模结果的符号与被除数的符号相同，且除法得到的商也未必都是正数。在Go语言中做取模运算的时候，遵循着这样的一个公式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = a % b==&gt;  x = a - a / b * b</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将9%（-4）带入到公式中，我们可以计算出：9/（-4）=-2.25，取整数后结果为-2，(-2)*（-4）= 8，最后 9-8=1，同理其他的三个结果也可以通过这个方式得出。</p><h4 id="自加自减（-，–运算）"><a href="#自加自减（-，–运算）" class="headerlink" title="自加自减（++，–运算）"></a>自加自减（++，–运算）</h4><p>&emsp;&emsp;相信在C语言或Java语言的学习过程中，初学者都会对i++,++i,i–,–i以及这四个运算混在一起的运算感到头疼。Go语言开发者为了减少这几种运算带来的迷惑性，对自加自减的运算进行了很多的简化以及限制，接下来我们就针对自加自减的运算做出一些说明。</p><p>&emsp;&emsp;自加自减运算本质上是改变当前的变量值，并且变为其前驱或者后继，例如：i++可以完全等价于i=i+1，同时i–可以完全等价于i=i-1，这个运算在循环结构中用到的非常多。</p><ol><li>Go语言中自加自减都是后缀运算，即运算符只能放在变量的后面：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">i++<span class="comment">//正确i--同理</span></span><br><span class="line">++i<span class="comment">//报错：unexpected ++--i同理</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="2"><li>Go语言中自加自减运算只能作为独立的语句，不能出现在其他赋值等表达式中：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">i++<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">var</span> j <span class="keyword">int</span> = i++<span class="comment">//错误</span></span><br><span class="line">fmt.Println(i++)<span class="comment">//错误</span></span><br><span class="line"><span class="keyword">if</span> i++ &gt; <span class="number">0</span><span class="comment">//错误</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>&emsp;&emsp;赋值运算符根据其名字就可以理解，其作用就是为变量或常量赋值，我们已经接触过的便是’=’符号，也就是我们常用的等于号。除了’=’号之外，还有一些与其他运算符组合的赋值运算符，如’+=’，’-=’，’*=’，’/=’，’%=’，这些符号的用法都十分简单，我们就只针对一个举例并说明。还有一些与位运算相组合的运算符，我们在讲位运算后再提及。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">i += <span class="number">10</span></span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段代码的输出值为20，在Go语言中i+=10所表示的含义为i=i+10，所以这个运算的核心是加法，也就是等号前面的符号。但是这个加号不要受到后面表达式的影响，即便是后面的表达式中出现了比等号前的符号优先级低的符号，也不会受到影响，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">i *= <span class="number">10</span> + <span class="number">2</span></span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这里可能会出现两种答案，一种是120，另一种是102，当我们利用编译器验证后，我们会发现答案其实是120，出现这两种候选的原意是，有人会将其翻译为：i = i * 10 + 2，另一种是i = i *( 10 + 2)，当我们在下一节讲到优先级的时候就会明白为什么结果如第二个表达式，而不是第一个表达式。因为赋值运算符在众多运算符中的优先级是非常低的。</p><p>&emsp;&emsp;还有一个需要注意的地方就依旧是’/=’的使用，在运算法则中，整数的运算结果还是整数，这个点只要注意到，就基本不会出现问题的。</p><h3 id="比较运算符-关系运算符"><a href="#比较运算符-关系运算符" class="headerlink" title="比较运算符/关系运算符"></a>比较运算符/关系运算符</h3><p>&emsp;&emsp;在计算机处理数据中，常常会对数据进行比较，例如，输入的整数是否处在一定的范围之内，从网络接收到的字符串是否是空串，几个数是否相等等等。因此在这种情况下，我们需要一种运算来连接两个数据，并且其表达式的值是一个能够表示真假的量，关系运算符就是如此。</p><p>&emsp;&emsp;在Go语言中，关系运算符有：&gt;，&lt;，==，&gt;=，&lt;=，!=，分别对应于：大于，小于，等于，大于等于，小于等于，不等于。这些运算符都可以通过字面来理解，其含义想必也不必多说，其中需要注意的问题是：在Go语言中，判断两个数据是否相等是要用’==’符号，而不是’=’号。我们刚刚讲，一个等于号代表的是赋值，而两个等于号才代表相等，这个点在初学者的编程过程中非常容易出现。我们依旧举一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">fmt.Println(a &gt; b)</span><br><span class="line">fmt.Println(a &lt; b)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其结果分别是false和true，这与我们心中所认为的是相同的，也就不过多介绍了。其中需要注意的点便是浮点型数据的精度丢失问题，当判断两个多位数的浮点型数据时候，使用’==’符号可能会出现与常理不太相同的结果，因此浮点型数据相等的判断往往是|a-b|&lt;=c的模式，即两个数相减的绝对值小于某个极小值。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们主要介绍了Go语言中的三种运算符，分别为算数运算符，赋值运算符以及关系运算符。在算数运算符中集中需要注意的是除法的运算规则以及取模运算的算式，在赋值运算符中则要注意其优先级，在比较运算符中需要注意的是两个数相等时所用的’==’运算符。</p><p>&emsp;&emsp;在下一小节中，我们将继续讲解其他几种运算符，以及列出诸多运算符的优先级，这样读者可以在面对一个表达式的时候有理有据地得出其最终结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-14-gt-运算符-算数、赋值与比较运算符&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-14-gt-运算符-算数、赋值与比较运算符&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;14
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;13&gt; 指针类型简明讲述</title>
    <link href="http://yoursite.com/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/"/>
    <id>http://yoursite.com/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/</id>
    <published>2020-02-16T12:03:25.000Z</published>
    <updated>2020-02-16T12:07:51.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-13-gt-指针类型简明讲述"><a href="#Go语言从入门到放弃系列-lt-13-gt-指针类型简明讲述" class="headerlink" title="Go语言从入门到放弃系列&lt;13&gt; 指针类型简明讲述"></a>Go语言从入门到放弃系列&lt;13&gt; 指针类型简明讲述</h2><p>&emsp;&emsp;在上一节中，我们讲解了Go语言基本数据类型间的相互转化，以及在转化过程中可能遇到的精度丢失，数据溢出等现象。在其他基本数据类型与string类型相互转换的时候，我们讲解了转换所需要的函数方法。在这一节中，我们将介绍一种特殊的数据类型：指针类型。由于Go语言对于指针做出了许多的简化，使之不会出现像C语言一般令初学者谈指针色变。虽说我们在这一节直接介绍指针有些过于提前，不过后续经常会用到它，便在这里做一个简单的解释。</p><h3 id="指针的引入"><a href="#指针的引入" class="headerlink" title="指针的引入"></a>指针的引入</h3><p>&emsp;&emsp;在计算机科学中，指针是编程语言中的一个对象，利用地址的方式进行数据的存取。它的值直接指向存在于电脑内存或硬盘中的另一个地方的值，由于可以通过地址找到所需的变量单元，我们形象地将地址称为指针。简而言之，指针就是指内存中的一个地址。</p><p>&emsp;&emsp;用一个形象一些的例子，依旧是我们在说变量与变量名的那小节的例子。我们定义一个变量，这个变量具备一个变量名，就可以比作有一个人住在房子里且把这个房子取名为txg。其中这个人是变量的值，房子是分配的内存空间，屋子的名字txg是这个变量的名字，然而除了这些可以描述这个房子的人为属性之外，还有一个自然属性，就是这个房子的物理地址，比如说112 A’Beckett Street, Melbourne,VIC。也就是说除了通过访问txg来访问屋子之外，我们依旧可以通过物理地址来访问这个房子。</p><p>&emsp;&emsp;这个物理地址便可以理解为变量在内存中的真实位置，其值就是指针变量的值。我们知道计算机的内存是线性的且是连续的，每一个字节都可以用一个整数来表示，比如说想要访问内存中的第一个字节可以通过地址为0来访问，那么下一个字节就需要通过1来访问了。因此可以讲，指针类型所存储的值就是一个整数。</p><p>&emsp;&emsp;我们通过以下一个例子循序渐进地理解指针的含义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">fmt.Println(<span class="string">"a的值为："</span>,a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么当计算机在执行上述代码时，内存中会发生什么现象呢。首先计算机会分配8个字节给一个整型变量（我的计算机是64位），并且对该段内存赋予一个名字a。当输出的时候通过a的值进行访问该内存空间，并将该空间中的值输出来，可以通过如下的图进行理解：</p><p><img src="/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/1.png" alt></p><p>&emsp;&emsp;那么我们已经得到了名为a的变量，也同时知道的a的值，那么a所处在内存中的位置又是多少，我们可以采用&amp;运算符来获取，我们通过下一段程序进行说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">fmt.Println(<span class="string">"a的值为："</span>,a)</span><br><span class="line">fmt.Println(<span class="string">"a的地址为："</span>,&amp;a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果截屏如下所示：</p><p><img src="/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/2.png" alt></p><p>&emsp;&emsp;从中我们可以看到，不仅a的值可以顺利地打印出来，a所在的地址也被成功输出出来了，即0xc00000a168这个十六进制数的位置。换句话说，系统为a变量所分配的空间处在距离内存的起点处0xc00000a168的地方，且由于系统根据情况自动为变量分配空间，因此我们每个人不同时刻所得到的地址值可能是不尽相同的，此处只是一个案例。将其画在内存的表示图中为：</p><p><img src="/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/3.png" alt></p><h3 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h3><p>&emsp;&emsp;既然我们已经得到了整数a的物理地址，那么我们就相当于知道了指针变量中的变量值。指针变量是一种变量，其中的值为另一个变量的地址，我们在接下来的程序中进行快速入门：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;a</span><br><span class="line">fmt.Println(<span class="string">"p的值为："</span>, p)</span><br><span class="line">fmt.Println(<span class="string">"p指向的值为："</span>, *p)</span><br><span class="line">fmt.Println(<span class="string">"p的地址为："</span>, &amp;p)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将会得到如下的值，依旧需要注意的是内存分配是系统完成，读者得到的数值结果可能与我的不同：</p><p><img src="/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/4.png" alt></p><p>&emsp;&emsp;从上述结果中我们可以看出，我们定义了一个指向整数的指针变量p，且输出的p的值为0xc0000a168，且刚好就是a变量所在的内存地址，p所指向的值是100，也刚好便是a变量的值，同时因为指针变量也是一种变量，需要存在于内存中，因此，指针变量也具备一个物理地址，其当然也可以通过另一个指针来指向。</p><h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><p>&emsp;&emsp;在这里我们逐行对上述代码进行讲解。首先毫无疑问的定义一个整形变量a，并初始化其值为100。然后我们定义一个指向整数的指针变量，在这里定义过程中采用了*的方式进行定义，换句话说星号在定义阶段的出现是表明该变量是一个指针变量。然后我们采用&amp;符号的方式，将a变量的地址赋值给p指针，也就是常说的令p指针指向a。下一步直接输出p的值。再然后输出p所指向的值，在这里*又一次出现了，在变量的使用阶段使用星号，代表取出该指针指向的值。最后一行输出p的地址，我们依旧使用&amp;符号获取p变量的内存地址。将p也加入到内存表示图中为：</p><p><img src="/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/5.png" alt></p><h4 id="amp-符号和-符号"><a href="#amp-符号和-符号" class="headerlink" title="&amp;符号和*符号"></a>&amp;符号和*符号</h4><p>&emsp;&emsp;在这里我们特殊强调一下，我们可以将&amp;符号与*符号看做一组互逆的符号对：&amp;符号可以取出该变量的地址得到指针，*符号可以取出该指针所指向的值，我们通过下面一个小程序来验证这两个符号对的使用关系：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">fmt.Println(*&amp;a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果依旧为100，因为我们先通过&amp;符号得到了a变量的地址，然后立刻通过*符号取出该地址的值，当然结果依旧是100，我们也可以理解为这两个符号同时出现后发生了互相抵消的现象。我们再看下一段程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">fmt.Println(&amp;*a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们只是把两个符号相互调换了顺序，但是这时，程序是无法编译通过的，虽然是两个符号逻辑上可以互相抵消，但是在实现的时候却是先执行了*符号，然后执行了&amp;符号。然而a变量是一个整型变量，不是一个指针变量，因此对一个整数变量进行取地址中的值的运算时，即*运算时是错误的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;a</span><br><span class="line">fmt.Println(&amp;*p)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将程序修改至上述的样式，就可以正确执行了，因为此时的p就是一个指针，因此就可以执行*取值操作了，然后再取地址可以相互抵消，其输出值就是a变量的地址：0xc00000a168。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;a</span><br><span class="line">fmt.Println(*&amp;p)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以考虑一下上述代码能否正确执行，结果当然是可以执行的。我们最初提到指针变量也是变量，也具备一个地址，那么我们先对指针变量取地址，再对指针变量的地址进行取值，所得到的结果依旧是指针变量，换句话说是可以相互抵消的。其输出值依旧为:0xc00000a168。</p><h4 id="指针也具备数据类型"><a href="#指针也具备数据类型" class="headerlink" title="指针也具备数据类型"></a>指针也具备数据类型</h4><p>&emsp;&emsp;这个标题我其实想说的是，指针类型也是根据其指向的类型不同而不同的，例如*int表示的是指向整数的指针，*float32表示的是指向float32类型的指针。且不同种的指针类型之间是不可以乱赋值的。比如说：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">float32</span> = &amp;a</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码就是错误的，因为我们定义的a是整数变量，但是定义的指针p是指向float32类型的指针，最后我们将a的地址赋给该指针，这个在程序编译的过程中就会报错误。错误信息与之前也十分相似：cannot use &amp;a (type *int) as type *float32 in assignment。</p><p>&emsp;&emsp;我们可能会开始思考，指针的值就是变量的地址，就是内存的地址，换句话说就是一个十六进制的整数而已，既然都是整数，那指向不同数据类型的指针的意义何在。当我们在后面讲到数组的时候，我们会讲解到指针是可以移动的，且移动的长度与其指向的数据类型是相关的。比如指向int8类型的指针向后移动时，只需要移动一个字节就表示下一个int8了，而对于float32类型的指针来说，如果想通过指针移动得到下一个float32的值，则需要移动4个字节。因此写明该指针所指向的数据类型是十分必要的。</p><h4 id="注意空指针（野指针）"><a href="#注意空指针（野指针）" class="headerlink" title="注意空指针（野指针）"></a>注意空指针（野指针）</h4><p>&emsp;&emsp;到目前为止我们所见到的指针一般都是具有指向目标的，在上述的例子中p指针指向的是a变量。那么，如果一个指针变量没有指向任何的值，那么这个指针可以被称为野指针。指针变量和基本数据类型变量相似，也具备一个初始值零值，我们可以通过程序看指针的零值是什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span><span class="comment">//没有指向任何值</span></span><br><span class="line">fmt.Println(p)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将p的值直接输出来，我们会发现输出结果为：&lt;nil&gt;，而不是像之前一样输出一个十六进制的整数。&lt;nil&gt;的值表示为空，那么从空中妄图取出值，当然就会报错了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">fmt.Println(*p)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其错误信息为：runtime error: invalid memory address or nil pointer dereference.</p><h4 id="指针可以改变数据"><a href="#指针可以改变数据" class="headerlink" title="指针可以改变数据"></a>指针可以改变数据</h4><p>&emsp;&emsp;既然我们可以通过指针的值来访问到变量的值，那么我们也可以通过指针来改变变量的值，例如如下程序:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;a</span><br><span class="line">*p = <span class="number">200</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(*p)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中我们令p指针指向a变量，然后我们通过p指针进行取数据操作，然后将该数据修改为200，最后我们输出了a的值，也输出了p所指向的值，其运算结果为200和200。即通过指针进行修改时，是修改其指向的变量的值。我们再看下面一段程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;a</span><br><span class="line">p = <span class="number">200</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们在为p指针所指向的值赋值时，忘记写了前面的星号，导致了在逻辑上成为了如下的意思：将p的值（即a变量的地址）改变成200，这是绝对不允许的。因为计算机的内存的值从一开始就是设定好的，是无法进行修改的，错误信息为：cannot use 200 (type int) as type *int in assignment</p><h3 id="值类型与引用类型"><a href="#值类型与引用类型" class="headerlink" title="值类型与引用类型"></a>值类型与引用类型</h3><p>&emsp;&emsp;在这里我们只是简要地解释一下值类型与引用类型的概念，这两个概念非常的简单，但是在后续的学习过程中经常出现，我们也会在出现的时候进行强调说明。同时这两个类型涉及到太多的尚未提及的知识，目前只是记住这个概念就好。</p><p>&emsp;&emsp;1. 值类型：一般来说，我们提到的基本数据类型，如int系列，float系列，bool类型，string以及结构体（struct）和数组都是值类型。值类型的特点是：变量直接存储值，内存通常在栈中分配。我们之前举的例子都是值类型的。</p><p>&emsp;&emsp;2. 引用类型：指针是一个最为常见的引用类型，除此之外还有切片（slice），map，管道（chan），接口（interface）等，其特点为：变量存储的是一个地址，这个地址所对应的空间才是真正存储数据的空间，内存通常在堆中分配。当没有任何变量引用到那些真正存储数据的地址时，这个地址所对应的空间就再也无法被调用，且被垃圾回收机制（GC）所回收。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们集中介绍了指针的相关概念，并通过一些例子形象地引出了指针的含义，然后我们对指针的定义、两个符号的关系、以及指针指向的数据类型的含义、野指针的问题进行了讲解。最后又对值类型与引用类型做出了引出，在后续讲解其他知识点的时候会反复提及。</p><p>&emsp;&emsp;在下一小节中，我们将集中地详细地介绍Go语言中的运算符，内容比较散碎，依旧会通过一些例子讲解不同类型的运算符在使用过程中所需要注意的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-13-gt-指针类型简明讲述&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-13-gt-指针类型简明讲述&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;13&amp;gt; 指针类型简明讲述&quot;
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;12&gt; 基本数据类型的转换</title>
    <link href="http://yoursite.com/2020/02/15/12-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/02/15/12-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-02-15T08:04:38.000Z</published>
    <updated>2020-02-15T08:05:39.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-12-gt-基本数据类型的转换"><a href="#Go语言从入门到放弃系列-lt-12-gt-基本数据类型的转换" class="headerlink" title="Go语言从入门到放弃系列&lt;12&gt; 基本数据类型的转换"></a>Go语言从入门到放弃系列&lt;12&gt; 基本数据类型的转换</h2><p>&emsp;&emsp;在上几个小节中，我们针对Go语言中的基本数据类型进行简要的描述，以及对各个基本数据类型在使用过程中可能出现的问题以及需要注意的点进行了详细的说明。在这一节中，我们将继续集中讲解Go语言中基本数据类型的互相转换方式，以及所用到的相关的函数等。</p><h3 id="不同数据类型的转换"><a href="#不同数据类型的转换" class="headerlink" title="不同数据类型的转换"></a>不同数据类型的转换</h3><p>&emsp;&emsp;我们首先介绍同类型的相互转换方式，例如int8转换为int32、float64转换为float32等。Go语言在这点上与C语言、Java语言等不同，Go语言在不同类型的变量之间赋值时需要进行显式转换，而不能自动转换。例如在Java语言中，我们完全可以将byte类型的数据直接赋值给int类型的数据完成自动转换，因为变量可容纳的空间是由小到大，因此不会出现数据溢出的问题，但是在Go语言中，我们需要明确地显式转换。 </p><p>&emsp;&emsp;大致上来说，Go语言中的类型转换都可以遵循一个语法：T(V)，其含义为将V的数据类型转换成T的数据类型。T是转换后的类型，如int32、float32等等，V是需要转换的变量，我们先写一段程序举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float32</span> = <span class="keyword">float32</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="keyword">uint8</span> = <span class="keyword">uint</span>(i)</span><br><span class="line">fmt.Println(i,f,u)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从以上程序中我们可以看出，我们首先定义了一个int类型的变量，并初始化为10，接着我们希望将这个int变量中的值赋给一个float32和uint8类型的变量，然后再输出，其输出结果为三个10，也就是说在这个类型转换过程中是成功的。接下来我们验证一下Go语言中数据类型不可以自动转换的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int8</span> = <span class="number">127</span></span><br><span class="line"><span class="keyword">var</span> bi <span class="keyword">int64</span> = i</span><br><span class="line">fmt.Println(bi)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在编译这段代码的时候，系统就会报出错误，其错误类型是：cannot use i (type int8) as type int64 in assignment。也就是int8类型的数据不能直接赋值给int64类型的数据，尽管理论上不会出现数据溢出的现象，也不会有任何的数据方面的问题。所以说Go语言对于数据类型的定义以及赋值限制是十分严格的。</p><h3 id="类型转换过程中的数据精度问题"><a href="#类型转换过程中的数据精度问题" class="headerlink" title="类型转换过程中的数据精度问题"></a>类型转换过程中的数据精度问题</h3><p>&emsp;&emsp;既然数据类型可以相互转换，则势必会出现数据精度丢失的问题，以及数据溢出的问题，例如我们将多字节的整数的值赋给一个少字节的整数，则可能会出现数据溢出，将浮点型数据向整数转换时小数的值会丢失。接下来我们写程序验证一下这两种事情发生时的情况。</p><h4 id="整数数据溢出"><a href="#整数数据溢出" class="headerlink" title="整数数据溢出"></a>整数数据溢出</h4><p>&emsp;&emsp;这个问题我们其实在整数精讲的部分时候已经提及过数据溢出的现象以及成因了，在这里我们只是通过程序验证一下这个现象并且通过例子更为深入地了解一下这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i32 <span class="keyword">int32</span> = <span class="number">456</span></span><br><span class="line"><span class="keyword">var</span> i8 <span class="keyword">int8</span> = <span class="keyword">int8</span>(i32)</span><br><span class="line">fmt.Println(i8)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出结果为-56，从程序中，我们可以明显地看出来456这个数值已经超出了int8所能表示的数据范围，如果强行将其赋给int8，我们会发现编译过程中是不报错的，同时也是可以正确输出结果的。下面我们就解释一下-56这个数字的由来，也顺便复习一下二进制与码制的知识点。</p><p>&emsp;&emsp;首先我们看到456是一个正数，因此其补码与原码相同，我们将其转换为二进制后可以得到如下的结果（除模取余，倒序输出）:0111001000，然后由于int8数据类型只分配到了8个二进制位的空间，因此超出8个二进制位的部分被全部舍弃，其结果变为11001000（第一个1溢出舍弃）。现在我们观察一下当前的结果，我们发现符号位为1，因此得到的这个数字是个负数，我们再根据补码规则，将其还原为原码：10111000（符号位不变，从右向左从第一个1以后所有位取反），根据二进制向十进制的转换关系为-56。</p><h4 id="浮点型向整数转换"><a href="#浮点型向整数转换" class="headerlink" title="浮点型向整数转换"></a>浮点型向整数转换</h4><p>&emsp;&emsp;由于整数是无法显示小数的，且整数与浮点型的表示方式也不甚一致，因此我们通过下面的一段程序来探究浮点型向整数转换时的小数问题，以及依旧可能出现的精度丢失问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">float32</span> = <span class="number">456.5</span></span><br><span class="line"><span class="keyword">var</span> i8 <span class="keyword">int8</span> = <span class="keyword">int8</span>(f)</span><br><span class="line">fmt.Println(i8)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据输出结果，我们会发现输出结果依旧是-56，也就是说，在浮点型数据向整型数据转换的时候，其小数位全部丢失，整数位根据整数之间的转换的原则进行数据溢出判断。所以相当于依旧是456向int8进行转换，根据上述的分析过程，我们依旧可以得到结果为-56。</p><h4 id="其他转换细节"><a href="#其他转换细节" class="headerlink" title="其他转换细节"></a>其他转换细节</h4><p>&emsp;&emsp;在大型的程序开发，或者说在多人的合作开发中，每个人完成特定的函数编写，因此可能存在数据类型不一致的情况，因此在计算过程中也可能会出现数据类型的转换，接下来我们举两个例子来完成类型转换的细节讲解。</p><p>&emsp;&emsp;首先我们看如下的一段程序，判断这段程序能否通过编译：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1 <span class="keyword">int32</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> n3 <span class="keyword">int8</span></span><br><span class="line">n2 = n1 + <span class="number">20</span></span><br><span class="line">n3 = n1 + <span class="number">20</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;答案是不能通过编译，因为数据类型不匹配，第一个错误类型依旧为：cannot use n1+20 (type int32) as type int64 in assignment。因此一个数据类型加一个常数，所得到的数据类型依旧是当前的数据类型。所以int32加20之后依旧是int32。接下来我们下面的一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1 <span class="keyword">int32</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="keyword">int64</span> = <span class="number">20</span></span><br><span class="line">n3 := n1 + n2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序中我们分别定义了int32和int64的值，并将两个值相加赋值给n3，我们利用类型推导来完成赋值，现在我们猜n3是什么数据类型。接触过C或者Java的人可能会回答n3的类型为int64，实则不然，因为这段程序根本无法编译，错误类型为：invalid operation: n1 + n2 (mismatched types int32 and int64)。因此不仅仅是赋值过程中不能隐式转换，就是运算过程中也不可以。如果我们将n2显式转换为int32后，编译通过，n3当然也就是int32类型。</p><p>&emsp;&emsp;第二个细节，是程序运算过程中的数据溢出判定，我们先看下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1 <span class="keyword">int32</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="keyword">int8</span></span><br><span class="line"><span class="keyword">var</span> n3 <span class="keyword">int8</span></span><br><span class="line">n2 = <span class="keyword">int8</span>(n1) + <span class="number">127</span></span><br><span class="line">n3 = <span class="keyword">int8</span>(n1) + <span class="number">128</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述程序中，是否能通过编译呢，答案依旧是不能，其错误的语句在于n3 = int8(n1) + 128，报出的错误为128溢出了int8数据类型，因此我们说，即便是’+’号两边的数据类型一致了，编译器也会检查两边的数据是否出现溢出的现象。对于加127那行语句，我们逻辑上可以看出数据溢出了，但是不会报错，程序运行也不受影响，但是128那一行会报错，因此在实际开发中需要注意。</p><h3 id="其他类型与string相互转化"><a href="#其他类型与string相互转化" class="headerlink" title="其他类型与string相互转化"></a>其他类型与string相互转化</h3><p>&emsp;&emsp;在实际开发中，我们常常会将其他基本数据类型与string类型相互转换，例如在网络传输过程中，我们会将实体类的各个属性转换成为一个字符串进行传输，在另一端收到字符串后会将其反序列化为实体类，其中的过程就是类型之间的互相转换。</p><h4 id="其他类型转string"><a href="#其他类型转string" class="headerlink" title="其他类型转string"></a>其他类型转string</h4><p>&emsp;&emsp;总体来说，其他数据类型向string类型转换时有两个常用的方法，分别是fmt包中的Sprintf函数以及strconv包中的几个函数，我们分别举例讲解：</p><ol><li>Sprintf函数，这个函数的签名为：fmt.Sprintf(“%参数”,表达式)，这个类型与fmt包中Printf输出函数十分的类似，如果我们使用Printf函数十分熟练的话，这种方式就非常简单了。无非就是将数据转成字符换和将数据转换成字符串后打印到屏幕上的区别，我们举一个例子：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"Devin"</span></span><br><span class="line"><span class="keyword">var</span> isAdult <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> info <span class="keyword">string</span></span><br><span class="line">info = fmt.Sprintf(<span class="string">"Name is %s age is %d isAdult is %t"</span>, name, age, isAdult)</span><br><span class="line">fmt.Println(info)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的程序的含义为：定义了几种数据类型的变量，并通过Sprintf方式将其格式化形成一个字符串，最后将这个字符串打印到屏幕上。经过运行后，我们会发现屏幕上输出了：Name is Devin age is 25 isAdult is true。也就是说，我们成功地将属性转换成了字符串，格式中的%d之类的表示方法与输出函数相同，可以参考前几节中我们讲到的知识点。</p><ol start="2"><li>strconv包中函数，这个包中的函数在转换过程中主要会用到以下4个函数，分别为：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatBool</span><span class="params">(b <span class="keyword">bool</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="keyword">float64</span>, fmt <span class="keyword">byte</span>, prec,bitSize <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="keyword">int64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatUint</span><span class="params">(i <span class="keyword">uint64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这些函数我们直接就在代码实践中以注释形式解释参数的含义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> num1 <span class="keyword">int32</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="keyword">float64</span> = <span class="number">12.345</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">str1 := strconv.FormatInt(<span class="keyword">int64</span>(num1), <span class="number">8</span>)</span><br><span class="line"><span class="comment">//注意输入参数的数据类型，参数是int64，因此要强转，8为基数，即以8进制形式转换，可选为2,8,10,16</span></span><br><span class="line">str2 := strconv.FormatFloat(num2, <span class="string">'f'</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"><span class="comment">//参数为float64，fmt表示格式: 'f':ddd.dd ,'b':dddp(+-)ddd(二进制科学计数法),'e':ddde(+-)ddd(十进制科学计数法)...</span></span><br><span class="line"><span class="comment">//10为保留10位小数，64指代传入的是float64，可选值为64和32</span></span><br><span class="line">str3 := strconv.FormatBool(b)</span><br><span class="line"><span class="comment">//传入布尔值，将其转换成字符串</span></span><br><span class="line">fmt.Println(str1)</span><br><span class="line">fmt.Println(str2)</span><br><span class="line">fmt.Println(str3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">144</span></span><br><span class="line"><span class="number">12.3450000000</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中FormatInt函数和FormatUint函数参数相同，也不做过多介绍了。</p><h4 id="string转其他基本类型"><a href="#string转其他基本类型" class="headerlink" title="string转其他基本类型"></a>string转其他基本类型</h4><p>&emsp;&emsp;string转向其他基本数据类型依旧使用的是strconv包中的函数，我们将其列出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="keyword">string</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(f <span class="keyword">float64</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(i <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseUint</span><span class="params">()</span><span class="title">s</span> <span class="title">string</span>, <span class="title">base</span> <span class="title">int</span>, <span class="title">bitSize</span> <span class="title">int</span>) <span class="params">(n <span class="keyword">uint64</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述的函数描述中，我们首次看到了两个返回值的函数，即bool值和error值，因此我们在调用的时候需要两个变量进行承接。我们依旧采用程序例子的方式进行说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str1 := <span class="string">"true"</span></span><br><span class="line">str2 := <span class="string">"100"</span></span><br><span class="line">str3 := <span class="string">"12.345"</span></span><br><span class="line">v1, _ := strconv.ParseBool(str1)</span><br><span class="line"><span class="comment">//暂时不关心error，所以采用_标识符进行接收</span></span><br><span class="line">v2, _ := strconv.ParseInt(str2, <span class="number">10</span>, <span class="number">32</span>)</span><br><span class="line"><span class="comment">//10表示以10进制形式转换，如果该值为0则根据字符串判断，出现0x为16进制，以0开头为8进制，否则10进制</span></span><br><span class="line"><span class="comment">//32表示结果可以赋值给int32，该值可选为0,8,16，32,64，分别对应int，int8，int16，int32，int64</span></span><br><span class="line"><span class="comment">//要求该数值指定结果必须能够无溢出地赋值</span></span><br><span class="line">v3, _ := strconv.ParseFloat(str3, <span class="number">32</span>)</span><br><span class="line"><span class="comment">//32表示：结果可以不改变精确值地赋给float32，可选值为32和64</span></span><br><span class="line">fmt.Printf(<span class="string">"v1的类型为%T,v1的值为%t\n"</span>, v1, v1)</span><br><span class="line">fmt.Printf(<span class="string">"v2的类型为%T,v2的值为%d\n"</span>, v2, v2)</span><br><span class="line">fmt.Printf(<span class="string">"v3的类型为%T,v3的值为%f\n"</span>, v3, v3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v1的类型为<span class="keyword">bool</span>,v1的值为<span class="literal">true</span></span><br><span class="line">v2的类型为<span class="keyword">int64</span>,v2的值为<span class="number">100</span></span><br><span class="line">v3的类型为<span class="keyword">float64</span>,v3的值为<span class="number">12.345000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据输出结果，我们可以看出其转换过程是成功的，且返回值分别是bool，int64，以及float64，当我们得到结果并且向转换成其他数据类型如int32时，可以再行显式转换。</p><p>&emsp;&emsp;值得注意的问题是，假如类型转换失败会发生什么现象，例如我们将”true”转换为整数，这时就需要用到error的值了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"true"</span></span><br><span class="line">v1, err := strconv.ParseInt(str, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">fmt.Println(v1)</span><br><span class="line">fmt.Println(err)</span><br><span class="line">v2, err := strconv.ParseBool(str)</span><br><span class="line">fmt.Println(v2)</span><br><span class="line">fmt.Println(err)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">strconv.ParseInt: parsing <span class="string">"true"</span>: invalid syntax</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以发现当数据转换成功的时候，是可以输出正确的值的，并且error的类型为nil，当数据转换不成功的时候，得到的值为该数据类型的<strong>零值</strong>，且error的类型是invalid syntax，因此在做数据类型转换的时候我们往往会根据err是否为nil来判断转换是否成功，所以我们一般会如下去写（使用到分支结构后续会详细讲解）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"Hello"</span></span><br><span class="line">v, err := strconv.ParseInt(str, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"类型转换出错"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在本小结中，我们集中讲解了Go语言的基本数据类型之间的互相转化，讨论了由高精度到低精度，高容量到低容量的转换过程中出现的问题，以及string类型与其他基本类型转换过程中使用到的函数与注意事项。整体来说，本节讲的知识点偏细，且比较杂，但难度不大。读者可以不必现在完全记住这些，当使用的时候，再回来仔细看即可。</p><p>&emsp;&emsp;在下一节中我们将集中介绍另一个数据类型：指针，并对指针数据类型的定义、使用、注意事项等进行详细地说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-12-gt-基本数据类型的转换&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-12-gt-基本数据类型的转换&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;12&amp;gt; 基本数据类型的
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;11&gt; 基本数据类型精讲-字符和字符串</title>
    <link href="http://yoursite.com/2020/02/14/11-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/02/14/11-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-02-14T06:19:09.000Z</published>
    <updated>2020-02-14T06:20:38.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-11-gt-基本数据类型精讲-字符和字符串"><a href="#Go语言从入门到放弃系列-lt-11-gt-基本数据类型精讲-字符和字符串" class="headerlink" title="Go语言从入门到放弃系列&lt;11&gt; 基本数据类型精讲-字符和字符串"></a>Go语言从入门到放弃系列&lt;11&gt; 基本数据类型精讲-字符和字符串</h2><p>&emsp;&emsp;在介绍Go语言的基本数据类型时，我们同时也提及了布尔型变量、复数类型以及字符串，并单独介绍了Go语言中不存在但是一些其他语言存在的字符型变量。复数类型在开发过程中不怎么常用，而布尔型变量我们会在条件结构的章节中详细地介绍，因此在这一节中，我们将集中讲述字符和字符串类型的各个注意事项以及一些细节点。</p><h3 id="（字符型）"><a href="#（字符型）" class="headerlink" title="（字符型）"></a>（字符型）</h3><p>&emsp;&emsp;我们在这里用括号括起来依旧是表示这个类型是不存在的，但是为了介绍方便以及引出字符串的注意点，我们依旧将它作为一种数据类型进行讲解。在前面的介绍中，我们可知Go语言中的字符不仅仅局限于数字、字母等传统ASCII字符集，而是囊括了各个国家的各种语言。因此虽说byte和rune类型均表示字符型类型，但是除非明确运用在英语国家，我们一般还是会运用rune类型。</p><h4 id="ASCII字符集"><a href="#ASCII字符集" class="headerlink" title="ASCII字符集"></a>ASCII字符集</h4><p>&emsp;&emsp;ASCII字符集是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他的西欧类语言。同时也是在西方英语国家中最为常用且通用的单字节编码系统，现在包括UTF-8编码在内的UNICODE编码均向下兼容了ASCII编码模式。一般来说，ASCII码是使用7位或8位二进制位的组合来表示128种或256种可能的字符。在早期ASCII码用于传输的时候是128个，也就是占据了7个二进制位，后来IBM公司根据字节这个最小单位所拥有的位数拓展成了256个字符，但日常编程中常用的是前128个。</p><p><img src="/2020/02/14/11-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/1.png" alt></p><p>&emsp;&emsp;上图即为ASCII码与字符之间的匹配关系（图片来源于网络），从图中看，我们可以找到几点规律：</p><p>&emsp;&emsp;1. 从编号为33的字符开始直到编号为126的字符，均是我们日常开发中在键盘上可以见到的、常用的字符，包括数字、字母、与众多标点等。其余的字符均是控制类与传输类的字符，往往需要转义才能得到。</p><p>&emsp;&emsp;2. 数字从0到9，字母从a到z，字母从A到Z的编码值分别是连续的，但是其之间是不连续的。在字符参与运算过程中，例如’A’+2，其结果为’C’，原理与整数相加是相同的。</p><p>&emsp;&emsp;3. 在编程过程中需要尤其注意0，’0’，与’\0’的关系，在上一节介绍用字符串表示浮点数与整数以消除其误差的时候，过程中的一环便是将字符型的数字转换成内存中的相应的数字，解决办法便是对每一位的值均实行减48的操作，这样计算结果才是正确的，前期练习的时候可能会在这个地方犯错。</p><p>&emsp;&emsp;接下来我们利用循环（后面会讲到）在控制台输出前128个字符，我们会发现还是有许多有趣的字符的：</p><p><img src="/2020/02/14/11-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/2.png" alt></p><p>&emsp;&emsp;从中我们看到了笑脸、看到了心、还看到了许多莫名其妙的字符，这些奇怪的字符代表的均是控制类和传输类的字符，如果仔细听，我们还会听到计算机的蜂鸣器发出了‘嘟’的一声，这个是因为ASCII码为7的字符发出的，其结果就是令蜂鸣器发出声音。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>&emsp;&emsp;在前面的阐述中，我们将字符串阐述成为字符的有序合集，是由一个个字符所构成的，但是这种说法不甚确切，准确地说Go语言的字符串是由字节所构成的。根据UTF-8编码规则可知，每个字符占据三个字节，所以Go语言中的字符串长度与其占据的字节数是不相同的。在Go语言的字符串使用中，我们需要注意以下的几个点：</p><h4 id="字符串是常量"><a href="#字符串是常量" class="headerlink" title="字符串是常量"></a>字符串是常量</h4><p>&emsp;&emsp;这个特性在很多语言中均是如此，字符串在定义过程中就已经分配好了空间，且不能通过类似数组方式进行单个字符的替换，例如如下程序，我们希望将Hallo中的’a’字符替换成’e’字符，这个操作是非法    的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hallo"</span></span><br><span class="line">str[<span class="number">1</span>] = <span class="string">'e'</span></span><br><span class="line">fmt.Println(str)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其报错信息为：cannot assign to str[1]，所以字符串一旦赋值了，字符串就不能更改了。当对字符串进行拼接操作时，例如如下程序，将Hello与World拼接起来，可以采用+号进行拼接:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello"</span></span><br><span class="line">str = str + <span class="string">" World"</span></span><br><span class="line">fmt.Println(str)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;程序输出结果为Hello World，将两个字符串拼在了一起，看起来像是将World单词拼接在了Hello的后面，实则不是。在执行这个操作的时候，内存中生成了两个字符串，分别为Hello和Hello World，只是str由原来的指向Hello变成了指向Hello World字符串。原来的Hello字符串由于没有任何变量指向它了，就被Go的GC机制回收并释放了内存。</p><h4 id="字符串的两种表示方式"><a href="#字符串的两种表示方式" class="headerlink" title="字符串的两种表示方式"></a>字符串的两种表示方式</h4><p>&emsp;&emsp;在前面的举例中，我们都用双引号进行字符串的表达，这个就不再举例了，前面的例子已经足够说明这种方式了，在这里我们介绍的是第二种表示方式，即利用反引号进行表示。反引号是我们键盘上左上角，esc按键下的那个按键，利用反引号可以使字符串以原生的形式进行表示，其中就包含了换行与特殊字符，可以实现防止攻击，输出源代码等效果，例如我们想输出一句Hello “World”，在World的两边输出双引号，如果利用双引号我们将需要写成如下的字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello \"World\""</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也就是说我们需要使用转义字符来手动控制字符串中的格式，否则遇见双引号字符串就提前结束了，因此这点在输出源代码的时候就会非常的困难，取而代之，我们可以利用如下的定义方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">`Hello "World"`</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样就可以将双引号原样输出，我们再举个例子，将程序的源代码输出：</p><p><img src="/2020/02/14/11-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/3.png" alt> </p><p>&emsp;&emsp;从上述代码中，我们可以发现使用反引号时可以将双引号、换行符、乃至于制表符都可以直接输出出来，这个特点在用Go做服务器的时候可以得到很多的使用。</p><h4 id="len函数与Sizeof函数"><a href="#len函数与Sizeof函数" class="headerlink" title="len函数与Sizeof函数"></a>len函数与Sizeof函数</h4><p>&emsp;&emsp;在字符串中我们往往需要知道其长度或占据了多少个字节，我们就因此引入两个函数，len函数的返回值表示了字符串的长度。而unsafe包下的Sizeof函数不太一致，其代表了字符串数据类型在内存中占用的空间，这个问题需要说明一下，否则很容易理解错误。我们首先来看纯英文的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">   <span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"unsafe"</span></span><br><span class="line">   )</span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello"</span></span><br><span class="line">   fmt.Println(<span class="built_in">len</span>(str))</span><br><span class="line">   fmt.Println(unsafe.Sizeof(str))</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过程序编译运行后，我们会发现输出的结果分别为5和16，也就是说，Hello这个字符串的长度为5，在内存中被分配了16个字节。相信字符串长度为5这个很好理解，但是字符串占据16个字节就有些问题了，我们先记下不表，现在我们将视线放在中文字符串上（只写main函数中）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"中国"</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(str))</span><br><span class="line">fmt.Println(unsafe.Sizeof(str))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序的输出结果为6和16，这个6也相对好理解，因为每个汉字都占据3个字节，两个汉字占据了6个字节是没问题的，但是通过Sizeof输出的结果依旧是16，而且不论什么字符串，结果都是16。可见通过Sizeof得到的值与字符串本身内容是不相关的。我们接下来解释一下这个问题。</p><p>&emsp;&emsp;有些人最初可能会将它与C语言中的sizeof函数进行类比，但通过分析它与C语言中的是完全不同的。Go语言中的Sizeof总是在编译期就进行求值而不是在运行期间求值。在Go语言中字符串类型其实对应于一个结构体，该结构体中有两个属性，换句话说字符串类型是由两部分构成的。第一部分为指向该字符串的指针（后续会讲到），第二部分为字符串的长度，每个部分都用了8个字节来存储各自的内容，而字符串的值本身则是在另一段连续的内存中储存着。就如同一个遥控器，一台电视一般，字符串数据引用是遥控器，字符串中的值是电视，Sizeof所测量的是遥控器的尺寸，而不是电视的大小。</p><h4 id="字符串拼接时’-’的位置"><a href="#字符串拼接时’-’的位置" class="headerlink" title="字符串拼接时’+’的位置"></a>字符串拼接时’+’的位置</h4><p>&emsp;&emsp;这个问题十分的简单，我们就举两个例子进行说明，这只是一个规定：当字符串过于长而不得不使用多行来赋值时，’+’的位置需要出现在字符串该行的结尾，而不是下一行的开头：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello"</span> +</span><br><span class="line"><span class="string">" World"</span></span><br><span class="line">fmt.Println(str)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码的编译是可以通过的，并且可以得到正确的结果。如果程序写成如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello"</span> </span><br><span class="line">+ <span class="string">" World"</span></span><br><span class="line">fmt.Println(str)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在编译过程中就会出现错误，错误的类型为：invalid operator: + untyped string。这个问题注意一下即可。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小结中，我们集中介绍了字符型数据类型的注意事项，包括ASCII码与字符的对应关系，以及其遵循的规律等。以及字符串在定义、使用过程中所需要注意的几点问题。包括常量的属性、表示方式、字符串长度函数以及拼接过程中+符号所需要处在的位置。在下几节中，我们将继续对基本数据类型进行讲解，集中举例说明数据类型之间的转化方式，例如将整数的值转换为字符串等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-11-gt-基本数据类型精讲-字符和字符串&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-11-gt-基本数据类型精讲-字符和字符串&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;11
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;10&gt; 基本数据类型精讲-整型和浮点型</title>
    <link href="http://yoursite.com/2020/02/13/10-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E6%95%B4%E5%9E%8B%E5%92%8C%E6%B5%AE%E7%82%B9%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/02/13/10-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E6%95%B4%E5%9E%8B%E5%92%8C%E6%B5%AE%E7%82%B9%E5%9E%8B/</id>
    <published>2020-02-13T04:41:54.000Z</published>
    <updated>2020-02-13T04:42:48.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-10-gt-基本数据类型精讲-整型和浮点型"><a href="#Go语言从入门到放弃系列-lt-10-gt-基本数据类型精讲-整型和浮点型" class="headerlink" title="Go语言从入门到放弃系列&lt;10&gt; 基本数据类型精讲-整型和浮点型"></a>Go语言从入门到放弃系列&lt;10&gt; 基本数据类型精讲-整型和浮点型</h2><p>&emsp;&emsp;在前几节中我们详细地讲述了Go语言中二进制的基础，基本数据类型和Go语言中标识符的规定及使用。在接下来的几节中，我们将针对之前提到的几种基本数据类型进行详细地讲解，并对程序开发中可能出现的问题进行讲解和原因的解释。</p><h3 id="整型变量的细节讨论"><a href="#整型变量的细节讨论" class="headerlink" title="整型变量的细节讨论"></a>整型变量的细节讨论</h3><p>&emsp;&emsp;首先，我们先复习一下之前所讲的基本数据类型中的整型变量，整型变量的定义按是否有符号可以分为有符号整数和无符号整数。有符号整数的最高位表示符号位，且0代表正数，1代表负数，无符号整数的最高位参与数字的表示，即只能表示正数。在intN类型中的N代表计算机系统为该类型分配多少个二进制位数，即int8为8位，int16为16位。不同的整数类型对于数值的表示大小是不相同的，我们在接下来的讲解中会以int8为例。</p><p>&emsp;&emsp;既然每种整数类型可以表示的数值范围大小是一定的，那么一旦其中存储的数据超出了其可以表示的最大的范围会发生什么呢，我们将以以下的几个例子进行详细地说明：</p><h4 id="赋值时越界"><a href="#赋值时越界" class="headerlink" title="赋值时越界"></a>赋值时越界</h4><p>&emsp;&emsp;首先我们知道，int8可以表示的范围为-128到127，我们看下面的一段代码（只写main函数中的代码了）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="keyword">int8</span> = <span class="number">128</span></span><br><span class="line">fmt.Println(num)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过对上述程序的分析，我们知道，将128赋值给int8是会出现数值越界的情况的，因为其可表示的最大的数值只为127。在开发阶段出现了这类数值越界的代码时，编译器会帮助我们进行检查，因此这段代码是无法编译通过的，而且其错误类型显示为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constant <span class="number">128</span> overflows <span class="keyword">int8</span></span><br><span class="line">即常量<span class="number">128</span>溢出了<span class="keyword">int8</span>所能表示的范围</span><br></pre></td></tr></table></figure><h4 id="运行时越界"><a href="#运行时越界" class="headerlink" title="运行时越界"></a>运行时越界</h4><p>&emsp;&emsp;既然在变量的赋值过程中是不会出现数据溢出的（否则编译不通过），那么在运行时是否会出现数据越界呢，一旦出现的数据越界程序是否会做出相应的响应，例如程序停止运行等行为。现在我们进行验证一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="keyword">int8</span> = <span class="number">127</span></span><br><span class="line">num = num + <span class="number">1</span></span><br><span class="line">fmt.Println(num)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;程序中出现的num=num+1的意思是，取出num所代表的值，进行加1运算后将结果再赋值给num。在这个过程中，我们会预见在做完加1运算后就又出现了数值溢出现象，经过编译运行后，我们会发现编译过程是不报错误的，同时运行过程中也没有任何的错误消息产生的，当我们看到输出结果时，我们会发现其结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-128</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在我们可以考虑一下为什么会是这个结果，在介绍原码、反码与补码的章节中，我们提到了正0和负0的问题，即00000000和10000000的问题，我们人为地将10000000所代表的数定为-128。首先我们将127转换为2进制表示方法，其结果为01111111，现在我们在此基础上加1，我们会发现通过进位后其结果成为10000000，而这个数字刚好是-128。</p><p>&emsp;&emsp;反过来思考，如果我们首先将num赋值为-128，然后在此基础上减1，其结果会显示为127，也正如当初举的时钟的例子一般，正数最大值和负数最小值是相连的。分析过程是相似的，读者可以自行思考。</p><p>&emsp;&emsp;接下来我们将目光放置在无符号整数上，例如uint8，之前我们曾经介绍过，uint8的表示范围为0到255，那么同样在开发过程中赋越界的值时会编译错误，所以我们依旧关注的是运行过程中数据越界的问题，看如下的程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="keyword">uint8</span> = <span class="number">255</span></span><br><span class="line">num = num + <span class="number">1</span></span><br><span class="line">fmt.Println(num)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以分析得，按照上述最大值和最小值相连的规律，其输出结果为0，由于该整数是一个无符号整数，因此最高位参与了计数，所以255用二进制表示为11111111（8个1），我们在其基础上加1后，经过一系列的进位运算，其结果应该是100000000（1后面有8个0），但是uint8数据类型只得到了8个二进制位的空间，因此最高位（第9位）的数据溢出并舍弃，所以计算结果为： 00000000（8个0）也就是0。逆过程可以自行思考。</p><p>&emsp;&emsp;在应用过程中有一个十分常见的例子，便是字符的表示方式。如果表示ASCII码，byte型就可以完全存储了，但是如果想存储汉字，那么byte就会出现越界，需要用rune类型数据进行存储。当然，用rune类型来存储ASCII字符也是没有问题的，程序验证如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">byte</span> = <span class="string">'中'</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其编译过程中会出现错误，异常信息为：const 20013 overflows byte，由此看出，’中’这个字符在UTF-8编码中的数值为20013，这个数值明显超出了byte所存储的范围，因此会报错。</p><p>&emsp;&emsp;所以，在整数的定义与表示过程中，无论定义了空间多大的整数，都会出现数据溢出的可能，因为每个整数都有确定的数据表示范围。因此针对不同的数据范围需求来选择对应的数据类型是十分重要的，否则在程序运行中会出现意想不到的问题，而这个问题并不涉及任何的逻辑上的错误。比如说我们定义一个变量，令该变量每次都加1，一直加到该变量为500为止，如果我们使用了uint8类型，那么这个程序就永远也停不下来了，因为255后的值又回归到0了。当然我们也可以采用int64来存储，但是针对这个需求而言，int64又有些内存的浪费了（虽说现在基本上不缺这点内存），所以选择适合的数据类型来完成特定的工作是一件需要考虑乃至于优化的事情。</p><h3 id="浮点型变量的细节讨论"><a href="#浮点型变量的细节讨论" class="headerlink" title="浮点型变量的细节讨论"></a>浮点型变量的细节讨论</h3><p>&emsp;&emsp;浮点型的存储过程中精度丢失一直都是一个无法回避的问题，这个问题在大规模的精确计算过程中十分的常见，精度丢失的问题甚至可能会导致逻辑上的问题。根据我们之前对数据类型的介绍，不论是float32还是float64类型的变量，其可表示范围都十分的广阔，同时我们也讲解了浮点型数据在内存中的存储方法，因此一般来说float32所能精确地表示小数位数为6<del>7位，而float64能表示为15</del>16位，超出的精度部分往往就会丢失了，我们来看下面的一段程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">1.00000001</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span> = <span class="number">1.0000001</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(b)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的一段程序中，我们为a和b两个变量分别赋值，并且在程序的最后输出这两个值。根据我们刚提及的精度丢失问题以及小数保留位数，我们会发现：最终的结果为a=1，b=1.0000001。可以说b的值的输出是正常的，但是a的值却产生了错误。其原因便是超出精度范围的数值被忽略了。如果我们依旧对于精度丢失所产生的问题不甚理解的话，那么我们可以再看一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">3.3333333</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span> = <span class="number">6.6666666</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">float32</span> = a + b</span><br><span class="line">fmt.Println(c)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可能令人大跌眼镜的是，这个运算结果也就是c的值为10，第一个例子中超出精度的部分被舍弃了，而在第二个例子中超出精度的部分就进了1位。这种问题既不可以被归结为编译的错误，也不可以归结为逻辑的错误，而是说这个错误出现的原因是由语言本身和机器本身所导致的。更确切地说是由浮点型数据的存储方法和二进制十进制对应关系所导致的。接下来我们从两个角度简要说明一下精度丢失的成因。</p><p>&emsp;&emsp;第一个成因便是<strong>进制转换时的精度丢失</strong>，在进制转换的那一小节中，我们抛出了一个问题，是否每一个有限的十进制数都有一个有限位数的二进制数相对应，我们对这个问题的解答是否定的。也就是说我们在用十进制数编程时，再用计算机转换成二进制码的时候，精度就已经丢失了一次了，这个丢失是内部原因导致的，也是基本无法避免的。</p><p>&emsp;&emsp;第二个成因便是<strong>浮点数的表示方法</strong>，按常理来说，一个有限位数的浮点型变量居然能表示那么大的范围，其精度必然是不会非常高的。我们在前几节介绍了浮点数的存储方式，即符号位、指数部分、和尾数部分。指数部分代表了科学计数法中的幂次，剩余的部分则表示在尾数部分，由于尾数部分也是有位数限制的，因此也会出现类似于整数一样的数据溢出问题的。因此太多的小数位数将溢出尾数部分，而保留的就是前几位未溢出的部分，因此在浮点数的存储方法中，会出现二次的精度损失。</p><p>&emsp;&emsp;那么一旦真的需要精度十分高的浮点型乃至于数值极为庞大的整数运算时，有一种解决办法便是利用字符串，字符串中的每一个字符值都是一个精确的数字。换句话说，利用字符串，在内存中所保存的是一系列的int8类型，每个int8对应于真值的每一位。同时Go语言开发者也向用户封装了基于字符串所表示的数据的数学运算函数，在需要时可以调用。详细源码可以研读Go语言中的math/big包。</p><p>&emsp;&emsp;利用字符串表示数据虽解决了数据存储与表示的问题，但是这种方式也有其特定的弊端。当我们利用int、float32等提供的数据类型进行运算操作时，系统在计算机底层予以其特殊的优化手段，使之计算速度有极大的提升。而利用字符串进行运算，则会拖慢运行速度，在一些已定义的函数中无法作为参数而不得已只好自行包装、改写函数。</p><p>&emsp;&emsp;不过话说来，浮点数精度丢失的问题一般不会影响到我们程序开发，在应用级的开发中往往不会用到8位小数之后，而且float64所提供的有效精度也足够使用了。但是在科学计算中，或在大规模的银行系统中，精度就会成为一个不得不慎重考虑的问题。曾经有一个生物信息专业的同学给我讲述过一个事情，在做DNA匹配计算过程中需要将各种的变异均考虑进去，并且得到的匹配结果十分的相似。此时问题就是，究竟是这两个DNA相同但是因为计算精度问题而显示成不同，还是说两种DNA真的是不同只是不同点比较少但是比较重要。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们主要讲述了Go语言中整数和浮点数使用注意事项，集中说明了整数中的数据溢出问题和浮点型数据中的精度丢失问题。这两个问题在计算机语言中是普遍存在的问题，不仅仅是Go语言中单独的问题。这两种问题在日常开发中几乎不会遇到，但是在实际工作中一旦出现了某种周期性问题或没有明显逻辑错误的问题时，这两个原因不失为一种考虑方向。</p><p>&emsp;&emsp;在下一节中，我们将针对于剩下的几种基本数据类型进行精讲，同时也将讲解在开发过程中可能出现的问题及原因。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-10-gt-基本数据类型精讲-整型和浮点型&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-10-gt-基本数据类型精讲-整型和浮点型&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;10
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;9&gt; 标识符、输出及转义字符</title>
    <link href="http://yoursite.com/2020/02/12/9-%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%8C%E8%BE%93%E5%87%BA%E5%8F%8A%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2020/02/12/9-%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%8C%E8%BE%93%E5%87%BA%E5%8F%8A%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</id>
    <published>2020-02-12T06:34:31.000Z</published>
    <updated>2020-02-12T06:36:05.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-9-gt-标识符、输出及转义字符"><a href="#Go语言从入门到放弃系列-lt-9-gt-标识符、输出及转义字符" class="headerlink" title="Go语言从入门到放弃系列&lt;9&gt; 标识符、输出及转义字符"></a>Go语言从入门到放弃系列&lt;9&gt; 标识符、输出及转义字符</h2><p>&emsp;&emsp;在上一小节中，我们集中介绍了变量的定义、变量的使用过程、初始化过程以及多变量的赋值。同时，我们也验证了每种基本数据类型的初始值的设定。在这一节中，我们将分别介绍Go语言中标识符的概念、合法性以及两个输出函数的使用方式，最后将对（字符型）数据中的转义字符进行介绍。</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>&emsp;&emsp;在上一节中我们介绍变量的时候提到了变量名，严格来说变量名就是一种标识符，标识符不仅仅针对于变量名，而是变量、方法、函数等命名时所使用的字符序列，均称之为标识符。简而言之便是：程序中但凡需要自己取的名字就是标识符。</p><h4 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h4><p>&emsp;&emsp;同其他的编程语言相似，Go语言中的标识符的规则也是可以由三部分构成：字母、数字、下划线，且不能以数字开头。在Go语言中，变量也是大小写敏感的，换句话说就是大写字母构成的标识符和同样字母但是小写所构成的标识符是不同的。既然标识符只能通过这三种字符构成，其他的如空格、回车、美元符号等都是非法的。我们举一些例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello <span class="keyword">int</span><span class="comment">//合法</span></span><br><span class="line"><span class="keyword">var</span> hello123 <span class="keyword">int</span><span class="comment">//合法</span></span><br><span class="line"><span class="keyword">var</span> Hello <span class="keyword">int</span><span class="comment">//合法，且与hello是不同的</span></span><br><span class="line"><span class="keyword">var</span> is_adult <span class="keyword">bool</span><span class="comment">//合法</span></span><br><span class="line"><span class="keyword">var</span> <span class="number">1</span>hello <span class="keyword">int</span><span class="comment">//不合法，数字不可以开头</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中需要说明的是，只由一个下划线所构成的标识符（’_’）是具备特殊含义的，在Go语言中称之为空标识符，其可以代表任何一个标识符，其中的值也是被忽略的。一个经典的例子便是，在Go语言中一些函数的返回值可能有多个，我们在使用的时候可能只希望获得其中的一个或忽略其中的某些，就可以通过下划线标识符来接收，这样程序不会因为返回值数量不匹配而报错，也不会因为定义了变量但没有使用而报错。举例如下（涉及函数知识，可后期再理解）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMaxAndMin</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> num1 &gt;= num2 &#123;</span><br><span class="line"><span class="keyword">return</span> num1, num2</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num2, num1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, b := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">c, _ := getMaxAndMin(a, b)</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;假设getMaxAndMin函数是其他人所实现的函数，我们无法去修改其内容，并且其中会返回最大值和最小值两个数，而我们只希望使用最大值而忽略掉最小值，就可以用’_‘来接收最小值并将其抛弃。那么问题来了，在上述的程序中我们能否输出’_‘以查看其中的值呢，答案是不能，报错的信息就是”不能把_视为一个值”。</p><p>&emsp;&emsp;除此之外，在为标识符取名的时候，还存在一些限制，即不能以系统保留的关键字作为表示符，如break、if、import、func等等。我们将会在下表中列举出系统保留的关键字：</p><table><thead><tr><th align="center">if</th><th align="center">else</th><th align="center">switch</th><th align="center">case</th><th align="center">default</th></tr></thead><tbody><tr><td align="center">break</td><td align="center">continue</td><td align="center">package</td><td align="center">import</td><td align="center">func</td></tr><tr><td align="center">for</td><td align="center">goto</td><td align="center">select</td><td align="center">interface</td><td align="center">defer</td></tr><tr><td align="center">go</td><td align="center">map</td><td align="center">struct</td><td align="center">chan</td><td align="center">const</td></tr><tr><td align="center">fallthrough</td><td align="center">range</td><td align="center">type</td><td align="center">return</td><td align="center">var</td></tr></tbody></table><p>&emsp;&emsp;上述提到的25个系统保留的关键字是绝对不可以使用在标识符里的，这些关键字在我们当使用集成开发工具编程的时候会自动变色，以提醒开发者这些词是不可以使用的。这些关键字中暂时有好多我们都不曾见过，不过我们会在后续的小节中一一接触到。</p><p>&emsp;&emsp;除了25个系统保留的关键字以外，Go语言中还提供了36个预定的标识符，这些标识符包括了期初数据类型和系统内建函数。这个特性是其他编程语言中所没有的特性，这36个标识符如下：</p><table><thead><tr><th align="center">int</th><th align="center">int8</th><th align="center">int16</th><th align="center">int32</th><th align="center">int64</th><th align="center">uint</th></tr></thead><tbody><tr><td align="center">uint8</td><td align="center">uint16</td><td align="center">uint32</td><td align="center">uint64</td><td align="center">byte</td><td align="center">rune</td></tr><tr><td align="center">uintptr</td><td align="center">float32</td><td align="center">float64</td><td align="center">complex64</td><td align="center">complex128</td><td align="center">string</td></tr><tr><td align="center">bool</td><td align="center">complex</td><td align="center">real</td><td align="center">append</td><td align="center">cap</td><td align="center">close</td></tr><tr><td align="center">copy</td><td align="center">false</td><td align="center">true</td><td align="center">imag</td><td align="center">iota</td><td align="center">len</td></tr><tr><td align="center">make</td><td align="center">new</td><td align="center">nil</td><td align="center">panic</td><td align="center">error</td><td align="center">recover</td></tr></tbody></table><p>&emsp;&emsp;在上述的表格中，我们依旧发现有好多我们都见过，并且在变量定义的时候也曾经用过。而且与一般编程语言所不同的是，这些标识符是可以被使用的。例如在Java语言中，int不可以被定义为标识符，但在Go语言中是可以的，换句话说 var int int 这条语句是成立的。但是，对于具备其他语言开发经验的开发者，这个用法是受到绝对抵制的，即便是编译器能正常运行。例如下面的这段程序，会对初学者产生极大的困惑和误导：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">byte</span> <span class="keyword">int</span> = <span class="string">'A'</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">string</span>, <span class="keyword">float32</span> = <span class="keyword">byte</span>, <span class="keyword">byte</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span> + <span class="keyword">float32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出结果是130，看起来各种的变量类型名都出现了一遍，但是其中只有一个数据类型：整型。所以这种用法十分不被推荐，如果哪个开发者以这种形式进行开发，这个人就很，，，不走寻常路。</p><h3 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h3><p>&emsp;&emsp;在这里我们只是简要地讲解几个常用的基本的输出函数，分别为Print()函数、Println()函数、以及Printf()函数。这三个函数都在fmt包中，也就是说如果使用这三个函数，都需要引入fmt包。接下来我们分别对这三个函数进行简要的叙述：</p><ol><li>Print函数和Println函数</li></ol><p>&emsp;&emsp;这两个函数的唯一区别便是输出的时候是否换行，当用Println函数的时候，函数将一个字符串输出之后会换到下一行，而Print函数则会接着当前的输出继续执行。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"Hello "</span>)</span><br><span class="line">fmt.Println(<span class="string">"Devin"</span>)</span><br><span class="line">输出结果为：</span><br><span class="line">Hello</span><br><span class="line">Devin</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;而</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Print(<span class="string">"Hello "</span>)</span><br><span class="line">fmt.Print(<span class="string">"Devin"</span>)</span><br><span class="line">输出结果为：</span><br><span class="line">Hello Devin</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Println函数的括号中（Print函数相同），我们可以传入一些任何类型的变量，而不单单只能传入字符串。例如我们在打印多个信息的时候，我们可以将多个信息通过逗号的形式进行分割，并在输出的时候进行拼接，例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age :=<span class="number">25</span></span><br><span class="line">name := <span class="string">"Devin"</span></span><br><span class="line">fmt.Println(<span class="string">"age is "</span>, age , <span class="string">" name is "</span> , name)</span><br><span class="line">输出结果为：</span><br><span class="line">age is <span class="number">25</span> name is Devin</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也就是说在输出过程中我们将三个字符串类型和一个整数类型的变量传给Println函数，这个函数将所有的参数均转换成了字符串并且按传入的顺序输出。</p><ol start="2"><li>Printf函数</li></ol><p>&emsp;&emsp;Printf函数往往被称之为格式化输出函数，我们可以将希望输出的格式预先规定好，然后向这个格式中填入数据，而不需要像Println函数一样拼接那么多的字符串，那么多的变量。例如：我们希望输出的是age is ‘占位符’ name is ‘占位符’，然后我们再向这个模板中填入25和Devin，就可以输出为age is 25 name is Devin。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"age is %d name is %s"</span>, age , name)</span><br><span class="line">其输出结果为：</span><br><span class="line">age is <span class="number">25</span> name is Devin</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中的%d和%s均为占位符，后面的age和name与这两个占位符分别对应，需要注意的是，后面的变量个数要与占位符的个数相同，且输入的数据类型要与占位符规定的数据类型相同，接触过C语言的开发者对这个应该十分的熟悉。</p><table><thead><tr><th>格式</th><th align="center">含义</th></tr></thead><tbody><tr><td>%%</td><td align="center">输出一个%</td></tr><tr><td>%d</td><td align="center">以十进制形式输出一个整数</td></tr><tr><td>%b</td><td align="center">以二进制形式输出一个整数</td></tr><tr><td>%o</td><td align="center">以八进制形式输出一个整数</td></tr><tr><td>%x(X)</td><td align="center">以十六进制形式输出一个整数且用小写字母（大写字母）表示</td></tr><tr><td>%c</td><td align="center">以字符形式输出一个整数（字符与整数一一对应）</td></tr><tr><td>%f</td><td align="center">输出一个浮点型数据（float32和float64均可使用）</td></tr><tr><td>%t</td><td align="center">以true或者false形式输出一个布尔值</td></tr><tr><td>%T</td><td align="center">输出对应的变量的数据类型</td></tr><tr><td>%v</td><td align="center">自动识别输出类型并输出（会把byte和rune识别成为整数形式）</td></tr></tbody></table><p>&emsp;&emsp;以上的这些就是常用的在输出的过程中使用到的占位符，在Printf函数中会经常使用到。</p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>&emsp;&emsp;这个小知识点我之前在写Java的时候将其写在了字符型数据的讲解中，但是在Go语言中没有这个数据类型，但是放在字符串中又不太合适，就单独写在这里了，转义字符的个数十分地多，我在这里也不一一罗列了，在实际使用的过程中慢慢积累，而且在网络中搜索转义字符也有许多的列表。</p><p>&emsp;&emsp;之前我们说起过计算机中的英文相关的字符可以用一个byte数据类型所存储，我们接触到的也一般都是字母、数字、格式的标点符号等这些能够通过键盘所打出来的字符，然而还有许多的字符是键盘打不出来的，比如说我们希望在一个字符串中存储一个换行的字符（也就是回车），当打印这个字符串时，遇到这个换行字符时自动到下一行输出。而当我们在编程的时候，按下回车键后光标就到了下一行了，字符串中并不能保存这个换行的字符。</p><p>&emsp;&emsp;再举一个例子便是，当我们在输出的时候希望输出的内容具有一些格式，使输出更为规范、有序。其中一个方法就是使用制表符（也就是Tab键），但是当我们编程的时候按下tab键，就直接将源代码向后空出制表间隔了，字符串中依旧没有存下来。因此，我们需要转义字符。</p><p>&emsp;&emsp;转义字符也是一种字符，我们通过键盘可以打出来的字符通过转义的形式，使其代表那些键盘打不出来的字符。转义的方式为’\字符’，例如’\n’，’\t’、’\0’,也就是’\‘这个字符可以将它后面的这个字符合起来共同表示一个其他的含义，比如’\n’代表回车，’\t’代表制表符，’\0’代表字符串的结尾。它们不是两个字符而是一个字符，那么当我们真的就希望输出一个\该如何去做，如果单单输出一个\，它会和后面的字符进行转义，因此，我们想输出\的时候，我们依旧需要将其转义，使用’\\‘（直接复制markdown的话会出现四个\，因为markdown中也要转义），其意思为第一个\表示后面的要转义了，第二个\表示转义后的字符就想输出为\。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info := <span class="string">"Hello World \nI am \t\t Devin"</span></span><br><span class="line">fmt.Println(info)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果为：</p><p><img src="/2020/02/12/9-%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%8C%E8%BE%93%E5%87%BA%E5%8F%8A%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/1.png" alt></p><p>&emsp;&emsp;Hello World后有回车，am和Devin中间有两个水平制表符。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们集中讲述了Go语言的标识符的概念，以及标识符的命名规则，系统定义的关键字的内容以及保留标识符的内容。同时我们也集中介绍了两种输出的形式，在后续的代码中会经常使用到的两种输出形式。最后我们介绍了转义字符的引出和概念，也提到了几个常用的转义字符，转义字符需要在平时进行慢慢地积累。</p><p>&emsp;&emsp;在之后的几个小节中，我们将针对不同的基本数据类型进行精讲，集中说明在使用这些数据的时候需要注意到的问题，以及出现问题的内部的原因以和解决方案等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-9-gt-标识符、输出及转义字符&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-9-gt-标识符、输出及转义字符&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;9&amp;gt; 标识符、输出
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;8&gt; 变量的定义及使用</title>
    <link href="http://yoursite.com/2020/02/11/8-%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/11/8-%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E4%BD%BF%E7%94%A8/</id>
    <published>2020-02-11T04:22:18.000Z</published>
    <updated>2020-02-12T06:37:11.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-8-gt-变量的定义及使用"><a href="#Go语言从入门到放弃系列-lt-8-gt-变量的定义及使用" class="headerlink" title="Go语言从入门到放弃系列&lt;8&gt; 变量的定义及使用"></a>Go语言从入门到放弃系列&lt;8&gt; 变量的定义及使用</h2><p>&emsp;&emsp;在上一小节中，我们集中说明了数据在内存中的存储形式，以及Go语言的各个基本数据类型、所分配的字节数、以及其可以表示的数据范围的大小。在这一节中，我们将使用之前说到的数据类型，结合变量的概念，讲述程序中的变量以及需要注意的地方。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>&emsp;&emsp;首先我们需要解释一下什么是变量，变量来源于数学，是计算机语言中存储计算结果或能表示值得抽象概念。根据字面的理解为可以变化的量，在生活中也具备许多的常用的例子，比如说人的年龄会随着时间而变化，日期会随着月份周期性变化。在计算机中，一个变量的值也可以发生变化。可以发生变化的值为变量，不能发生变化的值为常量，如圆周率等。</p><p>&emsp;&emsp;一般来说，在计算机语言中，每个变量都存在一个名字，这个名字与这个变量在一定的空间内是一一对应的。也就是说，程序开发者可以通过该名字来访问该变量的值，也可以通过名字来修改该变量的值。我们可以将其比喻为一间屋子，且每间屋子中都只能有一个人，屋子为变量本身，屋子中的人为变量的值，屋子的门牌号为变量的名字。</p><h4 id="变量使用的基本步骤"><a href="#变量使用的基本步骤" class="headerlink" title="变量使用的基本步骤"></a>变量使用的基本步骤</h4><p>&emsp;&emsp;一般来说，变量的使用可以分为三个步骤，分别为：变量的定义、变量的赋值、变量的使用。在这里，我们将通过几个例子分别对着三个过程进行简要的阐述。</p><h5 id="1-变量的定义（变量的声明）"><a href="#1-变量的定义（变量的声明）" class="headerlink" title="1. 变量的定义（变量的声明）"></a>1. 变量的定义（变量的声明）</h5><p>&emsp;&emsp;在这个阶段中，我们需要首先做的是确定这个变量的类型。比如说，如果我们希望存储的是一个人的年龄，我们当然会选择使用整数来存储，如果我们希望存储的是一个人的成绩或工资，那么我们将会采用浮点数的形式来存储。如果我们使用了错误的数据类型，我们可能将会面临因为精度丢失而导致的计算结果错误的风险，乃至于程序编译时发生编译错误。</p><p>&emsp;&emsp;基本数据类型的变量的定义基本满足于一个公式：var 变量名 数据类型，我们举一些例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span><span class="comment">//定义一个字符串用来存姓名</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int32</span><span class="comment">//定义一个整数用来存年龄</span></span><br><span class="line"><span class="keyword">var</span> salary <span class="keyword">float32</span><span class="comment">//定义一个浮点型用来存工资</span></span><br><span class="line"><span class="keyword">var</span> character <span class="keyword">byte</span><span class="comment">//定义一个整型（字符型）用来存字符</span></span><br><span class="line"><span class="keyword">var</span> isAdult <span class="keyword">bool</span><span class="comment">//定义一个布尔值用来存是否成年</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么在数据定义过程中会内存中发生什么变化，在程序执行到定义这一行的时候，内存会分配给这个变量名一段连续的空间，空间的大小根据数据类型而定。在这段内存空间中存在一个初始的值，我们称之为零值，不同的数据类型的零值不同，我们会稍后列出。</p><h5 id="2-变量的赋值"><a href="#2-变量的赋值" class="headerlink" title="2.变量的赋值"></a>2.变量的赋值</h5><p>&emsp;&emsp;在变量定义过后，即内存中已然出现了连续的空间后，我们便可以为之填充新的数值，这个过程可称之为赋值。由于变量中本身存在于一个零值，而赋值过后新的值将会代替原来的零值，因此在变量的多次赋值时，后一次的值将会覆盖掉原来的值，而保留的是最后一次修改后的值。依旧用房间打比方，我们为这个房间分配新的住户时，原来的住户需要搬离。变量的赋值过程如下（采用上述的数据的定义）:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"Devin"</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line">slary = <span class="number">1234.5</span></span><br><span class="line">chracter = <span class="string">'A'</span></span><br><span class="line">isAdult = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里需要注意的一点是，在Go语言中，数据类型的区别是十分严格的，在一些编程语言中存在着数据类型的隐式转换与显式转换，例如，可以利用‘+’将整数转为字符串，而在Go中是不允许的。</p><h5 id="3-变量的使用"><a href="#3-变量的使用" class="headerlink" title="3.变量的使用"></a>3.变量的使用</h5><p>&emsp;&emsp;变量的使用便不需要多做描述了，如何去使用这个变量也很难穷尽，不论是进行再赋值操作还是参与数学运算都是可以的。我们便举一个完整的例子表明变量的使用的全部过程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span><span class="comment">//变量的定义</span></span><br><span class="line">age = <span class="number">25</span><span class="comment">//变量的赋值</span></span><br><span class="line">fmt.Println(age)<span class="comment">//变量的使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-变量的初始化"><a href="#4-变量的初始化" class="headerlink" title="4.变量的初始化"></a>4.变量的初始化</h5><p>&emsp;&emsp;在上述的过程中，我们会发现变量的使用都要通过定义、赋值后才能进行使用，我们可能会觉得这个操作十分的麻烦，因此变量的初始化可以将变量的定义与赋值过程结合在一起，这样就会十分简便了。初始化的定义也是在变量定义时直接给与赋值操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"Devin"</span></span><br><span class="line"><span class="keyword">var</span> isAdult <span class="keyword">bool</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="变量使用中的注意事项及细节"><a href="#变量使用中的注意事项及细节" class="headerlink" title="变量使用中的注意事项及细节"></a>变量使用中的注意事项及细节</h3><h4 id="1-类型自动推导"><a href="#1-类型自动推导" class="headerlink" title="1.类型自动推导"></a>1.类型自动推导</h4><p>&emsp;&emsp;在上述的讲解中，我们提到了：数据定义过程中需要明确这个变量的数据类型，之后再进行其他的操作，但是在变量的初始化过程中其实已经出现了数据类型。因此，Go语言底层有一种机制，即根据用户所输入的值自动推导这个值得数据类型，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Devin"</span></span><br><span class="line"><span class="keyword">var</span> isAdult = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> salary = <span class="number">1000.0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;即相比于初始化过程，略去了数据类型定义的部分。在上述的例子中，Go语言底层会将age的类型自动识别为整数（int类型），name识别为字符串（string类型），isAdult识别为布尔值（bool类型），salary识别为浮点型（float64类型）。在这里需要注意的是浮点型的自动类型推导，我们需要在后面加入小数点，否则将会被推导成为整数。</p><p>&emsp;&emsp;在自动推导的定义过程中，我们会发现，几乎每个定义都有一个var的关键字，因此这个关键字也是可以省略的，不过如果仅仅是这样就会与变量的赋值相混淆了，因此在省略var关键字且初始化数据时，需要采用<strong>:=</strong>的方式进行定义，上述的程序可以改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age := <span class="number">25</span></span><br><span class="line">name := <span class="string">"Devin"</span></span><br><span class="line">isAdult := <span class="literal">true</span></span><br><span class="line">salary := <span class="number">1000.0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用变量的定义时，有一个需要注意的地方，即定义的变量名在相同的作用域中是不应该被定义过的，否则将会出现重定义，导致编译过程的错误（作用域的概念在后期会介绍到）。这一点在使用自动类型推导时容易出现错误。</p><h4 id="2-多变量的声明"><a href="#2-多变量的声明" class="headerlink" title="2.多变量的声明"></a>2.多变量的声明</h4><p>&emsp;&emsp;当我们需要定义多个同类型的数据时，比如说我们需要存储一个人的学号、姓名、住址等几个字符串信息时，我们当然可以分为多行进行定义，每一行定义一个数据，我们也可以在一行中将同样数据类型的变量同时定义，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, id, address <span class="keyword">string</span><span class="comment">//一行中定义三个字符串变量</span></span><br><span class="line">name = <span class="string">"Devin"</span><span class="comment">//分别使用</span></span><br><span class="line">id = <span class="string">"123456"</span></span><br><span class="line">address = <span class="string">"Liaoning Province"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们也可以采用初始化的形式，在一行中定义后直接使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, id, address <span class="keyword">string</span> = <span class="string">"Devin"</span>, <span class="string">"123456"</span>, <span class="string">"Liaoning Province"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;甚至直接类型推导:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, id, address = <span class="string">"Devin"</span>, <span class="string">"123456"</span>, <span class="string">"Liaoning Province"</span></span><br><span class="line">name, id, address := <span class="string">"Devin"</span>, <span class="string">"123456"</span>, <span class="string">"Liaoning Province"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;多个不同的数据类型的定义中，我们也可以采用小括号的形式进行定义以及初始化，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">age <span class="keyword">int</span> = <span class="number">25</span></span><br><span class="line">name <span class="keyword">string</span> = <span class="string">"Devin"</span></span><br><span class="line">isAdult = <span class="literal">true</span></span><br><span class="line">) </span><br><span class="line">或者</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">age = <span class="number">25</span></span><br><span class="line">name = <span class="string">"Devin"</span></span><br><span class="line">isAdult = <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要说明的一点是，在数据类型的自动推导过程中，可以不限制于同样的数据类型，不同的数据类型也是可以在同一行定义推导的，不过这种用法相对来说比较奇怪，习惯于传统语言开发的开发者可能会觉得相对不习惯：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name, age, isAdult := <span class="string">"Devin"</span>, <span class="number">25</span>, <span class="literal">true</span>   <span class="comment">//自动推导name为string，age为int，isAdult为bool</span></span><br></pre></td></tr></table></figure><h4 id="3-基本数据类型的零值"><a href="#3-基本数据类型的零值" class="headerlink" title="3.基本数据类型的零值"></a>3.基本数据类型的零值</h4><p>&emsp;&emsp;在这里我们将介绍Go语言中基本数据类型的零值。在一些编程语言中，为数据定义但不进行赋值是一种危险的行为，其值可以是一个没有意义的值。为了防止这种现象的发生，Go语言中明确定义了各种基本数据类型的零值。在一些开发过程中，有些人可能会利用零值的数值进行部分代码的省略，比如定义一个整数并为这个整数赋值为0。然而整数的零值就是0，所以一些开发者便只定义而不赋值，但是这种做法不是很推荐。</p><p>&emsp;&emsp;为了表明各个基本数据类型的零值，我们便采用下方的程序进行简单的验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">complex64</span></span><br><span class="line">fmt.Println(<span class="string">"a="</span>, a, <span class="string">" b="</span>, b, <span class="string">" c= "</span>, c, <span class="string">" d= "</span>, d, <span class="string">" e = "</span>, e, <span class="string">" f= "</span>, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其结果分别为：</p><p><img src="/2020/02/11/8-%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E4%BD%BF%E7%94%A8/1.png" alt></p><p>&emsp;&emsp;从中可知，整数的零值为0，浮点型的零值也为0，字符串的零值为空串（即””），字符型（整型）为0， 布尔值的零值为false，复数的零值为（0+0i）。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们集中介绍了变量的定义以及使用的过程，即定义、赋值、使用。同时我们也介绍了变量的初始化、自动推导类型等简便的使用方式。除此之外，我们也讲述了变量定义中的一些细节，如多变量的声明，以及各个基本数据类型的零值。在接下的几节中，我们将针对不同的数据类型进行更为详细的讲解，以及各个基本数据类型的互相转换等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-8-gt-变量的定义及使用&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-8-gt-变量的定义及使用&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;8&amp;gt; 变量的定义及使用&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
