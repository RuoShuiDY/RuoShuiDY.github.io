<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>云钰的亭轩阁</title>
  
  <subtitle>Running water never goes stale, so you gotta just keep on flowing.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-06T12:18:39.226Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Devin DENG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;56&gt; 终章-Socket网络编程</title>
    <link href="http://yoursite.com/2020/04/06/56-%E7%BB%88%E7%AB%A0-Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/04/06/56-%E7%BB%88%E7%AB%A0-Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2020-04-06T12:17:52.000Z</published>
    <updated>2020-04-06T12:18:39.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-56-gt-终章-Socket网络编程"><a href="#Go语言从入门到放弃系列-lt-56-gt-终章-Socket网络编程" class="headerlink" title="Go语言从入门到放弃系列&lt;56&gt; 终章-Socket网络编程"></a>Go语言从入门到放弃系列&lt;56&gt; 终章-Socket网络编程</h2><p>&emsp;&emsp;在上个小节中，我们主要讲解了Go语言的反射技术。在这个小节中，我们将开始讲解Go语言中tcp/ip中socket编程的部分。对网络稍有了解的读者可能会知道网络编程中还有http协议的编写以及相应的cookie、session等操作，但是这个部分我将其归属在Go Web部分，因此在这个系列中我们不做讲解，我们只讲解更为基层的socket编程。 </p><p>&emsp;&emsp;由于Go语言对socket编程的封装已然很好了，因此这个小节我们其实主要是带读者查询以及实现一下对应的API，完成最基本的服务器与客户端之间的信息交互。更为复杂的问题基本上都是简单问题的罗列，只是需要处理更多的冲突而已。 </p><h3 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h3><p>&emsp;&emsp;在这个部分，我们主要讲解与socket编程相关的网络基础，而对于更为广泛的知识点我们就不做提及了，如果读者有兴趣可以专门系统地去学习计算机网络，里面会有更为全面的讲解。因为封装的特性，用户可以不必知道某个函数方法的底层做了什么，只需要在特定的环境下调用特定的方法即可。因此我也只说到这个层面为止。 </p><p>&emsp;&emsp;首先说什么是socket，socket也被称之为套接字，用于描述机器的IP地址与端口。socket也是一个通信句柄，客户端与服务器通过套接字发出请求与回复网络请求。在计算机系统中，套接字其实就是一种文件，亦或是文件模式的一种特殊的实现。文件可以有打开、关闭、读取、写入等操作，因此socket也具备这些操作。socket可以完成不同计算机之间的数据传输，例如QQ消息，网页操作等均是socket通信完成的。 </p><p>&emsp;&emsp;那么tcp/ip协议和udp协议与socket又有什么关系，tcp/ip与udp其实是两种协议，而socket则是操作系统实现的、面向两种协议簇的接口。因此可以说tcp/ip是一种规定，而socket是针对这个规定的实现。我们通过Go语言实现网络通信是在操纵socket，理论上来说不需要深度了解tcp/ip与udp的协议内容。但是既然是网络通讯还是简单说明一下tcp/ip协议与udp协议的区别： </p><p>&emsp;&emsp;tcp/ip协议是一种可靠的连接的协议，当两端通过tcp/ip协议通讯时首先通过三次握手建立连接，然后才可以互相发送请求。当连接需要关闭的时候，在进行四次挥手完成断开。因此数据的传输是在成功建立的连接的基础上的，因此当网络中出现丢包的现象时，两端是可以检测到的。 </p><p>&emsp;&emsp;而udp协议相对而言就比较简单了，他是一种无连接的传输方式。即不需要复杂的断开与连接，不需要确定客户端、服务器是否能收到发出的消息。只要知道了对方的ip和端口，就可以直接发送。因为其省却了建立连接与断开连接的繁杂的步骤，因此其效率更高，但是由于数据传输不以建立连接为基础，所以它并不安全。如果用一个形象的比喻来说：tcp/ip更像是打电话，电话接通了才能讲话，而udp更像是写信，信一旦寄出去可能顺利到达，也可能丢失在不知名的角落。 </p><h3 id="IP与端口"><a href="#IP与端口" class="headerlink" title="IP与端口"></a>IP与端口</h3><p>&emsp;&emsp;在上一个部分中我们提到了，socket网络传输是通过IP地址和端口号来完成的。IP地址是为网络中的电脑进行编号的，每一个联网的计算机（不论是局域网还是广域网）都需要有一个IP地址，只有这样一个计算机在网络中才具备一个身份。IP地址是一个32位的二进制数，一般情况下被分为四个8位的部分（0-255），用十进制进行表示，每个部分用点号隔开，例如：192.168.0.1；127.0.0.1等等。常见IP地址可以分为IPV4和IPV6，IPV6的出现是因为网络的发展过快，IPV4的发放不够用，因此需要更多的位数的IPV6重新定义地址空间。但是更多的情况下还是在使用IPV4。 </p><p>&emsp;&emsp;那么端口又是做什么的，端口可以说是区分一台机器上不同的进程的方式。我们举一个例子：一台计算机可以同时完成访问互联网（80），通过Java的Tomcat接收请求（8080），ssh远端连接（22），MySQL数据访问（3306）。那么一台计算机在网络中具备一个特殊标识，但是一台计算机与多个应用是处于一对多的关系，这个一对多关系的载体就是端口。例如，我们希望通过远端访问网络中某一台机器的数据库，我们就需要对IP+对应的端口进行请求。 </p><p>&emsp;&emsp;端口号是由整数标记的，范围是从0到65535。但是这么多的端口并不是全部都可以让程序员随意使用。首先0号端口是保留端口，不可以使用。1-1024是固定端口，这些端口是被某些系统级别的程序固定使用，一般来说程序员也不应该使用，例如如果某个程序占用了22端口，那么这个机器可能就不能完成ssh访问了，亦或在ssh服务打开的情况下，自己写的软件根本不能运行。剩余的1025-65535端口是动态端口，这些端口程序员可以使用，但是依旧需要避开一些主流软件所占用的端口。例如假如我们的软件使用的端口是3306，这个端口处于动态端口之中，理论上讲程序员可以随意使用。但是如果这样做就会出现一个问题，要么MySQL数据库在3306上就用不了，要么就是我们的软件用不了。因此端口的选用还是需要注意的。 </p><h3 id="网络编程入门案例"><a href="#网络编程入门案例" class="headerlink" title="网络编程入门案例"></a>网络编程入门案例</h3><p>&emsp;&emsp;在这个部分中，我们将逐步介绍Go语言中socket网络编程的入门案例。从服务器监听、客户端连接，到客户端与服务器相互发送消息，我们将一一实现。至于像QQ聊天室一般多对多的聊天，无非就是控制向哪个connection发送数据而已。首先我们从最为简单最为基础的案例开始：</p><h4 id="1-实现服务器监听，客户端连接"><a href="#1-实现服务器监听，客户端连接" class="headerlink" title="1.实现服务器监听，客户端连接"></a>1.实现服务器监听，客户端连接</h4><p>&emsp;&emsp;从这里开始，我们由于需要分别写服务器与客户端的代码实现，因此像之前一样用一个go文件显然是不合适的，因此我们重新建立两个独立的文件夹，第一个文件夹是client文件夹，里面放client相关的代码，另一个是server文件夹，里面放置server相关的go文件。 </p><p>&emsp;&emsp;首先我们讲解服务器的书写：对于一台机器而言，如果希望其成为一个服务器，首先需要为其分配一个监听的端口，一旦有消息从这个端口中进入计算机，那么就由这个服务器进行数据处理。因此服务器的第一个步骤是监听。那么当分配给了端口之后，服务器需要等待客户端去连接，如果没有客户端来连接，服务器应当处于一种阻塞的状态，因此服务器的第二个步骤是接收连接。当接收到连接之后，服务器就可以通过这个连接进行数据交互了，我们暂时先不说数据交互的方式，只测试监听与接收连接是否成功。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Server starts listening"</span>)</span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"0.0.0.0:2333"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Server listen error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> listener.Close()</span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Accept error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Server conn is:"</span>, conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们首先输出服务器开始监听，通过Listen方法指定tcp连接与ip+端口号，该方法返回net.Listener接口，该接口中含有Addr方法，Accept方法，与Close方法。为了程序结束时将listener关闭，我们通过defer来完成该操作。当服务器开始监听之后，我们让listener接收进来的请求，并将得到的连接对象输出出来。 </p><p>&emsp;&emsp;说完服务器，我们再说客户端，客户端相比于服务器操作就少了很多。客户端只需要在希望连接时向服务器的ip地址与端口号发送一个请求，如果能够连接上，就会返回net.Conn接口实例，然后再通过该对象进行数据交互。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:2333"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"connection fail"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    fmt.Println(<span class="string">"Client conn is:"</span>, conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，我们通过net包中的Dial函数指定通过tcp方式向后面的ip+端口发送连接，在程序结束之后关闭对应的connection。当连接成功后，我们输出对应的conn接口实例。我们首先执行服务器代码，然后再执行客户端代码。结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server starts listening</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当执行了客户端代码之后，客户端控制台会输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Client conn is: &amp;&#123;&#123;<span class="number">0xc00009a000</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因为有了客户端的连接，所以服务器会再输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server conn is: &amp;&#123;&#123;<span class="number">0xc00008e2c0</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-服务器循环等待多客户端"><a href="#2-服务器循环等待多客户端" class="headerlink" title="2. 服务器循环等待多客户端"></a>2. 服务器循环等待多客户端</h4><p>&emsp;&emsp;在前一段代码中，我们让服务器监听2333端口，等待客户端的连接，但是当有客户端来连接过后，服务器就直接结束了。一般情况下服务器还是要为多客户端服务的，因此往往等待客户端连接的操作是在循环中完成的。代码修改如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Server starts listening"</span>)</span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"0.0.0.0:2333"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Server listen error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> listener.Close()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Accept error:"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"Server conn is:"</span>, conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;服务器修改成如上代码之后，我们通过终端启动多个客户端，此时服务器就已然具备等待多个客户端的能力了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Server starts listening</span><br><span class="line">Server conn is: &amp;&#123;&#123;<span class="number">0xc00009e2c0</span>&#125;&#125;</span><br><span class="line">Server conn is: &amp;&#123;&#123;<span class="number">0xc00009e580</span>&#125;&#125;</span><br><span class="line">Server conn is: &amp;&#123;&#123;<span class="number">0xc00009e840</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="3-客户端服务器互相发送数据"><a href="#3-客户端服务器互相发送数据" class="headerlink" title="3.客户端服务器互相发送数据"></a>3.客户端服务器互相发送数据</h4><p>&emsp;&emsp;在客户端与服务器相连之后，就可以通过Conn接口实例进行数据传输了，在API文档中，Conn中含有两个方法，分别为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Read(b []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">Write(b []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;读和写两个方法，我们就通过这两个方法完成数据的交互。首先我们依旧从服务器开始：当服务器接收到客户端的连接之后，服务器启动一个协程。这个协程专门负责服务器与这个客户端的信息交互。我们在先在服务器接收到消息，然后将消息输出到服务器的终端中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">        num, err := conn.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Read Error"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        content := <span class="keyword">string</span>(buf[:num])</span><br><span class="line">        fmt.Print(conn, <span class="string">":"</span>, content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Accept error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> process(conn)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在服务器中，我们写一个函数process，并通过协程调用它。在process中，我们将与客户端连接的conn传入，并在函数中循环接收消息：我们首先定义一个切片，并将切片传入到Read方法中，其返回值是一个整数num和一个error。我们取出buf切片中的前num个并组成一个字符串，就是接收到的消息了。</p><p>&emsp;&emsp;客户端中当然就是循环从控制台中读取消息，每读取一个字符串就通过conn的Write方法将该字符串写出到服务器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    reader := bufio.NewReader(os.Stdin)</span><br><span class="line">    content, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Read from console error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    _, err = conn.Write([]<span class="keyword">byte</span>(content))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Write error"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时再运行服务器，我们再启动两个客户端，我们可以发现两个客户端发送的消息都可以在服务器中接收到，并输出出来。</p><h4 id="4-服务器向客户端回送消息"><a href="#4-服务器向客户端回送消息" class="headerlink" title="4. 服务器向客户端回送消息"></a>4. 服务器向客户端回送消息</h4><p>&emsp;&emsp;现在我们再更新需求，当服务器收到了消息后，不仅要输出到终端，还要向客户端回送一条数据称消息已然收到。对于这个需求而言，我们首先修改服务器代码： </p><p>&emsp;&emsp;服务器在协程中循环接收客户端的消息，当接收到了消息之后直接通过Write方法向对应的conn接口写出即可，因此需要改动的部分并不大：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">        num, err := conn.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Read Error"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        _, err = conn.Write([]<span class="keyword">byte</span>(<span class="string">"Receive your message"</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Write error"</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        content := <span class="keyword">string</span>(buf[:num])</span><br><span class="line">        fmt.Print(conn, <span class="string">":"</span>, content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们修改了server中的process函数，在里面添加了Write相关代码。 </p><p>&emsp;&emsp;对于客户端而言，由于我们并不能确定服务器何时能够发过来数据，因此我们需要启动一个协程专门循环地读取数据。有读者可能会认为在这个需求中，服务器发回来数据一定发生在客户端写数据之后，因此不必要启动协程。但是当程序完善后，其他客户端给该客户端发消息时，该客户端就无法确定何时能够收到服务器发来的消息了，因此在这里，我们直接就启动协程了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">        num, err := conn.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Read Error"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="keyword">string</span>(buf[:num]))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="keyword">go</span> receive(conn)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    reader := bufio.NewReader(os.Stdin)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们在客户端中定义一个receive函数，并在主函数中通过协程启动这个函数。在函数中我们循环接收从服务器发来的消息，当接收到了过后，我们将消息输出到终端中。此时程序代码就可以接收到从服务器发来的消息了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们提及了socket的本质与概念，同时讲解了tcp/ip协议与udp协议，然后又说明了计算机的ip地址与端口号的作用。之后我们引入了socket编程的快速入门案例。从浅入深地讲解了服务器与客户端代码编写的方式与规则。更复杂的功能也不过是基于上述的案例进行进一步的发展了。 </p><p>&emsp;&emsp;到了这里，这一系列的连载也就告一段落了。我们也讲解到了Go语言中一部分的知识点，当然大多数的知识点我们依旧没有涉及。这个连载也只是面向刚刚接触Go语言的开发者，如果能坚持到这个小节也可以说是入门了。如果没有坚持到这里，也算是放弃了，倒也是符合系列连载的题目了（笑）。如果日后还有机会，也会出一些其他的相关的例如数据结构与算法，Go web，甚至其他语言的连载。如果喜欢请多多支持。(～￣▽￣)～ skr～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-56-gt-终章-Socket网络编程&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-56-gt-终章-Socket网络编程&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;56&amp;gt;
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;55&gt; 反射细节讨论</title>
    <link href="http://yoursite.com/2020/04/04/55-%E5%8F%8D%E5%B0%84%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/04/04/55-%E5%8F%8D%E5%B0%84%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/</id>
    <published>2020-04-04T12:30:00.000Z</published>
    <updated>2020-04-04T12:30:55.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-55-gt-反射细节讨论"><a href="#Go语言从入门到放弃系列-lt-55-gt-反射细节讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;55&gt; 反射细节讨论"></a>Go语言从入门到放弃系列&lt;55&gt; 反射细节讨论</h2><p>&emsp;&emsp;在上个小节中，我们介绍了Go语言中通过反射的方法获取一个变量的类型和值，我们并没有针对这两个属性做进一步的操作。在这个小节中，我们将介绍几个反射的操作以及操作过程中需要注意的问题,同时我们也将会通过代码完成注意事项的讲解。</p><h4 id="1-Type与Kind的区别"><a href="#1-Type与Kind的区别" class="headerlink" title="1. Type与Kind的区别"></a>1. Type与Kind的区别</h4><p>&emsp;&emsp;在上个小节的截图中，我们在Type接口和Value类中都看到Kind方法，其解释为返回该接口的具体分类，这个概念与Type还是比较相似的。在这里我们通过代码讲解这两个概念的不同之处：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectDemo</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        reflectValue := reflect.ValueOf(args[i])</span><br><span class="line">        reflectKind := reflectValue.Kind()</span><br><span class="line">        reflectType := reflectValue.Type()</span><br><span class="line">        fmt.Printf(<span class="string">"Kind is : %v, Type is : %v\n"</span>, reflectKind, reflectType)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    student := Stu&#123;</span><br><span class="line">        Name: <span class="string">"Devin"</span>,</span><br><span class="line">        Age: <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> f <span class="keyword">float32</span> = <span class="number">10.0</span></span><br><span class="line">    array := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">    reflectDemo(i, f, student, array, slice, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们依旧修改了reflectDemo函数的函数体。我们在函数体中获取每个参数的Value对象，再通过Value对象获取其Kind和Type（直接通过空接口获取也是可以的）。最后将获取的Kind和Type输出到控制台终端上。其输出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Kind is : <span class="keyword">int</span>, Type is : <span class="keyword">int</span></span><br><span class="line">Kind is : <span class="keyword">float32</span>, Type is : <span class="keyword">float32</span></span><br><span class="line">Kind is : <span class="keyword">struct</span>, Type is : main.Stu</span><br><span class="line">Kind is : array, Type is : [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">Kind is : slice, Type is : []<span class="keyword">int</span></span><br><span class="line">Kind is : <span class="keyword">map</span>, Type is : <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过输出结果我们可以发现：获取到的Kind实例相比于Type实例更为抽象一些，Type对象更为具体。同时，对于基本数据类型而言，其Kind和Type是相同的。对于复杂数据类型而言，Kind与Type就不相同了：我们将变量类型总结为几个大类，例如整数，浮点数，结构体，数组等，而Kind所返回的就是这些大类的名字。而对于Type而言，例如数组所保存的数据类型不同，数组的长度不同，数组类型就是不同的，Type返回的就是这种更为详细的结果。 </p><p>&emsp;&emsp;由此而看，假如一个结构体中含有数组作为其属性，那么这个Kind将会是struct，如果一个数组内部存储的数据是结构体，他的Kind是array。最后我们贴出Go语言中目前所有的Kind种类： </p><p><img src="/2020/04/04/55-%E5%8F%8D%E5%B0%84%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/1.png" alt> </p><h4 id="2-获取值需要类型匹配"><a href="#2-获取值需要类型匹配" class="headerlink" title="2. 获取值需要类型匹配"></a>2. 获取值需要类型匹配</h4><p>&emsp;&emsp;在之前我们获取到一个整数的Value的时候，我们通过对Value对象的输出已经看到了它应该保存的值。但是Value对象就是Value对象，它不是整数，即便是它具备输出保存的值的能力，它也不具备数学计算的能力，对于这个知识点，我们通过下面的这个小程序说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectDemo</span><span class="params">(arg <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    reflectValue := reflect.ValueOf(arg)</span><br><span class="line">    fmt.Println(reflectValue)</span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int64</span> = <span class="number">5</span></span><br><span class="line">    num = num + reflectValue</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    reflectDemo(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们获取了int数据类型的Value值，并输出的对应的Value。然后我们再定义一个整数，让这个整数与刚刚得到的value的相加，我们会发现，这段程序会出现错误。其错误类型为：数据类型不匹配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invalid operation: num + reflectValue (mismatched types <span class="keyword">int64</span> and reflect.Value)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们从这个输出结果可以看出我们试图让一个int64数据类型和reflect.Value型数据类型相加，当然是不合法的。所以我们需要将reflect.Value转换成为int64类型，然后才可以进行计算。而这个转换的过程是通过Value类的方法所完成的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectDemo</span><span class="params">(arg <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    reflectValue := reflect.ValueOf(arg)</span><br><span class="line">    realValue := reflectValue.Int()</span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int64</span> = <span class="number">5</span></span><br><span class="line">    num = num + realValue</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将函数修改为上述的代码，通过reflectValue获取其对应的Int值，我们就可以继续进行计算了。值得说明的是：通过Int方法得到的数据类型为int64，同理通过Float方法所得到的结果将会是float64，即反射得到的结果往往对应是精度最高的结果。 </p><p>&emsp;&emsp;同时在转换的过程中，需要类型相匹配，当类型不匹配的时候编译器会报出panic，例如我们在上述的程序中调用reflectValue的Float方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectDemo</span><span class="params">(arg <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    reflectValue := reflect.ValueOf(arg)</span><br><span class="line">    realValue := reflectValue.Float()</span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int64</span> = <span class="number">5</span></span><br><span class="line">    num = num + realValue</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时如果我们依旧传入一个整数变量，则会出现如下的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: reflect: call of reflect.Value.Float on <span class="keyword">int</span> Value</span><br></pre></td></tr></table></figure><h4 id="3-修改传入的值"><a href="#3-修改传入的值" class="headerlink" title="3. 修改传入的值"></a>3. 修改传入的值</h4><p>&emsp;&emsp;在我们之前的理解中，Go语言中数据类型分为值类型和引用类型。当数据为值类型时，传入函数的实参是复制的一个副本，函数内部无法改变外部的值。引用类型传入的是指针的副本，函数内部修改可以影响外部的值。因此这个问题在反射中依然存在，当我们使用SetXXX函数修改其值时，往往希望对函数外部有所影响，因此这个小节我们就完成这个需求。我们依旧以传入整数为例： </p><p>&emsp;&emsp;分析的过程可能如下：首先主函数中需要定义一个整数，并且将其传入到reflectDemo中，但是为了函数中可以修改函数外的值，因此我们传递的是这个整数的地址。然后我们继续在函数中通过反射得到Value，再调用Value中的SetInt方法修改。代码可能如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectDemo</span><span class="params">(arg <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    reflectValue := reflect.ValueOf(arg)</span><br><span class="line">    reflectValue.SetInt(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    reflectDemo(&amp;i)</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码中，其实有一个很重大的问题，就是我们传入的是一个指针，所以反射得到的reflectValue保存的是一个指针，指针是不可以赋值的。我们需要对指针所指向的值进行修改，于是需要用到Value对象的另一个方法：Elem方法。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectDemo</span><span class="params">(arg <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    reflectValue := reflect.ValueOf(arg)</span><br><span class="line">    fmt.Println(reflectValue.Elem().Int())</span><br><span class="line">    reflectValue.Elem().SetInt(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时，我们再执行代码，就可以发现在函数中输出的结果是10（初始值），在主函数中输出的结果是100（修改后的值）。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们讲解了Go语言中反射部分的几个注意事项。我们讲解了Type与Kind的区别：Type是一种接口，而Kind则是一种常量。我们也同时说明了将reflect.Value转换成为普通的变量，以及类型不匹配时出现的结果。最后我们讲解了如何通过反射完成对数据的修改：传入指针变量并通过Elem方法取出数据。 </p><p>&emsp;&emsp;由于反射这个知识点在平时开发中用到的并不多，且初学者也基本用不到这个点，因此我们就比较浅地介绍一下反射，说明一下反射能做什么，当然反射的魅力远远不仅如此，它能做到的事也远远不止这些。如果读者希望更深入地了解反射及相关技术，个人还是建议去找更为专业的书籍。 </p><p>&emsp;&emsp;到这里反射的基本入门就结束了，在下个小节中，我们将开始新的知识点的讲解：TCP网络编程。我们会讲解网络编程的入门，网络与多协程的配合等。届时，读者应该可以完成一定的小的服务器的开发。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-55-gt-反射细节讨论&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-55-gt-反射细节讨论&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;55&amp;gt; 反射细节讨论&quot;&gt;&lt;/a&gt;G
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;54&gt; 反射入门</title>
    <link href="http://yoursite.com/2020/04/02/54-%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2020/04/02/54-%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/</id>
    <published>2020-04-02T08:51:30.000Z</published>
    <updated>2020-04-02T08:53:19.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-54-gt-反射入门"><a href="#Go语言从入门到放弃系列-lt-54-gt-反射入门" class="headerlink" title="Go语言从入门到放弃系列&lt;54&gt; 反射入门"></a>Go语言从入门到放弃系列&lt;54&gt; 反射入门</h2><p>&emsp;&emsp;在这个小节中，我们将集中介绍Go语言中反射的一些概念与使用方法。即便是在不同的计算机语言中，反射都是一个非常重要的知识点，同时也是一个非常难的知识点。究其原因主要是：初学者乃至于初入工作的开发者往往不会接触到这个技术，甚至来说对这个技术基本没有需求。而当更为深入地去写框架的时候，才会逐渐意识到它的重要性。 </p><p>&emsp;&emsp;基于上述的反射的特点，我们在这个小节中简单地介绍一下Go语言反射的使用方式，难度相比于真实开发所能用到的难度会相对浅显。因此如果看完这个小节觉得反射这个概念十分地有趣，可以去查找其他的专业的教科书或文章深入地研究。在学习过程中，确实不是每个人都能够体会到反射的重要性的，而一旦没有体会到其重要性，反而会觉得这个技术既没什么作用，实现起来又复杂。这样的话就大可以不必纠结于这个小节，毕竟开发初期真的用不到这个知识点。</p><h3 id="反射引入"><a href="#反射引入" class="headerlink" title="反射引入"></a>反射引入</h3><p>&emsp;&emsp;其实我们在之前对序列化与空接口的讲解过程中，已然或多或少地带有了反射的概念。比如说，我们曾经在类的属性后添加了tag，使得序列化结果中的key是tag中的内容而不是属性字段，能够实现这个功能的原因其实就是反射。 </p><p>&emsp;&emsp;不仅如此，我们曾经在空接口的叙述中提到了类型断言的这个知识点。任何的类都可以说实现了空接口，因此任何的变量都可以作为空接口的参数传入。那么我们通过类型断言将变量从空接口转换成对象的时候，我们之前都是手动完成的，现在学过反射之后，我们就可以让其自动地完成断言。 </p><p>&emsp;&emsp;现在我们通过一个案例来完成快速入门：假设我们的工作是写一个函数，这个函数可以接收任何类型的变量，且在函数体中输出该变量的类型，例如输入的是int型整数，在函数中就要输出int；输入的是float64，在函数中就要输出float64。 </p><p>&emsp;&emsp;如果我们通过现有的知识储备，其实很难完成上述的要求。首先，Go语言不支持函数重载，用同一个函数名且入参不同的方式是不可行的。同时即便我们采用了空接口的形式，我们只能通过空接口来操作变量，依旧不知道它的类型（需要先知道类型才能断言，需要断言成功才人为地知道类型），因此我们引入反射：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectDemo</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        reflectType := reflect.TypeOf(args[i])</span><br><span class="line">        fmt.Println(reflectType)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> i8 <span class="keyword">int8</span> = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> f32 <span class="keyword">float32</span> = <span class="number">10.0</span></span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">"Hello World"</span></span><br><span class="line">    reflectDemo(i, i8, f32, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面的入门案例中，我们可以发现，我们引入了”reflect”包，同时在main函数中定义了四种不同的数据类型，且将这四种数据类型传入到reflectDemo函数中。在reflectDemo函数定义中，我们采用了空接口的可变参数的方式接收数据，在函数体中，我们遍历传入的参数输出其参数的类型。其输出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="keyword">int8</span></span><br><span class="line"><span class="keyword">float32</span></span><br><span class="line"><span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过这个输出结果我们可以发现，不同的类型的数据传入到函数中最终输出了不同的结果。如果再配合以类型断言，将空接口转为对应的类型的变量，我们就可以在函数内部操控传入的数据了。当然事情并不会这样简单，但是作为快速入门案例，我们就暂时先讲解到这，我们在后面会相对具体地说明。</p><h3 id="Type与Value"><a href="#Type与Value" class="headerlink" title="Type与Value"></a>Type与Value</h3><p>&emsp;&emsp;我们在正常使用一个变量的时候，往往会关注它的数据类型以及其内部的值，反射技术关心的往往也是这些。因此可以说reflect包下的Type类与Value是两个相对占比比较大的技术点。其他的知识点例如获取结构体信息之类的都可以从手册中查到。 </p><h4 id="1-Type"><a href="#1-Type" class="headerlink" title="1. Type"></a>1. Type</h4><p>&emsp;&emsp;我们首先说变量的Type，在上一个入门案例中，我们已然获取到了通过空接口的某些数据类型的Type。但是我们只获取了基本数据类型的Type，这里我们利用代码来说明其他的数据类型，例如结构体，数据等数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    student := Stu&#123;</span><br><span class="line">        Name: <span class="string">"Devin"</span>,</span><br><span class="line">        Age: <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    array := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">    reflectDemo(student, array, slice, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这次我们将Stu结构体（类）的实例，以及数组、切片、映射传入到入门案例的refelctDemo函数中，我们可以发现结果依然是正确的，且在输出Stu的时候是带有包名的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.Stu</span><br><span class="line">[<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">[]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;换句话说，我们既然获取到了变量的Type，我们就相当于拥有了变量的各个性质。我们可以通过该Type获取它的包名，包路径，占据字节数，实现了哪些接口，有多少个属性，获取具体属性等。通过下面的截图（部分截图）我们可以发现：<br><img src="/2020/04/02/54-%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/1.png" alt><br>&emsp;&emsp;Go语言中Type其实是一个接口，我们之前也提及过，可以通过接口调用接口中的方法，因此所有的数据类型都可以获取其Type，获取其Type之后全部都可以调用图中方法。当然，有些方法是针对特定的数据类型的，例如获取传入map中的key就只能针对map类型的数据，对于其他数据类型而言，编译器会报出panic。 </p><h4 id="2-Value"><a href="#2-Value" class="headerlink" title="2. Value"></a>2. Value</h4><p>&emsp;&emsp;如果说获取了Type就相当于得到了变量的各个性质，那么获取了Value就相当于得到了变量的值的相关操作的所有权。我们知道，变量定义出来就是为了存储，使用，因此Value作为反射的一部分用处也是非常的大。我们依旧通过快速入门案例来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectDemo</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        reflectValue := reflect.ValueOf(args[i])</span><br><span class="line">        fmt.Println(reflectValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    student := Stu&#123;</span><br><span class="line">        Name: <span class="string">"Devin"</span>,</span><br><span class="line">        Age: <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    array := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">    reflectDemo(i, student, array, slice, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们将reflectDemo函数的函数体改为ValueOf函数，获取的是传入参数的值而不是类型，根据输出结果我们可以发现，反射确实是可以获取变量内部的值的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line">&#123;Devin <span class="number">25</span>&#125;</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"><span class="keyword">map</span>[]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;与Type不同的是，Go语言中的Type是一个接口，而Value是一个类，其包含属于自己的多个方法。我们截部分图来说明Value的使用： </p><p><img src="/2020/04/02/54-%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/2.png" alt></p><p>&emsp;&emsp;从图中我们可以发现：当我们获取了Value值之后，我们可以通过Value变量判断该变量是否目前处于nil的状态，如果它是整数那么整数的值是多少，如果是slice或者map，它的容量是多大。值得注意的是：在Value的方法中，我们可以看到一个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v value)</span> <span class="title">Type</span><span class="params">()</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法可以通过Value实例获取到变量的Type，但是我们并没有在Type接口所包含的方法中找到获取Value的方法。从某种意义上说：空接口，Type，和Value是可以互相转换的。 </p><p>&emsp;&emsp;除了获取变量的值这个功能之外，我们当然可以改变变量的值，我们再通过下面的截图说明（中间省略了许多的方法）： </p><p><img src="/2020/04/02/54-%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/3.png" alt></p><p>&emsp;&emsp;这里带有Set的方法都是改变数据所用到的方法，且每一种Set方法都对应着自己的独特的数据类型，一旦数据类型匹配有误（例如为整数类型Set浮点数），会报出相应的panic。那么我们将如何知道传入的变量都是什么数据类型呢，获取其Type就明确了。</p><h4 id="3-Type，Value，空接口转换"><a href="#3-Type，Value，空接口转换" class="headerlink" title="3. Type，Value，空接口转换"></a>3. Type，Value，空接口转换</h4><p>&emsp;&emsp;在Go语言的反射中，这三个概念十分重要，当然在实际应用过程中需要相互地配合，也就需要经常地转换了。 </p><p>&emsp;&emsp;1.变量与空接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量---------------&gt;空接口</span><br><span class="line">空接口--（类型断言）--&gt;变量</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;2.空接口与Type</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflect.TypeOf(空接口)------&gt;Type</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;3.空接口与Value</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reflect.ValueOf(空接口)-----&gt;Value</span><br><span class="line">Value.Interface()----------&gt;空接口</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;4. Value与Type</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value.Type()------&gt;Type</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们简单地引入了反射的概念与基本用法，介绍了Go语言中反射包的两个比重较大的概念：Type和Value。对于这两个概念我们也初步地讲解了其入门案例及其使用方式，通过截图也大致介绍了其方法的作用。最后我们又总结出了变量、空接口、Value、Type之间的互相转化关系。 </p><p>&emsp;&emsp;在下个小节中，我们将继续针对反射做出相对详细的解释以及开发过程中需要注意的问题。然后我们将会再通过一些案例讲解为变量赋值等相对高级的操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-54-gt-反射入门&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-54-gt-反射入门&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;54&amp;gt; 反射入门&quot;&gt;&lt;/a&gt;Go语言从入门
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;53&gt; channel细节讨论</title>
    <link href="http://yoursite.com/2020/03/31/53-channel%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/03/31/53-channel%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/</id>
    <published>2020-03-31T15:47:15.000Z</published>
    <updated>2020-03-31T15:48:37.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-53-gt-channel细节讨论"><a href="#Go语言从入门到放弃系列-lt-53-gt-channel细节讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;53&gt; channel细节讨论"></a>Go语言从入门到放弃系列&lt;53&gt; channel细节讨论</h2><p>&emsp;&emsp;在上个小节中，我们讲解了Go语言中channel的定义与初始化方式，数据插入提取操作，以及主线程等待子协程运行结束的方式。在这个小节中，我们将针对channel的其他几个细节进行讲解。我们将提及管道的关闭，遍历，阻塞机制，以及只读只写的管道定义。最后我们还将针对子协程中异常捕获的方式作出简要的介绍。</p><h3 id="管道的关闭"><a href="#管道的关闭" class="headerlink" title="管道的关闭"></a>管道的关闭</h3><p>&emsp;&emsp;在之前的小节中，我们只讲解到了channel的定义，相当于channel的打开，但没有讲解到channel变量的关闭。在很多情况下channel的关闭是具备一些作用的，同时channel的关闭操作也影响channel的遍历阻塞情况。我们一一来讲解以上的内容。 </p><p>&emsp;&emsp;对于channel变量的关闭操作，Go语言提供了一个内置函数close，其参数就是任意类型的channel变量。换句话说，close函数所在的包就是Go语言中的builtin包，因此无需要引入任何其他的包。我们通过入门案例来说明其用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    channel &lt;- <span class="number">1</span></span><br><span class="line">    channel &lt;- <span class="number">2</span></span><br><span class="line">    channel &lt;- <span class="number">3</span></span><br><span class="line">    num := &lt;-channel</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">    <span class="built_in">close</span>(channel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们只需要close(channel)就可以关闭我们希望关闭的管道了。关闭在关闭过后将会有以下的几个性质：</p><p>&emsp;&emsp;1. 不可以继续向管道内写入数据，否则将出现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: send on closed channel</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;2. 可以继续从管道内读取数据，且当管道已然空了之后再读取不会出现panic，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    channel &lt;- <span class="number">1</span></span><br><span class="line">    channel &lt;- <span class="number">2</span></span><br><span class="line">    <span class="built_in">close</span>(channel)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        fmt.Println(&lt;-channel)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们在这段程序中初始化了一个容量为3的管道，向管道中插入2个数据，但是我们希望从管道中取出5个数据，此时输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以发现，当管道关闭过后且管道内无数据，取出的值，即管道内数据（整数数据）的零值为0。但是更多的情况下，我们并不想取出那些多余的数据，我们可以根据取出数据时带有的标志位来判别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">    num, flag := &lt;-channel</span><br><span class="line">    <span class="keyword">if</span> flag &#123;</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时的输出就不会带有后面的三个0了。</p><h3 id="管道的遍历"><a href="#管道的遍历" class="headerlink" title="管道的遍历"></a>管道的遍历</h3><p>&emsp;&emsp;其实在上一个小节中我们已经说到了管道的遍历了，只不过我们暂时并不知道管道的长度是多少，循环n次提取数据，如果提取超出限制就会返回0。同时我们也通过取出数据时的标志位来确定提取是否成功，一旦不成功我们就停止循环。 </p><p>&emsp;&emsp;但是就因为长度是无法确定的，所以在提取的时候循环次数是无法确定的。虽然我们可以通过len的方式来确定当前channel中有多少个数据再进行循环，但是我们也说了，channel是一种流动的数据类型，多个协程可以同时操作一个channel不出资源竞争。所以通过len函数得到的值在下一时刻可能就不再适用了，因此我们依旧介绍一种之前见过的遍历方式，range：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    channel &lt;- <span class="number">1</span></span><br><span class="line">    channel &lt;- <span class="number">2</span></span><br><span class="line">    <span class="built_in">close</span>(channel)</span><br><span class="line">    <span class="keyword">for</span> num := <span class="keyword">range</span> channel &#123;</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在for-range结构中，我们不需要在提取数据时判断标志位，具体channel中有多少数据，什么时候channel被关闭了，在for-range结构中都可以不需要进行考虑，编译器都如数帮助我们完成了判断。 </p><p>&emsp;&emsp;但是这里需要说明的一点是：不论是传统for结构，还是for-range结构，<strong>当channel没有被关闭的情况下</strong>，无限制地读取数据还是会出现阻塞且死锁现象。因此可以讲：channel的遍历是以channel被关闭为基础的。如果channel没有被关闭，就不能无限制地遍历。 </p><p>&emsp;&emsp;但是实际上是，channel并不能随随便便地关闭，且channel是引用类型，一旦某一个协程关闭了channel，其他的协程都无法再向该channel中写入数据了。换句话说，当遍历channel时率先关闭channel是不现实的，因为无法保证其他协程没有在用这个channel了；同时不关闭就无法遍历，这似乎成了一个死循环。因此我们将介绍一种其他的遍历方式：select，在这种前提下即便不关闭channel，也可以完成遍历操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    channel &lt;- <span class="number">1</span></span><br><span class="line">    channel &lt;- <span class="number">2</span></span><br><span class="line">    channel &lt;- <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> v := &lt;-channel:</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"No other data"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面的代码中，我们初始化了一个管道，并向其中插入三个数据，在后面的循环中，我们通过select块完成管道数据的提取。一旦数据成功被提取了，程序将会进入case部分，如若取不出来数据，就会继续向后匹配其他的case块，如若全都没有匹配，则会进入default部分。之后我们再次进入下一次的循环依旧提取数据。我在这里通过time.Sleep是为了让程序人为地减慢，否则程序将会一直输出”No other data”，此时由于我们没有设定跳出的操作，因此会无限循环，需要通过”ctrl+c”的方式（不同系统不一样）来强制退出。 </p><p>&emsp;&emsp;如果我们在程序中定义多个管道，且在同一个select块中提取数据，其执行顺序也是不可预见的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    intChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    intChannel &lt;- <span class="number">1</span></span><br><span class="line">    intChannel &lt;- <span class="number">2</span></span><br><span class="line">    intChannel &lt;- <span class="number">3</span></span><br><span class="line">    stringChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">    stringChannel &lt;- <span class="string">"Hello"</span></span><br><span class="line">    stringChannel &lt;- <span class="string">"World"</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> v := &lt;-intChannel:</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">            <span class="keyword">case</span> v := &lt;-stringChannel:</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"No other data"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管道的只读只写"><a href="#管道的只读只写" class="headerlink" title="管道的只读只写"></a>管道的只读只写</h3><p>&emsp;&emsp;在之前我们所定义的channel中，我们定义的都是双向的管道，即既可以向管道中写入数据也可以从管道中读取数据。其实在Go语言中，我们可以定义只读或者只写的管道：只读的管道只可以从管道中读取数据而不可以写入，只写管道只可以向管道中写入数据而不可以读。我们举个例子来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> channel &lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> channel <span class="keyword">chan</span>&lt;- <span class="keyword">int</span></span><br><span class="line">readChannel := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">writeChannel := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其定义或初始化方式就是在chan关键字前或后面添加指向的符号，以确定值只可以从管道取还是只可以向管道内写。如果操作没能满足只读只写的性质，会出现如下的运行时错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invalid operation: readChannel &lt;- <span class="number">1</span> (send to receive-only <span class="keyword">type</span> &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">invalid operation: &lt;-writeChannel (receive from send-only <span class="keyword">type</span> <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;经过上述的介绍，我们可能会考虑一个问题，我们在之前说管道内的数据是需要流动的，那么只读和只写着两个种性质岂不是直接地违背了管道数据的流动性。这个问题我们需要以多协程的形式来考虑，我们可以将只读和只写看做管道变量给予其他函数的权限。在某些协程中专门负责向管道中写入数据，某些协程中专门处理数据，管道内数据是不同协程之间流动的，而不是在一个协程之中流动。因此可以说，限定了管道权限可以一定意义上防止协程对管道的误操作。 </p><p>&emsp;&emsp;为了更详细说明一下，我们举一个例子，开启两个协程，一个协程向管道中写入50个数据，另一个协程从管道中取出数据，取出数据结束后主协程结束：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inputData</span><span class="params">(channel <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++ &#123;</span><br><span class="line">        channel &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(channel)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outputData</span><span class="params">(channel &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, exit <span class="keyword">chan</span>&lt;- <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> data := <span class="keyword">range</span> channel &#123;</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(exit)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">go</span> inputData(channel)</span><br><span class="line">    <span class="keyword">go</span> outputData(channel, exit)</span><br><span class="line">    &lt;-exit</span><br><span class="line">    fmt.Println(<span class="string">"主协程结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们在函数的形参中指定了channel的只读只写属性，而在主函数中调用协程时传入的实参是没有只读只写定义的。对于这个现象我们可以一定程度上理解为向下转型，即channel还是同一个channel，只是在参数传递的过程中赋给了一定的权限。因此只读或只写管道并不是两个独特的数据类型，其本质都是双向的管道，只是在定义初始化或使用过程中人为地添加了一个额外的属性。</p><h3 id="协程中处理错误"><a href="#协程中处理错误" class="headerlink" title="协程中处理错误"></a>协程中处理错误</h3><p>&emsp;&emsp;在Go语言中如果出现了运行时错误，整个程序就会完全崩溃停止。但在一些情况下，我们并不希望这样，因为每一个协程都可以说自已执行自己的代码。一个协程出了问题，不应该影响到其他的协程。比如说游戏逻辑出了一点问题不应该影响好友逻辑，因此结合之前我们所提到的defer+recover关键字，我们可以解决上述的问题。 </p><p>&emsp;&emsp;我们首先写一个没有做错误处理的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makePanic</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> myMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">    myMap[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> makePanic()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"主协程结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们可以发现：在makePanic函数中我们定义了一个map，但是没有初始化，而直接向map中写入数据，这个行为会造成panic，执行结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: assignment to entry in <span class="literal">nil</span> <span class="keyword">map</span>  </span><br><span class="line">goroutine <span class="number">19</span> [running]:</span><br><span class="line">main.makePanic()</span><br><span class="line">E:/GoProject/src/demo/demo.<span class="keyword">go</span>:<span class="number">10</span> +<span class="number">0x3c</span></span><br><span class="line">created by main.main</span><br><span class="line">E:/GoProject/src/demo/demo.<span class="keyword">go</span>:<span class="number">15</span> +<span class="number">0x40</span></span><br><span class="line">错误: 进程退出代码 <span class="number">2.</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以发现整个程序都停止了，现在我们希望协程中出现panic后并不影响主协程，我们可以采用以下的办法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makePanic</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        err := <span class="built_in">recover</span>()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Error happen:"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">var</span> myMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">    myMap[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> makePanic()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"主协程结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在makePanic函数中defer一个匿名函数，在函数中捕获函数中出现的异常，最后将异常打印出来，代码结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error happen: assignment to entry in <span class="literal">nil</span> <span class="keyword">map</span></span><br><span class="line">主协程结束</span><br><span class="line">成功: 进程退出代码 <span class="number">0.</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们集中讲解了管道的关闭以及管道关闭的作用、以关闭管道为基础的管道的遍历方式，以及不需要关闭管道的遍历方式。同时，我们也讲解了管道的只读只写属性，以及在协程参数传递中的使用方式。最后我们讲解了多协程编程过程中子协程panic的捕获方式，当子协程出现panic时，其他协程会正常工作。 </p><p>&emsp;&emsp;在下个小节中，我们将开始一个新的技术难点：反射。反射可以说是Go语言更底层的一种实现，在大多数的框架开发中使用十分频繁，下个小节也将会概念性地笼统地讲解一下其用法，深度应该不会太高。因为反射这个知识点对于初学者来说并不是十分的友好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-53-gt-channel细节讨论&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-53-gt-channel细节讨论&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;53&amp;gt; cha
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;52&gt; channel管道入门</title>
    <link href="http://yoursite.com/2020/03/30/52-channel%E7%AE%A1%E9%81%93%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2020/03/30/52-channel%E7%AE%A1%E9%81%93%E5%85%A5%E9%97%A8/</id>
    <published>2020-03-30T14:16:29.000Z</published>
    <updated>2020-03-30T14:17:18.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-52-gt-channel管道入门"><a href="#Go语言从入门到放弃系列-lt-52-gt-channel管道入门" class="headerlink" title="Go语言从入门到放弃系列&lt;52&gt; channel管道入门"></a>Go语言从入门到放弃系列&lt;52&gt; channel管道入门</h2><p>&emsp;&emsp;在上个小节中，我们通过资源竞争问题简要地介绍了Go语言中的全局互斥锁的使用方式，以及引出了channel的快速入门案例。在这个小节中，我们将针对Go语言中的channel变量进行更多的介绍，并相应地配合入门案例完成对应的讲解。</p><h3 id="channel基本介绍"><a href="#channel基本介绍" class="headerlink" title="channel基本介绍"></a>channel基本介绍</h3><p>&emsp;&emsp;相比于之前我们介绍的简单的或者复合的变量，channel形式的变量又显得比较特殊。channel其本质是一种队列的数据结构。在上个小节我们举了一个ATM取款的例子，当有人使用提款机时，后面的其他人需要排队等待，这种数据结构经过抽象后就是队列。 </p><p>&emsp;&emsp;再次类比上面的例子，当一个人最先到达，他会排在队列的前面，同时他也将会成为候补人选的第一个人。因此队列的逻辑形式是先入先出FIFO（first in first out）。队列中还有两个属性：长度与容量。容量是一个队列可以容纳的最多数据的个数，而长度则是指当前队列中究竟有几个元素。我们举一个例子：我们首先定义一个容量为10的队列，将1,3,5,2,4按顺序插入队列中，此时的队列为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">2</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;队列的容量是10，队列的长度为5。此时我们从队列中提取一个元素，因为队列是先入先出，因此提取出来的值是队列中的第一个值：1。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>  <span class="number">5</span>  <span class="number">2</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时队列的容量依旧为10，但是长度变为了4。假如此时我们再向队列中插入一个值10，因为后出入的值会排在最后面，因此此时的队列为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>  <span class="number">5</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;channel的本质是一个队列，因此channel中的数据也满足先入先出的思想，同时channel是线程（协程）安全的，当多个goroutine访问同一个channel时不需要加锁，也不会出现读写的资源竞争问题。接下来我们将通过代码案例完成channel的各个知识点的讲解。</p><h3 id="channel的定义与声明"><a href="#channel的定义与声明" class="headerlink" title="channel的定义与声明"></a>channel的定义与声明</h3><p>&emsp;&emsp;在Go语言中使用变量之前往往需要定义与声明，channel也需要先定义才可以继续向下使用。而channel的基本定义方式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 <span class="keyword">chan</span> 数据类型</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上述的声明结构，我们可以发现channel的声明由三部分构成：变量名，chan（指定变量为channel），以及channel中装载的数据类型。我们举几个案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> stringChan <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> mapChan <span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> classChan <span class="keyword">chan</span> StuInfo</span><br><span class="line"><span class="keyword">var</span> pointerChan <span class="keyword">chan</span> *StuInfo</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;解释一下上面的定义方式：第一个channel名为intChan，且channel中只能存放int类型的整数。同理其他的几个定义中channel只可以存放string，map[int]int，StuInfo类，StuInfo对象指针。 </p><p>&emsp;&emsp;channel在定义过后还需要注意的几点是：channel自身是一个引用类型，因此在函数或方法传递过程中会受到函数方法内的改变的影响。同时正因为其引用类型的特性，channel是需要初始化才可以写入数据的，即make操作过后才可以使用。还有一个特性是：channel是有数据类型的，一旦channel定义中出现int，那么该channel中只能写入整数int。当然我们已经介绍过了面向对象的多态与接口，因此在一定意义上可以用空接口解决多个类型存入的问题。</p><h3 id="Channel初始化与数据操作"><a href="#Channel初始化与数据操作" class="headerlink" title="Channel初始化与数据操作"></a>Channel初始化与数据操作</h3><p>&emsp;&emsp;在上个部分中我们提到，Go语言中channel变量需要make过后才可以使用。对于channel变量的make函数而言需要两个参数。分别为channel变量及存储的数据类型以及channal管道的容量。与切片slice和映射map不同的是，channel的容量是固定的，一经定义好，就不可以改变了。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上述的初始化过后，内存中就已然分配了一个容量为5，长度为0的管道，其本质就是一个容量为5的队列。经过初始化后，就可以向管道内插入和提取数据了。Go语言中向管道内插入数据与提取数据采用的是”&lt;-“符号（小于号和一个减号）。我们通过下面的案例来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    intChan &lt;- <span class="number">1</span></span><br><span class="line">    intChan &lt;- <span class="number">2</span></span><br><span class="line">    intChan &lt;- <span class="number">3</span></span><br><span class="line">    intChan &lt;- <span class="number">4</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(intChan))</span><br><span class="line">    num1 := &lt;-intChan</span><br><span class="line">    num2 := &lt;-intChan</span><br><span class="line">    fmt.Println(num1, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们初始化了一个容量为5的管道，并向管道中依次插入四个整数。然后我们输出了该管道当前的长度。之后我们再将管道中的前两个整数提取出来，最后将这两个整数输出到控制台终端。上述代码的输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们再测试一下当插入数据超出了channel所规定的容量时发生的情况。我们依旧初始化一个容量为5的channel，并依次向里面插入6个数，最后再使用输出channel的长度：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    intChan &lt;- <span class="number">1</span></span><br><span class="line">    intChan &lt;- <span class="number">2</span></span><br><span class="line">    intChan &lt;- <span class="number">3</span></span><br><span class="line">    intChan &lt;- <span class="number">4</span></span><br><span class="line">    intChan &lt;- <span class="number">5</span></span><br><span class="line">    intChan &lt;- <span class="number">6</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(intChan))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当程序执行到intChan&lt;-6这条语句时，插入数据已然超出了规定的最大的容量了。<strong>在单协程的情况下</strong>，程序会报出运行时错误。因为此时只有一个主协程，而主协程中管道已然满了而添加不进去新的数据，因此主协程被阻塞了。同时没有其他的协程从管道中提取数据，主协程将会一直阻塞，因此出现了致命错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同理，我们再测试当channel中暂时为空，而没有数据的前提下，我们从channel中提取数据。我们依旧初始化一个channel，不向其中插入数据，直接提取数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    num := &lt;-intChan</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的这段程序依旧会出现死锁的问题，其原因也是十分类似的：此时只有一个主协程，主协程中等待着其他协程向channel中插入数据，只有channel中有数据才可以提取出来。因此主协程被阻塞在提取的步骤上了，而没有其他的协程插入，因此编译器发现所有的协程都处于阻塞状态（虽然只有一个主协程），就报出了致命错误。错误类型是相同的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因此可以讲，channel的作用是在不同的协程中起到通信的作用，而且channel中的数据是一种动态的数据。如同水管一般，水是在水管中是流动的，正如数据在channel中流动。在一个协程中单独使用channel，或者channel中数据不流动往往是不合适的。 </p><h3 id="主协程等待子协程方式"><a href="#主协程等待子协程方式" class="headerlink" title="主协程等待子协程方式"></a>主协程等待子协程方式</h3><h4 id="channel阻塞机制"><a href="#channel阻塞机制" class="headerlink" title="channel阻塞机制"></a>channel阻塞机制</h4><p>&emsp;&emsp;既然channel在多协程的情况下提取空数据或者添加满数据时会发生阻塞，我们就可以利用这个特性让主协程等待所有的子协程执行结束后再退出了。假如程序将启动8个协程，每个协程在结束的时候向channel中写入一个true，主协程中循环8次提取channel中的bool值。当提取不满8次时，主协程阻塞；当第八次提取到了true时，说明所有子协程都结束了，主协程可以继续向下执行。 </p><p>&emsp;&emsp;现在我们通过案例来说明上述的场景，我们启动8个协程，在每个协程中0到10随机Sleep一段时间，当所有协程均结束后，主协程结束：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomDelay</span><span class="params">(channel <span class="keyword">chan</span> <span class="keyword">bool</span>, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s := rand.Intn(<span class="number">10</span>)</span><br><span class="line">    time.Sleep(time.Duration(s) * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"协程"</span>, i, <span class="string">"等待"</span>, s, <span class="string">"秒"</span>)</span><br><span class="line">    channel &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> randomDelay(channel, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">        &lt;-channel</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"主协程结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面的代码中，我们首先在主协程中确定了随机种子的值，然后初始化了容量为8的管道。在randomDelay中，我们随机生成一个0到10的整数，并让该函数阻塞对应长的时间，阻塞过后输出结果。同时在主协程中我们逐个将channel中的数据取出。由于channel中的数据只起到标志位的作用，因此能够取出数据就是我们希望的结果，而对于取出来的数据我们并不关心，因此可以不赋值给其他变量。最终，取出8次数据之后，主协程结束。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">协程 <span class="number">1</span> 等待 <span class="number">0</span> 秒</span><br><span class="line">协程 <span class="number">7</span> 等待 <span class="number">2</span> 秒</span><br><span class="line">协程 <span class="number">6</span> 等待 <span class="number">2</span> 秒</span><br><span class="line">协程 <span class="number">3</span> 等待 <span class="number">2</span> 秒</span><br><span class="line">协程 <span class="number">5</span> 等待 <span class="number">4</span> 秒</span><br><span class="line">协程 <span class="number">4</span> 等待 <span class="number">5</span> 秒</span><br><span class="line">协程 <span class="number">0</span> 等待 <span class="number">7</span> 秒</span><br><span class="line">协程 <span class="number">2</span> 等待 <span class="number">8</span> 秒</span><br><span class="line">主协程结束</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过这种方式，我们可以利用channel在多协程中的阻塞机制，让主协程强行等待最后一个子协程的结束后自己再结束。同时，channel变量自身就是线程（协程）安全的，不会出现资源共享时的竞争问题，因此在多协程通讯的时候，channel的作用可以说是十分重要的。 </p><p>&emsp;&emsp;除了这种方式之外，还有一种方式是利用管道关闭的性质完成主协程等待子协程的操作，具体的方法及细节我们将在下个小节中详细讲解。</p><h4 id="计数器模式"><a href="#计数器模式" class="headerlink" title="计数器模式"></a>计数器模式</h4><p>&emsp;&emsp;除了上述channel阻塞模式之外，我们还可以利用sync包中的WaitGroup类来完成该需求。其本质即是一个计数器：当我们开启一个协程时让计数器增加1，当某个协程结束时令计数器减少1，在计数器归零之前程序处于阻塞的状态，当计数器归零，程序就可以继续向下执行了。</p><p>&emsp;&emsp;在WaitGroup类中，主要被用到的只有三个方法：Add方法，Done方法和Wait方法。当我们希望在程序运行过程中对计数器进行增加操作时，我们就调用Add方法。Done方法与Add方法相反，程序每次调用Done方法都会令计数器自减。而Wait方法则是程序在调用其位置进行阻塞，直到计数器归零。  </p><p>&emsp;&emsp;在这里需要明确的是：WaitGroup既然是一个类，那么其对象即满足值类型的本质，当WaitGroup对象作为函数参数传递时，是需要复制一份副本进行传递，这样在函数方法内部就无法对计数器本身进行修改。因此在函数参数的传递过程中大多数还是要传递WaitGroup<strong>指针</strong>，否则计数器不归零程序将持续阻塞。我们举例完成上述同样的需求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomDelay</span><span class="params">(wg *sync.WaitGroup, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s := rand.Intn(<span class="number">10</span>)</span><br><span class="line">time.Sleep(time.Duration(s) * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"协程"</span>, i, <span class="string">"等待"</span>, s, <span class="string">"秒"</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> randomDelay(wg, i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"主协程结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在程序中，我们每启动一个goroutine，都令WaitGroup对象（wg）自增1，当每个goroutine结束的时候，我们都让计数器减1（Done方法），最后我们在程序的结尾处调用Wait方法，使得主协程开始阻塞等待所有协程的结束。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们首先介绍了队列数据结构的基本思路，进而说明了channel的核心就是一个队列。然后我们又简要介绍了Go语言中channel的定义方式以及channel中数据类型的多样性。随后我们又初始化channel，并说明了向管道写入以及从管道内取出数据的方法以及异常情况的阻塞机制。最后我们通过这种阻塞机制说明了主协程等待子协程的方法。 </p><p>&emsp;&emsp;在下个小节中，我们将集中针对channel数据类型讲解其各个细节，并通过一段代码综合地讲解goroutine和channel的配合。在这之后，读者应该可以完成一定的多协程开发与协程交互的任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-52-gt-channel管道入门&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-52-gt-channel管道入门&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;52&amp;gt; cha
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;51&gt; 资源竞争与管道</title>
    <link href="http://yoursite.com/2020/03/29/51-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E4%B8%8E%E7%AE%A1%E9%81%93/"/>
    <id>http://yoursite.com/2020/03/29/51-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E4%B8%8E%E7%AE%A1%E9%81%93/</id>
    <published>2020-03-29T14:13:21.000Z</published>
    <updated>2020-03-29T14:14:08.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-51-gt-资源竞争与管道"><a href="#Go语言从入门到放弃系列-lt-51-gt-资源竞争与管道" class="headerlink" title="Go语言从入门到放弃系列&lt;51&gt; 资源竞争与管道"></a>Go语言从入门到放弃系列&lt;51&gt; 资源竞争与管道</h2><p>&emsp;&emsp;在计算机语言中，对硬盘的读写和对内存空间的读写往往是不可避免的。在单线程单协程的环境下由于对资源的访问是顺序的，因此读写的问题并不能被表露出来。然而到了多协程程序设计中，我们并不能得出一个明确的结论哪一个协程先执行完，哪一个协程后执行完。且有极大的可能性多个协程共同执行完，那么当多个协程同时想读写一个文件时，就会出现资源的冲突。 </p><p>&emsp;&emsp;在这个小节中，我们将首先通过一个简单的案例引出Go语言中资源竞争的问题，同时将给出两种解决该问题的方式：全局互斥锁与管道channel。然后再对channel的知识点进行快速入门介绍。</p><h3 id="资源竞争问题"><a href="#资源竞争问题" class="headerlink" title="资源竞争问题"></a>资源竞争问题</h3><p>&emsp;&emsp;资源竞争往往出现在对内存或硬盘的写操作上，我们举一个日常的例子：假如只有一本书和多个人，这本书可以被多个人分享，且多个人可以同时读这一本书，每个人读到的内容不会出现不同，因此读操作是不会出现资源竞争的。相反，假如只有一个笔记本和多个人，多个人同时希望向一个本子上写一页的东西，这就出现了问题，因为当一个人在写东西的时候，其他人只能在一旁观看而不能同时写，因此在写的过程中出现了资源竞争。（这里我们不谈Google Doc等应用的实现方式） </p><p>&emsp;&emsp;我们接下来通过一段程序来说您这个问题，程序的需求如下：我们需要计算1到20的各个数字的阶乘，将阶乘结果保存到一个map中，在程序的最后将map输出到终端，要求通过协程技术来完成。基于现有的知识掌握，我们可以通过以下的思路来解决该问题：首先定义一个全局变量map，同时在自定义函数中完成阶乘操作与写入，然后在主函数中协程形式调用该函数，Sleep一小段时间后（这个问题我们会在这个小节解决），输出最终的map到控制台终端。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    myMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multi</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    result := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        result *= i</span><br><span class="line">    &#125;</span><br><span class="line">    myMap[n] = result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> multi(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"map[%d] = %d \n"</span>, i, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果我们采用如上的代码来完成这个需求，且按原来的方式进行编译运行，在一定的情况下可能会出现错误，因为多个协程同时请求了同一个map资源，因此会出现并发的写操作。这个问题有时候可能不会出现，因为我们只启动了20个协程，且阶乘操作用的时间不同，因此在20个的前提下还是存在不出现资源竞争的可能的。但是一旦我们需要计算1-200的阶乘，那么出现这个问题的概率就极大了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fatal error: concurrent <span class="keyword">map</span> writes</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">20</span> [running]:</span><br><span class="line">runtime.throw(<span class="number">0x4c56f0</span>, <span class="number">0x15</span>)</span><br><span class="line">  c:/<span class="keyword">go</span>/src/runtime/<span class="built_in">panic</span>.<span class="keyword">go</span>:<span class="number">608</span> +<span class="number">0x79</span> fp=<span class="number">0xc000097f60</span> sp=<span class="number">0xc000097f30</span> pc=<span class="number">0x429de9</span></span><br><span class="line">runtime.mapassign_fast64(<span class="number">0x4a8a40</span>, <span class="number">0xc000070240</span>, <span class="number">0x2</span>, <span class="number">0x0</span>)</span><br><span class="line">  c:/<span class="keyword">go</span>/src/runtime/map_fast64.<span class="keyword">go</span>:<span class="number">172</span> +<span class="number">0x2f1</span> fp=<span class="number">0xc000097fa0</span> sp=<span class="number">0xc000097f60</span> pc=<span class="number">0x40f2c1</span></span><br><span class="line">main.multi(<span class="number">0x2</span>)</span><br><span class="line">  E:/GoProject/src/demo/demo.<span class="keyword">go</span>:<span class="number">17</span> +<span class="number">0x6b</span> fp=<span class="number">0xc000097fd8</span> sp=<span class="number">0xc000097fa0</span> pc=<span class="number">0x490c9b</span></span><br><span class="line">runtime.goexit()</span><br><span class="line">  c:/<span class="keyword">go</span>/src/runtime/asm_amd64.s:<span class="number">1333</span> +<span class="number">0x1</span> fp=<span class="number">0xc000097fe0</span> sp=<span class="number">0xc000097fd8</span> pc=<span class="number">0x4519d1</span></span><br><span class="line">created by main.main</span><br><span class="line">  E:/GoProject/src/demo/demo.<span class="keyword">go</span>:<span class="number">22</span> +<span class="number">0x5f</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果希望更明确地看到这个问题的出现，我们在编译过程中可以通过 -race 的方式进行编译，然后再正常执行。这个结果我们就不做演示了，是可以得到具体哪几个协程发生了冲突的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build -race demo.<span class="keyword">go</span></span><br><span class="line">demo.exe (这个命令不同系统是不同的)</span><br></pre></td></tr></table></figure><h3 id="全局互斥锁"><a href="#全局互斥锁" class="headerlink" title="全局互斥锁"></a>全局互斥锁</h3><p>&emsp;&emsp;基于上述的问题，我们采取的第一种解决方式就是通过全局互斥锁的方式解决数据访问冲突。资源竞争的核心就是多个协程同时向同一个资源进行写操作，而操作系统与语言底层并没有某种机制来解决这个问题。在Go语言中，我们可以通过加锁的方式来完成。 </p><p>&emsp;&emsp;依旧首先举一个显式的例子：在一些ATM机取钱时，往往会有一个小的安全空间，每次只能让取款的人进入，而其他的取款人需要在门外排队等待。正在取款的人需要将们锁住代表目前这个ATM机的操作权限归他所有，当他取款过后，需要将门解锁后出来，后面的下一个人才能进入，这个例子其实就锁的机制。 </p><p>&emsp;&emsp;我们将这个例子应用到以上的程序中，我们可以采用如下的解决过程：首先定义一个全局的互斥锁，在程序中当一个协程需要写资源时，这个协程需要申请这个锁，如果没有任何其他协程拥有这个锁，这个协程就可以完成写的操作。且当该线程进行写操作时，其他写操作的协程需要等待。同理，当一个协程完成了写操作之后，这个锁就会被队列中的下一个协程所拥有。 </p><p>&emsp;&emsp;在程序设计中，我们采用的是sync包中的Mutex类，该类中存在两个方法分别是Lock方法和Unlock方法，接下来我们通过这个技术修改上述的程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    myMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    lock sync.Mutex</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multi</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    result := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        result *= i</span><br><span class="line">    &#125;</span><br><span class="line">    lock.Lock()</span><br><span class="line">    myMap[n] = result</span><br><span class="line">    lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过以上的改动之后，我们在全局变量处定义了一个Mutex锁，在对map写入之前进行Lock操作，写入之后进行Unlock操作。这次再像往常一般执行代码，就不会出现资源竞争的问题了。因为代码中的map同一时刻下只能被一个协程所拥有，其他协程需要在队列中等待。 </p><p>&emsp;&emsp;即便如此，我们通过加锁的方式解决了concurrent map writes的问题，但是协程之间的通讯问题依旧没有解决。换句话说我们依旧需要time.Sleep方法让主协程强行等待一个固定的时间，但这个做法十分不明智。如果当协程结束之后能够通过某种机制让主协程知道，在这之前，主协程处于阻塞的状态才是一种合适的解决方案。同时，因为Go语言中存在着Channel的解决机制，全局互斥锁的方法也被称为初等级的解决资源冲突的方案，用到该技术的时间其实并不多。 </p><h3 id="Channel引出"><a href="#Channel引出" class="headerlink" title="Channel引出"></a>Channel引出</h3><p>&emsp;&emsp;在前一个部分中我们使用全局变量加锁同步的方式来解决goroutine的通讯问题，但是依旧不完美，主要的原因有以下几点：主协程等待所有协程全部完成的时间无法估计，使得主协程的运行与各个子协程的运行相互脱节，在实际开发环境中不适合；不同的业务逻辑处理的问题不同，相应的需要的时间也不同，仅设置一个固定的时间会出现错误；通过全局变量加锁的机制其实依旧不利于多个协程对全局变量的读写操作。因此在这个小节中，我们引出Go语言中channel的用法，并用channel的方式解决上述问题。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mapChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">20</span>)</span><br><span class="line">    myMap  = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multi</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    result := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        result *= i</span><br><span class="line">    &#125;</span><br><span class="line">    m[n] = result</span><br><span class="line">    mapChan &lt;- m</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> multi(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ &#123;</span><br><span class="line">        temp := &lt;-mapChan</span><br><span class="line">        <span class="keyword">for</span> key, value := <span class="keyword">range</span> temp &#123;</span><br><span class="line">            myMap[key] = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(myMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码通过channel的方式完成了多协程计算阶乘的功能。在这里我们只是稍微地引出了Go语言中channel的使用方式。如果现阶段暂时没能理解上述代码是没有关系的。后续的几个小节将详细地讲解channel管道的使用方式与注意事项。届时可以反过来重新看上述的代码，想必可以完全理解了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们首先通过一个案例引出了Go语言全局变量的资源竞争问题。然后又简要地讲解了全局互斥锁的概念与简单的使用，同时我们也提及了全局互斥锁是一个相对初级的解决资源竞争的方案。最后我们引出了channel的概念，并通过channel的方式解决了上述的资源竞争的问题。在下个小节中，我们将开始针对Go语言中的channel进行相对详细地讲解，并通过代码案例来说明各个知识点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-51-gt-资源竞争与管道&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-51-gt-资源竞争与管道&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;51&amp;gt; 资源竞争与管道&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;50&gt; Goroutine入门</title>
    <link href="http://yoursite.com/2020/03/27/50-Goroutine%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2020/03/27/50-Goroutine%E5%85%A5%E9%97%A8/</id>
    <published>2020-03-27T08:17:33.000Z</published>
    <updated>2020-03-27T08:18:43.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-50-gt-Goroutine入门"><a href="#Go语言从入门到放弃系列-lt-50-gt-Goroutine入门" class="headerlink" title="Go语言从入门到放弃系列&lt;50&gt; Goroutine入门"></a>Go语言从入门到放弃系列&lt;50&gt; Goroutine入门</h2><p>&emsp;&emsp;在上个小节中我们从概念上讲解了进程、线程、协程的关系，以及并发和并行的区别与联系。同时我们也针对了线程协程的执行效率做了简要的讨论。</p><p>&emsp;&emsp;在这个小节中，我们将开始通过简单的代码来讲解Go语言中协程的特性与注意事项。如果说前面的各个章节中的知识点的讲解中，如果代码相同，我们都可以得到同样的答案（除了物理地址），那么对于协程的使用而言，同样的代码的执行结果大家的可能就不甚一致了，而且更多的情况中是非常不一致的。因此在这个小节中我们所展示出来的执行结果只是诸多可能的结果中的一个。 </p><h3 id="Goroutine快速入门"><a href="#Goroutine快速入门" class="headerlink" title="Goroutine快速入门"></a>Goroutine快速入门</h3><p>&emsp;&emsp;在上个小节中，我们提到：协程是一种逻辑上的概念而不是物理上的概念，同时我们在举例的时候也曾将协程的本质比作为一个函数。在Go语言的实现中，协程确实就是一个函数，它的内容与普通函数没有什么本质上的区别，只是在函数的调用过程中进行多协程、多线程的调用而已。 </p><p>&emsp;&emsp;基于上述的讲解，我们假设一种简单的需求：在Go语言主线程中每隔1秒输出一句”我在主线程X”，同时我们也需要在一个协程中每隔一秒输出一句”我在协程中X”，上述过程重复10次，X为当前所在的次数。如果我们不使用协程，因为顺序结构的存在，这两个过程就需要具有先后顺序。我们先完成顺序结构的代码的编写，进而再修改为协程的模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inRoutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">"我在协程中"</span>, i)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inRoutine()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">"我在主线程"</span>, i)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们定义了一个名为inRoutine的函数，在函数中我们循环10次，每次输出一个字符串并等待1秒钟。在主函数中我们首先调用了这个函数，然后再执行另一个循环，循环中输出10次我在主线程。那么根据之前我们所讲解的顺序结构，我们可以直接分析出执行结果：即先输出10次”我在协程中”，然后再输出10次”我在主线程”，且这个结果是一定的，不会有任何的例外。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我在协程中 <span class="number">1</span></span><br><span class="line">我在协程中 <span class="number">2</span></span><br><span class="line">...</span><br><span class="line">我在协程中 <span class="number">10</span></span><br><span class="line">我在主线程 <span class="number">1</span></span><br><span class="line">...</span><br><span class="line">我在主线程 <span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个结果是毋庸置疑的，而且通过运行过程我们也可以发现大致运用了20秒的时间，因此这两个过程是串行的，并没有达到我们的要求。现在我们就将上述的串行过程修改为并行的过程，改动的地方其实只有一个，将调用函数的部分修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> inRoutine()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时修改过后的程序就成为并行的形式了，可以看做为”我在主线程”的输出与”我在协程中”的输出是同时发生的。但是因为我们需要在屏幕上输出，而屏幕的输出是有顺序的，因此屏幕输出的时候是无法同时输出两个字符串的。反过来说，我们此时也无法通过屏幕输出的先后确定哪个字符串先输出了，宏观上我们认为是同时。 </p><p>&emsp;&emsp;既然输出的先后关系与发生的同时相悖，所以在同时发生的前提下，究竟谁会先输出是一个不可知的情况，因此大家的输出结果可能不相同。因此在一些测试中，往往不会在程序编写的题目中涉及多线程或多协程的概念，因为一旦涉及了这些概念，输出结果可能就是未知的了，我们下面列举出一个可能的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">我在主线程 <span class="number">1</span></span><br><span class="line">我在协程中 <span class="number">1</span></span><br><span class="line">我在协程中 <span class="number">2</span></span><br><span class="line">我在主线程 <span class="number">2</span></span><br><span class="line">我在主线程 <span class="number">3</span></span><br><span class="line">我在协程中 <span class="number">3</span></span><br><span class="line">我在协程中 <span class="number">4</span></span><br><span class="line">我在主线程 <span class="number">4</span></span><br><span class="line">我在协程中 <span class="number">5</span></span><br><span class="line">我在主线程 <span class="number">5</span></span><br><span class="line">我在主线程 <span class="number">6</span></span><br><span class="line">我在协程中 <span class="number">6</span></span><br><span class="line">我在主线程 <span class="number">7</span></span><br><span class="line">我在协程中 <span class="number">7</span></span><br><span class="line">我在协程中 <span class="number">8</span></span><br><span class="line">我在主线程 <span class="number">8</span></span><br><span class="line">我在协程中 <span class="number">9</span></span><br><span class="line">我在主线程 <span class="number">9</span></span><br><span class="line">我在协程中 <span class="number">10</span></span><br><span class="line">我在主线程 <span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过该结果来看，输出的先后顺序确实没有什么规律，而且再一次运行上述代码所得到的结果与上述结果可能还是不同的。但是有一点是可以确定的：在一个协程中的输出结果是有顺序的，比如协程中1就会在协程中2的前面，但是协程中1却无法保证在主线程1的后面。因此可以讲，协程之间没有确定的先后关系，但是协程之中还是满足顺序结构且具备先后关系的。</p><h3 id="MPG模型简介"><a href="#MPG模型简介" class="headerlink" title="MPG模型简介"></a>MPG模型简介</h3><p>&emsp;&emsp;可以说Go语言具备一次性启动上千的协程的能力都归功于其实现的MPG模型，在这个部分中我们对MPG模型做出简要的说明。M所指的是Machine，每个M一般直接关联一个内核线程，是物理级的且受操作系统管理；P指的是Processor，代表了M执行所需要的上下文环境。G代表Goroutine，其本质也是个轻量级线程，受到P的调度与对接。 </p><p>&emsp;&emsp;一般来说，P的数量往往取决于机器的核心数，例如我们的机器是4核的机器，那么它就会被设定为4。当然我们也可以通过GOMAXPROCS手动设定，在新版本Go中默认就是机器所具备的核数。Goroutine可以有许多个且存在于多个队列中，每个P都会将G从一个队列中取出执行，其他的G处于等待的状态。同时在多个P的情况下，通常每一个P都负责一个队列以减少资源锁的竞争。 </p><p><img src="/2020/03/27/50-Goroutine%E5%85%A5%E9%97%A8/1.jpg" alt></p><p>​                                                                     (图片来源于网络)<br>&emsp;&emsp;因此MPG的关系可以如上图表示：每一个M上挂载一个P，每一个P维护一个G的队列；在某一个时间点上，每个P上只有一个G在运行，其他的G处在队列中等待。因此可以讲，每启动一个Goroutine，都会在某个队列的末尾加入一个G，一旦P运行直到调度点的时候，某个G就会从队列中弹出，设定堆栈等后就开始执行。 </p><p>&emsp;&emsp;那么有些人可能会想：为什么需要这个P，直接把G队列绑定在M上不可以么。答案是不可以的，因为P存在的目的就是进行协程与线程之间的调度。例如在系统调用systemcall的时候，一个线程无法做到同时执行代码和系统调用。因此这个时候当前线程就不得不放弃当前的上下文。假设当前M0维护了一个协程队列，此时M0所执行的G0发生了系统调用，那么M0就必须要等待G0的系统调用的结束，在等待的这段时间中，系统会创建（或借用）一个M1线程，并将P以及P所维护的G队列都挂载在M1上继续进行。 </p><p><img src="/2020/03/27/50-Goroutine%E5%85%A5%E9%97%A8/2.jpg" alt></p><p>&emsp;&emsp;从图中可以看出，此时在系统调用的时候，M0上只有G0，那么当系统调用结束后，M0上就没有P了，它会选择偷一个P过来运行。如果没有多余的P可偷，那么G0就会被放入全局的队列中并被均衡负载在其他的队列中，而M0则进入线程缓存以等待下一个调用的来临。 </p><p>&emsp;&emsp;不仅如此，每个P会定期检查全局队列中是否有剩余的G，以便本M执行完队列中所有的G的时候有事可做。一旦全局G队列中没有多余的G的话，该P会在其他的P中借来一些G去运行。往往当P去借其他的P的时候，它会直接借取其他P的一半的队列。所以说，在多线程多协程的代码中，因为负载均衡，因为系统调用等多个因素，多个协程的执行先后顺序是完全无法被确定的，因此代码的执行结果也是无法预料的。 </p><h3 id="Go语言中线程与协程的关系"><a href="#Go语言中线程与协程的关系" class="headerlink" title="Go语言中线程与协程的关系"></a>Go语言中线程与协程的关系</h3><p>&emsp;&emsp;在之前的小节中，我们介绍到线程是存在于进程中的，协程是存在于线程中的，因此在Go语言中一旦主线程启动了协程之后，程序就会遵循如下的规律：当协程结束时，主线程不受影响；当主线程结束时，协程不论运行到什么状态都要停止且消失。对此我们做一个实验来证明：我们首先将协程中等待1秒改为等待0.5秒，这样协程就会先结束。然后我们令协程中等待1秒，而主线程中等待0.5秒，此时主线程会先结束。我们看最终的输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">我在主线程 <span class="number">1</span></span><br><span class="line">我在协程中 <span class="number">1</span></span><br><span class="line">我在协程中 <span class="number">2</span></span><br><span class="line">我在协程中 <span class="number">3</span></span><br><span class="line">我在主线程 <span class="number">2</span></span><br><span class="line">我在协程中 <span class="number">4</span></span><br><span class="line">我在主线程 <span class="number">3</span></span><br><span class="line">我在协程中 <span class="number">5</span></span><br><span class="line">我在协程中 <span class="number">6</span></span><br><span class="line">我在主线程 <span class="number">4</span></span><br><span class="line">我在协程中 <span class="number">7</span></span><br><span class="line">我在协程中 <span class="number">8</span></span><br><span class="line">我在主线程 <span class="number">5</span></span><br><span class="line">我在协程中 <span class="number">9</span></span><br><span class="line">我在协程中 <span class="number">10</span></span><br><span class="line">我在主线程 <span class="number">6</span></span><br><span class="line">我在主线程 <span class="number">7</span></span><br><span class="line">我在主线程 <span class="number">8</span></span><br><span class="line">我在主线程 <span class="number">9</span></span><br><span class="line">我在主线程 <span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们会发现：协程先结束的情况下，主线程依旧执行直到结束，我们再看主线程先结束的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我在主线程 <span class="number">1</span></span><br><span class="line">我在协程中 <span class="number">1</span></span><br><span class="line">我在主线程 <span class="number">2</span></span><br><span class="line">我在协程中 <span class="number">2</span></span><br><span class="line">我在主线程 <span class="number">3</span></span><br><span class="line">我在主线程 <span class="number">4</span></span><br><span class="line">我在协程中 <span class="number">3</span></span><br><span class="line">我在主线程 <span class="number">5</span></span><br><span class="line">我在主线程 <span class="number">6</span></span><br><span class="line">我在协程中 <span class="number">4</span></span><br><span class="line">我在主线程 <span class="number">7</span></span><br><span class="line">我在主线程 <span class="number">8</span></span><br><span class="line">我在协程中 <span class="number">5</span></span><br><span class="line">我在主线程 <span class="number">9</span></span><br><span class="line">我在主线程 <span class="number">10</span></span><br><span class="line">我在协程中 <span class="number">6</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们会发现，主线程结束后，协程还未运行完的情况下也就结束了。当然此时的”我在协程中 6”出现的原因是屏幕输出并发的原因，而不是主线程结束后协程依旧执行完6才结束的。 </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们讲解了Goroutine的入门程序，简单体验了一下Go语言中多协程编程的过程。在入门案例过后，我们又简单介绍了Go语言中MPG模型，也简单介绍了Go语言中G队列的调度方式。最后我们也说明了线程和协程的执行关系。到目前为止，我们尚只能通过在主线程中延时的方式（time.Sleep）等待协程结束，在下个小节中，我们将介绍Go语言协程中资源竞争的现象与管道Channel的用法，使得主线程以及协程之间可以互相通信。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-50-gt-Goroutine入门&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-50-gt-Goroutine入门&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;50&amp;gt; Gor
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;49&gt; Goroutine概念简介</title>
    <link href="http://yoursite.com/2020/03/26/49-Goroutine%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2020/03/26/49-Goroutine%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/</id>
    <published>2020-03-26T08:31:38.000Z</published>
    <updated>2020-03-26T08:32:30.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-49-gt-Goroutine概念简介"><a href="#Go语言从入门到放弃系列-lt-49-gt-Goroutine概念简介" class="headerlink" title="Go语言从入门到放弃系列&lt;49&gt; Goroutine概念简介"></a>Go语言从入门到放弃系列&lt;49&gt; Goroutine概念简介</h2><p>&emsp;&emsp;在之前的所有章节中，我们讲解的技术都是基于单线程的，换句话说我们的所有的操作都是在一条时间线上按规定的顺序执行。然而现如今，我们大多数人的机器都不是单核的，而是四核、八核乃至于更多，那么将所有的函数功能全部都集中在一个核上运行不仅浪费时间，还浪费了计算能力。 </p><p>&emsp;&emsp;因此从这个小节开始，我们将开始讲解Go语言中的多线程（协程）编程，尽最大的可能充分利用计算机的有限的资源。同时我们也将讲解到Go语言中管道（channel）的用法，讲解协程之间的通讯方式。在这之前，我们需要说明并区分几个概念，分别是：进程、线程、与协程；以及并行和并发的操作。最后我们还会基于线程协程的使用的几点讨论。 </p><h3 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h3><p>&emsp;&emsp;这三个概念和操作系统底层具备一定的关系，在这里我们并不希望通过硬件的讲解来说明这几个概念，只是大致通过具象的案例来说明。在大多数的计算机语言中，我们可能接触到的更多的是进程与线程的概念，而协程这个概念相对较少。协程并不是Go语言所独有的，但是Go语言对协程的实现也是这个语言的一大亮点。 </p><h4 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h4><p>&emsp;&emsp;进程这个概念也是由来已久了，这个概念在60年代初就已然出现了。狭义上讲，进程就是正在运行的程序实例，举个最简单的例子就是：当我们在Windows上打开了一个exe文件，那么系统中就会多一个程序实例，也就是多了一个进程。再比如说，当我们切出任务管理器，进入到进程的这个栏目中，我们所能看到的所有的都是进程，当我们将一个程序关闭时，在任务管理器中这个进程也就消失了，当我们通过任务管理器结束某个进程时，对应的程序也同样结束。 </p><p>&emsp;&emsp;在任务管理器中不是所有的进程都能够在桌面（控制台）可见，因为有许多的进程都是后台进程。比如系统的更新服务，各个硬件的驱动程序，系统中断服务等。 </p><p>&emsp;&emsp;广义上来说，进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动（源自百科）。在传统的操作系统中，进程是一个基本的分配单元，也是一个一个基本的执行单元。每一个进程都有自己的地址空间，一般情况下地址空间中包含代码段、数据段、和堆栈段。代码段存储处理器执行的代码、数据段存储变量和执行期间使用的内存、堆栈段则维护活动过程中的指令和本地变量。 </p><p>&emsp;&emsp;简而言之，进程可以被理解为一个在操作系统中正在运行的程序，每打开一个程序，系统中就会多一个（甚至几个）进程。一个操作系统中可以包含多个进程，进程之间相互独立，其可以同时运行。</p><h4 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h4><p>&emsp;&emsp;在上面说进程是操作系统中最小的资源管理单元，那么线程就是操作系统中最小的执行单元。不论是进程还是线程，都是由操作系统底层所管理的。线程是被包含在进程之中，是进程的实际运作单位，一个线程就是进程中的一个单一顺序的控制流，一个进程可以并发多个线程。 </p><p>&emsp;&emsp;线程是独立调度和分派的基本单位，线程可以分为操作系统内核所调度的线程，以及用户进程自行调度的用户线程。在多核或多CPU中使用多线程程序设计的好处是显而易见的：多线程提高了程序的执行吞吐率， 在单核CPU上使用多线程可以将I/O处理、人机交互等延时操作与计算分开执行。例如在一些网络游戏中，往往会分出一个线程用来做网络交互、一个线程做游戏控制、一个线程做界面输出。 </p><p>&emsp;&emsp;一个进程可以具备多个线程，如果将进程理解为操作系统，那么线程的地位就是相当于操作系统的进程。因此线程可以被理解为一个轻量级的进程，它也是独立调度和分配的基本单元。同时线程可以并发执行且共享进程资源。 </p><p>&emsp;&emsp;那么既然说起共享资源，那就不得不提出多线程的一个主要难题：资源冲突，即多个线程公用一个资源时就很容易出现这个问题，例如两个并发线程中，一个线程读取一个文件，另一个线程写入这个文件，那么此时就出现了资源问题。那么其解决方式就是添加同步锁等，这个行为是比较消耗计算资源的，同时在线程之间的互相切换过程中，也是消耗系统资源的。不仅如此，因为线程是由操作系统所调度的，所以就如同打开软件多了系统会卡顿一样，当一个程序启动的线程多了，操作系统和该软件也会卡顿。因此，即便线程是轻量级的进程，但是对于一些应用来说，它还是相对重一点。</p><h4 id="3-协程"><a href="#3-协程" class="headerlink" title="3. 协程"></a>3. 协程</h4><p>&emsp;&emsp;协程相比于线程，就如线程相比于进程。协程可以理解为更为轻量级的线程，只是协程不由操作系统所接管，而是由程序进行控制其挂起和运行等操作的。因此，可以将协程理解为一个特殊的函数，这种函数可以在某个地方挂起，也可以在挂起处继续运行。一个线程可以具备多个协程，换句话说，一个线程内可以具备多个类似的特殊的函数。 </p><p>&emsp;&emsp;协程具备自己的寄存器以及上下文，协程在调度切换时，是将寄存器等保存在其他地方，当从挂起的地方继续执行时，会将保存下来的资源恢复。协程相比于线程有一个本质上的区别，线程是操作系统中最小的执行单元，归根结底线程还是在操作系统的控制之中的，其并发调度运行是物理级别的。而协程看作为一种特殊的函数，是通过线程的程序所调度的，因此此时的并发操作是逻辑上的，内存级别的，没有像线程调度一般需要系统资源。 </p><p>&emsp;&emsp;一个线程可以具备多个协程，反过来说多个协程是存在于一个线程中的。由于只有一个线程，因此它不存在同时写变量的冲突。在协程中控制共享资源不加锁，只需要判断状态即可（但会出现资源竞争问题），因此其执行效率比多线程效率高。那么既然协程是在一个线程中执行，多核CPU并行操作则是采用进程+协程的方式完成的，这既充分利用了多核操作，又充分发挥了协程的高效率，性能会有较大的提升。</p><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>&emsp;&emsp;这两个概念也比较容易混淆，也确实有时候比较难以分辨两个词的区别。本质上来说，这两个词都代表了多个任务”同时”完成的情况，但具体区别则是单核与多核的区别。 </p><h4 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h4><p>&emsp;&emsp;并发在操作系统中是指某一个时间段中，有几个程序都处于启动的状态下。这几个程序都是在同一个计算单元上运行，但是任何一个时间点上其实只有一个程序在计算单元上运行。CPU分配时间片给每个程序，让每一个程序都有机会快速地运行，在视觉效果上，就像是多个程序同时执行。 </p><p>&emsp;&emsp;用一个比较具象化的例子来说就是写作业的过程：假设一个学生需要完成数学、语文、英语、物理四门课的作业。有一种写作业的办法就是：按顺序做完每一科作业，做完数学作业再开始做物理作业。第二种方式则是数学做一点，语文做一点，英文做一点，物理做一点，之后再数学做一点，一直到所有的作业都做完。其实两种写作业所用的时间相差无几，但是在视觉效果上看，这个学生好像四科作业同时在做。 </p><p>&emsp;&emsp;对于计算机的并发而言，无非就是将上述第二种写作业的方式的运行时间极大缩短，假如说做了10毫秒的数学之后立刻做10毫秒的语文。这样在极短的时间下，不仅视觉上还是感觉上都像是多个任务同时发生了。 </p><h4 id="2-并行"><a href="#2-并行" class="headerlink" title="2. 并行"></a>2. 并行</h4><p>&emsp;&emsp;并行则是计算机系统中同时执行两个或多个处理的计算方法。其主要目的是节省大型和复杂问题的解决时间，对代码工作做出一定的优化。将多个相互独立的任务分配给计算机的不同的CPU核中使之同时完成。但是并行并不能保证一定会加速。理论上来说，在n个并行处理的执行速度的最好结果是在单一处理器上执行的速度的n倍，但往往达不到这个比例。 </p><p>&emsp;&emsp;我们依旧采用上述写作业的例子来说明并行，假如这个学生依旧需要完成这四门功课。这时，这个学生又找来了三个朋友，并让这三个朋友帮助自己，使每一个人各做一门功课。这样在外人的眼中看来，这四门课才是真正的同时完成的，且也是真正节省了时间的。 </p><h4 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h4><p>&emsp;&emsp;并行与并发概念十分相似，但是又有所区别：并行的概念是指多个事件在同一时刻发生，而并发的概念则是多个事件在同一时间间隔内发生。在多程序的前提下，并发是指一段时间内宏观上有多个任务同时运行，但是在微观上则是只有一个任务分时交替进行。在计算机中若有多个处理器，任务被分配到不同的核心上，实现并行执行，此时多个任务是真正地同时进行。 </p><h3 id="基于多线程（协程）思想的几点讨论"><a href="#基于多线程（协程）思想的几点讨论" class="headerlink" title="基于多线程（协程）思想的几点讨论"></a>基于多线程（协程）思想的几点讨论</h3><p>&emsp;&emsp;在大多数情况下，我们都会说多线程多协程会节省时间，但是这个节省时间也是有一定条件的，这个条件就是I/O密集。在介绍并发的概念时我们所举的例子中，我们可能会发现每个作业做一点直到做完和按顺序做完每一科作业似乎没什么区别，甚至在并发的时候不断地换作业册反而更浪费时间。对于计算机而言其实也是一样的，线程、协程之间的调度也是需要时间和资源的，如果用并发模式来解决作业的问题显然是不可取的。 </p><p>&emsp;&emsp;现在我们换一种方式来理解，假如对于各个单科作业而言，每做完一小部分都需要家长核查一下答案，如果答案正确才可以继续进行。在这个前提下，如果按顺序完成单科作业的话，学生则会需要很多的等待时间。这个等待时间如果被利用下来去做其他科目的作业，那么学生和家长就可以好好地配合起来了。对于计算机而言，CPU和I/O可以被认为两种相对独立的任务，且CPU中运算速度是比I/O执行速度要快的多。例如当前的任务是打开一个文件，读取文件中的两个数，相加并写进这个文件中。那么这个任务所用的时间绝大多数都花在了打开文件和写入文件上。当I/O在完成这两个步骤时CPU其实是空闲的。 </p><p>&emsp;&emsp;因此可以讲，对于并发模式的使用而言，I/O密集的任务更为适合。而对于那种数学计算等任务，绝大多数运算都在CPU中，而没有文件操作，那么并发模式不仅没有节省时间，反而浪费了更多的时间。 </p><p>&emsp;&emsp;那么对于并行模式而言，虽然它可以真切地减少运行时间，但是能够应用并行模式的算法不多。只有同一个层面上相互独立的任务才有机会使用并行的模式。当多个函数之间存在先后关系，即后一个函数需要前一个函数的结果时，并行模式就不是很适用了。对于一个算法而言，一定会有可以并行运行的部分和必须要串行运行的部分。因此来说，即便是4核、8核的CPU，程序运行效率也无法达到4倍或8倍。 </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们介绍了进程、线程、和协程的概念，同时也区分了并行模式和并发模式的区别。在最后我们也针对并行和并发模式做出了几点讨论。可以说在这个小节中我们没有涉及到任何的代码操作，只是在思路上和概念上进行了一定的科普。在下个小节中，我们将介绍Go语言中Goroutine的语法以及其需要注意的各个事项。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-49-gt-Goroutine概念简介&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-49-gt-Goroutine概念简介&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;49&amp;gt;
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;48&gt; JSON与序列化</title>
    <link href="http://yoursite.com/2020/03/25/48-JSON%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://yoursite.com/2020/03/25/48-JSON%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2020-03-25T15:44:23.000Z</published>
    <updated>2020-03-25T15:45:03.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-48-gt-JSON与序列化"><a href="#Go语言从入门到放弃系列-lt-48-gt-JSON与序列化" class="headerlink" title="Go语言从入门到放弃系列&lt;48&gt; JSON与序列化"></a>Go语言从入门到放弃系列&lt;48&gt; JSON与序列化</h2><p>&emsp;&emsp;在上个小节中，我们讲解了Go语言中文件的各个基本操作。在这个小节中，我们将对Go语言中的序列化与反序列化的方式进行讲解，同时也对JSON数据格式进行提及。这个小节的核心其实就是两个函数的使用，其他的基本都是针对这两个函数进行细节的讲解。首先我们先简要介绍JSON的数据格式。</p><h3 id="JSON数据格式"><a href="#JSON数据格式" class="headerlink" title="JSON数据格式"></a>JSON数据格式</h3><p>&emsp;&emsp;JSON是一种轻量级的数据交换格式，易于人的阅读与机器的解析和生成。JSON是JavaScript Object Notation的简写。其层次结构简洁清晰，因此迅速成为了一种流行且理想的数据交换语言。在JS语言中一切均是对象，所以任何对象都可以通过JSON来表示，字符串、数组、数字、对象等均可以表示。在这里我们并不需要掌握JS语言，也不需要理解JS与JSON到底有什么关系，我们目前所关心的只是这种交互数据格式。 </p><p>&emsp;&emsp;我们举一个数据交互的例子：假如我们用Go语言写出了即时通讯的客户端与服务器（类比于QQ），当用户之间进行通信时，就需要一个客户端将信息发送给服务器，服务器将信息转交给另一个客户端。那么客户端到底发出了什么消息，这个就是交互数据。同理假如我们通过网页访问服务器，例如CRM系统后台，我们依旧需要从浏览器发出一个HTTP请求，请求中带有需要交互的数据。 </p><p>&emsp;&emsp;可以说交互数据就是双方的一种协议，双方规定好数据如何传输，某一个键到底对应了什么值。一旦这些规定都完成后，前后台就可以基本完全地分离，甚至双方所用的技术语言都可以不同，只要他们按规定传输数据、按规定解析数据即可。 </p><p>&emsp;&emsp;既然是规定协议，那么JSON就需要遵循几个规则，其规则如下：</p><h4 id="1-大括号保存对象"><a href="#1-大括号保存对象" class="headerlink" title="1.大括号保存对象"></a>1.大括号保存对象</h4><p>&emsp;&emsp;所有JSON对象都是存在于一对大括号之间的，大括号可以进行嵌套。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="2-键值对表示对象"><a href="#2-键值对表示对象" class="headerlink" title="2.键值对表示对象"></a>2.键值对表示对象</h4><p>&emsp;&emsp;键值对的概念我们曾经在map映射部分进行过提及，因此这里不对键值对的概念再做什么说明。键与值之间用冒号进行连接，不同数据之间用逗号分隔。例如我们想传输某个学生的信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Devin"</span>,<span class="string">"age"</span>:<span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="3-中括号保存数组"><a href="#3-中括号保存数组" class="headerlink" title="3.中括号保存数组"></a>3.中括号保存数组</h4><p>&emsp;&emsp;一旦一个JSON对象需要传输多组数据，那么就需要用中括号来保存数组。数组中的每一个元素均遵循大括号保存对象与键值对表示对象的原则，例如我们希望传输两个学生的信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="string">"name"</span>:<span class="string">"DENG"</span>,<span class="string">"age"</span>:<span class="number">25</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"YANG"</span>,<span class="string">"age"</span>:<span class="number">24</span>&#125;]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个JSON字符串中，我们可以发现，中括号中具有两个部分，每个部分都是一个对象，即分别由大括号包裹，每个大括号中又分别有name和age两个属性。 </p><p>&emsp;&emsp;不仅如此，JSON字符串中还可以保存普通的数组，甚至普通的基本数据，可以讲JSON确实是便于传输的数据格式，在AJAX框架中，JSON就是其专门的传输格式。当然上面说的这些也不重要，只需要能够看懂即可（相信大多数人一下子就都能看懂），同时我们也基本不会要求手写JSON数据，因为这种数据的生成往往是靠程序完成的。因此接下来我们将介绍在Go语言中JSON字符串的生成与解析。</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>&emsp;&emsp;理论上来说，序列化与JSON是没有关系的，只是说在Go语言中JSON是序列化的一个良好的形式。序列化是将对象的状态信息转换成可以存储或可以传输的形式的过程。我们举一个例子，假如我们的程序中有Student类，类中有Name和Age属性，在main函数中我们定义了一个数组，数组中包含5个Student对象，现在我们希望将这5个学生对象存在硬盘中，以备在程序关闭后下次执行的时候读取它，也就是一个保存的过程。 </p><p>&emsp;&emsp;面对这个需求，我们可能会想出如下的一个保存方式：将5个学生的信息整合成为一个字符串，属性之间用空格隔开，不同的对象之间用回车隔开，然后用IO存在本地的记事本中。这个过程其实包含了两个步骤，一个时Student对象的序列化，一个是序列化后的持久化。我们按时不看持久化过程，只看序列化过程，我们将信息整合成为一个字符串之后，就可以存储在本地，或者将这个字符串发送给其他客户端或服务器。而如果不进行序列化，对象只是在内存中的一段空间而已，是无法存储或传输的。 </p><p>&emsp;&emsp;当然，序列化不仅仅是整合成为一个字符串那么简单，它还可以整合成为其他的形式，有其他的协议规定。因此我们说JSON是一个序列化的一种合适的形式，xml文件也可以成为一种序列化的形式，我们这里只介绍JSON。 </p><h4 id="1-类的序列化"><a href="#1-类的序列化" class="headerlink" title="1.类的序列化"></a>1.类的序列化</h4><p>&emsp;&emsp;由于JSON数据的基本格式是键值对，因此类属性的定义刚好就天然地满足了键值对的格式，因此我们就先从类的序列化开始。首先我们定义一个Student类，包含Name属性和Age属性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后我们在main函数中实例化一个Student类，并为之赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s Student = Student&#123;<span class="string">"DENG"</span>, <span class="number">25</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在数据已经准备好了，我们接下来就开始对s进行序列化，我们首先需要引入一个包：encoding/json，然后使用该包中的Marshal()函数，我们将s对象传入，并得到两个返回值，分别为序列化后的数据data和error对象。得到的data数据是是个byte切片，我们在输出时将其转换为string类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s Student = Student&#123;<span class="string">"DENG"</span>, <span class="number">25</span>&#125;</span><br><span class="line">    data, err := json.Marshal(s)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"序列化失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行了上述程序之后，我们将会发现其结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"Name"</span>:<span class="string">"DENG"</span>,<span class="string">"Age"</span>:<span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们发现这个JSON字符串中的key值刚好就是Student类中的两个属性名，字符串中的value值则是我们为之赋值的数据。 </p><p>&emsp;&emsp;在这段程序中，我们会发现一个问题，在多人协作开发的过程中，往往需要key值都是小写的，如果我们将属性名的首字母变为小写，序列化的结果就是空的。这是因为我们是使用其他包中的函数，如果我们定义的属性是小写，则属性对于其他包是不可导出的，那么json包中当然就读不到对应的属性了，这个解决办法就是为属性添加tag利用反射的方式完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">    Age <span class="keyword">int</span>  <span class="string">`json:"age"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们加入了tag之后（数字1的左面的键，tab的上面的键），相当于告诉了json包，在序列化的过程中，将Name的key变为name，将Age这个key变为age，就完成了对应的功能。具体实现原理暂时不做解释，我们将会在反射的章节中详细说明。</p><h4 id="2-map映射的序列化"><a href="#2-map映射的序列化" class="headerlink" title="2.map映射的序列化"></a>2.map映射的序列化</h4><p>&emsp;&emsp;在Go语言中，不仅类属性满足于键值对的形式，map映射依旧满足于这个形式，在这个部分中，我们将举例讲解map的序列化的方式。 </p><p>&emsp;&emsp;我们首先定义一个map映射，map中的key是字符串类型，map中的value是空接口类型(interface{})，（回忆一下接口的实现原理：一个数据类型实现了接口中定义的方式则认为实现了该接口，同时该数据可以将指针赋值给接口实例）因为接口是空的，没有定义任何的方法，因此也可以说一切都实现了空接口，也就是一切都能作为map的值。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    m[<span class="string">"name"</span>] = <span class="string">"DENG"</span></span><br><span class="line">    m[<span class="string">"age"</span>] = <span class="number">25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时name所对应的value是字符串”DENG”，age所对应的value是整数25，现在我们将map映射进行序列化操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    m[<span class="string">"name"</span>] = <span class="string">"DENG"</span></span><br><span class="line">    m[<span class="string">"age"</span>] = <span class="number">25</span></span><br><span class="line">    data, err := json.Marshal(m)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"序列化错误"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们会发现，其结果是类似的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"age"</span>:<span class="number">25</span>,<span class="string">"name"</span>:<span class="string">"DENG"</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="3-切片的序列化"><a href="#3-切片的序列化" class="headerlink" title="3.切片的序列化"></a>3.切片的序列化</h4><p>&emsp;&emsp;根据之前的理解，切片中存储这多个同类型的数据，因此其序列化的结果应当是一个数组结合，在接下来的案例中，我们将实例化两个Student对象，并将对象放入切片中，最后序列化该切片，切片技术等都已然讲解过，因此直接通过代码体现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]Student, <span class="number">0</span>)</span><br><span class="line">    stu1 := Student&#123;<span class="string">"DENG"</span>, <span class="number">25</span>&#125;</span><br><span class="line">    stu2 := Student&#123;<span class="string">"YANG"</span>, <span class="number">24</span>&#125;</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">append</span>(s, stu1)</span><br><span class="line">    s = <span class="built_in">append</span>(s, stu2)</span><br><span class="line"></span><br><span class="line">    data, err := json.Marshal(s)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"序列化错误"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们会发现，其结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="string">"name"</span>:<span class="string">"DENG"</span>,<span class="string">"age"</span>:<span class="number">25</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"YANG"</span>,<span class="string">"age"</span>:<span class="number">24</span>&#125;]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同理，假如我们切片中存储的是map映射，其结果依旧类似，我们就不在这里赘述了。</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>&emsp;&emsp;作为序列化的逆过程，反序列化似乎就不难理解了。假如当我们从网络或者从文本文件中读取到了一个JSON字符串，我们想将其反过来赋值给一个map，一个类，或者一个切片，所用到的技术就是就反序列化技术。</p><h4 id="1-反序列化为类对象"><a href="#1-反序列化为类对象" class="headerlink" title="1. 反序列化为类对象"></a>1. 反序列化为类对象</h4><p>&emsp;&emsp;作为类的序列化的逆过程，我们需要首先具备JSON字符串，以及需要类的定义，然后才能通过该技术获取对象，我们通过案例来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">`&#123;"name":"DENG","age":25&#125;`</span></span><br><span class="line">    <span class="keyword">var</span> s Student</span><br><span class="line">    err := json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;s)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"反序列化失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在代码中，首先需要说明的一点是：我们在定义字符串的过程中采用了反引号（`），这是因为我们希望在字符串中保留双引号，否则我们需要通过转义的形式保留双引号。反引号的使用可以使其原样保存。 </p><p>&emsp;&emsp;第二点需要说明的是，我们传入Unmarshal函数的是Student对象指针，因为我们需要在Unmarshal函数中改变s内的值（直接传入s对象是错误的）。这段代码的结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;DENG <span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里还需要注意的一点是：假如此时我们的Student类中的Age属性（加了tag）的数据类型改为int8，反序列化依旧能够成功，因为在类型转换的时候没有出现问题。现在假如我们将25变为225，并将Age的类型改为int8，由于类型转换有误，所以输出结果为：反序列化失败。通过这个问题我们可以发现：JSON反序列化的本质就是字符串转换为其他类型而已，与生成JSON字符串的原类型无关。</p><h4 id="2-反序列化为map"><a href="#2-反序列化为map" class="headerlink" title="2. 反序列化为map"></a>2. 反序列化为map</h4><p>&emsp;&emsp;如果我们将Student类定义看成一个模板，将JSON字符串看做为内容，反序列化的工作就是将内容向模板上填充。反序列化为map也是一样的，我们定义一个map作为数据模板，然后将内容填充进去：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">`&#123;"name":"DENG","age":25&#125;`</span></span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    err := json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;m)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"反序列化失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, m[<span class="string">"age"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述程序中，我们定义了一个map，map的key是string类型，值是空接口，然后我们将str对应的byte切片和m指针传入。同时，我们又数据了m[“age”]所对应的数据类型:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[name:DENG age:<span class="number">25</span>]</span><br><span class="line"><span class="keyword">float64</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过结果我们可以发现：反序列化的结果是正确的，且JSON中的key值成为了map中的key，JSON中的键值变为了map中的value。同时我们还可以发现的是，在Unmarshal函数中对数字空接口类型的解读统一为float64。</p><h4 id="3-反序列化为切片"><a href="#3-反序列化为切片" class="headerlink" title="3. 反序列化为切片"></a>3. 反序列化为切片</h4><p>&emsp;&emsp;同理，我们定义一个切片，切片中保存的是Student类，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">`[&#123;"name":"DENG","age":25&#125;,&#123;"name":"YANG","age":24&#125;]`</span></span><br><span class="line">    <span class="keyword">var</span> s []Student</span><br><span class="line">    err := json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;s)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"反序列化失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此处我们依旧可以发现，切片s在程序中是不需要make函数的，因为在Unmarshal函数中已然帮我们make过了，上述的程序的输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;DENG <span class="number">25</span>&#125; &#123;YANG <span class="number">24</span>&#125;]</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p> &emsp;&emsp;在这个小节中，我们讲解了JSON数据类型的构成及其遵循的格式。同时，我们也讲解了Go语言中序列化与反序列化的方式方法，同时也简单说明了在这两个过程中需要注意的几个小点。序列化与反序列化在文件开发与网络开发中起着十分重要的作用，现在xml格式与json格式是传输数据中最为常用的两种模式，xml的序列化方式在encoding/xml包中，读者如果有兴趣可以自行自学尝试一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-48-gt-JSON与序列化&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-48-gt-JSON与序列化&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;48&amp;gt; JSON与序列化&quot;
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;47&gt; 文件与IO&lt;二&gt;</title>
    <link href="http://yoursite.com/2020/03/24/47-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/03/24/47-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%BA%8C/</id>
    <published>2020-03-24T10:16:50.000Z</published>
    <updated>2020-03-24T10:18:12.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-47-gt-文件与IO-lt-二-gt"><a href="#Go语言从入门到放弃系列-lt-47-gt-文件与IO-lt-二-gt" class="headerlink" title="Go语言从入门到放弃系列&lt;47&gt; 文件与IO&lt;二&gt;"></a>Go语言从入门到放弃系列&lt;47&gt; 文件与IO&lt;二&gt;</h2><p>&emsp;&emsp;在上个小节中，我们介绍了Go语言中文件的几个基本操作，包括创建文件、移动文件、删除文件、裁剪文件、以及获取文件信息所对应的函数和方法。在这个小节中，我们依旧针对Go语言中文件的读取和写入进行讲解，包括具备缓冲以及不具备缓冲的读写方式，同时也将对文件的打开模式进行简要的介绍。</p><h3 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h3><p>&emsp;&emsp;在Go语言中，文件的打开有两个函数，分别是Open函数和OpenFile函数，这两个函数的参数是不同的。简而言之，Open函数是OpenFile函数函数的简化，OpenFile函数提供了更多的自由度，可以让开发者自己指明打开方式。</p><h4 id="1-Open函数"><a href="#1-Open函数" class="headerlink" title="1.Open函数"></a>1.Open函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(file *File, err error)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Open函数的入参依旧是希望打开的文件所在的文件路径，相对路径与绝对路径均可以。函数的返回值是File实例指针和一个error实例。通过Open函数打开的文件只可以用于读取，具备O_RDONLY模式（这个模式后面会提及），如果读取出错，将会返回*PathError类型的实例。 </p><p>&emsp;&emsp;在这个部分中，我们首先向text文件中写入三行数据包括英文和中文，接下来我们打开该文件，并通过bufio中的Reader进行读取，将读取到的信息打印到控制台中。对于Reader的穿件和使用，我们曾经在输入字符串的小节中提及过，在这里我们依旧可以通过Reader读取文件中的信息。我们就通过这个案例进行快速入门：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">"text.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"打开文件失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    reader := bufio.NewReader(file)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        info, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"读取失败"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Print(info)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们首先通过Open函数打开文件，然后判断打开是否成功，延迟关闭文件。再定义Reader，使之读取文件中的内容，读取过程中按行读取，直到读取到文件的末尾：EOF（End Of File）停止读取。具体的bufio读取方式我们会在后面集中讲解。</p><h4 id="2-OpenFile函数"><a href="#2-OpenFile函数" class="headerlink" title="2.OpenFile函数"></a>2.OpenFile函数</h4><p>&emsp;&emsp;OpenFile函数相对复杂一点，其函数参数比较多，函数声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(file *File, err error)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以发现，在OpenFile函数中需要三个参数，第一个参数和Open一样，都是希望打开的文件所在的文件路径。第二个参数是一个int类型的参数，它代表着打开文件的模式，例如只读模式打开，只写模式打开，追加模式打开等，具体枚举如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    O_RDONLY <span class="keyword">int</span> = syscall.O_RDONLY <span class="comment">// 只读模式打开文件</span></span><br><span class="line">    O_WRONLY <span class="keyword">int</span> = syscall.O_WRONLY <span class="comment">// 只写模式打开文件</span></span><br><span class="line">    O_RDWR  <span class="keyword">int</span> = syscall.O_RDWR  <span class="comment">// 读写模式打开文件</span></span><br><span class="line">    O_APPEND <span class="keyword">int</span> = syscall.O_APPEND <span class="comment">// 写操作时将数据附加到文件尾部</span></span><br><span class="line">    O_CREATE <span class="keyword">int</span> = syscall.O_CREAT <span class="comment">// 如果不存在将创建一个新文件</span></span><br><span class="line">    O_EXCL  <span class="keyword">int</span> = syscall.O_EXCL  <span class="comment">// 和O_CREATE配合使用，文件必须不存在</span></span><br><span class="line">    O_SYNC  <span class="keyword">int</span> = syscall.O_SYNC  <span class="comment">// 打开文件用于同步I/O</span></span><br><span class="line">    O_TRUNC <span class="keyword">int</span> = syscall.O_TRUNC <span class="comment">// 如果可能，打开时清空文件</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第三个参数是指打开文件时的权限控制，这个在Windows操作系统中不起作用，而是在例如Linux系列或Unix系列操作系统等中会起作用。在linux操作系统中，一个文件针对用户具备三种权限，分别为r可读权限（4），w可写权限（2），以及x可执行权限（1）。同时一个文件针对本用户，用户组，其他用户的权限是不同的。 </p><p>&emsp;&emsp;例如我们在Linux终端中用ls -l命令，我们在第一列可能发现好多的dwrxwrxwrx，这里面d指代的是目录（-指代文件），第一组rwx表示对于该文件所属的主人是否具备读写执行权限，第二组rwx指对该用户所在的组的权限，最后一组代表该文件对其他用户的权限。因此，假如该文件对属主有读写执行权限，对于组内用户有读写权限，对于其他用户没有权限，则该权限为： -rwxrw—-。如果对于所有用户都有读写权限，那么我们就可以使用0666作为FileMode的值（三个组都是4+2）。由于这个涉及操作系统，因此我们不在这里详细说明了。 </p><p>&emsp;&emsp;在上一个小节中，我们也说到了在使用Create函数时，创建的文件权限就是0666，当然在OpenFile过程中，FileMode<strong>对Windows操作系统不起作用</strong>，因此写0666或者其他的0233其实都没有影响。现在我们通过OpenFile形式打开文件，其他的代码不变：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.OpenFile(<span class="string">"text.txt"</span>, os.O_RDONLY, <span class="number">0233</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时我们是通过只读的方式打开的文件，现在假如我们通过只写的方式打开文件，其他代码不变，会出现什么效果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.OpenFile(<span class="string">"text.txt"</span>, os.O_WRONLY, <span class="number">0233</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出结果为：读取失败，并return跳出程序，因为针对只写的文件，不可以读取。 </p><p>&emsp;&emsp;在flag中，我们不仅可以指明一种文件的打开模式，我们还可以指明多种组合打开方式，中间用”|”来分割。需要注意的是，组合中各个模式不可以互斥，例如通过只写模式和只读模式组合打开，那程序依旧无法读取文件中的内容。</p><h3 id="带缓冲区的读写"><a href="#带缓冲区的读写" class="headerlink" title="带缓冲区的读写"></a>带缓冲区的读写</h3><h4 id="1-读取"><a href="#1-读取" class="headerlink" title="1. 读取"></a>1. 读取</h4><p>&emsp;&emsp;在文件正确地且模式正确地打开过后，就可以向文件中写入或读取数据了，我们首先介绍的是具备缓冲区的读写方式。即通过bufio包中的newReader函数和newWriter函数获取对应的实例进行操作。由于获取Reader这个操作我们之前多次提及过了，因此我们就简单地说明一下而不举例了。 </p><p>&emsp;&emsp;在上面读取文件的代码中，我们是通过逐行读取的方式进行的，逐行读取的特点是按行读取，即每读到一个换行符（’\n’）就停止了此次的读取。值得注意的是读取到info的字符串末尾是含有’\n’的，因此我们在输出的时候就不需要Println了，而是采用的Print。在读取字符串过后，我们需要判断返回的err情况：如果err为EOF，说明读到了文件的末尾；除此之外err如果不为空，则说明读取失败（例如以只写的方式开发文件）。最后我们再进行处理info字符串。 </p><p>&emsp;&emsp;在读取过程中有人可能会遇到这样的一种情况：打开记事本后发现，最后一行没有输出出来。其原因是如果是最后一行，err会出现EOF现象，因此程序在未处理info的情况下就直接退出了。修改的方法可以是让程序先处理info字符串，再判断err，但是这样一旦读取失败，处理子串的工作就会出错。因此我们可以直接在记事本中最后一行后敲击回车，这样最后一行可以被读取，且由于换行的存在，err不会出现EOF。或者就在判断EOF的分支中做最后一次的字符串处理。</p><h4 id="2-写入"><a href="#2-写入" class="headerlink" title="2.写入"></a>2.写入</h4><p>&emsp;&emsp;写入和读取是一组逆过程，换句话说程序是如何读取的，就可以同理联想到如何写入。在这里我们举一个例子进行快速入门：向text.txt中写入10句Hello World！：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.OpenFile(<span class="string">"text.txt"</span>, os.O_WRONLY, <span class="number">0233</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"打开文件失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    writer := bufio.NewWriter(file)</span><br><span class="line">    info := <span class="string">"Hello World !\n"</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        writer.WriteString(info)</span><br><span class="line">    &#125;</span><br><span class="line">    writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们依旧打开text.txt文件，然后以只写的形式打开，然后通过bufio包中的NewWriter得到输出流，并通过该Writer向记事本中写十句话。这里尤其需要注意的一点是：由于Writer是具备缓存的，因此我们所使用的WriteString其实是向缓存中写入了十句话，而没有向文件中写。最后要用Flush方法将缓存中的数据写入硬盘，如果不调用这个方法，数据是无法写入的。 </p><p>&emsp;&emsp;需要说明一下换行的问题，传说在早期的电传打字机中，每秒可以打印10个字符，但是打完一行之后换行的时间0.2秒中刚好丢失两个字节，因此研究人员想了一个方法，就是在每行后面规定两个表示结束的字符：一个是回车，一个是换行。后来计算机发明之后，这个概念也就应用到了计算机上，但是在计算机上结尾加两个字符有些浪费，加一个字符其实就可以了，因此出现了这样的一个（坑爹的）分歧： </p><p>&emsp;&emsp;Unix操作系统中，每行的结尾是换行’\n’； </p><p>&emsp;&emsp;Windows操作系统中，每行的结尾是换行+回车’\r\n’； </p><p>&emsp;&emsp;Mac系统中，每行结尾是回车。 </p><p>&emsp;&emsp;其后果就是在Unix/Mac系统中的文件在Windows下打开，可能所有的字都变成了一行；Windows系统的文件在Unix/Mac系统下打开，会多一个莫名其妙的符号。因此，不同的平台下的换行需要自行注意一下。</p><h3 id="一次性读写"><a href="#一次性读写" class="headerlink" title="一次性读写"></a>一次性读写</h3><p>&emsp;&emsp;在上面的介绍中，我们讲解了带有缓冲的读写方式，这种方式可以将一个文件按行、按块地分批地读写。还有一种读写的方式是将文件一次性地读取写出，当文件的大小超过了内存所能容纳的大小，就会出现问题。所以在编程过程中还是相对推荐有缓存的方法的，当然如果文件都比较小，两种方式都差不多。 </p><h4 id="1-一次性读入"><a href="#1-一次性读入" class="headerlink" title="1. 一次性读入"></a>1. 一次性读入</h4><p>&emsp;&emsp;一次性读入的函数所在io/ioutil包中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;函数的参数是希望读入的文件的路径，可以是相对路径或绝对路径。返回值有两个，第一个是存储文件内容的byte切片，第二个返回值是在读取过程中是否出现了错误。我们通过案例代码进行快速入门：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    info, err := ioutil.ReadFile(<span class="string">"text.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"读取错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要说明的一点就是，ReadFile函数是在io/ioutil包中（理解成文件夹就是io文件夹下的ioutil文件夹中），因此单独引入io包是没有用的，即便是io文件夹是ioutil文件夹的父文件夹。第二点说明的是，其返回值是byte切片，因此直接输出将会是一些数字，我们需要将其以字符的形式输出，同样地byte切片对于中文的支持十分不友好，因此我们在输出的时候需要将其转为字符串输出。最后一点说明是文件打开关闭都已然封装在了函数中，因此不需要显式的打开和关闭文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Print(<span class="keyword">string</span>(info))</span><br></pre></td></tr></table></figure><h4 id="2-一次性写入"><a href="#2-一次性写入" class="headerlink" title="2. 一次性写入"></a>2. 一次性写入</h4><p>&emsp;&emsp;作为读取文件的逆过程，一次性写入的函数WriteFile也在io/ioutil包中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(filename <span class="keyword">string</span>, data []<span class="keyword">byte</span>, perm os.FileMode)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;函数参数依旧是写入文件的路径；希望写入的byte切片；以及文件权限。如果当前文件不存在将会以对应的FileMode创建该文件并写入，如果文件已然存在则会先清空文件再写入。这里不多做说明了，直接通过案例演示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">"Hello 世界! \n"</span></span><br><span class="line">    err := ioutil.WriteFile(<span class="string">"aaa.txt"</span>, []<span class="keyword">byte</span>(str), <span class="number">233</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"写入失败"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过WriteFile函数依旧不需要打开或关闭文件，这两个过程都被封装在函数中。在写入的时候需要将字符串转换为byte切片再传入函数中。最后文件模式同打开文件中所介绍的一样，对于Windows操作系统不起作用，对于Linux等系统需要进行修改（一般是0666或0777）。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们主要讲解了Go语言中文件的打开关闭函数，以及具有缓存和不具有缓存的读写方式。这个小节其实只是对入门开发者进行简要的介绍，当然Go语言API文档中还提供了例如读取当前文件路径等函数，因此对于那些熟练开发的程序员来说，这篇文章其实不甚适合，直接在API文档中寻找对应方法或函数方为上策。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-47-gt-文件与IO-lt-二-gt&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-47-gt-文件与IO-lt-二-gt&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;47&amp;gt;
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;46&gt; 文件与IO&lt;一&gt;</title>
    <link href="http://yoursite.com/2020/03/22/46-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%B8%80/"/>
    <id>http://yoursite.com/2020/03/22/46-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%B8%80/</id>
    <published>2020-03-22T12:38:41.000Z</published>
    <updated>2020-03-22T12:39:50.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-46-gt-文件与IO-lt-一-gt"><a href="#Go语言从入门到放弃系列-lt-46-gt-文件与IO-lt-一-gt" class="headerlink" title="Go语言从入门到放弃系列&lt;46&gt; 文件与IO&lt;一&gt;"></a>Go语言从入门到放弃系列&lt;46&gt; 文件与IO&lt;一&gt;</h2><p>&emsp;&emsp;在之前的几个章节中，我们分别介绍了Go语言中面向过程的部分与面向对象的部分的知识点。在这个小节中，我们将开始讲解Go语言中的文件操作，包括文件的创建、删除、读取、写入等操作。同时也就以上的几个知识点做出相对详细的讲解，并通过简单的案例完成入门代码。</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>&emsp;&emsp;在之前的各个章节的讲解中，我们经常会提到指针、内存等概念，但一直没有提到文件的使用。之前不论是通过键盘输入的还是通过计算得到的数据都是存储在内存中的。那么数据为什么不能够一直存储在内存中呢，其一个原因就是程序在关闭的时候、函数在结束的时候、乃至于出现故障突然掉电的情况下，对应区域内的内存数据会被清空而无法再次被寻找到。 </p><p>&emsp;&emsp;而文件的存在是处在硬盘中的，它具备掉电依旧保存的能力，因此我们将需要持久保存的数据写入文件中，以备出现故障等情况，亦或是在软件开发过程中就有写入文件的需求。从某种意义上讲，这个过程可以被称为持久化。一些具备丰富开发经验的人可能会想，在开发过程中往往会把数据存储在数据库这种服务软件中，其实究其本质，数据库中的数据存储方式依旧是通过文件所完成的。 </p><p>&emsp;&emsp;文件可以有很多种，而且不同的操作系统的文件也有所不同，但是不论怎样，计算机中的文件本质都是二进制。不论是音频数据、视频数据、亦或是文本数据，我们都可以以文件的形式进行操作。文件同时也具备读、写、执行等操作，只读的文件不可以被修改，只写的文件不可以被读等（当然可以通过一些操作修改其读写属性）。 </p><p>&emsp;&emsp;在Go语言中，对文件的操作基本都在于os包中，且核心结构体（类）为File类。下图是Golang文档中对于File相关的函数和方法的列表，我们将会针对其中几个进行讲解。 </p><p> <img src="/2020/03/22/46-%E6%96%87%E4%BB%B6%E4%B8%8EIO%E4%B8%80/1.png" alt><br>&emsp;&emsp;在上图中，我们可以发现，前五个是Go语言中的函数，而后续的多个均是File类所对应的方法，在使用的过程中需要注意。 </p><h3 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h3><p>&emsp;&emsp;在这个部分中，我们集中讲解文件的创建、裁剪、移动（重命名）、删除、和文件信息的获取。 </p><h4 id="1-创建文件"><a href="#1-创建文件" class="headerlink" title="1.创建文件"></a>1.创建文件</h4><p>&emsp;&emsp;在Go语言中，创建文件的所采用的是os包中的Create函数，其函数参数为希望创建的文件的路径，返回值为文件指针以及错误类型。创建模式为0666，权限模式为任何人可以读写不可以执行。值得说明的是，此处所使用的文件路径既可以是相对路径，也可以是绝对路径。相对路径是希望创建的位置与当前Go文件的相对关系，例如我们希望在当前路径的上一级创建文件，则可以使用”../xxx.txt”的方式。绝对路径则是从根目录（Windows中从对应盘符）开始逐级向下明确指明位置，最后进行创建。 </p><p>&emsp;&emsp;因此创建文件的方式相对容易，通过Create函数创建，再通过error类型判断是否创建成功即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> file *os.File</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    file, err = os.Create(<span class="string">"text.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"创建失败"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(file)</span><br><span class="line">    file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们首先定义了file变量用来承接File指针，也定义了error变量。然后通过这两个变量作为Create函数的返回值。然后我们判断err是否为空，如果err不为空（说明有错误）则输出创建失败。然后我们输出了file的值，最后关闭文件。 </p><p>&emsp;&emsp;此时我们创建的text.txt是相对路径，相对于当前目录下创建了一个空的名为text的文本文件。然后在控制台中输出的是file指针所对应的地址。需要注意的一点是创建文件的时候，文件所存储的目录一定需要存在，即在文件系统中真实存在这个目录，否则文件创建会失败，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file, err = os.Create(<span class="string">"aaa/text.txt"</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于当前Go文件所在的目录下并没有aaa的文件夹，因此文件创建是失败的。还有一点需要注意的是如果当前文件已经存在，则会将已存在的文件清空，因此在创建文件的时候需要十分注意，以免影响到原有的文件。</p><h4 id="2-文件裁剪"><a href="#2-文件裁剪" class="headerlink" title="2.文件裁剪"></a>2.文件裁剪</h4><p>&emsp;&emsp;文件裁剪采用os包下Truncate函数来完成，其核心功能是将文件裁剪到对应的大小。函数参数是一个int64类型的数，指明将文件裁剪到固定的大小。例如我们在第一个小点中创建了一个text文件，此时该文件的大小是0字节，里面没有任何的内容，此时我们通过这个函数将其裁剪为100字节：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := os.Truncate(<span class="string">"text.txt"</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时我们再看文件的属性，发现此时该文本文件为100字节，且其中的内容为100个空字符。那么假如一个文件原有大小为200字节，我们将其裁剪为100字节，则超出的100字节全部<strong>舍弃</strong>；假如文件不足100字节，则不足的字节均由空值所占据。如果没有text这个文件，则直接创建100个字节的该文件。</p><h4 id="3-移动（重命名文件）"><a href="#3-移动（重命名文件）" class="headerlink" title="3.移动（重命名文件）"></a>3.移动（重命名文件）</h4><p>&emsp;&emsp;在Go语言中，移动文件和重命名一个文件所采用的的方式是相同的，均是通过Rename函数完成的。既然是移动文件，函数参数当然是两个文件文件路径，且返回值为移动（重命名）是否成功。这个函数并不难理解，因此我们直接通过代码进行快速入门：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    oldFile := <span class="string">"text.txt"</span></span><br><span class="line">    newFile := <span class="string">"newText.txt"</span></span><br><span class="line">    err := os.Rename(oldFile, newFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"移动失败"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个函数中，新旧文件的文件路径可以是相同的，但是旧文件必须是可以被找到的，否则在运行时会报错。同理因为新文件相当于是创建文件，因此新文件所处在的文件路径依旧需要是存在的，否则也会运行时报错。</p><h4 id="4-删除文件（目录）"><a href="#4-删除文件（目录）" class="headerlink" title="4. 删除文件（目录）"></a>4. 删除文件（目录）</h4><p>&emsp;&emsp;当文件已经存在时，可以通过Remove函数来完成文件或目录的删除工作。同理，Remove函数的参数为希望删除的文件或目录的路径，包括相对路径和绝对路径。返回值依旧是error对象，来验证删除是否成功。此时我们将当前文件夹中的newText文件删除：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file := <span class="string">"newText.txt"</span></span><br><span class="line">    err := os.Remove(file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"删除失败"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Go语言中还有一个RemoveAll函数，这两个函数的区别为：RemoveAll函数可以删除指定path的文件，或者目录<strong>以及它下属的所有文件或目录</strong>。因此它会尝试删除所有的东西，直到出现错误。</p><h4 id="5-获取文件信息"><a href="#5-获取文件信息" class="headerlink" title="5. 获取文件信息"></a>5. 获取文件信息</h4><p>&emsp;&emsp;一个文件可以有许多的属性，例如文件位置，文件大小，文件权限等等。这些属性可以通过Go语言中Stat函数（方法）来完成。之所以这样讲是因为Go语言在os包中提供了Stat函数，同时也在File类中提供了Stat方法，这两种获取方式结果是大致相似的。其获取结果FileInfo类定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="keyword">string</span>    <span class="comment">// 文件的名字（不含扩展名）</span></span><br><span class="line">    Size() <span class="keyword">int64</span>    <span class="comment">// 普通文件返回值表示其大小；其他文件的返回值含义各系统不同</span></span><br><span class="line">    Mode() FileMode   <span class="comment">// 文件的模式位</span></span><br><span class="line">    ModTime() time.Time <span class="comment">// 文件的修改时间</span></span><br><span class="line">    IsDir() <span class="keyword">bool</span>    <span class="comment">// 等价于Mode().IsDir()</span></span><br><span class="line">    Sys() <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 底层数据来源（可以返回nil）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以发现，Stat函数（方法）的返回值是error变量和一个接口，通过这个接口实例可以调用相应的方法，得到文件名、文件大小、文件权限、修改时间等。我们经常通过这个函数来判断文件是否存在：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fileInfo, err := os.Stat(<span class="string">"text.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">            fmt.Println(<span class="string">"文件不存在"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(fileInfo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们主要讲解了Go语言中的文件的概念，使用场景，以及文件的基本操作，如创建、删除、移动等函数。在下个小节中，我们依旧针对文件的读写、拷贝等方式进行讲解。可以说，文件这两小节中我讲解的并不多，只是一些基本的操作方法，其实Go语言开发者为我们提供了更多的文件方法与函数。如果在日常开发中遇到文件相关的操作，API文档将会是一个更好的选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-46-gt-文件与IO-lt-一-gt&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-46-gt-文件与IO-lt-一-gt&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;46&amp;gt;
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;45&gt; 面向对象-多态</title>
    <link href="http://yoursite.com/2020/03/21/45-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2020/03/21/45-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/</id>
    <published>2020-03-21T07:08:16.000Z</published>
    <updated>2020-03-21T07:09:07.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-45-gt-面向对象-多态"><a href="#Go语言从入门到放弃系列-lt-45-gt-面向对象-多态" class="headerlink" title="Go语言从入门到放弃系列&lt;45&gt; 面向对象-多态"></a>Go语言从入门到放弃系列&lt;45&gt; 面向对象-多态</h2><p>&emsp;&emsp;在前几个小节中，我们分别讲解了Go语言中的继承概念与接口概念，同时我们也曾提及：Go语言的多态特性是通过接口的形式反映出来的。因此我们先讲解了接口的概念与语法，进而再讲解Go语言中面向对象的另一大特性：多态。在这个小节中，我们将首先讲解Go语言中继承与接口的不同点、多态的引出、以及类型断言的用法。在这之后，Go语言中面向对象部分的讲解就基本结束了。</p><h3 id="继承与接口的区别"><a href="#继承与接口的区别" class="headerlink" title="继承与接口的区别"></a>继承与接口的区别</h3><p>&emsp;&emsp;通过前几个小节的讲解，有人可能会疑惑，Go语言中既然支持了多重继承，又具备接口实现，这两种技术有一定的交叉点，概念上也有些类似，那么出现两种技术的意义又何在。在这个部分中，我们将着重讲解Go语言中继承与接口实现的关系。 </p><p>&emsp;&emsp;我们首先基于一个童话来引入这个问题，相信大家都曾经听过老虎向猫咪学艺的故事，在这个童话中出现了两种生物：猫和老虎。如果两种生物没有任何交集，那么小虎继承于老虎、小猫继承与大猫是不需要怀疑，且是天然存在的继承关系。但在故事中老虎想向猫学习一些本领，例如说爬树，此时在小虎的“固有人设”上就会发生变化。小虎不仅有老虎的所有的属性与行为，它还希望具备猫身上的一种行为，这个过程就是实现接口。我们通过案例来说明这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span> <span class="title">climbTree</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"我会爬树"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Tiger <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tiger)</span> <span class="title">attack</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"我会进攻"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样地，我们依旧定义了虎类与猫类，类中不含属性，且每个类具备一个方法。现在我们假设一只小虎想要学爬树，我们可能有两种做法：第一种做法是将爬树这个行为作为接口，让小虎实现这个接口；第二种方式就是让小虎继承于虎类，同时继承于猫类。这两种办法在代码实现的层面上讲，都可以完成代码任务，但是在实际层面上讲，第二种方法简直荒谬，因为这样做的结果就是小虎的多继承破坏了虎类的继承树，使得虎的祖先不仅有虎还有猫（我们不谈生物现象）。因此我们说，为了实现某个功能而进行多重继承不是一个合理的选择，而是应该通过接口实现的方式为一个类添加方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LikeCat <span class="keyword">interface</span> &#123;</span><br><span class="line">    climbTree()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> LittleTiger <span class="keyword">struct</span> &#123;</span><br><span class="line">    Tiger</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LittleTiger)</span> <span class="title">climbTree</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"小虎会爬树了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，由于Go语言实现接口是通过实现方法的特性，我们也可以说：猫类实现了LikeCat接口具备了爬树行为，小虎类也实现了LikeCat接口与爬树行为。 </p><p>&emsp;&emsp;那么接口与继承的意义究竟何在，我们通过前几个小节的侧重点发现：继承的价值在于<strong>代码复用与维护性</strong>，而接口的意义则在于<strong>代码编写过程中规范的设计</strong>。接口的使用实际上是比继承更为灵活且轻量，继承关系一旦确立，则需要继承父类所有的属性与所有的方法，而接口则只需要实现对应的方法即可。由于我们所举的例子都十分简单，因此体会不到接口的轻量，假如虎类和猫类都有上百种行为，而小虎只需要具备猫类中爬树的行为，那么多重继承的重量性就不言而喻了。 </p><p>&emsp;&emsp;那么我们再思考这样一个问题：为什么我们写了LikeCat接口，如果我们不写这个接口而直接在小虎类中添加一个ClimbTree方法，程序其实也是没有错误的。但是此时假如在代码中有一个切片，让会爬树的动物都添加到切片中，此时小虎是做不到的，因为数据类型不一致。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>&emsp;&emsp;讲解了接口的概念与使用过后，多态的概念就十分简单了。多态按字面的意思理解就是多个状态，那么到目前为止我们在什么情况下接触到一种“实例”可以对应多个类型，答案就是在接口的介绍过程中，接口的多种不同的实现类的实例可以赋值给接口变量。换句话说，一个接口变量可以具备很多不同的类型，而这些类型都是实现了该接口的类。“多态性是允许你将父对象设置成为一个子对象相等的技术，赋值过后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作”（摘自Delphi4编程技术内幕）。这句话有些专业且不易理解，我们用一个简单的方式表述就是：将实现类的指针赋值给接口变量指针。 </p><p>&emsp;&emsp;对于有十分丰富的编程经历的开发者而言，这里尤其需要注意的是：Go语言中不支持将子类对象指针赋值给父类对象指针，因为变量类型不匹配。在Java中存在向上转型的概念，但是在Go语言中子类父类是不能相互赋值的，例如在刚刚的案例中我们如下写就会报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t Tiger = LittleTiger&#123;&#125;</span><br><span class="line">cannot use LittleTiger literal (<span class="keyword">type</span> LittleTiger) as <span class="keyword">type</span> Tiger in assignment</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们回到具体的案例中，多态是同一个行为具备不同表现形式或形态的能力，根据传入的实例不同，程序具备不同的相应。例如在现实中，我们经常使用的ctrl+c组合是指复制的功能，然而在命令行中同样的组合则代表强制结束当前的执行过程，因此同一个行为在不同的情况下具备不同的响应。 </p><p>&emsp;&emsp;我们在通过USB接口的案例继续说明多态的技术点：除了键盘与鼠标实现了USB接口规范之外，手机类Phone也实现了USB接口规范，现在我们有一个需求：将实现了USB接口的设备统一放置于一个切片中，遍历这个切片，调用每一个切片元素的Start方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Mouse <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mouse)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"鼠标开始工作"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Keyboard <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k *Keyboard)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"键盘开始工作"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Phone)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"手机开始工作"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m Mouse</span><br><span class="line">    <span class="keyword">var</span> k Keyboard</span><br><span class="line">    <span class="keyword">var</span> p Phone</span><br><span class="line">    usbSlice := <span class="built_in">make</span>([]USB, <span class="number">0</span>)</span><br><span class="line">    usbSlice = <span class="built_in">append</span>(usbSlice, &amp;m)</span><br><span class="line">    usbSlice = <span class="built_in">append</span>(usbSlice, &amp;k)</span><br><span class="line">    usbSlice = <span class="built_in">append</span>(usbSlice, &amp;p)</span><br><span class="line">    <span class="keyword">for</span> _, device := <span class="keyword">range</span> usbSlice &#123;</span><br><span class="line">        device.Start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码我们在讲解接口的时候已经提及过了，此处也就不再过多赘述了。它反映出来的一个思想就是：切片中每一个“USB实例”的Start方法所得到的结果均是不同的。</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>&emsp;&emsp;在上一个部分中，我们讲解的是将实现类的实例赋值给接口变量，使得接口实例可以通过同一个方法调用得到不同的结果。这个小部分中我们所讲解的过程是上一个部分的逆过程，在实际编码过程中，不仅需要让实现类进行“向上转型”，还需要让接口变量进行“向下转型”。 </p><p>&emsp;&emsp;我们回到USB的例子中，假设Mouse类不仅具备Start方法，还具备独特的按键点击Click方法，Keyboard类依旧具备Start方法。根据刚刚的描述，我们可以将Mouse实例和Keyboard实例赋给USB实例，他们都可以调用Start方法，但是此时我们希望如果是Mouse实例的话，同时再调用Click方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mouse <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mouse)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"鼠标启动"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mouse)</span> <span class="title">Click</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"鼠标点击"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m Mouse</span><br><span class="line">    <span class="keyword">var</span> usb USB = &amp;m</span><br><span class="line">    usb.Start()    <span class="comment">//可以调用</span></span><br><span class="line">    usb.Click()    <span class="comment">//编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们在main函数中将一个Mouse实例赋值给USB实例，并通过USB实例调用Start方法和Click方法。在调用Start方法时（假如Click方法被注释），程序是可以成功完成调用的。但是在调用Click方法时，会出现编译错误的情况，因为USB接口中没有对应的Click方法，Click方法是Mouse类所独有的方法，所以通过接口实例是不能调用接口外的方法的。 </p><p>&emsp;&emsp;但是我们确实是将Mouse实例赋给了usb对象，所以理论上它还是具备调用Click方法的能力的，如果想要调用这个方法，我们就需要使用类型断言，其格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接口实例.(类的类型)</span><br><span class="line">convertM := usb.(*Mouse)</span><br><span class="line">convertM.Click()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，我们通过类型断言（和强制转换不同）将usb“实例”重新返回给了Mouse对象指针，此时convertM就相当于是Mouse实例了，因此就可以调用其本身的Click方法了。 </p><p>&emsp;&emsp;这里需要注意的是：在使用类型断言的时候，如果出现了类型断言的错误，程序会抛出panic并跳出。例如我们将Mouse指针赋给了USB实例，却使用了Keyboard指针作为类型断言，程序在编译过程是不会报错的，但是在执行过程中会出现如下的panic:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> conversion: main.USB is *main.Mouse, not *main.Keyboard</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因此在使用类型断言的时候，我们往往通过两个变量进行接收结果：第一个变量是类型转换过后的实例类型，第二个则是在转换过程中是否出现了错误。我们通过后一个变量接收是否出现panic，并判断是否为true，这样就可以避免程序在执行过程中跳出了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Keyboard代码省略，和之前的一样</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m Mouse</span><br><span class="line">    <span class="keyword">var</span> usb USB = &amp;m</span><br><span class="line">    usb.Start()</span><br><span class="line">    convertM, err := usb.(*Keyboard)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">true</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"类型转换错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    convertM.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的程序中，我们留一个彩蛋，希望读者自行验证一下。笔者暂时不清楚上述代码结果的原因，是这种独特的设计还是后续版本会更新。在代码中，我们首先定义了Mouse实例并赋给了usb对象，然后我们通过usb实例进行调用Start，此时输出毋庸置疑，是：鼠标启动。然后我们将usb转换成为Keyboard，此时当然是类型不匹配，因此“类型转换错误”是一定会输出的。<strong>然后，convertM的Start方法会输出什么？</strong> </p><p>&emsp;&emsp;其输出结果是：键盘启动。换句话就是转换过程中报出了panic，但是转换是成功的，Keyboard由于也实现了USB接口，所以也具备Start方法。程序依旧可以正常执行，而没有出现运行时错误。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们介绍了Go语言面向对象特点中的多态特点。多态特性的显示是通过接口完成的，由于接口实例的存在，使得通过接口实例调用的方法可以根据实现类的实现方法而不同。同时，我们也讲解了Go语言中继承和接口实现的不同点，以及Go语言中“向下转型”的方式：类型断言的使用。 </p><p>&emsp;&emsp;到此Go语言的面向对象部分就已经介绍完了，在后续的章节中，我们将开始介绍Go语言中的文件操作以及I/O的使用方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-45-gt-面向对象-多态&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-45-gt-面向对象-多态&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;45&amp;gt; 面向对象-多态&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;44&gt; 面向对象-接口细节讨论</title>
    <link href="http://yoursite.com/2020/03/19/44-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/03/19/44-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/</id>
    <published>2020-03-19T04:21:41.000Z</published>
    <updated>2020-03-19T04:22:29.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-44-gt-面向对象-接口细节讨论"><a href="#Go语言从入门到放弃系列-lt-44-gt-面向对象-接口细节讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;44&gt; 面向对象-接口细节讨论"></a>Go语言从入门到放弃系列&lt;44&gt; 面向对象-接口细节讨论</h2><p>&emsp;&emsp;在上个小节中，我们通过案例讲解了Go语言中接口的概念，并在最后也简单介绍了Go语言中对接口实现的独特方式。与传统面向对象语言相比，Go语言中接口的实现并不依赖于关键字，而是依赖于接口方法的实现与否。在这个小节中，我们将针对接口的使用规则与细节进行更为详细的描述。</p><h4 id="1-接口不创建实例，但可以接收实例，接收的实例必须实现该接口"><a href="#1-接口不创建实例，但可以接收实例，接收的实例必须实现该接口" class="headerlink" title="1. 接口不创建实例，但可以接收实例，接收的实例必须实现该接口"></a>1. 接口不创建实例，但可以接收实例，接收的实例必须实现该接口</h4><p>&emsp;&emsp;这句话可能相对难以理解，我们根据上一章节中所举的USB接口为例来说明这个问题。在之前的代码中，Computer的Work方法的形式参数是一种USB所指代的实例，而在主函数中传入的却是Mouse和Keyboard，以及Printer类的实例。因此我们说：USB接口并不创建实例，因为代码中并没有如下的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> usb USB</span><br><span class="line">usb.Start()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的写法在运行过程中会报错，因为此时声明的usb“对象”是一个抽象的概念，通过这个抽象的概念来完成Start方法的调用会引发panic：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: runtime error: invalid memory address or <span class="literal">nil</span> pointer dereference</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是假如我们将USB接口与其实现类绑定，换句话说此时的接口就具备的一个实体，这个实体可以完成Start方法。再通俗一些理解就是：USB接口是一种规范，要求实现该接口的硬件都要有Start方法；这个规范是一种抽象的、虚构的存在，但是实现了该接口的硬件却是一种实际的物体，可以进行工作。因此接口不能创建实例，但是接口可以接收实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m *Mouse</span><br><span class="line"><span class="keyword">var</span> usb USB = m</span><br><span class="line">usb.Start()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，我们声明了一个usb引用，且让该引用指向一个Mouse实例，此时usb就从虚无变成了存在了，因此它就可以调用接口中的方法了。 </p><p>&emsp;&emsp;那么这种语法存在的意义是什么，假如我们在写一个游戏，这个游戏中具备多个角色子类，每种角色有不同的技能。此时我们需要统计一下具有某一种技能的所有角色有哪些，并将该角色存入到一个切片中。在之前的讲解中，我们说到切片与数组都是同一种数据类型的集合体。那么现在不同角色是不同的结构体类型，是不可以放到同一个切片中的。为了解决这个问题，我们可以通过定义接口切片的形式来完成：</p><p>&emsp;&emsp;既然一个对象实例可以赋给一个接口，那么只要实现了该接口的所有类的实例就都可以赋给该接口，这样相当于所有的类都是“同一种数据类型”了，我们通过代码说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Run <span class="keyword">interface</span> &#123;</span><br><span class="line">    Move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Attack <span class="keyword">interface</span> &#123;</span><br><span class="line">    Attack()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Role <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Role)</span> <span class="title">Move</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"行动"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Role)</span> <span class="title">Attack</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"攻击"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r Role = Role&#123;<span class="string">"DENG"</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> runSlice = <span class="built_in">make</span>([]Run, <span class="number">0</span>)</span><br><span class="line">    runSlice = <span class="built_in">append</span>(runSlice, r)</span><br><span class="line">    fmt.Println(runSlice)</span><br><span class="line">    <span class="keyword">var</span> attackSlice = <span class="built_in">make</span>([]Attack, <span class="number">0</span>)</span><br><span class="line">    attackSlice = <span class="built_in">append</span>(attackSlice, r)</span><br><span class="line">    fmt.Println(attackSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们在程序中定义了两个接口，并让Role类实现了两个接口，在主函数中，我们分别声明了两个不同类型的切片：Run接口类型的切片和Attack接口类型的切片。实例化一个Role之后，将该对象追加到两个切片中，程序正常运行且正确输出。这是一种向上转型的思想，可以理解为一个类实现的某个接口，那么这个类就是这个接口实例。</p><h4 id="2-实现接口需要实现接口中所有方法，且接口中方法没有方法体"><a href="#2-实现接口需要实现接口中所有方法，且接口中方法没有方法体" class="headerlink" title="2. 实现接口需要实现接口中所有方法，且接口中方法没有方法体"></a>2. 实现接口需要实现接口中所有方法，且接口中方法没有方法体</h4><p>&emsp;&emsp;既然接口定义的方法是一种规则的制定，那么在接口中制定的方法就不需要被实现。因为不同的类实现该接口的时候会覆盖重写该方法。就如同USB接口规则的制定者并不需要说明这个接口如何实现它，只需要指定入参是什么，返回值是什么，方法名是什么。实现者才需要考虑具体的实现方式，手机有手机的实现方式，鼠标有鼠标的实现方式。 </p><p>&emsp;&emsp;那么对于Go语言的接口定义而言，直接实现对应的方法会报错，其原因即是上述所讲：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Run <span class="keyword">interface</span> &#123;</span><br><span class="line">    Move()&#123;</span><br><span class="line">        fmt.Println(<span class="string">"Hello"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">syntax error: unexpected &#123;, expecting semicolon or newline or &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;除了所有方法都没有方法体之外，当一个类实现了某个接口时，需要覆盖实现接口中所有的方法。反过来说也是成立的，如果一个类没有实现一个接口中的所有方法，那么这个类就没有实现该接口。在Go语言中不通过implements关键字指定实现关系，因此只能通过检测一个类是否实现全部方法来判定是否实现了接口。 </p><p>&emsp;&emsp;有时在多人开发过程中，每个人可能制定了自己的接口规则，也存在这种两个人定义的接口名不同，但是方法签名都相同的可能性。那么此时一个类实现了其中的一个接口，实现了接口中所有的方法，那么这个类也就同时实现了另一个接口了。 </p><p>&emsp;&emsp;这种接口实现方式说实话不同人有不同的看法。有些开发者认为这个隐式实现的特性非常好，这是一种松耦合的体现。但是也有人会感到这种方式比较怪异，当程序量比较大之后，一旦对接口中的方法签名发生了修改，或添加了一个方法，由于没有明确的实现关系，因此编译器并不能提示开发者哪些类需要作出相应的修改。如果类中没有相应的方法更新或实现，那么编译器就直接认为放弃了接口的实现。</p><h4 id="3-一个自定义类型可以实现多个接口"><a href="#3-一个自定义类型可以实现多个接口" class="headerlink" title="3. 一个自定义类型可以实现多个接口"></a>3. 一个自定义类型可以实现多个接口</h4><p>&emsp;&emsp;在这个小标题中包含了两个知识点，第一个知识点是在Go语言中只要是自定义类型，不仅仅局限于结构体，都可以实现接口。第二个知识点是一个结构体类可以实现多个接口。 </p><p>&emsp;&emsp;在之前介绍方法的时候我们就提及过，一个自定义类型就可以存在方法。我们也通过为一个自定义整数（Integer）类型添加判断奇偶性的方法来举例。对于接口实现而言，这个现象依旧通用，我们依旧可以为整数等等类实现接口。由于在Go语言中是通过实现方法来实现接口的，而自定义类具备方法这个特性我们已然讲解过，那么自定义数据类型当然顺理成章就可以实现接口了。 </p><p>&emsp;&emsp;对于多个接口的实现，Go语言乃至于传统面向对象语言是都支持的。在前文中我们也提到了：如果两个接口中的方法名，那么一个类实现了一个接口的同时就自动实现了另一个接口，当然多接口实现不仅仅于此，我们通过一个案例来说明： </p><p>&emsp;&emsp;假如我们的投影仪不仅仅有VGA接口，还有HDMI接口，那么一个投影仪就需要实现两个接口。我们用代码说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> VGA <span class="keyword">interface</span> &#123;</span><br><span class="line">    StartVGA()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> HDMI <span class="keyword">interface</span> &#123;</span><br><span class="line">    StartHDMI()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Projector <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Projector)</span> <span class="title">StartVGA</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"VGA start"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Projector)</span> <span class="title">StartHDMI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"HDMI start"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *Projector</span><br><span class="line">    <span class="keyword">var</span> vga VGA = p</span><br><span class="line">    <span class="keyword">var</span> hdmi HDMI = p</span><br><span class="line">    vga.StartVGA()</span><br><span class="line">    hdmi.StartHDMI()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们定义了两个接口，分别为VGA和HDMI接口。两个接口中规定的方法不同，然后我们又定义了一个Projector结构体类，并让这个类实现了两个方法。最后在主函数中我们实例化了一个Projector，同时用两个接口接收了p对象。最后通过两个接口来调用方法，程序的数据结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VGA start</span><br><span class="line">HDMI start</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上个小节中我们讲到，只有一个类实现了对应接口，才可以将该类的对象赋给接口对象。而在上述程序中，p对象成功地被分配给了两个接口，且程序正常输出，因此这个类确实实现了多个接口。</p><h4 id="4-接口可以继承接口，但是不能实现接口"><a href="#4-接口可以继承接口，但是不能实现接口" class="headerlink" title="4. 接口可以继承接口，但是不能实现接口"></a>4. 接口可以继承接口，但是不能实现接口</h4><p>&emsp;&emsp;在这之前我们讲解了接口与实现类的关系，那么其实接口与接口之间也可以存在关系。在第2个知识点中，我们说到接口中定义的方法是不可以被实现的，是抽象方法。同时如果一个类实现了一个接口，就需要实现接口中所有的方法。因此接口实现接口这个命题从根本上就是矛盾的，一方面接口中方法不可以实现，另一方面实现了方法才实现了接口，因此接口之间是没有实现关系的。 </p><p>&emsp;&emsp;但是接口之间是存在继承关系的，其继承模式与类的继承的表现形式是相同的。都是通过匿名的方式完成。例如，一个组织定义了一种接口形式以及接口方法，但是随着时代的推进，原来的方法不足以满足所有的需求，于是基于原来的接口出现了新的接口，这个形式就是接口的继承。 </p><p>&emsp;&emsp;接口的继承规定了子接口中的方法完全继承了父接口的方法，因此如果一个类想要实现该接口，则需要实现该接口中的所有方法，以及父接口中的所有方法。此处不通过代码说明了，读者可以自己验证一下。 </p><p>&emsp;&emsp;值得说明的是，在接口的继承中一定要注意一个问题：父接口中的方法名一定不要和子接口新增的方法名相同，即便是返回值不同，参数不同也不可以。因为归根结底接口中的方法声明在实现类中都是方法，而Go语言不支持方法重载，所以同名是不可以的，这个接口也就不可能被实现了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们针对Go语言的接口的各个细节进行了说明，讲解了接口实例与实现类对象的关系，接口中方法规定，多接口实现以及接口的继承的概念。在这个小节中其实知识点含量较多，初学者可以自行通过写代码去练习，接口在Go语言中的用处还是十分地大的。 </p><p>&emsp;&emsp;在下个小节中，我们将集中说明Go语言通过继承与接口实现的方式对于多态概念的实现，以及接口与继承的比较关系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-44-gt-面向对象-接口细节讨论&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-44-gt-面向对象-接口细节讨论&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;44&amp;gt; 面向对
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;43&gt; 面向对象-接口</title>
    <link href="http://yoursite.com/2020/03/17/43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2020/03/17/43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-03-17T04:10:38.000Z</published>
    <updated>2020-03-17T04:11:29.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-43-gt-面向对象-接口"><a href="#Go语言从入门到放弃系列-lt-43-gt-面向对象-接口" class="headerlink" title="Go语言从入门到放弃系列&lt;43&gt; 面向对象-接口"></a>Go语言从入门到放弃系列&lt;43&gt; 面向对象-接口</h2><p>&emsp;&emsp;在这之前，我们已然介绍了面向对象编程部分的抽象思想，封装思想，和继承技术。在接下来的几个小节中我们将开始介绍面向对象的另一个特性-多态。然而就目前而言，直接介绍多态相对复杂，因此我们先介绍接口的技术，然后通过接口和继承的技术来说明多态的特性。在这个小节中，我们将通过案例引入接口的概念以进行快速入门程序的书写。</p><h3 id="接口引入"><a href="#接口引入" class="headerlink" title="接口引入"></a>接口引入</h3><p>&emsp;&emsp;在日常生活中，接口的概念十分广泛。比如我们都十分熟悉的USB接口，TypeC接口，HDMI接口，VGA接口等。在面向对象语言中，也存在接口的概念。我们通过物理的接口为例来了解Go语言的接口：现在我们的计算机基本都有USB接口，手机可以通过USB接口连入计算机，打印机可以通过USB接口连入计算机。不同的设备通过同一种接口连入计算机，却能够拥有不同的响应，换句话说：接口可以根据连入的设备不同自动判断对应的执行结果。 </p><p>&emsp;&emsp;在好多年前的计算机中，鼠标和键盘与计算机的连接都不是通过USB接口的，而是有各自的具体的接口，且不同的接口是连不上的。这也意味着曾经计算机需要为不同的硬件专门设计不同的接口。我们通过简化的代码来模拟这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mouse <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Mouse)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"鼠标开始工作"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Keyboard <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k Keyboard)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"键盘开始工作"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们定义了两个类分别为鼠标类和键盘类，且类中没有属性只有方法。向鼠标和键盘类分别绑定各自的不同的Start方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Computer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Computer)</span> <span class="title">MouseWork</span><span class="params">(m *Mouse)</span></span> &#123;</span><br><span class="line">    m.Start()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Computer)</span> <span class="title">KeyboardWork</span><span class="params">(k *Keyboard)</span></span> &#123;</span><br><span class="line">    k.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们接下来又定义了一个计算机类，在计算机类中依旧没有任何的属性，且计算机类需要分别为鼠标和键盘绑定一个方法。此时我们调用不同的方法以将鼠标或键盘连接到计算机上，我们用主函数模拟：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Computer</span><br><span class="line">    <span class="keyword">var</span> m Mouse</span><br><span class="line">    <span class="keyword">var</span> k Keyboard</span><br><span class="line">    c.MouseWork(&amp;m)</span><br><span class="line">    c.KeyboardWork(&amp;k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在主函数中，我们声明了一个计算机实例，鼠标实例，和键盘实例，并通过计算机实例的两个不同的接口完成设备的连入。此时程序的输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">鼠标开始工作</span><br><span class="line">键盘开始工作</span><br></pre></td></tr></table></figure><h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>&emsp;&emsp;在这种当前的解决方案下，即使程序可以正常执行，结果可以正确输出，但是这种做法的扩展性相对较低。例如我们再定义一个打印机类，打印机类具备自己的驱动方法，自己的执行方式。同时我们需要修改计算机类，让计算机类为打印机留出一个接口。程序修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Printer <span class="keyword">struct</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Printer)</span> <span class="title">Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Computer)</span> <span class="title">PrinterWork</span><span class="params">(p *Printer)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种修改方式实在过于繁琐，且随着硬件的增多，程序会变得非常的大，而且代码十分重复。不仅如此，假如不同的硬件厂商的设计理念不同，生产出的硬件不兼容，计算机只好为不同厂商的同一种硬件做不同的适配，这无疑会增加更多的工作量。 </p><p>&emsp;&emsp;除此之外，即便是我们可以为所有的不同种类的硬件都预留出对应的接口，还是会出现一定的问题。一般情况下，计算机外设只有鼠标和键盘，但对于一些人来说可能需要打印机，对于开发人员来说，需要各种手机的连入接口。换句话说，不同的使用者更倾向于不同的特定的功能，而其他的预留接口都被浪费了。 </p><p>&emsp;&emsp;因此，如果存在着一种规定，不同的硬件厂商在生产的时候都遵循这个规定，计算机只接受实现了这个规定的硬件。这样的话，计算机只需要预留出几个接口就可以了，需要什么功能的硬件直接插入即可。因为规定都是相同的，协议都是一致的，在Go语言中，接口就可以起到这个功能。</p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>&emsp;&emsp;对于上述问题的解决方式可以分为以下几个步骤：<br>&emsp;&emsp;1. 制定一种规定，设计一种接口；<br>&emsp;&emsp;2. 让鼠标和键盘实现这种规定；<br>&emsp;&emsp;3. 让计算机拥有这个接口。<br>&emsp;&emsp;因此，我们首先定义一个接口，这个接口中有一个抽象方法，即只有实现了这个方法，才算是实现了这个接口，然后我们让鼠标和键盘分别实现这两个方法，最后在计算机类的方法中注入这个接口实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span>&#123;</span><br><span class="line">    Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于我们在之前的代码中已然为Mouse和Keyboard类绑定了Start方法，因此这两个类不需要做出改动。如果之前写的方法名不是Start的话，则需要改为Start方法。 </p><p>&emsp;&emsp;接下来我们修改Computer类，这个类不再需要为每一个硬件都预留方法，因此将其他方法删除，而是需要把USB接口传入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Computer)</span> <span class="title">Work</span><span class="params">(usb USB)</span></span> &#123;</span><br><span class="line">    usb.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后在main函数中定义一个Computer类，Mouse类，和Keyboard类。并将Mouse和Keyboard传入到Computer类中的Work方法中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Computer</span><br><span class="line">    <span class="keyword">var</span> m Mouse</span><br><span class="line">    <span class="keyword">var</span> k Keyboard</span><br><span class="line">    c.Work(&amp;m)</span><br><span class="line">    c.Work(&amp;k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的代码中，我们可以发现，在定义Work方法的时候定义的参数是USB实例，但是我们传入的是Mouse和Keyboard对象指针。即便如此，并没有出现参数不匹配的现象，反而根据传入对象的不同输出结果不同，这就是一种多态的体现。 </p><p>&emsp;&emsp;现在假设我们又添加了一个新的打印机类，只要这个类实现了Start方法，它就可以被传入到Work方法中，并完成程序的调用。对于Computer类而言，则完全不需要进行修改。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们主要通过USB接口的案例来说明Go语言中的接口的概念，并通过该案例引入了Go语言接口实现的方式。在一些面向对象的语言中，接口的实现是通过implements关键字完成的，并且直接指明了实现关系。但是在Go语言中并没有这个关键字，接口的实现完全是靠实现接口定义的方法完成的。假如程序中定义了两个接口，且接口中定义的抽象方法是相同的，那么一个类实现其中一个接口的同时也就实现了另一个接口。 </p><p>&emsp;&emsp;在下个小节中，我们将针对Go语言中接口的使用方式和需要注意的细节进行相对深入的讨论。在讨论过程中也会通过代码案例来完成相应的说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-43-gt-面向对象-接口&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-43-gt-面向对象-接口&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;43&amp;gt; 面向对象-接口&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;42&gt; 面向对象-继承细节讨论</title>
    <link href="http://yoursite.com/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/03/16/42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/</id>
    <published>2020-03-16T15:43:52.000Z</published>
    <updated>2020-03-16T15:44:39.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-42-gt-面向对象-继承细节讨论"><a href="#Go语言从入门到放弃系列-lt-42-gt-面向对象-继承细节讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;42&gt; 面向对象-继承细节讨论"></a>Go语言从入门到放弃系列&lt;42&gt; 面向对象-继承细节讨论</h2><p>&emsp;&emsp;在上个小节中，我们通过银行账户的例子引入了Go语言中面向对象中继承的概念，并用代码演示了继承的实现方式。在入门案例中，我们通过将父类的结构体以匿名的方式嵌入到子类结构体中完成了子类对父类的属性和方法的继承。在这个小节中，我们将针对Go语言中继承的概念的一些细节做出更为详细的讨论。</p><h4 id="1-Go语言中继承关系是通过匿名结构体完成的"><a href="#1-Go语言中继承关系是通过匿名结构体完成的" class="headerlink" title="1. Go语言中继承关系是通过匿名结构体完成的"></a>1. Go语言中继承关系是通过匿名结构体完成的</h4><p>&emsp;&emsp;在传统面向对象语言中，例如Java，继承关系是通过extends关键字完成的，且子类与父类之间有着明确的继承关系。父类中的属性和方法是有选择性地被子类所继承。然而在Go语言中，继承关系是通过匿名结构体的方式完成的，且在Go语言中继承与组合的关系变得不是那么的明确。继承可以讲是一种“is-a”的关系，例如VIP账户继承了账户类，那么VIP账户自身就是一个账户。而组合关系则是一种“has-a”的关系，例如一辆车具备车轮，一只猫有四条腿，而不是一辆车是车轮，一只猫是四条腿。我们通过代码来说明这个问题： </p><p>&emsp;&emsp;假如我们事先定义好了一个Account类，并在VIPAccount类中继承这个类，那么代码会是以下的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> VIPAccount <span class="keyword">struct</span>&#123;</span><br><span class="line">    Account</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码中反映的就是一种继承关系。接下来我们再通过代码讲解一下组合的关系，我们保留Account类不变，我们修改一下VIPAccount类的构成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> VIPAccount <span class="keyword">struct</span>&#123;</span><br><span class="line">    a Account</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，Account类的一个实例成为了VIPAccount类中的一个属性，因此我们讲此时VIPAccount拥有了一个Account变量。当然此时我们在主函数调用VIP实例的时候依旧需要通过“变量.属性.属性”的形式完成。在这个角度上看，Go语言中继承与组合的关系十分密切，甚至可以讲，Go语言中的继承关系就是通过组合关系的形式完成的。</p><h4 id="2-父类中的全部属性和方法均被继承"><a href="#2-父类中的全部属性和方法均被继承" class="headerlink" title="2. 父类中的全部属性和方法均被继承"></a>2. 父类中的全部属性和方法均被继承</h4><p>&emsp;&emsp;在传统面向对象语言中，父类中的private修饰的属性是不可以被子类所继承的，包括private修饰的方法也是不可以被继承的。然而在Go语言中，这个规则不再被继续遵循。父类的所有属性和方法（不论首字母大小写）均会被子类所继承。我们依旧采用Account类为例，我们设定Name属性为公有，balance属性为私有，Query方法为公有，withdraw方法为私有，最后再用VIPAccount类继承：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name     <span class="keyword">string</span></span><br><span class="line">    balance   <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">Query</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.Name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">withdraw</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    a.balance -= money</span><br><span class="line">    fmt.Println(<span class="string">"余额为："</span>, a.balance)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VIPAccount <span class="keyword">struct</span>&#123;</span><br><span class="line">    Account</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们在当前的包中的主函数中分别为两个属性赋值并调用两个不同的方法。如果子类完全继承了父类的全部属性和方法，那么父类中首字母小写的也可以正确地被表示出来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> vipa VIPAccount</span><br><span class="line">    vipa.Account.Name = <span class="string">"DENG"</span></span><br><span class="line">    vipa.Account.balance = <span class="number">10000</span></span><br><span class="line">    vipa.Account.withdraw(<span class="number">500</span>)</span><br><span class="line">    vipa.Account.Query()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们在主函数中声明了一个VIP账户，并为该账户的用户名和初始余额赋值，接下来我们通过私有方法withdraw模拟取出一些余额，最后在通过公有方法输出剩余的余额值。程序的输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">余额为： <span class="number">9500</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述结果可知，通过子类对象是可以调用父类的属性和方法，且不论父类的属性方法是公有的还是私有的，全部可以被继承下来。这个点上是与传统面向对象语言完全不同的。不过即便是子类继承了父类的所有属性和方法，但是继承得到的作用域还是不变的。即父类中withdraw是私有的，不可以在其他包中使用，那么子类中的withdraw也是私有的，同样不可以在其他的包中使用。</p><h4 id="3-子类中调用属性和方法可以简化"><a href="#3-子类中调用属性和方法可以简化" class="headerlink" title="3. 子类中调用属性和方法可以简化"></a>3. 子类中调用属性和方法可以简化</h4><p>&emsp;&emsp;在上个小节的快速入门和这个小节的前面一部分中，我们都是通过子类对象.匿名结构体.属性/方法的方式来完成调用的，这种调用方式是可以在任何情况下都适用的。不过在一些情况下，为了简便操作，我们可以将匿名结构体所省略。可以理解为：子类中继承了父类的所有属性，因此子类相当于有了同样的属性，所以，我们可以直接通过子类对象.属性/方法的方式来调用。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> vipa VIPAccount</span><br><span class="line">    vipa.Account.Name = <span class="string">"DENG"</span></span><br><span class="line">    vipa.Account.balance = <span class="number">10000</span></span><br><span class="line">    vipa.Account.withdraw(<span class="number">500</span>)</span><br><span class="line">    vipa.Account.Query()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的代码中我们使用的方式就是原始的方式，我们可以对上述代码修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> vipa VIPAccount</span><br><span class="line">    vipa.Name = <span class="string">"DENG"</span></span><br><span class="line">    vipa.balance = <span class="number">10000</span></span><br><span class="line">    vipa.withdraw(<span class="number">500</span>)</span><br><span class="line">    vipa.Query()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是这种简化方式并不是任何时候都通用的，当出现属性或者方法名冲突的时候，就需要明确指定具体的属性或方法了。</p><h4 id="4-当子类和匿名结构体有同样的属性或字段时就近原则"><a href="#4-当子类和匿名结构体有同样的属性或字段时就近原则" class="headerlink" title="4. 当子类和匿名结构体有同样的属性或字段时就近原则"></a>4. 当子类和匿名结构体有同样的属性或字段时就近原则</h4><p>&emsp;&emsp;在一些情况下，子类中的属性和父类中的属性可能会相互冲突，例如马车既继承与马，又继承与车，而马和车都可以移动，这样马车在继承了两个父类的情况下，它的移动行为的继承就是相互冲突的。我们通过例子来说明这个问题。首先我们假设如下两个类：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述代码中我们可以看出，我们首先声明了一个Person类，且Person类中包含Name和Age属性。接下来我们又定义了Child类，Child类不仅继承了Person类，还又定义了一个Name属性。此时在Child类中就具备了两个Name属性，我们依旧在main函数中进行声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Child</span><br><span class="line">    c.Name = <span class="string">"DENG"</span></span><br><span class="line">    c.Person.Name = <span class="string">"YANG"</span></span><br><span class="line">    fmt.Println(c.Name)</span><br><span class="line">    fmt.Println(c.Person.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DENG</span><br><span class="line">YANG</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们分别采用子类对象.属性和子类对象.匿名结构体.属性进行了赋值和输出，通过运行结果可以发现，这两种不同的赋值方法所得到的结果是不同的。当父类和子类都有同名的属性时，且当直接子类对象.属性时，访问的是子类的属性。我们再举一个例子，假设A类中有Name属性，B类继承于A类，且B类中自己又定义一个Name属性，再之后C类继承于B类。假如主函数中C类有一个实例c，此时c.Name访问的是B类中的Name属性，c.B.A.Name才是A类中的Name属性。 </p><p>&emsp;&emsp;换句话说，当我们简化调用时，会根据继承树逐级向上找，直到找到距离调用点最近的属性为止，如果找遍了继承树都没有找到对应的属性，就会报错。此外，方法的冲突也是同一个道理。</p><h4 id="5-多重继承导致的属性-方法冲突，必须要明确匿名结构体"><a href="#5-多重继承导致的属性-方法冲突，必须要明确匿名结构体" class="headerlink" title="5. 多重继承导致的属性/方法冲突，必须要明确匿名结构体"></a>5. 多重继承导致的属性/方法冲突，必须要明确匿名结构体</h4><p>&emsp;&emsp;在第四个小点中，我们讲解的情况是子类中新定义了父类中存在的属性或方法，在这个小点中，我们将讲解子类继承了多个父类，且多个父类中存在相同的属性。当直接使用子类对象访问属性时，会根据继承树找到最近的属性，然而当两个父类中的属性同样近的时候，则必须需要指明，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">struct</span> &#123;</span><br><span class="line">    A</span><br><span class="line">    B</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c C</span><br><span class="line">    c.Name = <span class="string">"DENG"</span></span><br><span class="line">    fmt.Println(c.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们可以发现，A类和B类中都具备Name属性，且C继承了A和B两个类，此时我们通过c.Name来访问属性则会出现模糊的问题。因为C类中没有Name属性，因此需要根据继承树向上查找，且找到了A类和B类均有Name属性，此时错误结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ambiguous selector c.Name</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们在代码中所写的c.Name编译器并不能确定具体是哪个父类的属性，因此就会报错。此时我们再访问属性的时候，就需要指明具体哪个父类的匿名结构体中的属性了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c C</span><br><span class="line">    c.A.Name = <span class="string">"DENG"</span></span><br><span class="line">    fmt.Println(c.A.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们通过代码和概念更为深入地讲解了Go语言中继承技术的细节点，并讲解了在属性访问过程中的几个原则。Go语言中具备多继承的理念即一个子类继承多个父类，但在日常开发中这个理念并不提倡，因为在多继承的过程中十分容易出现属性或方法名的冲突，使得开发者不得不需要指定对应的父类匿名结构体来调用。这个过程相对而言不是很方便。最后我们在小节中出一道简单的测试，来证明是否完全理解了本节的知识点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span> <span class="title">sayName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(a.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    A</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">sayName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b.A.Name = <span class="string">"GUO"</span></span><br><span class="line">    fmt.Println(b.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b B</span><br><span class="line">    b.Name = <span class="string">"DENG"</span></span><br><span class="line">    b.A.Name = <span class="string">"YANG"</span></span><br><span class="line">    b.A.sayName()</span><br><span class="line">    b.sayName()</span><br><span class="line">    b.A.sayName()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序的最终输出结果是什么？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-42-gt-面向对象-继承细节讨论&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-42-gt-面向对象-继承细节讨论&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;42&amp;gt; 面向对
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;41&gt; 面向对象-继承</title>
    <link href="http://yoursite.com/2020/03/15/41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2020/03/15/41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/</id>
    <published>2020-03-15T12:06:23.000Z</published>
    <updated>2020-03-15T12:06:53.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-41-gt-面向对象-继承"><a href="#Go语言从入门到放弃系列-lt-41-gt-面向对象-继承" class="headerlink" title="Go语言从入门到放弃系列&lt;41&gt; 面向对象-继承"></a>Go语言从入门到放弃系列&lt;41&gt; 面向对象-继承</h2><p>&emsp;&emsp;在上个小节中，我们讲解了面向对象特征其中的一个-封装的概念，封装是贯穿面向对象的一个思想而不是某些技术点，因此需要在日常开发中自行学习和加强。在这个小节中，我们将开始介绍Go语言中面向对象中的另一个特性-继承。Go语言对于继承有着独特的解决方式，与传统的面向对象语言的实现方式完全不同。如果有其他语言的开发经验，可能会对Go语言的继承的实现表示出费解，这是语言层面上的设计问题，开发者最好还是需要适应这种独特的方式。 </p><h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>&emsp;&emsp;在日常生活中，继承的概念随处可见，继承的关系往往涉及两个或多个个体类。例如，一个孩子的长相性格大多继承于父母，孩子也会有自己的独特的个性；在面向对象程序设计中，也经常会出现类似的问题。比如我们上一个小节提到的Account的例子，可以分为个人用户，企业用户，VIP用户等。每一个类型的用户都有其独特的特点，但是他们又同时都有存取款，查询转账等功能。因此可以说，不同类型的用户继承于Account大类。 </p><p>&emsp;&emsp;我们现在就针对这个问题举个简化的例子：假如我们需要一个普通账户和一个VIP账户，这两种账户都具备存款，查询，取款的功能。普通用户一次可以取10k，VIP用户一次可以取出50k。如果采用之前介绍的抽象等方式，我们需要建立两个结构体，分别为NormalAccount和VIPAccount。（暂时不考虑封装的问题）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NormalAccount&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> VIPAccount&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来，我们分别实现对应的方法，存钱取钱的方法为了简便暂时就不考虑密码的匹配，只是为了说明一下继承的问题。取钱的方法需要判断对应的取钱上限，以及余额是否少于需要取出的钱。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(na *NormalAccount)</span> <span class="title">QueryAccount</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(na.Balance)</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(na *NormalAccount)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    na.Balance += money</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(na *NormalAccount)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> money &gt; <span class="number">10000</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"超出上限"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> na.Balance &lt; money &#123;</span><br><span class="line">        fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    na.Balance -= money</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vipa *VIPAccount)</span> <span class="title">QueryAccount</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(vipa.Balance)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vipa *VIPAccount)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    vipa.Balance += money</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vipa *VIPAccount)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> money &gt; <span class="number">50000</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"超出上限"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> vipa.Balance &lt; money &#123;</span><br><span class="line">        fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    vipa.Balance -= money</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承实现"><a href="#继承实现" class="headerlink" title="继承实现"></a>继承实现</h3><p>&emsp;&emsp;在上述的代码实现中，虽说可以完成对应的功能，但是依旧有许多可以解决的问题。比如说，NormalAccount和VIPAccount的属性十分相似（在本例中完全相同），还有两种账户除了最高取款限额不同之外，其他的也十分类似。如果以当前的实现形式进行发展，那么企业账户，附属账户等需要再大致一模一样地再实现一遍，一旦账户中需要多加一个功能，则需要每一个账户类型都新写一个方法，这对大型程序来说十分不利。 </p><p>&emsp;&emsp;那么我们是否可以像类的构建中的抽象一般，将几个类中公有的属性再次抽象出来，形成一个父类，让所有继承于父类的子类都具备和父类一样的属性和方法，同时在子类中可以随意覆盖父类中的方法。基于这样一个思想，我们将继承的话题引入到讲解中。 </p><p>&emsp;&emsp;经过再次抽象后，我们发现在本例中每一个账户都需要姓名和账户余额，因此这两个属性可以被提取出来成为父类所共有的属性。同理，我们也发现每一个账户都存在取款，存款和查询功能。在取款过程中，我们可以通过传入一个参数来规定取款的最高限额，因此这三个方法都可以被写入到父类中。此时，父类Account可以被归纳如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">QueryAccount</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(a.Balance)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    a.Balance += money</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>, limit <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> money &gt; limit &#123;</span><br><span class="line">        fmt.Println(<span class="string">"超出上限"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> a.Balance &lt; money &#123;</span><br><span class="line">        fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    a.Balance -= money</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;建立了父类Account之后，我们就可以将两个账户类型定义出来了，由于两个账户均继承于父类Account，因此，父类中的属性以及行为可以直接被子类所拥有，此时在子类中就不需要再次定义了。对于取钱这个问题，我们可以重写父类的方法，将取款上限传入。我们首先写NormalAccount：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NormalAccount <span class="keyword">struct</span> &#123;</span><br><span class="line">    Account</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(na *NormalAccount)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    na.Account.WithdrawAccount(money, <span class="number">10000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们通过将Account父类嵌入到NormalAccount子类的方式，令子类继承了Account父类。在重写WithdrawAccount方法中，我们在子类的方法中调用了父类的方法进行了一次包装，就完成了子类的重写工作。同理对于VIPAccount类而言，做法也是类似的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> VIPAccount <span class="keyword">struct</span> &#123;</span><br><span class="line">    Account</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vipa *VIPAccount)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    vipa.Account.WithdrawAccount(money, <span class="number">50000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时，两个子类的代码就都编写完成了。接下来，我们讲解一下如何在函数中使用上述两个子类。在主函数中，我们将分别实例化两个子类，为之赋值，并调用三个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> na NormalAccount = NormalAccount&#123;Account&#123;<span class="string">"DENG"</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">var</span> vipa VIPAccount</span><br><span class="line">    vipa.Account.Name = <span class="string">"YANG"</span></span><br><span class="line">    vipa.Account.Balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    na.SaveAccount(<span class="number">1000</span>)</span><br><span class="line">    na.WithdrawAccount(<span class="number">300</span>)</span><br><span class="line">    na.QueryAccount()</span><br><span class="line"></span><br><span class="line">    vipa.SaveAccount(<span class="number">50000</span>)</span><br><span class="line">    vipa.WithdrawAccount(<span class="number">100000</span>)</span><br><span class="line">    vipa.QueryAccount()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在主函数中，我们通过初始化直接赋值的方式实例化了NormalAccount，也通过先创建后赋值的方式实例化了VIPAccount，接下来我们用两个对象分别进行继承得到的方法，并进行输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">700</span></span><br><span class="line">超出上限</span><br><span class="line"><span class="number">50000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;得到了上述的结果，与预期的结果相同，也进而说明了我们的代码实现是没有问题的，继承的结果也是正确的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们通过一个案例引出了继承的概念，并通过代码的方式进行了快速入门。在案例中，我们可以发现，在Go语言中的面向对象继承，是通过嵌入匿名结构体的方式完成的。且作为父类的匿名结构体中的属性和方法均被子类所继承到，子类拥有了方法继承后可以通过子类的实例调用对应的方法。 </p><p>&emsp;&emsp;在传统面向对象继承中，往往是通过extends关键字的方式完成的，在Go语言中并没有这个关键字。Go语言中类的组合与继承的关系也不如传统面向对象语言那般分明，因此我们需要适应这种独特的继承方式。在下个小节中，我们将针对继承中的一些细节，例如访问修饰，属性冲突，多重继承等细节进行详细地介绍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-41-gt-面向对象-继承&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-41-gt-面向对象-继承&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;41&amp;gt; 面向对象-继承&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;40&gt; 面向对象-封装</title>
    <link href="http://yoursite.com/2020/03/14/40-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/"/>
    <id>http://yoursite.com/2020/03/14/40-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/</id>
    <published>2020-03-14T15:15:50.000Z</published>
    <updated>2020-03-14T15:17:27.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-40-gt-面向对象-封装"><a href="#Go语言从入门到放弃系列-lt-40-gt-面向对象-封装" class="headerlink" title="Go语言从入门到放弃系列&lt;40&gt; 面向对象-封装"></a>Go语言从入门到放弃系列&lt;40&gt; 面向对象-封装</h2><p>&emsp;&emsp;在面向对象部分的介绍中，我们自始至终地都在强化一种思想，即是抽象的思想。我们在定义一个结构体(类)的时候，实际上就是将一类事物所共有的属性和行为提取出来，建立一个物理模型，就成为了一个类。在这其中,             共有的属性以字段的形式存在，行为以方法的形式存在。这个提取的过程就是抽象的思想，因此我们所说的抽象并不涉及技术上的实现，而是贯穿整个面向对象的一种解决问题的方法。 </p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>&emsp;&emsp;作为面向对象的特性之一，封装的概念在Go语言中也有所体现。封装就是将抽象出来的字段和对字段的操作封装在一起，将数据在内部保护起来，其他的程序只可以通过放出的方法接口来对属性字段进行操作。就如同我们在讲解工厂模式的时候举的例子：学生的年龄只可以读取而不可以在其他包中修改。我们说在这个例子中，我们将年龄这个属性与读取的方法封装在了一起。 </p><p>&emsp;&emsp;通过封装的概念，使得程序员在基于他人的代码进行二次开发过程中不需要完全了解其代码实现，只需要了解一个方法应当如何输入，其返回值是什么，对于程序中其他的属性是否存在关联的变动。而这三个方面往往都会在用户的开发文档中或代码注释中标明。 </p><p>&emsp;&emsp;举一个很典型的例子：我们普通用户并不需要知道电视机的成像原理，不需要知道其内部的集成电路是如何工作的，也不需要知道红外线控制器的协议过程。我们只需要知道对于一个电视机，哪些按键是开关，哪些按键控制频道，哪些按键控制音量。而一旦电视机出现问题，我们只需要联系维修人员即可。同理，对于其他人的代码，我们只需要知道输入格式，输出格式，而代码中出现bug，则需要联系开发人员，或通过其他途径完成自己的开发需求。</p><h3 id="案例讲解"><a href="#案例讲解" class="headerlink" title="案例讲解"></a>案例讲解</h3><p>&emsp;&emsp;假设一个银行在写管理系统，并且我们负责系统中个人账户的部分，要求用户可以查询余额，存钱取钱，且单次取钱额度不超过10k，以及用户之间互相转账的功能，单次转账也不超过50k。我们通过这个小案例进行封装的入门。当然真实的开发操作要比这个复杂地多得多，而且还需要进行加锁操作，数据库操作等等，我们在这里只是针对这个案例进行一个简单的分析和实现而已，只是介绍一下封装的使用方式，对于实现方式就当做一个代码篇来看吧。 </p><h3 id="1-属性行为分析"><a href="#1-属性行为分析" class="headerlink" title="1. 属性行为分析"></a>1. 属性行为分析</h3><p>&emsp;&emsp;在代码编写之前，我们往往需要首先分析一下一个类的构成。在这个案例中，我们可以清楚地知道：转账过程需要对方的用户名和本人的密码，查询余额和存钱取钱需要余额的显示，其他的暂时先不需要了。因此我们可以将在Account类中包含三个属性，分别为用户名，密码，和余额。 </p><p>&emsp;&emsp;接下来，我们继续分析这个类的行为。根据需求描述，我们可以知道需求中存在着如下的几个行为：查询，存储，取出，转账这四个行为，且这四个行为均是账户管理中的行为。因此对于类的设计中我们可以采用如下的类定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">    UserName <span class="keyword">string</span></span><br><span class="line">    Password <span class="keyword">string</span></span><br><span class="line">    Balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">QueryAccount</span><span class="params">(password <span class="keyword">string</span>)</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">Transfer</span><span class="params">(to *Account, money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="2-权限控制修改"><a href="#2-权限控制修改" class="headerlink" title="2. 权限控制修改"></a>2. 权限控制修改</h4><p>&emsp;&emsp;在对工厂模式的讲解中，我们介绍到了私有类的访问方式，以及私有属性的访问方式。在大多数情况下，我们将类名以及属性名的首字母小写，使之成为私有，可见性只针对于本包。此时我们需要为之添加一个公有类型的工厂函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> account <span class="keyword">struct</span> &#123;</span><br><span class="line">    userName <span class="keyword">string</span></span><br><span class="line">    password <span class="keyword">string</span></span><br><span class="line">    balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAccount</span><span class="params">(userName <span class="keyword">string</span>, password <span class="keyword">string</span>)</span> *<span class="title">account</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;account&#123;</span><br><span class="line">        userName: userName,</span><br><span class="line">        password: password,</span><br><span class="line">        balance: <span class="number">0.0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述程序中，我们添加了NewAccount函数，且需要两个入参分别为用户名和密码，在函数中为本类中的userName和password赋值，同时我们设定balance的初始值为0。</p><h4 id="3-方法的实现"><a href="#3-方法的实现" class="headerlink" title="3. 方法的实现"></a>3. 方法的实现</h4><p>&emsp;&emsp;我们首先完成余额查询的功能。在这个功能中我们需要首先判断输入的密码是否与account中的密码相匹配，如果匹配则输出对应的balance属性的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *account)</span> <span class="title">QueryAccount</span><span class="params">(password <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> password == a.password &#123;</span><br><span class="line">        fmt.Println(a.balance)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"密码错误！"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们完成存款的实现，首先依旧是判断输入密码是否与account中密码相同，如果相同则将balance加上对应的金额：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *account)</span> <span class="title">SaveAccount</span><span class="params">(money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> password == a.password &#123;</span><br><span class="line">        a.balance += money</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"密码错误！"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来是取钱的操作，它与存钱的区别便是一次性取钱不能超过10k，且余额不能小于0。 在密码得以匹配和上述条件均满足的情况下，balance的值减少对应的money金额：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *account)</span> <span class="title">WithdrawAccount</span><span class="params">(money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> password == a.password &#123;</span><br><span class="line">        <span class="keyword">if</span> money &gt;= <span class="number">10000</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"超出额度"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> money &gt; a.balance &#123;</span><br><span class="line">            fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        a.balance -= money</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"密码错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后是转账操作的实现，一次转账操作可以相当于两个行为：一方的取出操作和另一方的存入操作。取出操作依旧遵循上述的判断过程，存入操作不需要什么其他的限制：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *account)</span> <span class="title">Transfer</span><span class="params">(to *account, money <span class="keyword">float64</span>, password <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> password == a.password &#123;</span><br><span class="line">        <span class="keyword">if</span> money &gt;= <span class="number">50000</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"超出额度"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> money &gt; a.balance &#123;</span><br><span class="line">            fmt.Println(<span class="string">"余额不足"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        a.balance -= money</span><br><span class="line">        to.balance += money</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"密码错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> acc1 = test.NewAccount(<span class="string">"DENG"</span>, <span class="string">"123456"</span>)</span><br><span class="line">    <span class="keyword">var</span> acc2 = test.NewAccount(<span class="string">"YANG"</span>, <span class="string">"654321"</span>)</span><br><span class="line">    acc1.SaveAccount(<span class="number">5000</span>, <span class="string">"123456"</span>)</span><br><span class="line">    acc1.WithdrawAccount(<span class="number">2000</span>, <span class="string">"123456"</span>)</span><br><span class="line">    acc1.Transfer(acc2, <span class="number">1000</span>, <span class="string">"123456"</span>)</span><br><span class="line">    acc1.QueryAccount(<span class="string">"123456"</span>)</span><br><span class="line">    acc2.QueryAccount(<span class="string">"654321"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最终我们在demo文件下的main包中进行功能的测试，我们只写了简单的几个过程，并没有将所有的功能全部都测试完全，代码也只是作为demo说明而已。其结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2000</span></span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这两个数值的输出也一定程度上证实了主要功能的正确，对于其他的错误的输出没有做任何的测试。</p><h3 id="封装规则"><a href="#封装规则" class="headerlink" title="封装规则"></a>封装规则</h3><p>&emsp;&emsp;在Go语言的开发过程中，其实并没有特别强调封装的概念。Go语言说起来并没有对面向过程或面向对象有着明显的倾向性，它对于面向对象的实现也有着自己一套的灵活的实现方式。它与Java语言，C/C++语言不同，不能以传统的面向对象的语法特性看待Go语言。Go语言本身而言对面向对象的概念是做了一定的简化的。 </p><p>&emsp;&emsp;相较于传统面向对象的开发习惯，Go语言的封装规则可以总结为一下的几个步骤： </p><p>&emsp;&emsp;1. 将结构体和属性字段的首字母小写，将其变为私有属性，在其他包中不可导出，类似于传统面向对象中的private属性。 </p><p>&emsp;&emsp;2. 为结构体所在包提供一个工厂函数，函数的首字母大写，该函数可以在其他包中被调用，导出结构体实例指针。 </p><p>&emsp;&emsp;3. 为私有属性提供首字母大写的SetXXX方法，在该方法中对属性进行判断与赋值。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *XXX)</span> <span class="title">SetYYY</span> <span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line">    ...  <span class="comment">//数据验证等操作</span></span><br><span class="line">    x.YYY = 参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;4. 为私有属性提供首字母大学的GetXXX方法，在该方法中返回该属性的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *XXX)</span> <span class="title">GetYYY</span> <span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.YYY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们讲解了Go语言中面向对象概念中的封装，并通过一个案例讲解了封装思路。可以说，封装是一种思想而不是一种技术，因此开发人员需要在日常开发中多多积累相应经验。由于它是思想，因此不同的人对这个思想的理解倾向性不同，因此很难辨明孰是孰非。针对于同一个需求，开发的思路也不同。笔者开发经验也不多，在一些问题上考虑地也并不完善，说的不到的地方希望见谅。 </p><p>&emsp;&emsp;在下一个小节中，我们将开始讲解面向对象特性中的另一个概念，继承。继承与封装不太相似，继承是一个技术点，因此具备一定的语法规则，我们会在下几节中详细地说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-40-gt-面向对象-封装&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-40-gt-面向对象-封装&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;40&amp;gt; 面向对象-封装&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;39&gt; 面向对象-方法细节与工厂模式</title>
    <link href="http://yoursite.com/2020/03/13/39-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/13/39-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-03-13T11:02:37.000Z</published>
    <updated>2020-03-13T11:05:05.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-39-gt-面向对象-方法细节与工厂模式"><a href="#Go语言从入门到放弃系列-lt-39-gt-面向对象-方法细节与工厂模式" class="headerlink" title="Go语言从入门到放弃系列&lt;39&gt; 面向对象-方法细节与工厂模式"></a>Go语言从入门到放弃系列&lt;39&gt; 面向对象-方法细节与工厂模式</h2><p>&emsp;&emsp;在上一个小节中，我们简单讲解了Go语言面向对象部分中的方法的概念，同时我们也通过简单的案例进行了快速入门的讲解。方法不论在定义上与使用上都与函数十分的类似，包括方法的传参机制也与函数如出一辙。除此之外，我们也对其他的自定义数据类型的方法做出了一定的讲解，并说明了Go语言中String方法的作用。 </p><p>&emsp;&emsp;在这个小节中，我们依旧对Go语言的方法进行讲解，主要说明方法在使用过程中的一些注意事项，以及Go语言中的工厂模式。</p><h3 id="方法的细节与注意事项"><a href="#方法的细节与注意事项" class="headerlink" title="方法的细节与注意事项"></a>方法的细节与注意事项</h3><h4 id="1-Go语言中的方法不支持重载"><a href="#1-Go语言中的方法不支持重载" class="headerlink" title="1. Go语言中的方法不支持重载"></a>1. Go语言中的方法不支持重载</h4><p>&emsp;&emsp;在传统面向对象语言中，方法是可以被重载的，即多个方法函数名相同，返回值相同，但是函数参数不同。例如，当初始化一个学生类的时候需要调用initStudent方法，且我们可以传入学生的姓名与学号。当用户只传入学号时则只初始化学号，当用户只传入姓名时则只初始化姓名，如果两个都输入则全部初始化。 </p><p>&emsp;&emsp;由于方法中定义的参数类型不同，参数个数不同，传统面向对象语言可以根据这两个特点寻找到用户需要调用哪一个初始化方法，并能够成功地完成操作。然而这个特性在Go语言中并不存在，一旦两个方法或函数的名字相同的时候，在编译过程中就会报错，且报错的内容为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method redeclared: xxx</span><br></pre></td></tr></table></figure><h4 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h4><p>&emsp;&emsp;当初在介绍到包的概念的时候我们提及过作用域的一些问题，在Go语言中存在两种作用域分别为共有的和私有的。当变量的首字母大写的时候是可以在其他包中访问到该变量的，当变量首字母是小写的时候则无法在其他包中访问。函数与方法也遵循这个原则：当函数名或方法名首字母大写的时候才可以在其他包中调用函数或方法，方法名首字母小写则只能在本包中使用，具体便不再举例了。</p><h4 id="3-接收者的类型"><a href="#3-接收者的类型" class="headerlink" title="3. 接收者的类型"></a>3. 接收者的类型</h4><p>&emsp;&emsp;接收者即指明的从属类，我们在之前的案例中都使用的是类的对象，也可以某种程度上理解为传入的一个参数为一个对象。由于struct是值传递，因此传入对象之后在方法中无法改变对象中的值，这个特性对于熟悉面向对象编程的开发者来说十分不友好，因此接收者不仅可以是类的对象，也可以是一个指针，我们举两个例子进行对比：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s stu)</span> <span class="title">setName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    s.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> student stu = stu&#123;<span class="string">"DENG"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    student.setName(<span class="string">"YANG"</span>)</span><br><span class="line">    fmt.Println(student.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在第一个例子中，我们在方法的接收者部分使用的是struct变量，且在setName方法中我们将stu中对应的name属性赋值。在main函数中我们首先为student的name赋值为”DENG”，然后通过setName方法进行修改，最后再进行输出。由于结构体的值类型的属性，传入到setName方法中的student是另一段内存，调用过后就释放了，因此输出结果为：DENG </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stu)</span> <span class="title">setName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    s.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> student stu = stu&#123;<span class="string">"DENG"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    student.setName(<span class="string">"YANG"</span>)</span><br><span class="line">    fmt.Println(student.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个例子中，我们将方法的接收者改为一个stu指针，这样传入的就是一个student的引用，方法中的name修改直接影响到调用者的属性，因此此时的输出为：YANG </p><p>&emsp;&emsp;值得最后一次一提的是：我们只将stu改为了*stu，而其他的部分均没有发生变化，因此在上述的程序中我们使用了非常多的编译优化的特性，且这种特性对Java等开发者十分友好。如果读者已经完全明白引用与值的关系，在以后的编程过程中可以活用这个编译特性，本人在这里以及以后也对读者不做任何的限制了。</p><h4 id="4-编译器优化指针"><a href="#4-编译器优化指针" class="headerlink" title="4. 编译器优化指针"></a>4. 编译器优化指针</h4><p>&emsp;&emsp;在之前的介绍中，我们提到了Go语言的编译器对指针类型与数值类型的使用进行了优化，即根据函数参数的类型自动判断其应当传入的指针或数值类型。这种编译器优化只针对于方法，而不针对于函数。假如在函数的使用过程中出现了不匹配的情况，在编译过程中将直接报出错误。 </p><p>&emsp;&emsp;首先我们举一个函数的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showName</span><span class="params">(stu *student)</span></span> &#123;</span><br><span class="line">    fmt.Println(stu.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu student = student&#123;</span><br><span class="line">        name: <span class="string">"DENG"</span>,</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//showName(stu)  //cannot use stu (type student) as type *student in argument to showName</span></span><br><span class="line">    showName(&amp;stu)  <span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们首先定义了一个结构体，然后又定义了一个showName的函数，由于它并没有绑定对象，因此它只是一个函数而非方法。最后在主函数中我们实例化一个结构体，并分别通过结构体对象和结构体对象指针进行showName的调用。由于在showName函数定义中，我们采用了student指针作为入参。因此在通过对象实例进行传参的时候出现了参数不匹配的情况。而采用实例指针进行传参的时候，程序可以正确执行并输出相应的结果。 </p><p>&emsp;&emsp;因此对于普通函数来说，<strong>编译器并没有对普通函数参数检查进行指针优化</strong>。 </p><p>&emsp;&emsp;接下来，我们将showName函数改为student类的一个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span> <span class="title">showName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(s.name)    <span class="comment">//正确</span></span><br><span class="line">    fmt.Println((*s).name)  <span class="comment">//正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu student = student&#123;</span><br><span class="line">        name: <span class="string">"DENG"</span>,</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    (&amp;stu).showName()  <span class="comment">//正确</span></span><br><span class="line">    stu.showName()    <span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，我们将showName方法绑定到student类上，并在主函数中通过stu对象调用了showName方法。在主函数中，我们实例化了student类成为一个对象，并分别通过对象的方式和对象指针的方式调用了方法。同时，在方法中，我们通过传入的指针参数调用了s对象指针的name属性。在运行结果中，都可以正确地完成姓名的输出。 </p><p>&emsp;&emsp;因此，对于方法而言，<strong>编译器对方法进行了指针的优化</strong>。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>&emsp;&emsp;在这个部分中，我们将对Go语言中的工厂模式进行阐述，这种代码模式在日常开发中还是十分常见的。而且在多人代码合作中，这个模式用到地就更为常见了。 </p><h4 id="1-工厂模式引入"><a href="#1-工厂模式引入" class="headerlink" title="1. 工厂模式引入"></a>1. 工厂模式引入</h4><p>&emsp;&emsp;在之前的讲解中，我们提到标识符首字母的大小写是控制其可见性的一个标准。当标识符首字母大写的时候，我们可以通过其他包访问到这个变量或函数。如果标识符首字母小写的话，我们只可以在本包中访问对应的变量。然而在程序开发过程中，将所有的属性、方法都设定为共有是及其不可取的做法，这样做意味着其他的开发者可以在其他包中任意修改本包的数据。而将属性方法设定为私有的话，其他开发者又完全没有办法读取本包数据。因此，我们采用工厂模式来完成对应的优化。 </p><p>&emsp;&emsp;我们依旧采用demo包和test包举例，在test包中存在一个student的类，在demo包中完成对student对象属性的调用。首先我们假设Student类中有两个属性：Name和Age：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">test.<span class="keyword">go</span>：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">package</span> test</span><br><span class="line">    <span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        Age <span class="keyword">int8</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">demo.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">package</span> main</span><br><span class="line">    <span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"test"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> stu = test.Student&#123;</span><br><span class="line">            Name: <span class="string">"DENG"</span>,</span><br><span class="line">            Age: <span class="number">18</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(stu.Name)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码实现当然是没有问题，因为Student的首字母是大写的，Student类中所有属性的首字母也都是大写的，因此Student类是完全共有的，不会出现属性访问的问题。那么假如两个包是由两个不同的人开发，且每个人都希望保护自己的代码，将Student的首字母小写成为student，那么当前的做法就会报错了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;修改过后，此时demo中会报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cannot refer to unexported name test.student</span><br><span class="line">undefined: test.student</span><br></pre></td></tr></table></figure><h4 id="2-解决方式"><a href="#2-解决方式" class="headerlink" title="2. 解决方式"></a>2. 解决方式</h4><p>&emsp;&emsp;既然类已经被限定在本包中使用而其他包无法创建，那么就让该类的实例化过程出现在该类对应的包中：在一个公有的函数中完成类的实例化，并将该对象通过指针的形式返回出去。这个公有的函数可以具备一些形式参数来完成对象的初始化，类似于构造函数。基于上述的案例，我们将test包中的代码修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">student</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">        Name: name,</span><br><span class="line">        Age: age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们在test包中通过NewStudent函数做了student类的实例化操作，并将该对象的指针通过返回值返回给调用者，由于NewStudent函数是公有的，因此其他包可以通过这个函数来完成实例化操作。对应的demo包中代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"test"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu = test.NewStudent(<span class="string">"DENG"</span>, <span class="number">18</span>)</span><br><span class="line">    fmt.Println(stu.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-属性权限控制"><a href="#3-属性权限控制" class="headerlink" title="3. 属性权限控制"></a>3. 属性权限控制</h4><p>&emsp;&emsp;完成了私有类的实例化操作后，对象中属性也可能会出现私有的现象。例如：希望student类中的Age属性只可以在其他包中读取，但是不可以在其他包中修改。完成这个操作的思路其实和类的实例化非常相似，唯一的区别是属性的权限控制可以通过方法来完成。我们直接通过代码说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">student</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">        Name: name,</span><br><span class="line">        age: age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span> <span class="title">GetAge</span><span class="params">()</span> <span class="title">int8</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们修改了age的访问权限（首字母变为小写），这样在其他的包中就无法访问了，同时我们又添加了一个公有的方法GetAge，在这个方法中访问age属性。由于其他包中可以通过NewStudent函数得到对象，又可以通过对象得到属性，因此这种实现方式相当于间接访问到了age属性，但不可以修改它。 </p><p>&emsp;&emsp;此时demo.go中代码变为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main    </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"test"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu = test.NewStudent(<span class="string">"DENG"</span>, <span class="number">18</span>)</span><br><span class="line">    <span class="comment">//stu.age = 20  //stu.age undefined (cannot refer to unexported field or method age)</span></span><br><span class="line">    fmt.Println(stu.GetAge())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p> &emsp;&emsp;在这个小节中，我们继续讲解了Go语言中方法的概念以及注意事项，同时我们也针对Go语言中工厂模式进行了讲解，解决了私有属性的访问权限控制以及类的实例化的函数。在下几个小节中，我们将针对面向对象中的抽象和封装两个概念进行讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-39-gt-面向对象-方法细节与工厂模式&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-39-gt-面向对象-方法细节与工厂模式&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;39&amp;g
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;38&gt; 面向对象-方法</title>
    <link href="http://yoursite.com/2020/03/12/38-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/12/38-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95/</id>
    <published>2020-03-12T15:16:11.000Z</published>
    <updated>2020-03-12T15:16:41.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-38-gt-面向对象-方法"><a href="#Go语言从入门到放弃系列-lt-38-gt-面向对象-方法" class="headerlink" title="Go语言从入门到放弃系列&lt;38&gt; 面向对象-方法"></a>Go语言从入门到放弃系列&lt;38&gt; 面向对象-方法</h2><p>&emsp;&emsp;在上两个小节中，我们讲解了Go语言中面向对象部分的结构体的概念及使用。在结构体中，我们涉及到的最多的都是各种属性，例如一个人的类的结构体中会具备眼睛、鼻子、耳朵、嘴等属性，但是这些属性相对于面向对象而言更为”静态”。即它只说明了一个结构体中、一个类中具备什么样的性质，而没有指明这个类对应的实例能够做什么，例如一个人可以行走、可以观察等，这些相对”动态”的行为是由面向对象中的方法完成的。 </p><h3 id="方法快速入门"><a href="#方法快速入门" class="headerlink" title="方法快速入门"></a>方法快速入门</h3><p>&emsp;&emsp;在Go语言的面向对象体系中，有一个和函数十分类似的概念，我们称之为方法。在一些完全面向对象的计算机语言中，函数和方法是通用的，函数主要是指面向过程中的程序单元，方法主要是指面向对象中的类行为。可以说函数的说法是先于方法的，面向对象语言的发展是基于面向过程的，因此对于Java、PHP等语言来说函数和方法是等价的，而对于C++、Go等既包含面向过程部分也包含面向对象部分的语言来说，函数和方法是两个十分相似但是本质不同的概念。 </p><p>&emsp;&emsp;我们在方法的引出过程中也提及到了：方法(method)是针对于某一个类甚至是某几个类而言的，不同的类方法是可以不相同的，例如对于人类来说，我们可以具备使用工具、计算、行走等行为，但是对于鸟类来说他们具备飞行等行为，同理在Go语言中，每一个方法的出现往往会指定某一个类型作为”接收者”，即在某种情况下这个方式仅仅隶属于某一个类。在这里我们依旧沿用上一节中举的例子：学生类</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int</span></span><br><span class="line">    friends []stu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个类中，我们仅仅指明了一个学生结构体中具备姓名、年龄、以及朋友三个属性，而对于学生类的实例具体能做什么没有任何的说明。接下来我们假设一个学生实例可以完成计算两个数的加和的行为，此时根据上述的分析，方法在定义中需要指明某一个行为属于某一个类，那么此时计算的行为可以如下表示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s stu)</span> <span class="title">calculate</span><span class="params">(n1, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的程序段就可以称为一个方法，我们可以发现方法和函数不仅在概念上十分的相似，在定义方式上也是十分的相像。既然方法也是为了完成某一个目的而进行了抽象，那么方法的定义中也可以存在参数或者返回值，它与函数的唯一区别就是它需要指明这个方法归属于哪个类，在上述的方法定义中指明了归属于stu。 </p><p>&emsp;&emsp;在一些面向对象语言中，方法的定义是在class类中，和属性的定义相平行，这样的做法使方法得以访问到类中所定义的属性。在Go语言中，方法的实现是不相同的，它的方法是定义在struct结构体之外的，通过字段的指定来确定方法的归属。因此方法的调用是需要通过对应的类的实例来完成的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> student stu = stu&#123;&#125;</span><br><span class="line">    fmt.Println(student.calculate(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先通过学生类实例化一个对象，然后通过这个student对象来完成计算方法的调用。一个类具备某种行为，由该类实例化得到的个体对象当然也具备该方法的使用能力，因此此时可以通过”.”来完成从属关系的调用。</p><h3 id="方法的”传参”机制"><a href="#方法的”传参”机制" class="headerlink" title="方法的”传参”机制"></a>方法的”传参”机制</h3><p>&emsp;&emsp;在这个小部分中，我们所说的传参可以分为两部分来理解，一部分是方法的参数中的真的参数，另一部分则是方法归属类的抽象实例。方法的参数与函数的参数是相同的，即传入的数据类型是值类型的时候是在内存中复制一份原有数据再传入，传入的数据与原数据没有关系；当传入的数据类型为引用类型或指针时，则复制一份指向的地址传入，函数、方法中对数据的修改会影响到原数据。这个似乎不难理解，我们在函数的讲解中已经十分详细地介绍过了。 </p><p>&emsp;&emsp;现在我们回到Go语言对于面向对象特性的实现方式上，其他语言可以在方法中调用到类中的属性，那么在Go语言中这个特性也应该可以完成。由于方法的定义中已然指明了它所归属的类，所以此时<strong>假如</strong>我们再传入一个该类所对应的实例（对象），通过该对象来访问实例中的属性数据就可以了。在Go语言中也确实就是如此设计的，方法在指明对应类的同时直接传入一个抽象的实例，传入的方式和函数的传参一致，而又由于结构体本身是值类型，因此对应的抽象实例也就是和值传递相同。 </p><p>&emsp;&emsp;我们换一种理解方式：假如在一个函数中需要传入一个对象，在函数中输出对象所对应的一个属性，我们可能会采用如下的方式来完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span> <span class="params">(student stu)</span></span>&#123;</span><br><span class="line">    fmt.Println(student.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时的student对象是作为函数参数传入的，且传入的方式为值传递，我们通过该对象完成了name属性值的输出。那么对于方法而言，已然指出的类的归属，那么就可以如下来完成了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(student stu)</span> <span class="title">method</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(student.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个方法的定义中，student依然是值传递的方式传入的，从某种程度上讲，上述两种不同的函数与方法的实现方式，在理解过程中可以认为是相同的，即类的从属的指定作为方法的另一个参数。</p><h3 id="自定义类型的方法"><a href="#自定义类型的方法" class="headerlink" title="自定义类型的方法"></a>自定义类型的方法</h3><p>&emsp;&emsp;在Go语言中可以说通过type关键字所修饰的都是自定义数据类型，包括结构体的声明也可以被归结为自定义数据类型，因为不同的属性名、属性的数据类型、属性的个数所确定的结构体类型是完全不同的。既然Go语言中方法是作用于指定的数据类型上，那么只要是自定义类型，就都可以有方法，我们举一个例子： </p><p>&emsp;&emsp;现在我们的需求是为一个整数（int）添加一个方法，如果这个整数是奇数则返回false，是偶数则返回true。在此之前我们在程序中需要整数时直接定义一个int类型的变量，也不曾听说过整数类的概念，此时添加方法的途径就是将其变为一个自定义的数据类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Integer)</span> <span class="title">isEven</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num Integer = <span class="number">10</span></span><br><span class="line">    fmt.Println(num.isEven())</span><br><span class="line">    num++</span><br><span class="line">    fmt.Println(num.isEven())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如同声明结构体数据类型一般，我们通过type的方式将一个int类型自定义为Integer，此处的Integer数据类型就可以添加方法了，不仅如此，我们在main函数中将Integer变量进行自加操作，程序依旧可以完成对应的加法。由此可见：通过type的方式可以借助一些内置数据类型来自定义一些类型，这些类型可以添加方法，同时也同样具备数据本身的属性，如数学运算等。 </p><p>&emsp;&emsp;需要注意的一点是：我们通过type的方式为int类型自定义了一个Integer类型，如果在程序中有两个变量分别由int和Integer类型所定义，这两个变量的数据类型是不同的，在相互转化的时候需要进行强制转化。因此通过int定义的变量，是不具备isEven方法的，但是将其强转成Integer类型时就可以使用该方法了。</p><h3 id="String-方法"><a href="#String-方法" class="headerlink" title="String()方法"></a>String()方法</h3><p>&emsp;&emsp;在Go语言中我们经常通过fmt.Println()函数来完成数据向屏幕的输出，那我们可能会想了：当输出一个整数变量时编译器输出对应的值，当输出数组时编译器将数组中所有值都输出了，当输出引用类型的map时，编译器输出了指向的内存中的key和value的所有值，那么这个输出究竟遵循什么原则。 </p><p>&emsp;&emsp;在Go语言中一个数据类型如果实现了String()方法，那么当执行fmt.Println()时，输出到屏幕上的就是String()方法的返回值，我们举个例子：假如我们还是使用stu结构体，现在要求当我们使用fmt.Println(stu对象)的时候输出为：xxx(stu对象中的name属性)是个好人。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int</span></span><br><span class="line">    friends []stu</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s stu)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.name + <span class="string">"是个好人"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> student stu = stu&#123;<span class="string">"DENG"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    fmt.Println(student)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DENG是个好人</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样地我们也可以采用String方法来完成一些基本数据类型的其他形式的输出，当然前提条件是通过type关键字根据基本数据类型完成自定义类型的创建，然后再覆盖String方法，此处也不再做举例了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们引入了面向对象编程的另一个组成部分：方法，同时我们也通过一个入门案例完成了对方法的介绍。如果读者在之前掌握了Go语言中函数的概念与使用方式，那么对于方法的理解就轻而易举了，二者也有十分多的相似之处。最后我们又介绍了Go语言中独特的自定义数据类型的方法调用方式，以及String方法对一个数据类型的作用。 </p><p>&emsp;&emsp;在下个小节中，我们将继续讲解面向对象中方法的细节与注意事项，同时也会在下个小节中插入代码篇部分，简单针对几个小需求举几个方法的例子并进行简要地讲解。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-38-gt-面向对象-方法&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-38-gt-面向对象-方法&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;38&amp;gt; 面向对象-方法&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到放弃系列&lt;37&gt; 结构体细节讨论</title>
    <link href="http://yoursite.com/2020/03/11/37-%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/03/11/37-%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/</id>
    <published>2020-03-11T11:00:25.000Z</published>
    <updated>2020-03-11T11:01:19.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-37-gt-结构体细节讨论"><a href="#Go语言从入门到放弃系列-lt-37-gt-结构体细节讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;37&gt; 结构体细节讨论"></a>Go语言从入门到放弃系列&lt;37&gt; 结构体细节讨论</h2><p>&emsp;&emsp;在上一个小节中，我们引入了结构体的概念，讲解了Go语言中结构体内存对齐的原理，同时也简要提及了面向对象与面向过程的区别，准确地说Go语言并不是一个严格的面向对象的语言，但是它具备着面向对象的许多的特点。在这个小节中，我们依旧暂时不去讲解面向对象的其他特性，而是依旧针对于结构体进行一些细节上的讲解。 </p><h3 id="结构体的声明方式"><a href="#结构体的声明方式" class="headerlink" title="结构体的声明方式"></a>结构体的声明方式</h3><p>&emsp;&emsp;在Go语言中，结构体声明与使用可以由四种方式来完成，分别对应于熟悉不同开发语言的用户。在实际运用中均十分地常见，在这个部分中，我们将分别介绍这四种方式。首先我们先声明一个如下结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int</span></span><br><span class="line">    friends []stu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们定义了一个学生结构体，结构体中三个属性分别是指学生的姓名、学生的年龄、以及学生对应的朋友切片，切片的元素类型依旧是stu类型。由于上一个小节我们已经讲解了内存对齐的问题，因此在这里我们也就不再说这个结构体占据多大的内存空间了。接下来就是四种使用方式：</p><h4 id="1-先定义再赋值"><a href="#1-先定义再赋值" class="headerlink" title="1. 先定义再赋值"></a>1. 先定义再赋值</h4><p>&emsp;&emsp;这种方式与我们入门案例程序中的使用方式是相同的，即将其想象成为一个普通的数据类型，用同样的方式进行定义变量，之后再为每个属性进行赋值。值得说明的是：属性中的map映射需要进行make操作才能够正常使用，对于slice而言，如果直接用append操作就可以不用make了。我们举一个例子说明即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 stu</span><br><span class="line">stu1.name = <span class="string">"Devin"</span></span><br><span class="line">stu1.age = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> stu2 stu</span><br><span class="line">stu1.friends = <span class="built_in">append</span>(stu1.friends, stu2)</span><br><span class="line">fmt.Println(stu1)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们定义了一个stu结构体变量，之后我们再分别为每一个属性进行赋值，在为friends赋值时，我们又定义了一个新的变量，并将新的变量加入到切片中，由于stu2只进行了定义而没有做任何赋值，因此stu2的各个属性默认值均为其零值，即数字类型为0，字符串为空串，切片等引用类型及指针为nil。</p><h4 id="2-定义时初始化"><a href="#2-定义时初始化" class="headerlink" title="2. 定义时初始化"></a>2. 定义时初始化</h4><p>&emsp;&emsp;就如同普通变量在定义时直接赋值成为初始化一样，结构体在定义的时候也可以直接赋值进行初始化。其实通过上述的例子可以发现，当我们没有显式初始化而是只定义的情况下，编译器其实是通过属性对应的零值进行了初始化操作。如果我们不想使用其初值而是使用自己赋给的值时，可以直接进行初始化操作，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 stu = stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">fmt.Println(stu1)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于了解面向对象编程的读者而言，可以将其理解为stu类的构造函数，虽然在Go语言中并不存在构造函数的概念，同时也不支持函数的重载。但是这种定义方式可以直接为类中所有的变量进行数据的初始化，那么既然可以为所有的数据进行初始化，那么对某一部分属性进行初始化也应该是可以完成的。 </p><p>&emsp;&emsp;例如我们只希望初始化stu的对象中的name和age属性，而其他属性则保持其默认的零值。解决办法则是在结构体初始化过程中指明需要初始化哪个属性，不需要初始化的属性不予体现即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student stu = stu&#123;</span><br><span class="line">    name: <span class="string">"DENG"</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;既然我们在程序中指明了哪些属性需要初始化，且初始化的值也一一对应了，那么在运行时编译器就可以为特定的值进行赋值了。在这里需要尤其注意的一点是：在这种初始化过程中，每指定一对属性和值之后都有一个逗号，即便是对属性赋值这个操作是最后一个（age:25后面有一个逗号），如果没有逗号则会编译错误。 </p><h4 id="3-new函数实现内存分配"><a href="#3-new函数实现内存分配" class="headerlink" title="3. new函数实现内存分配"></a>3. new函数实现内存分配</h4><p>&emsp;&emsp;第三种方式可以说对于熟悉Java等语言的开发者十分地友好，因为开发者往往需要通过new关键字来完成对象的创建。Go语言的开发者考虑到类似的需求，便为结构体创建实例添加了这个方式。只是在Go语言中，new并不是其中的关键字，而是一个内建函数，其返回值也不是结构体变量，而是指向结构体变量的指针，我们通过程序来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 = <span class="built_in">new</span>(stu)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, stu1)</span><br><span class="line">(*stu1).name = <span class="string">"Devin"</span></span><br><span class="line">stu1.age = <span class="number">25</span></span><br><span class="line">fmt.Println(*stu1)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果运行上述的程序，我们可以看到第二行对应的输出结构为*main.stu，其含义为main包下的stu类的指针，因此new函数的返回值是一个结构体指针。既然它是一个指针变量，当然就需要遵守指针的原则，即先取出指针所指向的结构体，再进行成员操作。由于运算符的优先级中成员符号要高于取值符号，因此我们在取出对应的结构体时需要用括号进行修饰，即(*stu1).name。假如不使用括号进行修饰，则.运算符先进行运算，虽然Go语言底层对于指针进行了优化操作，将指针的成员默认为指针对应结构体成员，但是对一个变量做*运算依旧是错误的，因此括号是必须要加的。 </p><p>&emsp;&emsp;说起Go语言对底层的优化，我们在之前的小节中也有相应的讲解，上述代码中也运用到了这个优化操作，即stu1.age = 25这一行代码。对指针进行成员操作是无意义的，因此编译器就自动翻译成为了取值后再做成员操作。如果读者对于什么是指针、什么是值、什么时候应该怎样的操作都十分熟悉了，那么当然就可以利用这个优化进行简要的操作了。</p><h4 id="4-初始化时返回指针"><a href="#4-初始化时返回指针" class="headerlink" title="4. 初始化时返回指针"></a>4. 初始化时返回指针</h4><p>&emsp;&emsp;准确地说这个方式不算是一个特殊的方式，它只是将方式2中的结构体初始化结果以指针形式进行返回，当然其定义部分的数据类型也当然就是指针，这种方式在程序开发中也是十分常用，由于其只是方式2的变形，我们就只举个例子，不再过多说明了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 *stu = &amp;stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">fmt.Println(*stu1)</span><br></pre></td></tr></table></figure><h3 id="结构体的赋值"><a href="#结构体的赋值" class="headerlink" title="结构体的赋值"></a>结构体的赋值</h3><p>&emsp;&emsp;在之前的各个章节中，我们均介绍到了各个数据类型是值类型还是引用类型，在这个部分中，我们将针对结构体的性质进行讲解。我们采用的结构体声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name   <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int</span></span><br><span class="line">    class   *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-结构体是值类型"><a href="#1-结构体是值类型" class="headerlink" title="1. 结构体是值类型"></a>1. 结构体是值类型</h4><p>&emsp;&emsp;在Go语言中，结构体是值类型而不是引用类型，这也就说明了一旦将一个结构体变量赋值给另一个结构体变量，其内部属性的所有值将会全部复制，在内存中出现一个完全新的结构体变量，两者之间并不互相影响，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 stu = stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="keyword">var</span> stu2 stu = stu1</span><br><span class="line">stu2.name = <span class="string">"RuoShui"</span></span><br><span class="line">fmt.Println(stu1)</span><br><span class="line">fmt.Println(stu2)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们定义了一个结构体变量stu1，且将该变量直接赋值给另一个变量stu2，此时内存中存在着两个地址不同但内容相同的结构体变量。接下来我们将stu2的name属性修改后，分别输出两个结构体观察结果，最后可以发现，对stu2的修改并不影响stu1的属性。 </p><p>&emsp;&emsp;在这个特性上Go语言与Java语言是不同的，Java秉承了没有显式指针的思想，但核心是全部都是指针，因此熟悉Java的读者在使用Go语言结构体赋值的时候可能会不甚适应，那么如何让一个结构体变量的修改影响到另一个结构体，我们可以采用如下指针的方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 *stu = &amp;stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="keyword">var</span> stu2 *stu = stu1</span><br><span class="line">stu2.name = <span class="string">"RuoShui"</span>    <span class="comment">//这里采用了编译器优化</span></span><br><span class="line">fmt.Println(*stu1)</span><br><span class="line">fmt.Println(*stu2)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们通过指针进行直接赋值，stu2也同样指向了结构体变量，就如同一个机器具备两个控制源，任何一个控制源发布命令，机器都会做出响应。这种实现方式可能更适合于熟悉Java开发的人们。 </p><h4 id="2-深浅拷贝"><a href="#2-深浅拷贝" class="headerlink" title="2. 深浅拷贝"></a>2. 深浅拷贝</h4><p>&emsp;&emsp;我们在这里介绍的概念在笔试乃至于面试中经常出现，即深拷贝与浅拷贝的区别，这两种拷贝方式并不局限于Go语言，而是适用于每一个编程开发语言，只是不同的语言可能采用着不同的拷贝策略，既然Go语言中结构体的赋值是将一个结构体在内存中完全复制、新建、粘贴，那么在这个过程中它究竟是深拷贝还是浅拷贝。 </p><p>&emsp;&emsp;首先我们介绍一下什么是深拷贝，什么是浅拷贝。这两种拷贝方式的区别十分简单：深拷贝就是完全复制，首先对外层对象进行拷贝，对内层引用也进行拷贝；而浅拷贝则是只复制了对象本身，其内部的引用其他对象不做复制，只做引用。 </p><p>&emsp;&emsp;用一个通俗的例子来讲便是，假如我们有一个收纳盒（结构体），盒子中有一个遥控器（引用），这个遥控器可以控制房间内的电视机（指针指向的值）。现在我们希望再建立一个收纳盒，且保持其中的物品不变，将这个收纳盒送给其他人（结构体赋值）。深拷贝的做法就是用一个新的收纳盒，装载一个新的遥控器，控制一个新的电视机，将这三样物品全部交给其他人；浅拷贝的做法就是用一个新的收纳盒，复制那个遥控器，电视机不做任何改动，将收纳盒与遥控器交给其他人，这两个遥控器均可以控制该屋子中的电视机。 </p><p>&emsp;&emsp;那么在Go语言中结构体的赋值是哪一种拷贝方式，我们做一个简单的验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> stu1 *stu = &amp;stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, &amp;a&#125;</span><br><span class="line"><span class="keyword">var</span> stu2 *stu = stu1</span><br><span class="line">fmt.Println(*stu1)</span><br><span class="line">fmt.Println(*stu2)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的程序中，我们依旧将stu1直接赋值给stu2，在最后的输出中，我们会将stu1与stu2中的class属性的地址直接输出。通过对结果的检验，我们可以发现两个结构体变量中class所指向的地址是相同的，因此可以验证得到Go语言中结构体的直接赋值过程是一个浅拷贝过程。 </p><p>&emsp;&emsp;通过这个结果我们可以想象到：当一个结构体中存在一个引用类型或者指针类型时，即便是结构体本身是值类型，其复制得到的结构体变量中的引用是不变的，从这个角度来说通过一个结构体变量修改引用类型或指针类型数据时是会影响到另一个结构体变量的，但是这与结构体值类型中两个结构体内存无关联是不相矛盾的。</p><h4 id="3-结构体类型强转"><a href="#3-结构体类型强转" class="headerlink" title="3. 结构体类型强转"></a>3. 结构体类型强转</h4><p>&emsp;&emsp;在我们之前讲解到的基本数据类型中，我们讲解过基本数据类型之间的相互转化，那么作为数据类型集合的结构体数据类型也可以发生强制转化。例如我们案例中的学生结构体是由姓名、年龄、班级所构成的，假如存在一个person类，且person类中的三个属性分别为姓名、年龄、以及性别（假如性别使用整数来表示），那么stu类与person类是否可以强制互相转化。 </p><p>&emsp;&emsp;在Go语言中，数据类型是十分严格的，即便是同一种数据类型精度不同也不可以不作声明地直接转化，结构体变量也是相同的。如果希望从一个结构体强制转换成另一个结构体，需要满足一个条件：两个结构体需要有完全相同的字段，完全相同是指属性的名字、个数、类型完全相同。我们举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> per <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">    class *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> stu1 stu = stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, &amp;a&#125;</span><br><span class="line">    <span class="keyword">var</span> per1 per = per(stu1)</span><br><span class="line">    fmt.Println(per1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们又新建了一个结构体叫做per，它也是由三个属性构成的，分别为name，age，和class。在主函数中，我们定义了一个stu类型的变量，且将该变量强制类型转换成为per类型赋给per1，最后输出per1，这段程序在编译以及运行过程中均不会报错，也就证明了强制类型转化是成功的。现在我们将per结构体做一些改变：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> per <span class="keyword">struct</span> &#123;</span><br><span class="line">    name   <span class="keyword">string</span></span><br><span class="line">    age    <span class="keyword">int</span></span><br><span class="line">    gender   *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时由于两个结构体的字段（属性）并不是完全一致的，主函数中的程序是无法编译通过的，其报错的信息为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert stu1 (<span class="keyword">type</span> stu) to <span class="keyword">type</span> per</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在本章节中，我们深入Go语言的结构体进行了深入的讲解，包括结构体的四种定义方式：两种返回值、两种返回指针，结构体值类型的特性以及结构体赋值时的浅拷贝特性，再有就是不同结构体之间做类型转换的条件与错误类型。 </p><p>&emsp;&emsp;在下个小节中，我们将不再针对结构体的属性进行讲解，而是进入到面向对象的另一个小部分：成员方法的讲解。在讲解的过程中，我们也将会详细说明一个类中的方法的概念、使用方式、以及它与函数的区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言从入门到放弃系列-lt-37-gt-结构体细节讨论&quot;&gt;&lt;a href=&quot;#Go语言从入门到放弃系列-lt-37-gt-结构体细节讨论&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到放弃系列&amp;lt;37&amp;gt; 结构体细节讨论&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
