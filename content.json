{"meta":{"title":"云钰的亭轩阁","subtitle":"Running water never goes stale, so you gotta just keep on flowing.","description":"","author":"Devin DENG","url":"http://yoursite.com","root":"/"},"pages":[{"title":"About me","date":"2020-02-04T12:23:32.000Z","updated":"2020-02-04T12:24:37.775Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Go语言从入门到放弃系列<11> 基本数据类型精讲-字符和字符串","slug":"11-基本数据类型精讲-字符和字符串","date":"2020-02-14T06:19:09.000Z","updated":"2020-02-14T06:20:38.886Z","comments":true,"path":"2020/02/14/11-基本数据类型精讲-字符和字符串/","link":"","permalink":"http://yoursite.com/2020/02/14/11-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"Go语言从入门到放弃系列&lt;11&gt; 基本数据类型精讲-字符和字符串&emsp;&emsp;在介绍Go语言的基本数据类型时，我们同时也提及了布尔型变量、复数类型以及字符串，并单独介绍了Go语言中不存在但是一些其他语言存在的字符型变量。复数类型在开发过程中不怎么常用，而布尔型变量我们会在条件结构的章节中详细地介绍，因此在这一节中，我们将集中讲述字符和字符串类型的各个注意事项以及一些细节点。 （字符型）&emsp;&emsp;我们在这里用括号括起来依旧是表示这个类型是不存在的，但是为了介绍方便以及引出字符串的注意点，我们依旧将它作为一种数据类型进行讲解。在前面的介绍中，我们可知Go语言中的字符不仅仅局限于数字、字母等传统ASCII字符集，而是囊括了各个国家的各种语言。因此虽说byte和rune类型均表示字符型类型，但是除非明确运用在英语国家，我们一般还是会运用rune类型。 ASCII字符集&emsp;&emsp;ASCII字符集是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他的西欧类语言。同时也是在西方英语国家中最为常用且通用的单字节编码系统，现在包括UTF-8编码在内的UNICODE编码均向下兼容了ASCII编码模式。一般来说，ASCII码是使用7位或8位二进制位的组合来表示128种或256种可能的字符。在早期ASCII码用于传输的时候是128个，也就是占据了7个二进制位，后来IBM公司根据字节这个最小单位所拥有的位数拓展成了256个字符，但日常编程中常用的是前128个。 &emsp;&emsp;上图即为ASCII码与字符之间的匹配关系（图片来源于网络），从图中看，我们可以找到几点规律： &emsp;&emsp;1. 从编号为33的字符开始直到编号为126的字符，均是我们日常开发中在键盘上可以见到的、常用的字符，包括数字、字母、与众多标点等。其余的字符均是控制类与传输类的字符，往往需要转义才能得到。 &emsp;&emsp;2. 数字从0到9，字母从a到z，字母从A到Z的编码值分别是连续的，但是其之间是不连续的。在字符参与运算过程中，例如’A’+2，其结果为’C’，原理与整数相加是相同的。 &emsp;&emsp;3. 在编程过程中需要尤其注意0，’0’，与’\\0’的关系，在上一节介绍用字符串表示浮点数与整数以消除其误差的时候，过程中的一环便是将字符型的数字转换成内存中的相应的数字，解决办法便是对每一位的值均实行减48的操作，这样计算结果才是正确的，前期练习的时候可能会在这个地方犯错。 &emsp;&emsp;接下来我们利用循环（后面会讲到）在控制台输出前128个字符，我们会发现还是有许多有趣的字符的： &emsp;&emsp;从中我们看到了笑脸、看到了心、还看到了许多莫名其妙的字符，这些奇怪的字符代表的均是控制类和传输类的字符，如果仔细听，我们还会听到计算机的蜂鸣器发出了‘嘟’的一声，这个是因为ASCII码为7的字符发出的，其结果就是令蜂鸣器发出声音。 字符串&emsp;&emsp;在前面的阐述中，我们将字符串阐述成为字符的有序合集，是由一个个字符所构成的，但是这种说法不甚确切，准确地说Go语言的字符串是由字节所构成的。根据UTF-8编码规则可知，每个字符占据三个字节，所以Go语言中的字符串长度与其占据的字节数是不相同的。在Go语言的字符串使用中，我们需要注意以下的几个点： 字符串是常量&emsp;&emsp;这个特性在很多语言中均是如此，字符串在定义过程中就已经分配好了空间，且不能通过类似数组方式进行单个字符的替换，例如如下程序，我们希望将Hallo中的’a’字符替换成’e’字符，这个操作是非法 的： 123var str string = \"Hallo\"str[1] = 'e'fmt.Println(str) &emsp;&emsp;其报错信息为：cannot assign to str[1]，所以字符串一旦赋值了，字符串就不能更改了。当对字符串进行拼接操作时，例如如下程序，将Hello与World拼接起来，可以采用+号进行拼接: 123var str string = \"Hello\"str = str + \" World\"fmt.Println(str) &emsp;&emsp;程序输出结果为Hello World，将两个字符串拼在了一起，看起来像是将World单词拼接在了Hello的后面，实则不是。在执行这个操作的时候，内存中生成了两个字符串，分别为Hello和Hello World，只是str由原来的指向Hello变成了指向Hello World字符串。原来的Hello字符串由于没有任何变量指向它了，就被Go的GC机制回收并释放了内存。 字符串的两种表示方式&emsp;&emsp;在前面的举例中，我们都用双引号进行字符串的表达，这个就不再举例了，前面的例子已经足够说明这种方式了，在这里我们介绍的是第二种表示方式，即利用反引号进行表示。反引号是我们键盘上左上角，esc按键下的那个按键，利用反引号可以使字符串以原生的形式进行表示，其中就包含了换行与特殊字符，可以实现防止攻击，输出源代码等效果，例如我们想输出一句Hello “World”，在World的两边输出双引号，如果利用双引号我们将需要写成如下的字符串： 1var str string = \"Hello \\\"World\\\"\" &emsp;&emsp;也就是说我们需要使用转义字符来手动控制字符串中的格式，否则遇见双引号字符串就提前结束了，因此这点在输出源代码的时候就会非常的困难，取而代之，我们可以利用如下的定义方式： 1var str string = `Hello \"World\"` &emsp;&emsp;这样就可以将双引号原样输出，我们再举个例子，将程序的源代码输出： &emsp;&emsp;从上述代码中，我们可以发现使用反引号时可以将双引号、换行符、乃至于制表符都可以直接输出出来，这个特点在用Go做服务器的时候可以得到很多的使用。 len函数与Sizeof函数&emsp;&emsp;在字符串中我们往往需要知道其长度或占据了多少个字节，我们就因此引入两个函数，len函数的返回值表示了字符串的长度。而unsafe包下的Sizeof函数不太一致，其代表了字符串数据类型在内存中占用的空间，这个问题需要说明一下，否则很容易理解错误。我们首先来看纯英文的例子： 12345678910package main import ( \"fmt\" \"unsafe\" ) func main() &#123; var str string = \"Hello\" fmt.Println(len(str)) fmt.Println(unsafe.Sizeof(str)) &#125; &emsp;&emsp;通过程序编译运行后，我们会发现输出的结果分别为5和16，也就是说，Hello这个字符串的长度为5，在内存中被分配了16个字节。相信字符串长度为5这个很好理解，但是字符串占据16个字节就有些问题了，我们先记下不表，现在我们将视线放在中文字符串上（只写main函数中）： 123var str string = \"中国\"fmt.Println(len(str))fmt.Println(unsafe.Sizeof(str)) &emsp;&emsp;这段程序的输出结果为6和16，这个6也相对好理解，因为每个汉字都占据3个字节，两个汉字占据了6个字节是没问题的，但是通过Sizeof输出的结果依旧是16，而且不论什么字符串，结果都是16。可见通过Sizeof得到的值与字符串本身内容是不相关的。我们接下来解释一下这个问题。 &emsp;&emsp;有些人最初可能会将它与C语言中的sizeof函数进行类比，但通过分析它与C语言中的是完全不同的。Go语言中的Sizeof总是在编译期就进行求值而不是在运行期间求值。在Go语言中字符串类型其实对应于一个结构体，该结构体中有两个属性，换句话说字符串类型是由两部分构成的。第一部分为指向该字符串的指针（后续会讲到），第二部分为字符串的长度，每个部分都用了8个字节来存储各自的内容，而字符串的值本身则是在另一段连续的内存中储存着。就如同一个遥控器，一台电视一般，字符串数据引用是遥控器，字符串中的值是电视，Sizeof所测量的是遥控器的尺寸，而不是电视的大小。 字符串拼接时’+’的位置&emsp;&emsp;这个问题十分的简单，我们就举两个例子进行说明，这只是一个规定：当字符串过于长而不得不使用多行来赋值时，’+’的位置需要出现在字符串该行的结尾，而不是下一行的开头： 123var str string = \"Hello\" + \" World\"fmt.Println(str) &emsp;&emsp;上述代码的编译是可以通过的，并且可以得到正确的结果。如果程序写成如下： 123var str string = \"Hello\" + \" World\"fmt.Println(str) &emsp;&emsp;在编译过程中就会出现错误，错误的类型为：invalid operator: + untyped string。这个问题注意一下即可。 小结&emsp;&emsp;在这一小结中，我们集中介绍了字符型数据类型的注意事项，包括ASCII码与字符的对应关系，以及其遵循的规律等。以及字符串在定义、使用过程中所需要注意的几点问题。包括常量的属性、表示方式、字符串长度函数以及拼接过程中+符号所需要处在的位置。在下几节中，我们将继续对基本数据类型进行讲解，集中举例说明数据类型之间的转化方式，例如将整数的值转换为字符串等。","categories":[],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"}]},{"title":"Go语言从入门到放弃系列<10> 基本数据类型精讲-整型和浮点型","slug":"10-基本数据类型精讲-整型和浮点型","date":"2020-02-13T04:41:54.000Z","updated":"2020-02-13T04:42:48.396Z","comments":true,"path":"2020/02/13/10-基本数据类型精讲-整型和浮点型/","link":"","permalink":"http://yoursite.com/2020/02/13/10-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E6%95%B4%E5%9E%8B%E5%92%8C%E6%B5%AE%E7%82%B9%E5%9E%8B/","excerpt":"","text":"Go语言从入门到放弃系列&lt;10&gt; 基本数据类型精讲-整型和浮点型&emsp;&emsp;在前几节中我们详细地讲述了Go语言中二进制的基础，基本数据类型和Go语言中标识符的规定及使用。在接下来的几节中，我们将针对之前提到的几种基本数据类型进行详细地讲解，并对程序开发中可能出现的问题进行讲解和原因的解释。 整型变量的细节讨论&emsp;&emsp;首先，我们先复习一下之前所讲的基本数据类型中的整型变量，整型变量的定义按是否有符号可以分为有符号整数和无符号整数。有符号整数的最高位表示符号位，且0代表正数，1代表负数，无符号整数的最高位参与数字的表示，即只能表示正数。在intN类型中的N代表计算机系统为该类型分配多少个二进制位数，即int8为8位，int16为16位。不同的整数类型对于数值的表示大小是不相同的，我们在接下来的讲解中会以int8为例。 &emsp;&emsp;既然每种整数类型可以表示的数值范围大小是一定的，那么一旦其中存储的数据超出了其可以表示的最大的范围会发生什么呢，我们将以以下的几个例子进行详细地说明： 赋值时越界&emsp;&emsp;首先我们知道，int8可以表示的范围为-128到127，我们看下面的一段代码（只写main函数中的代码了）： 12var num int8 = 128fmt.Println(num) &emsp;&emsp;通过对上述程序的分析，我们知道，将128赋值给int8是会出现数值越界的情况的，因为其可表示的最大的数值只为127。在开发阶段出现了这类数值越界的代码时，编译器会帮助我们进行检查，因此这段代码是无法编译通过的，而且其错误类型显示为： 12constant 128 overflows int8即常量128溢出了int8所能表示的范围 运行时越界&emsp;&emsp;既然在变量的赋值过程中是不会出现数据溢出的（否则编译不通过），那么在运行时是否会出现数据越界呢，一旦出现的数据越界程序是否会做出相应的响应，例如程序停止运行等行为。现在我们进行验证一下： 123var num int8 = 127num = num + 1fmt.Println(num) &emsp;&emsp;程序中出现的num=num+1的意思是，取出num所代表的值，进行加1运算后将结果再赋值给num。在这个过程中，我们会预见在做完加1运算后就又出现了数值溢出现象，经过编译运行后，我们会发现编译过程是不报错误的，同时运行过程中也没有任何的错误消息产生的，当我们看到输出结果时，我们会发现其结果为： 1-128 &emsp;&emsp;现在我们可以考虑一下为什么会是这个结果，在介绍原码、反码与补码的章节中，我们提到了正0和负0的问题，即00000000和10000000的问题，我们人为地将10000000所代表的数定为-128。首先我们将127转换为2进制表示方法，其结果为01111111，现在我们在此基础上加1，我们会发现通过进位后其结果成为10000000，而这个数字刚好是-128。 &emsp;&emsp;反过来思考，如果我们首先将num赋值为-128，然后在此基础上减1，其结果会显示为127，也正如当初举的时钟的例子一般，正数最大值和负数最小值是相连的。分析过程是相似的，读者可以自行思考。 &emsp;&emsp;接下来我们将目光放置在无符号整数上，例如uint8，之前我们曾经介绍过，uint8的表示范围为0到255，那么同样在开发过程中赋越界的值时会编译错误，所以我们依旧关注的是运行过程中数据越界的问题，看如下的程序： 123var num uint8 = 255num = num + 1fmt.Println(num) &emsp;&emsp;可以分析得，按照上述最大值和最小值相连的规律，其输出结果为0，由于该整数是一个无符号整数，因此最高位参与了计数，所以255用二进制表示为11111111（8个1），我们在其基础上加1后，经过一系列的进位运算，其结果应该是100000000（1后面有8个0），但是uint8数据类型只得到了8个二进制位的空间，因此最高位（第9位）的数据溢出并舍弃，所以计算结果为： 00000000（8个0）也就是0。逆过程可以自行思考。 &emsp;&emsp;在应用过程中有一个十分常见的例子，便是字符的表示方式。如果表示ASCII码，byte型就可以完全存储了，但是如果想存储汉字，那么byte就会出现越界，需要用rune类型数据进行存储。当然，用rune类型来存储ASCII字符也是没有问题的，程序验证如下： 1var ch byte = '中' &emsp;&emsp;其编译过程中会出现错误，异常信息为：const 20013 overflows byte，由此看出，’中’这个字符在UTF-8编码中的数值为20013，这个数值明显超出了byte所存储的范围，因此会报错。 &emsp;&emsp;所以，在整数的定义与表示过程中，无论定义了空间多大的整数，都会出现数据溢出的可能，因为每个整数都有确定的数据表示范围。因此针对不同的数据范围需求来选择对应的数据类型是十分重要的，否则在程序运行中会出现意想不到的问题，而这个问题并不涉及任何的逻辑上的错误。比如说我们定义一个变量，令该变量每次都加1，一直加到该变量为500为止，如果我们使用了uint8类型，那么这个程序就永远也停不下来了，因为255后的值又回归到0了。当然我们也可以采用int64来存储，但是针对这个需求而言，int64又有些内存的浪费了（虽说现在基本上不缺这点内存），所以选择适合的数据类型来完成特定的工作是一件需要考虑乃至于优化的事情。 浮点型变量的细节讨论&emsp;&emsp;浮点型的存储过程中精度丢失一直都是一个无法回避的问题，这个问题在大规模的精确计算过程中十分的常见，精度丢失的问题甚至可能会导致逻辑上的问题。根据我们之前对数据类型的介绍，不论是float32还是float64类型的变量，其可表示范围都十分的广阔，同时我们也讲解了浮点型数据在内存中的存储方法，因此一般来说float32所能精确地表示小数位数为67位，而float64能表示为1516位，超出的精度部分往往就会丢失了，我们来看下面的一段程序： 1234var a float32 = 1.00000001var b float32 = 1.0000001fmt.Println(a)fmt.Println(b) &emsp;&emsp;在上述的一段程序中，我们为a和b两个变量分别赋值，并且在程序的最后输出这两个值。根据我们刚提及的精度丢失问题以及小数保留位数，我们会发现：最终的结果为a=1，b=1.0000001。可以说b的值的输出是正常的，但是a的值却产生了错误。其原因便是超出精度范围的数值被忽略了。如果我们依旧对于精度丢失所产生的问题不甚理解的话，那么我们可以再看一段代码： 1234var a float32 = 3.3333333var b float32 = 6.6666666var c float32 = a + bfmt.Println(c) &emsp;&emsp;可能令人大跌眼镜的是，这个运算结果也就是c的值为10，第一个例子中超出精度的部分被舍弃了，而在第二个例子中超出精度的部分就进了1位。这种问题既不可以被归结为编译的错误，也不可以归结为逻辑的错误，而是说这个错误出现的原因是由语言本身和机器本身所导致的。更确切地说是由浮点型数据的存储方法和二进制十进制对应关系所导致的。接下来我们从两个角度简要说明一下精度丢失的成因。 &emsp;&emsp;第一个成因便是进制转换时的精度丢失，在进制转换的那一小节中，我们抛出了一个问题，是否每一个有限的十进制数都有一个有限位数的二进制数相对应，我们对这个问题的解答是否定的。也就是说我们在用十进制数编程时，再用计算机转换成二进制码的时候，精度就已经丢失了一次了，这个丢失是内部原因导致的，也是基本无法避免的。 &emsp;&emsp;第二个成因便是浮点数的表示方法，按常理来说，一个有限位数的浮点型变量居然能表示那么大的范围，其精度必然是不会非常高的。我们在前几节介绍了浮点数的存储方式，即符号位、指数部分、和尾数部分。指数部分代表了科学计数法中的幂次，剩余的部分则表示在尾数部分，由于尾数部分也是有位数限制的，因此也会出现类似于整数一样的数据溢出问题的。因此太多的小数位数将溢出尾数部分，而保留的就是前几位未溢出的部分，因此在浮点数的存储方法中，会出现二次的精度损失。 &emsp;&emsp;那么一旦真的需要精度十分高的浮点型乃至于数值极为庞大的整数运算时，有一种解决办法便是利用字符串，字符串中的每一个字符值都是一个精确的数字。换句话说，利用字符串，在内存中所保存的是一系列的int8类型，每个int8对应于真值的每一位。同时Go语言开发者也向用户封装了基于字符串所表示的数据的数学运算函数，在需要时可以调用。详细源码可以研读Go语言中的math/big包。 &emsp;&emsp;利用字符串表示数据虽解决了数据存储与表示的问题，但是这种方式也有其特定的弊端。当我们利用int、float32等提供的数据类型进行运算操作时，系统在计算机底层予以其特殊的优化手段，使之计算速度有极大的提升。而利用字符串进行运算，则会拖慢运行速度，在一些已定义的函数中无法作为参数而不得已只好自行包装、改写函数。 &emsp;&emsp;不过话说来，浮点数精度丢失的问题一般不会影响到我们程序开发，在应用级的开发中往往不会用到8位小数之后，而且float64所提供的有效精度也足够使用了。但是在科学计算中，或在大规模的银行系统中，精度就会成为一个不得不慎重考虑的问题。曾经有一个生物信息专业的同学给我讲述过一个事情，在做DNA匹配计算过程中需要将各种的变异均考虑进去，并且得到的匹配结果十分的相似。此时问题就是，究竟是这两个DNA相同但是因为计算精度问题而显示成不同，还是说两种DNA真的是不同只是不同点比较少但是比较重要。 小结&emsp;&emsp;在这一小节中，我们主要讲述了Go语言中整数和浮点数使用注意事项，集中说明了整数中的数据溢出问题和浮点型数据中的精度丢失问题。这两个问题在计算机语言中是普遍存在的问题，不仅仅是Go语言中单独的问题。这两种问题在日常开发中几乎不会遇到，但是在实际工作中一旦出现了某种周期性问题或没有明显逻辑错误的问题时，这两个原因不失为一种考虑方向。 &emsp;&emsp;在下一节中，我们将针对于剩下的几种基本数据类型进行精讲，同时也将讲解在开发过程中可能出现的问题及原因。","categories":[],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"}]},{"title":"Go语言从入门到放弃系列<9> 标识符、输出及转义字符","slug":"9-标识符，输出及转义字符","date":"2020-02-12T06:34:31.000Z","updated":"2020-02-12T06:36:05.588Z","comments":true,"path":"2020/02/12/9-标识符，输出及转义字符/","link":"","permalink":"http://yoursite.com/2020/02/12/9-%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%8C%E8%BE%93%E5%87%BA%E5%8F%8A%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/","excerpt":"","text":"Go语言从入门到放弃系列&lt;9&gt; 标识符、输出及转义字符&emsp;&emsp;在上一小节中，我们集中介绍了变量的定义、变量的使用过程、初始化过程以及多变量的赋值。同时，我们也验证了每种基本数据类型的初始值的设定。在这一节中，我们将分别介绍Go语言中标识符的概念、合法性以及两个输出函数的使用方式，最后将对（字符型）数据中的转义字符进行介绍。 标识符&emsp;&emsp;在上一节中我们介绍变量的时候提到了变量名，严格来说变量名就是一种标识符，标识符不仅仅针对于变量名，而是变量、方法、函数等命名时所使用的字符序列，均称之为标识符。简而言之便是：程序中但凡需要自己取的名字就是标识符。 标识符命名规则&emsp;&emsp;同其他的编程语言相似，Go语言中的标识符的规则也是可以由三部分构成：字母、数字、下划线，且不能以数字开头。在Go语言中，变量也是大小写敏感的，换句话说就是大写字母构成的标识符和同样字母但是小写所构成的标识符是不同的。既然标识符只能通过这三种字符构成，其他的如空格、回车、美元符号等都是非法的。我们举一些例子： 12345var hello int //合法var hello123 int //合法var Hello int //合法，且与hello是不同的var is_adult bool //合法var 1hello int //不合法，数字不可以开头 &emsp;&emsp;其中需要说明的是，只由一个下划线所构成的标识符（’_’）是具备特殊含义的，在Go语言中称之为空标识符，其可以代表任何一个标识符，其中的值也是被忽略的。一个经典的例子便是，在Go语言中一些函数的返回值可能有多个，我们在使用的时候可能只希望获得其中的一个或忽略其中的某些，就可以通过下划线标识符来接收，这样程序不会因为返回值数量不匹配而报错，也不会因为定义了变量但没有使用而报错。举例如下（涉及函数知识，可后期再理解）： 1234567891011121314package mainimport \"fmt\"func getMaxAndMin(num1 int, num2 int) (int, int) &#123; if num1 &gt;= num2 &#123; return num1, num2 &#125; else &#123; return num2, num1 &#125;&#125;func main() &#123; a, b := 10, 20 c, _ := getMaxAndMin(a, b) fmt.Println(c)&#125; &emsp;&emsp;假设getMaxAndMin函数是其他人所实现的函数，我们无法去修改其内容，并且其中会返回最大值和最小值两个数，而我们只希望使用最大值而忽略掉最小值，就可以用’_‘来接收最小值并将其抛弃。那么问题来了，在上述的程序中我们能否输出’_‘以查看其中的值呢，答案是不能，报错的信息就是”不能把_视为一个值”。 &emsp;&emsp;除此之外，在为标识符取名的时候，还存在一些限制，即不能以系统保留的关键字作为表示符，如break、if、import、func等等。我们将会在下表中列举出系统保留的关键字： if else switch case default break continue package import func for goto select interface defer go map struct chan const fallthrough range type return var &emsp;&emsp;上述提到的25个系统保留的关键字是绝对不可以使用在标识符里的，这些关键字在我们当使用集成开发工具编程的时候会自动变色，以提醒开发者这些词是不可以使用的。这些关键字中暂时有好多我们都不曾见过，不过我们会在后续的小节中一一接触到。 &emsp;&emsp;除了25个系统保留的关键字以外，Go语言中还提供了36个预定的标识符，这些标识符包括了期初数据类型和系统内建函数。这个特性是其他编程语言中所没有的特性，这36个标识符如下： int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 byte rune uintptr float32 float64 complex64 complex128 string bool complex real append cap close copy false true imag iota len make new nil panic error recover &emsp;&emsp;在上述的表格中，我们依旧发现有好多我们都见过，并且在变量定义的时候也曾经用过。而且与一般编程语言所不同的是，这些标识符是可以被使用的。例如在Java语言中，int不可以被定义为标识符，但在Go语言中是可以的，换句话说 var int int 这条语句是成立的。但是，对于具备其他语言开发经验的开发者，这个用法是受到绝对抵制的，即便是编译器能正常运行。例如下面的这段程序，会对初学者产生极大的困惑和误导： 1234567package mainimport \"fmt\"func main() &#123; var byte int = 'A' var string, float32 = byte, byte fmt.Println(string + float32)&#125; &emsp;&emsp;输出结果是130，看起来各种的变量类型名都出现了一遍，但是其中只有一个数据类型：整型。所以这种用法十分不被推荐，如果哪个开发者以这种形式进行开发，这个人就很，，，不走寻常路。 输出函数&emsp;&emsp;在这里我们只是简要地讲解几个常用的基本的输出函数，分别为Print()函数、Println()函数、以及Printf()函数。这三个函数都在fmt包中，也就是说如果使用这三个函数，都需要引入fmt包。接下来我们分别对这三个函数进行简要的叙述： Print函数和Println函数 &emsp;&emsp;这两个函数的唯一区别便是输出的时候是否换行，当用Println函数的时候，函数将一个字符串输出之后会换到下一行，而Print函数则会接着当前的输出继续执行。例如： 12345fmt.Println(\"Hello \")fmt.Println(\"Devin\")输出结果为：HelloDevin &emsp;&emsp;而 1234fmt.Print(\"Hello \")fmt.Print(\"Devin\")输出结果为：Hello Devin &emsp;&emsp;在Println函数的括号中（Print函数相同），我们可以传入一些任何类型的变量，而不单单只能传入字符串。例如我们在打印多个信息的时候，我们可以将多个信息通过逗号的形式进行分割，并在输出的时候进行拼接，例如: 12345age :=25name := \"Devin\"fmt.Println(\"age is \", age , \" name is \" , name)输出结果为：age is 25 name is Devin &emsp;&emsp;也就是说在输出过程中我们将三个字符串类型和一个整数类型的变量传给Println函数，这个函数将所有的参数均转换成了字符串并且按传入的顺序输出。 Printf函数 &emsp;&emsp;Printf函数往往被称之为格式化输出函数，我们可以将希望输出的格式预先规定好，然后向这个格式中填入数据，而不需要像Println函数一样拼接那么多的字符串，那么多的变量。例如：我们希望输出的是age is ‘占位符’ name is ‘占位符’，然后我们再向这个模板中填入25和Devin，就可以输出为age is 25 name is Devin。 123fmt.Printf(\"age is %d name is %s\", age , name)其输出结果为：age is 25 name is Devin &emsp;&emsp;其中的%d和%s均为占位符，后面的age和name与这两个占位符分别对应，需要注意的是，后面的变量个数要与占位符的个数相同，且输入的数据类型要与占位符规定的数据类型相同，接触过C语言的开发者对这个应该十分的熟悉。 格式 含义 %% 输出一个% %d 以十进制形式输出一个整数 %b 以二进制形式输出一个整数 %o 以八进制形式输出一个整数 %x(X) 以十六进制形式输出一个整数且用小写字母（大写字母）表示 %c 以字符形式输出一个整数（字符与整数一一对应） %f 输出一个浮点型数据（float32和float64均可使用） %t 以true或者false形式输出一个布尔值 %T 输出对应的变量的数据类型 %v 自动识别输出类型并输出（会把byte和rune识别成为整数形式） &emsp;&emsp;以上的这些就是常用的在输出的过程中使用到的占位符，在Printf函数中会经常使用到。 转义字符&emsp;&emsp;这个小知识点我之前在写Java的时候将其写在了字符型数据的讲解中，但是在Go语言中没有这个数据类型，但是放在字符串中又不太合适，就单独写在这里了，转义字符的个数十分地多，我在这里也不一一罗列了，在实际使用的过程中慢慢积累，而且在网络中搜索转义字符也有许多的列表。 &emsp;&emsp;之前我们说起过计算机中的英文相关的字符可以用一个byte数据类型所存储，我们接触到的也一般都是字母、数字、格式的标点符号等这些能够通过键盘所打出来的字符，然而还有许多的字符是键盘打不出来的，比如说我们希望在一个字符串中存储一个换行的字符（也就是回车），当打印这个字符串时，遇到这个换行字符时自动到下一行输出。而当我们在编程的时候，按下回车键后光标就到了下一行了，字符串中并不能保存这个换行的字符。 &emsp;&emsp;再举一个例子便是，当我们在输出的时候希望输出的内容具有一些格式，使输出更为规范、有序。其中一个方法就是使用制表符（也就是Tab键），但是当我们编程的时候按下tab键，就直接将源代码向后空出制表间隔了，字符串中依旧没有存下来。因此，我们需要转义字符。 &emsp;&emsp;转义字符也是一种字符，我们通过键盘可以打出来的字符通过转义的形式，使其代表那些键盘打不出来的字符。转义的方式为’\\字符’，例如’\\n’，’\\t’、’\\0’,也就是’\\‘这个字符可以将它后面的这个字符合起来共同表示一个其他的含义，比如’\\n’代表回车，’\\t’代表制表符，’\\0’代表字符串的结尾。它们不是两个字符而是一个字符，那么当我们真的就希望输出一个\\该如何去做，如果单单输出一个\\，它会和后面的字符进行转义，因此，我们想输出\\的时候，我们依旧需要将其转义，使用’\\\\‘（直接复制markdown的话会出现四个\\，因为markdown中也要转义），其意思为第一个\\表示后面的要转义了，第二个\\表示转义后的字符就想输出为\\。 12info := \"Hello World \\nI am \\t\\t Devin\"fmt.Println(info) &emsp;&emsp;其输出结果为： &emsp;&emsp;Hello World后有回车，am和Devin中间有两个水平制表符。 小结&emsp;&emsp;在这一小节中，我们集中讲述了Go语言的标识符的概念，以及标识符的命名规则，系统定义的关键字的内容以及保留标识符的内容。同时我们也集中介绍了两种输出的形式，在后续的代码中会经常使用到的两种输出形式。最后我们介绍了转义字符的引出和概念，也提到了几个常用的转义字符，转义字符需要在平时进行慢慢地积累。 &emsp;&emsp;在之后的几个小节中，我们将针对不同的基本数据类型进行精讲，集中说明在使用这些数据的时候需要注意到的问题，以及出现问题的内部的原因以和解决方案等。","categories":[],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"}]},{"title":"Go语言从入门到放弃系列<8> 变量的定义及使用","slug":"8-变量的定义及使用","date":"2020-02-11T04:22:18.000Z","updated":"2020-02-12T06:37:11.049Z","comments":true,"path":"2020/02/11/8-变量的定义及使用/","link":"","permalink":"http://yoursite.com/2020/02/11/8-%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Go语言从入门到放弃系列&lt;8&gt; 变量的定义及使用&emsp;&emsp;在上一小节中，我们集中说明了数据在内存中的存储形式，以及Go语言的各个基本数据类型、所分配的字节数、以及其可以表示的数据范围的大小。在这一节中，我们将使用之前说到的数据类型，结合变量的概念，讲述程序中的变量以及需要注意的地方。 变量&emsp;&emsp;首先我们需要解释一下什么是变量，变量来源于数学，是计算机语言中存储计算结果或能表示值得抽象概念。根据字面的理解为可以变化的量，在生活中也具备许多的常用的例子，比如说人的年龄会随着时间而变化，日期会随着月份周期性变化。在计算机中，一个变量的值也可以发生变化。可以发生变化的值为变量，不能发生变化的值为常量，如圆周率等。 &emsp;&emsp;一般来说，在计算机语言中，每个变量都存在一个名字，这个名字与这个变量在一定的空间内是一一对应的。也就是说，程序开发者可以通过该名字来访问该变量的值，也可以通过名字来修改该变量的值。我们可以将其比喻为一间屋子，且每间屋子中都只能有一个人，屋子为变量本身，屋子中的人为变量的值，屋子的门牌号为变量的名字。 变量使用的基本步骤&emsp;&emsp;一般来说，变量的使用可以分为三个步骤，分别为：变量的定义、变量的赋值、变量的使用。在这里，我们将通过几个例子分别对着三个过程进行简要的阐述。 1. 变量的定义（变量的声明）&emsp;&emsp;在这个阶段中，我们需要首先做的是确定这个变量的类型。比如说，如果我们希望存储的是一个人的年龄，我们当然会选择使用整数来存储，如果我们希望存储的是一个人的成绩或工资，那么我们将会采用浮点数的形式来存储。如果我们使用了错误的数据类型，我们可能将会面临因为精度丢失而导致的计算结果错误的风险，乃至于程序编译时发生编译错误。 &emsp;&emsp;基本数据类型的变量的定义基本满足于一个公式：var 变量名 数据类型，我们举一些例子： 12345var name string //定义一个字符串用来存姓名var age int32 //定义一个整数用来存年龄var salary float32 //定义一个浮点型用来存工资var character byte //定义一个整型（字符型）用来存字符var isAdult bool //定义一个布尔值用来存是否成年 &emsp;&emsp;那么在数据定义过程中会内存中发生什么变化，在程序执行到定义这一行的时候，内存会分配给这个变量名一段连续的空间，空间的大小根据数据类型而定。在这段内存空间中存在一个初始的值，我们称之为零值，不同的数据类型的零值不同，我们会稍后列出。 2.变量的赋值&emsp;&emsp;在变量定义过后，即内存中已然出现了连续的空间后，我们便可以为之填充新的数值，这个过程可称之为赋值。由于变量中本身存在于一个零值，而赋值过后新的值将会代替原来的零值，因此在变量的多次赋值时，后一次的值将会覆盖掉原来的值，而保留的是最后一次修改后的值。依旧用房间打比方，我们为这个房间分配新的住户时，原来的住户需要搬离。变量的赋值过程如下（采用上述的数据的定义）: 12345name = \"Devin\"age = 25slary = 1234.5chracter = 'A'isAdult = true &emsp;&emsp;这里需要注意的一点是，在Go语言中，数据类型的区别是十分严格的，在一些编程语言中存在着数据类型的隐式转换与显式转换，例如，可以利用‘+’将整数转为字符串，而在Go中是不允许的。 3.变量的使用&emsp;&emsp;变量的使用便不需要多做描述了，如何去使用这个变量也很难穷尽，不论是进行再赋值操作还是参与数学运算都是可以的。我们便举一个完整的例子表明变量的使用的全部过程。 1234567package mainimport \"fmt\"func main()&#123; var age int //变量的定义 age = 25 //变量的赋值 fmt.Println(age) //变量的使用&#125; 4.变量的初始化&emsp;&emsp;在上述的过程中，我们会发现变量的使用都要通过定义、赋值后才能进行使用，我们可能会觉得这个操作十分的麻烦，因此变量的初始化可以将变量的定义与赋值过程结合在一起，这样就会十分简便了。初始化的定义也是在变量定义时直接给与赋值操作。 123var age int = 25var name string = \"Devin\"var isAdult bool = true 变量使用中的注意事项及细节1.类型自动推导&emsp;&emsp;在上述的讲解中，我们提到了：数据定义过程中需要明确这个变量的数据类型，之后再进行其他的操作，但是在变量的初始化过程中其实已经出现了数据类型。因此，Go语言底层有一种机制，即根据用户所输入的值自动推导这个值得数据类型，例如： 1234var age = 25var name = \"Devin\"var isAdult = truevar salary = 1000.0 &emsp;&emsp;即相比于初始化过程，略去了数据类型定义的部分。在上述的例子中，Go语言底层会将age的类型自动识别为整数（int类型），name识别为字符串（string类型），isAdult识别为布尔值（bool类型），salary识别为浮点型（float64类型）。在这里需要注意的是浮点型的自动类型推导，我们需要在后面加入小数点，否则将会被推导成为整数。 &emsp;&emsp;在自动推导的定义过程中，我们会发现，几乎每个定义都有一个var的关键字，因此这个关键字也是可以省略的，不过如果仅仅是这样就会与变量的赋值相混淆了，因此在省略var关键字且初始化数据时，需要采用:=的方式进行定义，上述的程序可以改为： 1234age := 25name := \"Devin\"isAdult := truesalary := 1000.0 &emsp;&emsp;使用变量的定义时，有一个需要注意的地方，即定义的变量名在相同的作用域中是不应该被定义过的，否则将会出现重定义，导致编译过程的错误（作用域的概念在后期会介绍到）。这一点在使用自动类型推导时容易出现错误。 2.多变量的声明&emsp;&emsp;当我们需要定义多个同类型的数据时，比如说我们需要存储一个人的学号、姓名、住址等几个字符串信息时，我们当然可以分为多行进行定义，每一行定义一个数据，我们也可以在一行中将同样数据类型的变量同时定义，例如： 1234var name, id, address string //一行中定义三个字符串变量name = \"Devin\" //分别使用id = \"123456\"address = \"Liaoning Province\" &emsp;&emsp;我们也可以采用初始化的形式，在一行中定义后直接使用： 1var name, id, address string = \"Devin\", \"123456\", \"Liaoning Province\" &emsp;&emsp;甚至直接类型推导: 12var name, id, address = \"Devin\", \"123456\", \"Liaoning Province\"name, id, address := \"Devin\", \"123456\", \"Liaoning Province\" &emsp;&emsp;多个不同的数据类型的定义中，我们也可以采用小括号的形式进行定义以及初始化，例如： 1234567891011var ( age int = 25 name string = \"Devin\" isAdult = true) 或者var ( age = 25 name = \"Devin\" isAdult = true) &emsp;&emsp;需要说明的一点是，在数据类型的自动推导过程中，可以不限制于同样的数据类型，不同的数据类型也是可以在同一行定义推导的，不过这种用法相对来说比较奇怪，习惯于传统语言开发的开发者可能会觉得相对不习惯： 1name, age, isAdult := \"Devin\", 25, true //自动推导name为string，age为int，isAdult为bool 3.基本数据类型的零值&emsp;&emsp;在这里我们将介绍Go语言中基本数据类型的零值。在一些编程语言中，为数据定义但不进行赋值是一种危险的行为，其值可以是一个没有意义的值。为了防止这种现象的发生，Go语言中明确定义了各种基本数据类型的零值。在一些开发过程中，有些人可能会利用零值的数值进行部分代码的省略，比如定义一个整数并为这个整数赋值为0。然而整数的零值就是0，所以一些开发者便只定义而不赋值，但是这种做法不是很推荐。 &emsp;&emsp;为了表明各个基本数据类型的零值，我们便采用下方的程序进行简单的验证： 1234567891011package mainimport \"fmt\"func main() &#123; var a int var b float32 var c string var d byte var e bool var f complex64 fmt.Println(\"a=\", a, \" b=\", b, \" c= \", c, \" d= \", d, \" e = \", e, \" f= \", f)&#125; &emsp;&emsp;其结果分别为： &emsp;&emsp;从中可知，整数的零值为0，浮点型的零值也为0，字符串的零值为空串（即””），字符型（整型）为0， 布尔值的零值为false，复数的零值为（0+0i）。 小结&emsp;&emsp;在这一小节中，我们集中介绍了变量的定义以及使用的过程，即定义、赋值、使用。同时我们也介绍了变量的初始化、自动推导类型等简便的使用方式。除此之外，我们也讲述了变量定义中的一些细节，如多变量的声明，以及各个基本数据类型的零值。在接下的几节中，我们将针对不同的数据类型进行更为详细的讲解，以及各个基本数据类型的互相转换等。","categories":[],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"}]},{"title":"Go语言从入门到放弃系列<7> 数据与数据的存储<二>","slug":"7-数据与数据存储二","date":"2020-02-10T03:37:57.000Z","updated":"2020-02-10T03:39:10.903Z","comments":true,"path":"2020/02/10/7-数据与数据存储二/","link":"","permalink":"http://yoursite.com/2020/02/10/7-%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BA%8C/","excerpt":"","text":"Go语言从入门到放弃系列&lt;7&gt; 数据与数据的存储&lt;二&gt;&emsp;&emsp;在上一节集中介绍了二进制的原码，反码和补码之后，我们在这一章简要地介绍一下Go语言中的基本数据类型，简单地列举一下几个基本数据类型所能存储的数字范围，并对数据范围的大小作出讲解。 Go语言中的基本数据类型（计算机内存进制）&emsp;&emsp;在介绍数据类型之前，我们首先介绍计算机中的几个表示内存的单位，分别为：bit、byte、kb、mb、gb等等。在bit和byte转换规则中存在一个等式：1byte=8bit，换句话说1个字节的长度等于8个二进制位的长度。而在bit和kb之间、kb和mb之间的进率这个现在很难讲。从我接触到计算机开始，我所学到的进制表示法始终是1kb=1024bit，也就是进制为1024，不过近来我在网上查资料的时候，发现了一种进制表示是1kb=1000bit，而且这两种表示方法均存在，在不同的计算机系统中（如Windows和Mac）也是不同的。此时此刻我依旧为这个问题而感到费解，因此这个进制我不做说明，希望读者自行去查找。 整型&emsp;&emsp;正如我们所理解的一般，整型所代表的就是计算机存储的整数，是不具备小数位的数字。根据不同的定义，整数可以分为有符号整型以及无符号整型。根据上个小节对码制的介绍，有符号整数的最高位代表符号位，并且负数的表示方式为补码方式。而对于无符号整数来说，其最高位表示的是数字中的一部分，不代表符号，是计入数字的计数的，同时因为其无符号的特性，该值永远是正值。下表将列出Go语言中整数的定义方式，以及其分配的bit空间和可表示的范围： 类型名称 是否有符号 分配的bit数 可表示范围 int8 有 8 -128到127 int16 有 16 -32768到32767 int32 有 32 -2^31到2^31-1 int64 有 64 -2^63到2^63-1 uint8 无 8 0到255 uint16 无 16 0到65535 uint32 无 32 0到2^32-1 uint64 无 64 0到2^64-1 int 有 与CPU位数相关 与CPU位数相关 uint 无 与CPU位数相关 与CPU位数相关 rune 有 与int32等价 暂不做介绍 byte 无 与uint8等价 暂不做介绍 uintptr 无 - - &emsp;&emsp;其中需要说明的是，int和uint整形变量分配的位数，这个是与CPU位数相关，如果计算机的CPU位数是32位，则为之分配32个bit位，即4个字节的空间。如果计算机CPU位数是64位，则为之分配64个bit位，即8个字节的空间。至于rune以及byte我们会在字符部分为之说明。 &emsp;&emsp;uintptr是一种无符号的整数，没有指定具体大小，但是足以容纳指针，一般来说是内存地址的哈希值，关于指针我们会在后续介绍到。uintptr类型一般用在底层编程中，在我们入门级别的学习中往往并不常见，在GO语言与C语言函数库的对接以及与操作系统底层硬件交互时才会经常用到。 浮点型&emsp;&emsp;浮点数在计算机中可以被理解为小数，Go语言提供了两种不同精度的小数，分别为float32以及float64，它们的定义符合IEEE754规范的定义，与整数的表示方式不同。这个规范是被现有的所有的各式CPU所支持。根据定义可以看出，float32的浮点数被分配的空间是32个二进制位，float64则分配64个二进制位。 &emsp;&emsp;那么我们可能会思考，一个整数，即便是64个二进制位，也不过是1.8*10^19（大约）这么大的数字。对于一个小数而言，既有整数部分，也有小数部分，其表示的数字范围岂不是小的可怜。为了防止出现这个结果，浮点数的存储方式与整数的存储方式是截然不同的。 &emsp;&emsp;一个浮点数可以被分为三个部分，我们以32位浮点数为例，其第一部分为最高位，也就是符号位，同整数相同，0代表正数，1代表负数。第二部分为指数位，被分配8个二进制位并通过移码后专门表示指数。最后剩下23位是第三部分，为尾数部分，这部分将代表这个小数以科学计数法表示后的整数部分。对于float64而言，则是1位的符号位，11位的指数部分，和52位的尾数部分。 &emsp;&emsp;我们举一个例子，十进制的135.5这个数字用二进制来表示为:1000 0111.1，我们采用二进制的科学计数法为：1.00001111*2^7，首先我们知道，这个数字为正数，因此符号位为0。然后指数部分采用移码的形式，即32位小数用127移，64位小数用1023移，所以7+127=134，将134化成二进制为：10000110，最后是尾数部分，由于科学计数法表示后，整数位一定是1，因此这个位可以被忽略掉，只表示00001111即可，在后面补充0，直到23位，所以结果如下： 符号位 指数部分 尾数部分 0 10000110 00001111000000000000000 &emsp;&emsp;因此，这个数字在内存中表示为：01000011000001111000000000000000(图片来自于binaryconvert) &emsp;&emsp;通过这种存储方式，浮点数可以表示的范围就会极大了，粗略来说，float32表示范围可为：-3.4*10^38到3.4*10^38，对于float64而言，其范围可以是：-1.79*10^308到1.79*10^308。 复数&emsp;&emsp;Go语言支持对复数的定义，同样也具备两种精度的复数类型，分别为complex64和complex128，正如我们所了解的，复数一般是由实部和虚部构成，因此这两种复数类型的实部和虚部分别相对应float32和float64。一般来说，复数的使用在应用开发中很少会出现，在数学计算中可能会得到应用。在此不做详细的说明了。 布尔型&emsp;&emsp;布尔值一般代表逻辑值，一般来说只有真或假，所对应的值为true或false。在程序中分支控制和循环控制中往往会用到布尔值。布尔值可以通过“与或非”三种逻辑进行运算，但是并不参与数学运算。在有些开发语言中，true可以表示为1，而false可以表示为0，这两种值可以被替换为整数进行数学运算。而在Go语言开发中，这个是不成立的，因此不能参与数学运算。布尔值的具体用法我们将会在分支结构中更为详细地讲述。 （字符型）&emsp;&emsp;这个字符型为什么会打了一个括号，是因为这个数据类型在Go语言中不存在，不过在其他语言中是存在的，对于后面字符串的引出也是即为重要的，因此单独做出介绍。在前面我们介绍编码的时候就提及过，最初的计算机只能应用在英语的环境中，而大小写英文字母的数量加一些转义字符的数量也不超过256个。因此最初字符是可以通过一个8位的整数来表示，这便是我们在介绍整数的时候byte的用法。 &emsp;&emsp;在后面计算机到了各国之后，不同国家开始应用各个国家的字符集，例如中国汉字，其个数就远超了256个，因此一个byte的空间就没有办法进行存储汉字了，而UTF-8编码格式又融入了所有国家的所有的字符编码，于是就需要寻找容量更大的存储方式，在Go语言中我们采用int32的数据类型来存储汉字，为了区分字符与整数的表示方式，我们采用rune的方式表示。 &emsp;&emsp;虽说字符一般采用byte和rune的方式进行定义与表示，其核心本质依旧是uint8和int32，所以说Go语言中不存在字符型的变量，传统的字符型都用整数来表示了。 字符串&emsp;&emsp;在其他的编程语言中，往往会把字符串作为复杂数据类型来划分，但是字符串同时在编程中应用地十分地普遍，因此Go语言便也把它划分在基础数据类型中。字符串是一个不可改变的字节序列，可以理解为多个字符拼接而成的常量，用双引号所包含（如入门程序中的”Hello World”）。字符串可以包含任何的数据，文本字符串通常会表示为UTF-8编码的rune序列。在这里只是提一句字符串的概念，在后续学习中，我们会针对于字符串及其自带的函数做出详细地讲解。 小结&emsp;&emsp;在这两个小节中，我们集中介绍了数据的存储形式，介绍了原码，反码和补码。并通过对这三种码制引出了Go语言的基本数据类型，这几种类型将会在下几小节中详细地叙述。在下一节中，我们将会主要介绍变量与常量的概念，命名规则以及针对基本数据类型定义过程的一些例子。","categories":[],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"}]},{"title":"Go语言从入门到放弃系列<6> 数据与数据的存储<一>","slug":"6-数据与数据存储一","date":"2020-02-09T06:29:44.000Z","updated":"2020-02-09T06:30:58.284Z","comments":true,"path":"2020/02/09/6-数据与数据存储一/","link":"","permalink":"http://yoursite.com/2020/02/09/6-%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%80/","excerpt":"","text":"Go语言从入门到放弃系列&lt;6&gt; 数据与数据的存储&lt;一&gt;&emsp;&emsp;在上一个小节中，我们集中说明了一些二进制相关的事，介绍了不同进制之间的转换规律以及该规律的原理，并对二进制有了最基本的认识。那么在这个小节中，我们将基于二进制的知识，引出基本数据类型的存储格式，介绍到原码，反码和补码的知识，进而对Go语言的数据类型进行简要的引出。 原码，反码，和补码&emsp;&emsp;我们回顾一下自己对数字的认识过程，相信大多数人都经历了如下的过程。在很小的时候只知道正数，然后到了初中开始接触负数，之后再考虑到0这个特殊的数字。那么我们就暂时遵循这个过程，对这几种码制作出阐述。可以说，大家对于正数的了解是普遍的，日常生活中也经常会出现与正数打交道的情况。那么对于正数，计算机是如何存储的呢。 原码&emsp;&emsp;读过上一个小节的人们可能会直接想到，无非就是把十进制的正数转换成二进制的数而已，这个想法是正确的，只不过是在现有的想法上加上一个符号位，而这个符号位则是最高位，同时我们将符号位的0作为正数的标志，符号位的1就作为负数的标志，因此，对于106这个十进制正数而言，其带符号位的二进制数是： 101101010 &emsp;&emsp;最高位的0代表了正数。相信大家很容易接受这种表示方式，毕竟改变不是很大。当我们对正数做完阐述之后，我们可能会想到，既然如此，我们将符号位置1，其余的不变，就可以表示对应的负数了。确实这是一种表示方法，也就是我们今天所提及的原码方式。对于-106而言，其二进制数为： 111101010 &emsp;&emsp;但是现在问题就来了，这种方式虽然存储起来很方便，但是对计算而言是极为的不利的。例如，我们每个人都知道的一个等式&nbsp;-1+1=0&nbsp;在计算机用原码表示来计算就会出现错误，我们列举一下计算过程，假设我们依旧用8位来表示每一个数字： 100000001+10000001=10000010 &emsp;&emsp;我们会发现结果是-2，而不是0。不仅如此，任何一个正数与一个负数相加，其结果都是负数，因为符号位的0+1=1。很显然，这种数制的表示方法并不能完成计算的任务，因此我们引进了反码。 反码&emsp;&emsp;正数的反码与原码是相同的，负数的反码则是符号位不变，其余的位数取反。比如说，对于-106而言，其反码为： 110010101 &emsp;&emsp;那么反码的好处在哪里呢，我们依旧回到-1+1=0的问题上，根据我们上述所说，-1的反码为：11111110，+1的反码为：00000001，那么两个数字相加，我们会得到11111111，对此结果我们再取反码，得到了10000000，换算成十进制为-0，其计算结果是可以接受的，但是现在我们依旧存在一个问题，即+0与-0的问题。 &emsp;&emsp;不仅如此，即便是在一次计算中真值部分得到了正确的结果，但涉及到中途结果为-0的时候，就又一次出现了问题，我们举一个简单的例子，我们都知道，-1+1+1=1，那么我们采用反码的形式再一次做出计算： 111111110+00000001+00000001=100000000 &emsp;&emsp;在计算之前，我们首先假定了由8位构成一个数字，那么计算结果应该也是由8位构成，但是我们的到的结果是9位，因此计算机选择的是忽略掉溢出的位置，因此结果为00000000，也就是我们所说的10进制的0。这个结果显然是不能接受的，而导致这个不可接受的结果的原因则是这个-0的参与运算。因此，单纯地采用补码来运算依旧不是一个很好的方法，接下来，我我们将对补码进行简要地介绍。 补码&emsp;&emsp;首先，我们需要对补码有一个相对直观的认识，举一个很常见的例子，就是我们平日生活中的钟表。我们假设时针指向12的时候为0点，时针顺时针为正，逆时针为负，并且以时针指向6为分界，即小于6的时候为正值，大于6点为负值。同时我们采用上一章节所提及的“模”的概念，即在时钟的周期中模为12。 &emsp;&emsp;现在我们转换一下思想，在上述情况下所说的-1点，就是平时我们称的11点，同时上述情况下所称的1点依旧是平时我们所想的1点，这便是补码的一种直观的思想。即负数可以表示为：周期的模减去该负数的绝对值，比如说：-1点即11点。 112-abs(-1)=11 &emsp;&emsp;那么现在我们回过头来看一下-3用补码是怎样表示的，首先我们依旧假设用8位来表示一个数字，那么8个二进制位所能表示的数字的模是多少。十进制的模是十，是个位为0同时其高位为1，那么8个二进制位的模当然就是八个位都是0，而其高位（借来的第九位）为1：100000000。同时，-3的绝对值是3，其二进制表示方法为：00000011。现在我们将其相减，得到的-3的补码是： 111111101 &emsp;&emsp;现在我们对-3的补码和-3的原码进行对比，并从中寻找一个转换的规律。我们说，-3的原码为：10000011，-3的补码为：11111101，我们可以发现，补码的转换规则为：正数的补码是原码本身，负数的补码是，符号位不变，从右向左找到第一个1不变，这个1向左的各位取反。 &emsp;&emsp;再一次回到-1+1+1的问题上，我们知道-1的表示方法为：模-1，那么-1+1便是：模-1+1=模。根据上述的说明，模的表示方法为：各个位数为0，高位为1，而高位在计算中会溢出而不做计算，因此结果为0，这个+0再加上任何的数字就是正常的数字了。现在我们已然解决了正0的问题，那么原来的-0究竟表示了什么呢。 &emsp;&emsp;通过上述的描述，我们知道了负数的表示方法，那么我们可以这样来想，模减去某个负数的绝对值等于了“-0”，因此这个“某个负数”的绝对值便是模的大小，取负数之后便是其可以表示的数。因此，原来的-0即表示了-模长。 小结&emsp;&emsp;在本节中，我们集中介绍了计算机存储数据的方法，即原码、反码、和补码的概念，并分别阐述了这三种表示方式的来由。在下一小节中，我们将介绍数据类型的概念，计算机内存中如何表示整数、小数、字符等等，并对其可表示范围作出讲解。","categories":[],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"}]},{"title":"Go语言从入门到放弃系列<5> 二进制浅谈","slug":"5-二进制浅谈","date":"2020-02-08T03:48:41.000Z","updated":"2020-02-08T03:49:47.074Z","comments":true,"path":"2020/02/08/5-二进制浅谈/","link":"","permalink":"http://yoursite.com/2020/02/08/5-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%85%E8%B0%88/","excerpt":"","text":"Go语言从入门到放弃系列&lt;5&gt; 二进制浅谈&emsp;&emsp;在上一个小节中，我们集中阐述了Go语言的一些命令，并对其中的几个常用命令进行讲解，在这一小节中，我们将对进制的概念进行阐述，并且对进制之间的相互转换进行详细地说明。 二进制&emsp;&emsp;说起进制，大家似乎都不陌生，因为我们每天都在以十进制的形式计数，那么什么是十进制呢，便是逢十进一。换句话说，在十进制数中每一个位都可以存放十种不同的数字，分别为0到9，当当前的数字为9的时候，再向上加1，就需要向更高的位进1，而自身的数字归零。在这里，我们也可以称这种计数单位的模为10。 &emsp;&emsp;如果我们沿用上述的方式，换一种思路，将逢十进一的概念转变为逢二进一，似乎二进制的概念就会比较好理解了。在十进制中，每个位都可以有10种数字，在二进制中，每个位只有两种形式，分别为0和1。在当前位为1的时候再加1，便向更高位进1，自身的数字归零。这便是二进制的计数方式。 &emsp;&emsp;为什么计算机会采取二进制的形式用来表示数据，是因为二进制是世界上比较常见的一种进制方式，尽管我们我日常生活中并不常用。开关的闭合或开启、逻辑的真与假、电容器是否具有电势等，都是两种状态之间的互相转换。在数字电路中，高电平与低电平也代表两种不同的逻辑态。对于完全由电路构成的计算机而言，主要处理的便是逻辑运算，因此二进制当然也就再合适不过了。 二进制向十进制的转换&emsp;&emsp;虽说计算机非常喜欢二进制的计数方式，但是似乎人们并不喜欢，因为从小到大所接触到的都是十进制的世界，为了更好地理解数字的本质，我们需要了解不同进制之间的转换规则。同样地，我们先从十进制出发，例如我首先写下一个数字： 1123456 &emsp;&emsp;不出意外的话，每个人都能迅速地说出来这个数字是十二万三千四百五十六，那么为什么这个一串的字符就可以表示出这个数字呢，是因为这个结果是可以通过某种计算方式而得到： 1X=1*10^5+2*10^4+3*10^3+4*10^2+5*10^1+6*10^0 &emsp;&emsp;如果理解了上述的这个公式，那么对于二进制而言，我们仿照这个计算模式，将其迅速地转换为十进制的表达方式，例如如下的这个二进制数字： 111001010 &emsp;&emsp;其结果为： 1X=1*2^7+1*2^6+0*2^5+0*2^4+1*2^3+0*2^2+1*2^1+0*2^0=202 &emsp;&emsp;如果继续向下总结的话，我们可以得到一条规律，从任何进制向十进制的转换规律为：第i位的数字乘以模的i次幂的求和（i从0开始）。根据这个规则，我们就可以自行理解八进制和十六进制，乃至于其他进制向十进制转换的规则了。 十进制向二进制的转换&emsp;&emsp;在这个部分中，我们换一种方法来表示二进制向十进制转换过程，所举的例子依旧是上方提到的两个数字，我们可以分别表示为： 12123456=(((((1*10)+2)*10+3)*10+4)*10+5)*10+6202=(((((((1*2)+1)*2+0)*2+0)*2+1)*2+0)*2+1)*2+0 &emsp;&emsp;我们会发现这种表达方式和上述的表达方式的结果是一致的，那么我们为什么采用这种表述方式，是因为在这种表达方式中，我们可以很直观地理解如何从十进制转回到二进制中。如果我们将转回的过程看做上述过程的一个逆过程，答案就会很简单了。我们用两个未知数来表示上述表达式中的两个部分，我们会发现： 1202=X*2+Y （X，Y为整数） &emsp;&emsp;虽说这个二元一次方程具备很多的解，但是联合二进制的规定，我们会加一个条件，即Y&lt;2。这样，我们就会轻而易举地得出X为101，Y为0，也就是说，我们得到了二进制的最后一位。接下来，我们针对101进行分析： 1101=X*2+Y &emsp;&emsp;在这个方程中，我们可以得到X为50，Y为1，这样我们就得到了倒数第二位的数值，如果一直重复上述过程，我们将会得到二进制的最终结果。换句话说，十进制整数向二进制的转换规则为：该数字除以模数向下取整，取余数，最后将余数倒序输出，即为二进制数。这个规则同样也适用于十进制向任何一个进制转换的过程。 浮点数的进制转换&emsp;&emsp;说完整数的数制转换后，我们对浮点数（小数）的进制转换做出简要的说明。在说明之前，我们首先思考一个问题，根据上述的二进制转十进制的规则来看，对于一个有限位数的整数而言，是否每一个二进制数都有一个有限位数的十进制数相对应，是否每个十进制数都有一个有限位数的二进制数相对应。两个答案都是肯定的。那么对于小数而言，上述两句话还是否依旧成立？ &emsp;&emsp;我们以以下的这个二进制数为例： 10.1011 &emsp;&emsp;这个二进制数转换成十进制数是多少呢，根据刚刚所讲的计算规律，我们将之拓展，就会发现它可以通过这种方式来表示： 1X=1*2^(-1)+0*2^(-2)+1*2^(-3)+1*2^(-4)=0.6875 &emsp;&emsp;这种二进制小数向十进制小数的转换方式是非常容易的，可以说依旧遵循着第i位的值乘以模的i次幂的求和。那么对于小数而言，如何将这个小数转回到二进制的表示方式。现在我们首先假设二进制的每一位为Xi，那么对于上述的小数我们可以表示为： 10.6875=(X0)*2^(-1)+(X1)*2^(-2)+(X2)*2^(-3)+(X3)*2^(-4) &emsp;&emsp;接下来，我们在等式两边同时乘以2，我们即可以得到如下的结果： 11.375=(X0)+(X1)*2^(-1)+(X2)*2^(-2)+(X3)*2^(-3) &emsp;&emsp;那么对于上述这个等式进行分析，以及二进制的限制我们还可以知道X0、X1、X2、X3均小于2，并且只有X0可以代表整数位，我们便可以得到X0的值为1。接下来等式两边再同时减去X0的值，我们可以得到： 10.375=(X1)*2^(-1)+(X2)*2^(-2)+(X3)*2^(-3) &emsp;&emsp;重复上述的过程，我们可以得到： 10.75=(X1)+(X2)*2^(-1)+(X3)*2^(-2) &emsp;&emsp;因此，只有X1的值可以表示整数位的值，即X1的值为0，以此类推，我们最终是可以得到1011的值的。通过这个过程，我们可以得到这样的一个小数的转换规则：该小数乘以模，取整数位的值，顺序输出。 &emsp;&emsp;我们回到刚刚提出的那个问题，是否每一个有限位数的二进制小数都有一个有限位数的十进制小数向对应，这个结果是是的，根据本节提到的公式也可以得到这个结果。那么是否每一个有限位数的十进制小数都有一个有限位数的二进制小数相对应，这个结果是否定的，比如十进制中的0.1就无法用有限位数的二进制进行表示，它是一个无限的循环小数。计算机只能无限地去接近这个数，却永远也无法精确地达到这个小数的真值。其具体原因，我目前尚不能明确地说清楚，也希望大家可以考虑一下，相信在考虑的过程中会有一定的收获。 小结&emsp;&emsp;经过上述的一些讨论过后，我们集中说明了十进制与二进制的互相转化规律，将此推广，其他进制之间的转换规律也如出一辙，简而化之的记忆口诀就为除模取余，逆序排序，乘模取整，顺序输出。我们最后再用一张图片演示进制的过程。（图片转自网络） &emsp;&emsp;在下一个小节中，我们将介绍二进制表示数字的几种形式，原码，反码以及补码，通过对这三种码制的介绍，我们引出基本数据类型的概念，以及变量和常量的问题。","categories":[],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"}]},{"title":"Go语言从入门到放弃系列<4> 常用的Go命令","slug":"4-常用的Go命令","date":"2020-02-07T04:00:21.000Z","updated":"2020-02-07T04:06:28.580Z","comments":true,"path":"2020/02/07/4-常用的Go命令/","link":"","permalink":"http://yoursite.com/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Go语言从入门到放弃系列&lt;4&gt; 常用的Go命令&emsp;&emsp;在上一节中，我们集中对快速入门程序Hello World的编写做出了简要的讲解，同时对包的概念，引入的方式，主函数的执行流程做出基本的介绍。在这一节中，我们将对Go语言的中命令行的常用命令进行介绍。 &emsp;&emsp;相信许多初学者通过集成开发工具进行入门开发时，将两个go文件写在了同一个文件夹下，同时又都具备main函数，在用ide运行的时候报出了错误，我们从这个错误引入到今天的命令的介绍中。 解决办法&emsp;&emsp;在上一节中，我们提出了包的概念，并且说明了一个项目中只能存在一个main函数，而一般来说，ide的编译运行是以工程为基础。换句话讲，便是以文件夹为基础的编译。因此当开发工具检测到同一个文件夹中含有两个或多个main函数时，会报出主函数重定义的错误。 &emsp;&emsp;1. 第一个解决办法当然便是将不同的go文件分放在不同的文件夹下，这样使得每个文件夹即每个工程都可以单独地进行编译以及运行，不过对于初学者来说这种做法尚不甚方便，到目前为止乃至于之后一段时间内所写的Demo性质的程序往往都是以单个文件为基础的，因此这个方法对于目前来说不是很适用。 &emsp;&emsp;2. 第二个解决办法便是通过Go语言的命令行形式进行编译运行，就如同在前几节所提及的那样，通过控制台的cd命令进入到go文件所在的目录，然后运用go run命令进行运行，这种方式是以单个文件的方式进行编译的，因此不会报出重定义的错误。go语言的命令相对来说并不多，常用的也就更少了，我们会在下面着重讲述几个命令。 常用的Go命令&emsp;&emsp;如果在控制台直接输入go help命令，我们会发现系统提示了许多的可用命令，在这里便列一个表格，分别简单解释一下每个命令的含义。在后面我们也会针对其中的几个进行详细地讲解。 Go命令 含义 build 编译包和依赖 clean 移除对象文件 doc 显示包或者符号的文档 env 打印go的环境信息 bug 启动错误报告 fix 运行go tool fix fmt 运行gofmt进行格式化 generate 从processing source生成go文件 get 下载并安装包和依赖 install 编译并安装包和依赖 list 列出包 run 编译并运行go程序 test 运行测试 tool 运行go提供的工具 version 显示go的版本 vet 运行go tool vet build和run命令&emsp;&emsp;正如同其他的静态语言一般，Go语言也是需要先编译再运行的。编译过程产生可执行文件，如Windows中的exe文件，之后再运行该可执行文件。而go build命令就是用来编译的，并不是所有的go程序都会编译出可执行文件，其条件即为：go程序属于main包、main包中包含main函数。现在假如在test文件夹中只有一个TestDemo.go文件，我们通过命令行定位到该位置后，键入go build TestDemo.go后，结果将如下图所示： &emsp;&emsp;从上图我们可以发现，build命令会生成一个与go文件相同名的可执行文件，进而执行该文件可以得到输出结果。可是往往我们在实际开发中，并不希望生成的可执行文件与go文件是同名的，在另一些情况下多个go程序生成的名字是相同的时候，会覆盖旧版本的exe文件（在大工程中很容易出现）。因此我们希望在编译过程中将生成的结果修改名字，其命令为： go build -o 新名字 go文件。 &emsp;&emsp;而go run的方法则是将编译和运行两个步骤合并为一个步骤，因此我们在使用go run命令时，在当前的文件夹中或其他的位置是找不到可执行文件的生成的，这很适用于程序开发中的调试阶段，具体便不做演示了。 fmt以及doc命令&emsp;&emsp;在上一节中我们演示到一个问题，就是大括号的位置问题。同时，Go语言有一个特性，便是对格式的要求十分的严格。不同的开发者对这个特性的看法不一，不过也是需要遵守这个格式的。各个开发者的格式是统一的，便利于组合开发以及代码的清晰。go fmt命令便是格式化代码，将代码根据规定的格式进行调整。其格式为：go fmt xxx.go，这个也不做演示了，而且一般情况下也不要手动去调用，一般的集成开发工具都会自动帮助我们去调整。 &emsp;&emsp;doc命令是查看文档的命令，例如我们在使用fmt包的时候忘记了某个函数如何去写，或希望查到某个函数的具体含义，可能就会用到这个命令，其格式为:go doc package，在终端上就会显示这个包的文档。由于控制台的大小有限，一般来说直接go doc一个包会显示不全。不过我们可以使用go doc package.function来查具体的功能。 &emsp;&emsp;还有一个比较好的一点是，这个命令可以启动我们自己的文档服务器，比如说我们使用godoc -http=:10000(数字可以随意，不过需要大于1024)，之后打开一个浏览器，在网址栏中输入localhost:10000我们会发现出现了图形界面的帮助文档，可以离线地、更方便地查询信息。 get和install命令&emsp;&emsp;get命令也是十分常用的命令，我们可以通过这个命令来直接从网上下载第三方的包，调用方式为go get source。如果本地已经存有该文件，便会更新指定的代码和依赖，如果使用go语言操作redis数据库，下载并使用beego的web框架时等，会通过这个命令进行下载。 &emsp;&emsp;install命令与build命令十分的相像，其结果都是生成一个可执行程序，不同点便是生成的可执行文件的路径、名字、以及依赖包。这时我们需要在环境变量中配置GOBIN变量，这个变量的值便是GOPATH下的bin目录，在这里我们简要地演示一下。 &emsp;&emsp;那么install和build的区别具体可用如下的表格来表示: 区别 install build 生成可执行文件路径 在工作目录的bin目录下，或GOBIN下 当前目录下 可执行文件名 和源码所在的目录同名 与go文件同名，或-o设定 依赖包 在工作目录的pkg文件夹中 - 小结&emsp;&emsp;在这个小结中，我们初步解决了在Demo演示过程中出现的主函数重定义问题，以及介绍了一些Go语言中相对常用的几个命令。在下一小节中，我们将集中讲解进制相关的一些问题，进而在后续的文章中引出数据类型的概念以及其可以表示的大小的限制。","categories":[],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"}]},{"title":"Go语言从入门到放弃系列<3> 基于Hello World的几点讨论","slug":"3-基于HelloWorld的几点讨论","date":"2020-02-06T03:38:07.000Z","updated":"2020-02-06T03:40:23.015Z","comments":true,"path":"2020/02/06/3-基于HelloWorld的几点讨论/","link":"","permalink":"http://yoursite.com/2020/02/06/3-%E5%9F%BA%E4%BA%8EHelloWorld%E7%9A%84%E5%87%A0%E7%82%B9%E8%AE%A8%E8%AE%BA/","excerpt":"","text":"Go语言从入门到放弃系列&lt;3&gt; 基于Hello World的几点讨论&emsp;&emsp;在第一个小节中，我们阐述了Go语言环境的安装与配置，同时也写了一小段的程序来验证开发环境是否正确配置。那么在这一节中，我们集中针对于这段代码自上而下进行几点简要的讲解。 123456//Hello World的编写package mainimport \"fmt\"func main() &#123; fmt.Println(\"Hello World\")&#125; Go语言代码注释&emsp;&emsp;Go语言的注释风格依旧遵循了C语言的注释风格，即采用两个斜杠（//）对单行注释，同时也支持/*…*/的方式对代码块进行注释。一般来说，行注释更为通用，块注释主要是针对包的详细说明或者屏蔽更大的代码块而使用的。 &emsp;&emsp;注释的作用往往是为了标注某个变量、代码块、或者函数等的具体功能，以备后续维护时能够快速地理解代码的含义。因此在实际开发中，强烈建议每个包都具备一个注解，即package前的注解，这个注解会详细介绍此包、提供相应的包信息、注明作者引用等等。 &emsp;&emsp;处在注释中的语句是不执行的，同样地，在编译的过程中也不会参与编译的过程。因此，不必担心写太多的注释会令可执行文件增大。注释出现的位置也是十分地灵活，可以出现在某行中，也可以出现在某条语句的结尾，但不可以出现在某条语句的中间。 123456package mainimport \"fmt\"//注释可以出现在某行func main() &#123; //也可以出现在某语句的结尾 fmt.Println(\"您好世界\")&#125; Go语言的包&emsp;&emsp;同一些其他的语言一样，Go语言是以包package作为管理单位，如果针对于文件系统可以理解为以文件夹为管理单位。因此，每个Go文件都需要声明包，并且只能存在于一个包内。不仅如此，每个程序中都必须要有一个main包，如果没有main包是无法编译通过的。 &emsp;&emsp;在日后的开发过程中，package的名字当然可以不是main，但是具备main函数的go文件必须是main包，因此在开发中，尤其指多人的开发中，每个程序员负责自己的部分，便会以包的名字建立一个文件夹，只是不在其中写main函数，这个问题我们在后面的一些章节会再次提及。由于我们目前的开发均在一个文件中，不需要跨越文件编程，因此在习惯上暂且先都写package main即可。 包的引入&emsp;&emsp;在开发的过程中往往需要使用开发者所提供的函数，或者其他人的代码，这时就需要将这个包进行引入操作，所用的关键字为import。fmt包是我们接触到的第一个引用的包，这个包的作用是提供了许多的格式化输出的函数。当我们希望在屏幕上打印出某行汉字的时候，我们不需要了解其内部的过程，如何让屏幕的像素点亮起来，我们只需要知道调用该包的特定函数可以完成需求。当然，fmt包中不仅仅具备格式化输出的函数，随着学习的深入，我们将会接触到更多的包和相应的函数。 &emsp;&emsp;有时候在程序开发的过程中，我们可能不仅仅需要引用一个包，而是需要引入多个包。比如说，我希望生成一个随机数，并且采用当前时间为种子进行随机生成，最后将这个随机数打印在屏幕上（这个案例我们后续会讲到）。那么，我们可能需要多个包，生成随机数需要一个包，获取时间需要一个包，打印在屏幕上需要一个包，因此需要多个包的引入。引入的方式有两种，分别为：多个import关键字，一个import后加一个小括号，将包写于括号中。 123import \"fmt\"import \"math/rand\"import \"time\" 12345import ( \"fmt\" \"math/rand\" \"time\") 主函数及大括号&emsp;&emsp;每一个项目中都需要有一个主函数，注意这不是指每一个Go文件都有一个主函数。主函数作为程序的入口，往往会最先被执行（这个说法不好，后面会对这句话进行更正，初期可以先这样理解）。声明函数的关键字func即function的前四个字母，main为函数名，后面的括号为函数参数，大括号所包裹的代码即为函数体（在函数的章节中会详细讲）。程序便从大括号后的第一行开始执行，直到函数的结束。 &emsp;&emsp;与一些传统的编程语言相不同的是，Go语言语句后不需要以分号为结尾。同时，大括号的位置也不如C语言等那样灵活。Go语言的规定是：左大括号的位置一定需要是某个块定义的结尾，而不能单独另取一行，否则在编译时是无法通过的。 函数体&emsp;&emsp;在日后的计算机的学习中，我们将会接触到计算机程序的三大流程控制，分别为：顺序结构、分支结构、和循环结构。我们今天所接触到的便是其中的第一个：顺序结构。 &emsp;&emsp;顺序结构的核心思想是，程序从上至下逐条依次执行，每一条都会被执行，而且每条都会被执行一次。例如我们在程序中令其多次输出几个字符串，我们会发现结果的输出与程序中的输出顺序是相一致的。 1234567package mainimport \"fmt\"func main() &#123; fmt.Println(\"您好世界 1\") fmt.Println(\"您好世界 2\") fmt.Println(\"您好世界 3\")&#125; &emsp;&emsp;这段代码的输出结果为： 123您好世界 1您好世界 2您好世界 3 &emsp;&emsp;在我们后续讲到函数，并且提及defer关键字时，会对现有的理解的顺序结构产生冲击，这个问题我们在日后会详细地进行讲解。 &emsp;&emsp;在程序中，我们可以看到的是，函数的调用往往是需要包的存在的，也就是说Println函数是属于fmt包的，即便是自己定义的函数，也是属于当前的package的。如果不通过fmt包，就无法直接使用Println函数，也就无法通过这个函数向屏幕中输出了。还有一个需要注意的点是：当引入了某个包，但是这个包并没有在程序中被使用，也是不允许的。在编译过程中会报如下的错误： 小结&emsp;&emsp;在这个小节中，我们针对快速入门程序，Hello World的输出程序，进行了几点简要的讨论，分别讲解了注释的用法，包的概念的入门，主函数的作用，以及函数体中的顺序结构。同时，也对开发中的几点小细节做出了说明，如大括号位置，包的使用等等。 &emsp;&emsp;在下一小节中，我们将讲解一些cmd命令行中与Go相关的一些命令，并集中讲解几个常用的命令以及实际过程中的运用。","categories":[],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"}]},{"title":"Go语言从入门到放弃系列<2> 编码及几种ide的介绍","slug":"2-编码及几种ide的介绍","date":"2020-02-05T04:34:38.000Z","updated":"2020-02-05T04:36:46.123Z","comments":true,"path":"2020/02/05/2-编码及几种ide的介绍/","link":"","permalink":"http://yoursite.com/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"Go语言从入门到放弃系列&lt;2&gt; 编码及几种ide的介绍&emsp;&emsp;在这个小节中，我们首先介绍几个实用的常用的Go语言的集成开发工具，并对几种工具做一个简要的比较，集成开发工具的选择会方便程序员对程序的编写，但对于语言本身来说是基本没有关系的。因此，不必过于纠结于集成开发工具的选择，做到能用、方便、正确即可以。同时，对于初学者来说，建议使用功能不是十分强大的开发工具，这样能相对强制性地记住更多的基本的语法与应用。 编码格式&emsp;&emsp;在这一小节中，我们首先介绍计算机中的编码格式，通过对编码格式的叙述引入对ide的介绍。编码是用预先规定的方法将文字、数字或其它对象编成数码，或将信息、数据转换成规定的电脉冲信号（引用自百度百科）。通俗一点解释便是，将每个字符（汉字、字母等）与计算机中的数字相关联。字符是有限的，而数字是无限的，因此，每一个字符必定能对应于一个数字，这个对应关系便是编码。 &emsp;&emsp;目前来说，对于中国的用户而言，常见的编码格式有ASCII、ANSI、GBK、GB2312、UTF-8等等。不同的编码格式有不同的对应关系，因此在网络传输时，或者在打开文件时，如若对应的编码格式是不一致的，内容就会显示为乱码。 &emsp;&emsp;从计算机对多国语言的支持程度上来分，编码可以分为三个阶段。第一个阶段是计算机的初期，只在美国国内通用时，是只支持英文显示的，而其他国家的语言是无法显示的。在这个阶段的代表性编码规则为ASCII码。随着计算机的国际通用，各国均开始研发适应于本国的编码规则，也为第二阶段，不同的国家制定了不同的标准，出现了采用两个字节代表一个字符的汉字延伸编码方式，称为ANSI编码，如GB2312等。然而不同国家的ANSI编码依旧不兼容。所以便进入了第三个阶段，UNICODE编码，这种编码为每一个国家、每一种语言、每一个字符均设定了统一的且是唯一的数字编号，以满足跨语言，跨平台的特性，代表字符集为UTF-8编码。 &emsp;&emsp;对于Go语言来说，为了出现字符集的冲突与乱码的形成，官方规定：所有的字符编码均为UTF-8编码，如果采用了其他的编码样式，程序是无法编译通过的。采用上一个小节所举的例子，将编码改为ANSI后并输入对应的中文，运行时会出现如下的效果： &emsp;&emsp;在将字符集恢复成UTF-8编码之后，就恢复了正常的显示。所以在各个集成开发工具中，默认的字符编码均为UTF-8编码，所以在使用工具时，可以不需要担心这个问题。 几种集成开发工具的介绍1. LiteIDE&emsp;&emsp;LiteIDE是一款开源的简单的IDE，同时也是Go语言的首个发布的正式版的IDE，通过QT开发，是专门为了Go语言而设计的。在LiteIDE中，可以直接配置构建命令，高级代码编辑，代码管理，自动完成格式化等多个功能。是一个十分轻量级且功能强大的小开发工具。 2. VSCode&emsp;&emsp;VSCode是微软开发的一个开源IDE，单独这款IDE本身不支持Go语言开发，需要在IDE中进行Go语言的扩展，也是十分方便的。同样地，VSCode的诸多插件也为开发者提供了许多的功能。不仅如此，它也提供了多种语言的支持，使之成为广受欢迎的集成开发工具。 3. GoClipse插件&emsp;&emsp;看到这个名字可能会比较熟悉，会想起一款名为eclipse的开发工具，GoClipse正是eclipse的插件，通过使用这个插件，开发者可以通过流行的eclipse开发工具进行go语言的开发，其优点是高度的可扩展性，包括源代码编辑器，项目向导，以及GDB项目调试器等等。eclipse和GoClipse插件均为开源的，因此也是免费的。 4. VIM编辑器&emsp;&emsp;这个想必也不需要多说，经常使用Linux和MacOS操作系统的对于这个简直不能更熟悉，通过VIM-Go插件使得该编辑器具备了编译器，增强的语法高亮、代码折叠等等功能。除此之外，也可以集成一些高级的源分析工具。可以讲，VIM编辑器的强大之处完全不仅仅在于对Go语言的支持上。 5. Goland&emsp;&emsp;Goland是由JetBrains公司开发的，旨在为Go语言开发者提供一个更为简便、快速的开发环境。这个商业的IDE整合了IntelliJ平台的Go相关的辅助编码功能和其他的工具。Goland是一个极为强大的开发工具，具备智能补全，检查和快速修复，格式化程序，以及调试器，版本控制器等功能。当然商业工具是需要付费的，对于个人使用可以采用破解（划掉，改为购买~）的方式。 小结&emsp;&emsp;在这个小节中，我们首先介绍了编码的含义以及Go语言对编码的要求，同时也介绍了几款相对好用的集成开发工具可供选择，在下一个小节中，我们将集中对第一个Go语言程序，Hello World的输出程序，进行简要的讲解以及对初期开发过程中所需要注意的问题和要求进行说明。","categories":[],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"}]},{"title":"Go语言从入门到放弃系列<1> 环境安装及设置","slug":"1-环境安装及设置","date":"2020-02-04T12:05:41.000Z","updated":"2020-02-04T13:45:46.807Z","comments":true,"path":"2020/02/04/1-环境安装及设置/","link":"","permalink":"http://yoursite.com/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"Go语言从入门到放弃系列&lt;1&gt; 环境安装及设置&emsp;&emsp;首先第一节，今天便说一说Go语言开发环境的搭建。所谓工欲善其事，必先利其器，没有开发环境对于Go语言的开发简直如同空谈。因此在本章节中，我们会集中阐述开发环境的安装，环境变量的配置，以及对环境变量配置的结果进行验证。 安装和配置&emsp;&emsp;最先说明，在写这篇文章的时候，我采用的是windows环境，因此我的各项操作均是基于windows操作系统的，如果读者希望采用其他的系统进行开发，可以在网络上找到配置的方式。此处只介绍windows相关配置，其他系统暂不再赘述。 &emsp;&emsp;首先，作为最初的，便是在网络中下载Go的安装包，本文给出安装包的下载地址：https://golang.org/dl/ &emsp;&emsp;需要说明的是，这个网站可能需要翻墙才能进入，因此如果打不开可以尝试这个地址：https://golang.google.cn/dl/ 因为本人是在国内开始写的这个连载，因此采用的是第二个网址。进入下载页面后如下图（图片将来可能会根据网站版本不同而改变）： &emsp;&emsp;从图中可以看出，Go官方提供了基于不同系统的不同的安装包，只需要下载相应系统的安装包，再根据不同系统的命令进行安装即可，我们以下依旧采用windows为例。安装过程便不作具体描述了，一般来说不需要修改其中的设置，只需要下一步直到完成。值得说明的是，当选择Go语言开发环境的安装位置时如果不作修改便是C:\\Go这个文件夹，修改的话需要记住修改后的位置，在后续配置中是需要的。同时，在安装过程中，尽量不要出现中文路径，以防止后续出现问题。 &emsp;&emsp;在安装过后，我们打开cmd命令控台，键入go version命令（中间有空格） &emsp;&emsp;从上图我们可以看到的是，我的机器的Go开发环境版本为1.11.2，如果安装不同的版本，这个版本号会不同。在安装过后，我们进入环境变量中会发现，系统自动为我们设置了GOROOT环境变量，并且该值为 刚刚安装的目录 ，如果发现该值与安装目录不同，需要进行修改。本人在安装的时候没有对安装目录进行修改，所以均为默认值。 &emsp;&emsp;除此之外，还需要检查Path变量是否进行了更新，对Path的配置便是在后面加入 安装目录下的bin\\目录 的全路径，建议用分号将其与前后的其他设置分开。 &emsp;&emsp;到目前为止，可以说环境变量已经配置完了，可以进行初级的开发，不过为了后续的开发方便，我们继续配置GOPATH环境变量，在Go语言的包引入过程中，是采用%GoPath%\\src为起始的目录引入的，因此建议单独生成一个文件夹，并将所有的源代码均写在这个文件夹的src目录中，而GOPATH的配置便是这个文件夹，本人在E盘下新建了GoProject，并且所有的源代码均写于E:\\GoProject\\src\\xxx\\yyy.go下，因此我的GOPATH为： E:\\GoProject &emsp;&emsp;此时我们在cmd控制台中键入： go env，将显示出当前GO的所有环境配置，如下图所示。 环境测试&emsp;&emsp;安装环境已经结束，接下来我们需要对环境的配置进行检测，便写一段简单的代码进行验证。代码也是众所周知的Hello World的输出。首先，我们在任意一个文件夹下建立一个.txt文件并将扩展名改为.go，本人便于桌面上建立一个test.go文件。请注意，在修改文件时一并修改的文件格式，也就是将隐藏已知文件名的选项去掉，否则会成为一个test.go.txt的文件。（windows各版本设置方式不同，windows7为例） &emsp;&emsp;采用记事本的方式打开，并在其中输入如下代码： 12345678//Hello World的编写package main import \"fmt\" func main()&#123; fmt.Println(\"Hello World\")&#125; &emsp;&emsp;最后，打开cmd控制台，进入到桌面上，键入go run test.go后会立刻出现程序的执行结果，也就是在控制台输出了Hello World字样，如果成功输出则代表Go环境在本机配置正确，可以进行代码的编写了。 &emsp;&emsp;环境配置工作是相对简单的，本人也暂时没有发现在这个过程中出现什么问题，因此也不知如何去写问题的解答。不过一定要注意将环境配好，这可能会影响后续一些小节的内容的讲解。 小结&emsp;&emsp;这个小节集中阐述了Go语言开发环境的安装，环境变量的配置，以及入门程序Hello World的编写。其版本号以及其他图片实例均与个人的配置相关，或在版本升级后将有其他的样式。在下一章，我们将集中介绍几款GO开发的集成开发环境，并选择其中一个进行安装。","categories":[],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"}]}]}