<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;14&gt; 运算符-算数、赋值与比较运算符</title>
      <link href="/2020/02/17/14-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%AE%97%E6%95%B0%E3%80%81%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2020/02/17/14-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%AE%97%E6%95%B0%E3%80%81%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-14-gt-运算符-算数、赋值与比较运算符"><a href="#Go语言从入门到放弃系列-lt-14-gt-运算符-算数、赋值与比较运算符" class="headerlink" title="Go语言从入门到放弃系列&lt;14&gt; 运算符-算数、赋值与比较运算符"></a>Go语言从入门到放弃系列&lt;14&gt; 运算符-算数、赋值与比较运算符</h2><p>&emsp;&emsp;在上几节中，我们讲述了Go语言中的多种数据类型，包括整型、浮点型、字符串以及指针类型等。在接下来的几个小节中我们将集中说明Go语言中的运算符的使用。在这一小节中，我们将主要介绍算数运算符、赋值运算符以及比较运算符（关系运算符）。</p><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>&emsp;&emsp;我们最先介绍算数运算符，因为算数运算符在我们日常生活中是最为常用的，在Go语言中算数运算符<br> 主要是进行数学运算的，例如加减乘除取余、正负号、自加自减等等。除此之外，我们将字符串拼接时所用到的加号也算在这个范畴中。我们在下述的表中列出算数运算符、其含义、举例以及案例中的结果：</p><table><thead><tr><th align="left">运算符</th><th align="left">运算</th><th align="left">范例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">正号</td><td align="left">+5</td><td align="center">5</td></tr><tr><td align="left">-</td><td align="left">负号</td><td align="left">-5</td><td align="center">-5</td></tr><tr><td align="left">+</td><td align="left">加法</td><td align="left">5+2</td><td align="center">7</td></tr><tr><td align="left">-</td><td align="left">减法</td><td align="left">5-2</td><td align="center">3</td></tr><tr><td align="left">*</td><td align="left">乘法</td><td align="left">5*2</td><td align="center">10</td></tr><tr><td align="left">/</td><td align="left">除法</td><td align="left">5/2</td><td align="center">2</td></tr><tr><td align="left">%</td><td align="left">取模（求余）</td><td align="left">5%2</td><td align="center">1</td></tr><tr><td align="left">++</td><td align="left">自加</td><td align="left">i=5 i++</td><td align="center">i=6</td></tr><tr><td align="left">–</td><td align="left">自减</td><td align="left">i=5 i–</td><td align="center">i=4</td></tr><tr><td align="left">+</td><td align="left">字符串拼接</td><td align="left">“Hello”+”!”</td><td align="center">“Hello!”</td></tr></tbody></table><p>&emsp;&emsp;在上述表中所列举的数据中，我们将选择几个运算符进行注意事项的讲解。首先表中的前几个运算符：正号、负号、加法、减法、与乘法就不做讲解了，因为这些运算与我们所理解到的数学运算是完全相同的。后面的几个运算符在一定情况下得到的结果与预期值不同，需要做一点讲解。</p><h4 id="除法（-运算）"><a href="#除法（-运算）" class="headerlink" title="除法（/运算）"></a>除法（/运算）</h4><p>&emsp;&emsp;在数学运算中，如果使用不是很小心，除法是最容易出现问题的一个运算法则，我们首先看如下的一段程序，并分析程序的输出结果会是什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">5</span> / <span class="number">2</span></span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在我们的理解中，输出的结果应该是2.5，但是可能令人惊异的是其输出结果是2。其实在上述的代码中出现了两个问题：第一个问题是期望的结果是浮点型但是定义了整型，第二个问题则是整数的运算结果依旧是整数。我们依次对这两个问题进行解决：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">5</span> / <span class="number">2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果只改变了变量a的数据类型，其结果依旧是错误的，也就是说单独地改变结果的数据类型是没有作用的。从中我们可以分析得到，在这一条语句中是存在两个行为的：第一个行为是计算5/2，第二个计算则是将第一个行为的结果赋值给变量a。因此真正出现问题的地方是整数运算结果为整数的规则，所以我们不仅要改变变量a的数据类型，我们还要改变5或者2的数据类型。</p><p>&emsp;&emsp;解决办法有两种：</p><ol><li>对5或者2进行显式类型转换：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="keyword">float32</span>(<span class="number">5</span>) / <span class="number">2</span>or</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">5</span> / <span class="keyword">float32</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>直接将5或2写成浮点型</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">5.0</span> / <span class="number">2</span>or</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">5</span> / <span class="number">2.0</span>or</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">5.0</span> / <span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以说，在Go语言中，整数除以整数得到的结果依旧是整数这个特点可能会使程序运行中出现一定的错误，但是这个特性在很多场景中都得到了很好的应用，因为整数的除法是一种天然的对结果向下取整的运算过程。因此在实际运用中需要注意或利用这个特性。</p><h4 id="取模（-运算）"><a href="#取模（-运算）" class="headerlink" title="取模（%运算）"></a>取模（%运算）</h4><p>&emsp;&emsp;在计算机中也常常会出现取模运算，我们上一次接触到取模运算是在讲解二进制转换的时候。当时十进制转换到二进制的时候各个二进制位都是通过取模运算得到的。在Go语言中取模运算也十分常见，尤其是在出现环路的情况，例如输入任意一个时间数输出它的下一个或几个小时之后的时间。</p><p>&emsp;&emsp;那么我们在最开始学习数学接触到余数的时候往往都是正数的取余运算，其实Go语言中也是支持负数的取模运算的。首先我们看下面一段程序，并考虑其输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">fmt.Println(<span class="number">9</span> % <span class="number">4</span>)</span><br><span class="line">fmt.Println(<span class="number">9</span> % <span class="number">-4</span>)</span><br><span class="line">fmt.Println(<span class="number">-9</span> % <span class="number">4</span>)</span><br><span class="line">fmt.Println(<span class="number">-9</span> % <span class="number">-4</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果为 1、1、-1、-1，从中我们可以看出一个规律：取模结果的符号与被除数的符号相同，且除法得到的商也未必都是正数。在Go语言中做取模运算的时候，遵循着这样的一个公式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = a % b==&gt;  x = a - a / b * b</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将9%（-4）带入到公式中，我们可以计算出：9/（-4）=-2.25，取整数后结果为-2，(-2)*（-4）= 8，最后 9-8=1，同理其他的三个结果也可以通过这个方式得出。</p><h4 id="自加自减（-，–运算）"><a href="#自加自减（-，–运算）" class="headerlink" title="自加自减（++，–运算）"></a>自加自减（++，–运算）</h4><p>&emsp;&emsp;相信在C语言或Java语言的学习过程中，初学者都会对i++,++i,i–,–i以及这四个运算混在一起的运算感到头疼。Go语言开发者为了减少这几种运算带来的迷惑性，对自加自减的运算进行了很多的简化以及限制，接下来我们就针对自加自减的运算做出一些说明。</p><p>&emsp;&emsp;自加自减运算本质上是改变当前的变量值，并且变为其前驱或者后继，例如：i++可以完全等价于i=i+1，同时i–可以完全等价于i=i-1，这个运算在循环结构中用到的非常多。</p><ol><li>Go语言中自加自减都是后缀运算，即运算符只能放在变量的后面：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">i++<span class="comment">//正确i--同理</span></span><br><span class="line">++i<span class="comment">//报错：unexpected ++--i同理</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="2"><li>Go语言中自加自减运算只能作为独立的语句，不能出现在其他赋值等表达式中：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">i++<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">var</span> j <span class="keyword">int</span> = i++<span class="comment">//错误</span></span><br><span class="line">fmt.Println(i++)<span class="comment">//错误</span></span><br><span class="line"><span class="keyword">if</span> i++ &gt; <span class="number">0</span><span class="comment">//错误</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>&emsp;&emsp;赋值运算符根据其名字就可以理解，其作用就是为变量或常量赋值，我们已经接触过的便是’=’符号，也就是我们常用的等于号。除了’=’号之外，还有一些与其他运算符组合的赋值运算符，如’+=’，’-=’，’*=’，’/=’，’%=’，这些符号的用法都十分简单，我们就只针对一个举例并说明。还有一些与位运算相组合的运算符，我们在讲位运算后再提及。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">i += <span class="number">10</span></span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段代码的输出值为20，在Go语言中i+=10所表示的含义为i=i+10，所以这个运算的核心是加法，也就是等号前面的符号。但是这个加号不要受到后面表达式的影响，即便是后面的表达式中出现了比等号前的符号优先级低的符号，也不会受到影响，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">i *= <span class="number">10</span> + <span class="number">2</span></span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这里可能会出现两种答案，一种是120，另一种是102，当我们利用编译器验证后，我们会发现答案其实是120，出现这两种候选的原意是，有人会将其翻译为：i = i * 10 + 2，另一种是i = i *( 10 + 2)，当我们在下一节讲到优先级的时候就会明白为什么结果如第二个表达式，而不是第一个表达式。因为赋值运算符在众多运算符中的优先级是非常低的。</p><p>&emsp;&emsp;还有一个需要注意的地方就依旧是’/=’的使用，在运算法则中，整数的运算结果还是整数，这个点只要注意到，就基本不会出现问题的。</p><h3 id="比较运算符-关系运算符"><a href="#比较运算符-关系运算符" class="headerlink" title="比较运算符/关系运算符"></a>比较运算符/关系运算符</h3><p>&emsp;&emsp;在计算机处理数据中，常常会对数据进行比较，例如，输入的整数是否处在一定的范围之内，从网络接收到的字符串是否是空串，几个数是否相等等等。因此在这种情况下，我们需要一种运算来连接两个数据，并且其表达式的值是一个能够表示真假的量，关系运算符就是如此。</p><p>&emsp;&emsp;在Go语言中，关系运算符有：&gt;，&lt;，==，&gt;=，&lt;=，!=，分别对应于：大于，小于，等于，大于等于，小于等于，不等于。这些运算符都可以通过字面来理解，其含义想必也不必多说，其中需要注意的问题是：在Go语言中，判断两个数据是否相等是要用’==’符号，而不是’=’号。我们刚刚讲，一个等于号代表的是赋值，而两个等于号才代表相等，这个点在初学者的编程过程中非常容易出现。我们依旧举一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">fmt.Println(a &gt; b)</span><br><span class="line">fmt.Println(a &lt; b)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其结果分别是false和true，这与我们心中所认为的是相同的，也就不过多介绍了。其中需要注意的点便是浮点型数据的精度丢失问题，当判断两个多位数的浮点型数据时候，使用’==’符号可能会出现与常理不太相同的结果，因此浮点型数据相等的判断往往是|a-b|&lt;=c的模式，即两个数相减的绝对值小于某个极小值。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们主要介绍了Go语言中的三种运算符，分别为算数运算符，赋值运算符以及关系运算符。在算数运算符中集中需要注意的是除法的运算规则以及取模运算的算式，在赋值运算符中则要注意其优先级，在比较运算符中需要注意的是两个数相等时所用的’==’运算符。</p><p>&emsp;&emsp;在下一小节中，我们将继续讲解其他几种运算符，以及列出诸多运算符的优先级，这样读者可以在面对一个表达式的时候有理有据地得出其最终结果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;13&gt; 指针类型简明讲述</title>
      <link href="/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/"/>
      <url>/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-13-gt-指针类型简明讲述"><a href="#Go语言从入门到放弃系列-lt-13-gt-指针类型简明讲述" class="headerlink" title="Go语言从入门到放弃系列&lt;13&gt; 指针类型简明讲述"></a>Go语言从入门到放弃系列&lt;13&gt; 指针类型简明讲述</h2><p>&emsp;&emsp;在上一节中，我们讲解了Go语言基本数据类型间的相互转化，以及在转化过程中可能遇到的精度丢失，数据溢出等现象。在其他基本数据类型与string类型相互转换的时候，我们讲解了转换所需要的函数方法。在这一节中，我们将介绍一种特殊的数据类型：指针类型。由于Go语言对于指针做出了许多的简化，使之不会出现像C语言一般令初学者谈指针色变。虽说我们在这一节直接介绍指针有些过于提前，不过后续经常会用到它，便在这里做一个简单的解释。</p><h3 id="指针的引入"><a href="#指针的引入" class="headerlink" title="指针的引入"></a>指针的引入</h3><p>&emsp;&emsp;在计算机科学中，指针是编程语言中的一个对象，利用地址的方式进行数据的存取。它的值直接指向存在于电脑内存或硬盘中的另一个地方的值，由于可以通过地址找到所需的变量单元，我们形象地将地址称为指针。简而言之，指针就是指内存中的一个地址。</p><p>&emsp;&emsp;用一个形象一些的例子，依旧是我们在说变量与变量名的那小节的例子。我们定义一个变量，这个变量具备一个变量名，就可以比作有一个人住在房子里且把这个房子取名为txg。其中这个人是变量的值，房子是分配的内存空间，屋子的名字txg是这个变量的名字，然而除了这些可以描述这个房子的人为属性之外，还有一个自然属性，就是这个房子的物理地址，比如说112 A’Beckett Street, Melbourne,VIC。也就是说除了通过访问txg来访问屋子之外，我们依旧可以通过物理地址来访问这个房子。</p><p>&emsp;&emsp;这个物理地址便可以理解为变量在内存中的真实位置，其值就是指针变量的值。我们知道计算机的内存是线性的且是连续的，每一个字节都可以用一个整数来表示，比如说想要访问内存中的第一个字节可以通过地址为0来访问，那么下一个字节就需要通过1来访问了。因此可以讲，指针类型所存储的值就是一个整数。</p><p>&emsp;&emsp;我们通过以下一个例子循序渐进地理解指针的含义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">fmt.Println(<span class="string">"a的值为："</span>,a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么当计算机在执行上述代码时，内存中会发生什么现象呢。首先计算机会分配8个字节给一个整型变量（我的计算机是64位），并且对该段内存赋予一个名字a。当输出的时候通过a的值进行访问该内存空间，并将该空间中的值输出来，可以通过如下的图进行理解：</p><p><img src="/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/1.png" alt></p><p>&emsp;&emsp;那么我们已经得到了名为a的变量，也同时知道的a的值，那么a所处在内存中的位置又是多少，我们可以采用&amp;运算符来获取，我们通过下一段程序进行说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">fmt.Println(<span class="string">"a的值为："</span>,a)</span><br><span class="line">fmt.Println(<span class="string">"a的地址为："</span>,&amp;a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果截屏如下所示：</p><p><img src="/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/2.png" alt></p><p>&emsp;&emsp;从中我们可以看到，不仅a的值可以顺利地打印出来，a所在的地址也被成功输出出来了，即0xc00000a168这个十六进制数的位置。换句话说，系统为a变量所分配的空间处在距离内存的起点处0xc00000a168的地方，且由于系统根据情况自动为变量分配空间，因此我们每个人不同时刻所得到的地址值可能是不尽相同的，此处只是一个案例。将其画在内存的表示图中为：</p><p><img src="/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/3.png" alt></p><h3 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h3><p>&emsp;&emsp;既然我们已经得到了整数a的物理地址，那么我们就相当于知道了指针变量中的变量值。指针变量是一种变量，其中的值为另一个变量的地址，我们在接下来的程序中进行快速入门：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;a</span><br><span class="line">fmt.Println(<span class="string">"p的值为："</span>, p)</span><br><span class="line">fmt.Println(<span class="string">"p指向的值为："</span>, *p)</span><br><span class="line">fmt.Println(<span class="string">"p的地址为："</span>, &amp;p)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将会得到如下的值，依旧需要注意的是内存分配是系统完成，读者得到的数值结果可能与我的不同：</p><p><img src="/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/4.png" alt></p><p>&emsp;&emsp;从上述结果中我们可以看出，我们定义了一个指向整数的指针变量p，且输出的p的值为0xc0000a168，且刚好就是a变量所在的内存地址，p所指向的值是100，也刚好便是a变量的值，同时因为指针变量也是一种变量，需要存在于内存中，因此，指针变量也具备一个物理地址，其当然也可以通过另一个指针来指向。</p><h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><p>&emsp;&emsp;在这里我们逐行对上述代码进行讲解。首先毫无疑问的定义一个整形变量a，并初始化其值为100。然后我们定义一个指向整数的指针变量，在这里定义过程中采用了*的方式进行定义，换句话说星号在定义阶段的出现是表明该变量是一个指针变量。然后我们采用&amp;符号的方式，将a变量的地址赋值给p指针，也就是常说的令p指针指向a。下一步直接输出p的值。再然后输出p所指向的值，在这里*又一次出现了，在变量的使用阶段使用星号，代表取出该指针指向的值。最后一行输出p的地址，我们依旧使用&amp;符号获取p变量的内存地址。将p也加入到内存表示图中为：</p><p><img src="/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/5.png" alt></p><h4 id="amp-符号和-符号"><a href="#amp-符号和-符号" class="headerlink" title="&amp;符号和*符号"></a>&amp;符号和*符号</h4><p>&emsp;&emsp;在这里我们特殊强调一下，我们可以将&amp;符号与*符号看做一组互逆的符号对：&amp;符号可以取出该变量的地址得到指针，*符号可以取出该指针所指向的值，我们通过下面一个小程序来验证这两个符号对的使用关系：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">fmt.Println(*&amp;a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果依旧为100，因为我们先通过&amp;符号得到了a变量的地址，然后立刻通过*符号取出该地址的值，当然结果依旧是100，我们也可以理解为这两个符号同时出现后发生了互相抵消的现象。我们再看下一段程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">fmt.Println(&amp;*a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们只是把两个符号相互调换了顺序，但是这时，程序是无法编译通过的，虽然是两个符号逻辑上可以互相抵消，但是在实现的时候却是先执行了*符号，然后执行了&amp;符号。然而a变量是一个整型变量，不是一个指针变量，因此对一个整数变量进行取地址中的值的运算时，即*运算时是错误的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;a</span><br><span class="line">fmt.Println(&amp;*p)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将程序修改至上述的样式，就可以正确执行了，因为此时的p就是一个指针，因此就可以执行*取值操作了，然后再取地址可以相互抵消，其输出值就是a变量的地址：0xc00000a168。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;a</span><br><span class="line">fmt.Println(*&amp;p)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以考虑一下上述代码能否正确执行，结果当然是可以执行的。我们最初提到指针变量也是变量，也具备一个地址，那么我们先对指针变量取地址，再对指针变量的地址进行取值，所得到的结果依旧是指针变量，换句话说是可以相互抵消的。其输出值依旧为:0xc00000a168。</p><h4 id="指针也具备数据类型"><a href="#指针也具备数据类型" class="headerlink" title="指针也具备数据类型"></a>指针也具备数据类型</h4><p>&emsp;&emsp;这个标题我其实想说的是，指针类型也是根据其指向的类型不同而不同的，例如*int表示的是指向整数的指针，*float32表示的是指向float32类型的指针。且不同种的指针类型之间是不可以乱赋值的。比如说：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">float32</span> = &amp;a</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码就是错误的，因为我们定义的a是整数变量，但是定义的指针p是指向float32类型的指针，最后我们将a的地址赋给该指针，这个在程序编译的过程中就会报错误。错误信息与之前也十分相似：cannot use &amp;a (type *int) as type *float32 in assignment。</p><p>&emsp;&emsp;我们可能会开始思考，指针的值就是变量的地址，就是内存的地址，换句话说就是一个十六进制的整数而已，既然都是整数，那指向不同数据类型的指针的意义何在。当我们在后面讲到数组的时候，我们会讲解到指针是可以移动的，且移动的长度与其指向的数据类型是相关的。比如指向int8类型的指针向后移动时，只需要移动一个字节就表示下一个int8了，而对于float32类型的指针来说，如果想通过指针移动得到下一个float32的值，则需要移动4个字节。因此写明该指针所指向的数据类型是十分必要的。</p><h4 id="注意空指针（野指针）"><a href="#注意空指针（野指针）" class="headerlink" title="注意空指针（野指针）"></a>注意空指针（野指针）</h4><p>&emsp;&emsp;到目前为止我们所见到的指针一般都是具有指向目标的，在上述的例子中p指针指向的是a变量。那么，如果一个指针变量没有指向任何的值，那么这个指针可以被称为野指针。指针变量和基本数据类型变量相似，也具备一个初始值零值，我们可以通过程序看指针的零值是什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span><span class="comment">//没有指向任何值</span></span><br><span class="line">fmt.Println(p)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将p的值直接输出来，我们会发现输出结果为：&lt;nil&gt;，而不是像之前一样输出一个十六进制的整数。&lt;nil&gt;的值表示为空，那么从空中妄图取出值，当然就会报错了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">fmt.Println(*p)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其错误信息为：runtime error: invalid memory address or nil pointer dereference.</p><h4 id="指针可以改变数据"><a href="#指针可以改变数据" class="headerlink" title="指针可以改变数据"></a>指针可以改变数据</h4><p>&emsp;&emsp;既然我们可以通过指针的值来访问到变量的值，那么我们也可以通过指针来改变变量的值，例如如下程序:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;a</span><br><span class="line">*p = <span class="number">200</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(*p)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中我们令p指针指向a变量，然后我们通过p指针进行取数据操作，然后将该数据修改为200，最后我们输出了a的值，也输出了p所指向的值，其运算结果为200和200。即通过指针进行修改时，是修改其指向的变量的值。我们再看下面一段程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;a</span><br><span class="line">p = <span class="number">200</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们在为p指针所指向的值赋值时，忘记写了前面的星号，导致了在逻辑上成为了如下的意思：将p的值（即a变量的地址）改变成200，这是绝对不允许的。因为计算机的内存的值从一开始就是设定好的，是无法进行修改的，错误信息为：cannot use 200 (type int) as type *int in assignment</p><h3 id="值类型与引用类型"><a href="#值类型与引用类型" class="headerlink" title="值类型与引用类型"></a>值类型与引用类型</h3><p>&emsp;&emsp;在这里我们只是简要地解释一下值类型与引用类型的概念，这两个概念非常的简单，但是在后续的学习过程中经常出现，我们也会在出现的时候进行强调说明。同时这两个类型涉及到太多的尚未提及的知识，目前只是记住这个概念就好。</p><p>&emsp;&emsp;1. 值类型：一般来说，我们提到的基本数据类型，如int系列，float系列，bool类型，string以及结构体（struct）和数组都是值类型。值类型的特点是：变量直接存储值，内存通常在栈中分配。我们之前举的例子都是值类型的。</p><p>&emsp;&emsp;2. 引用类型：指针是一个最为常见的引用类型，除此之外还有切片（slice），map，管道（chan），接口（interface）等，其特点为：变量存储的是一个地址，这个地址所对应的空间才是真正存储数据的空间，内存通常在堆中分配。当没有任何变量引用到那些真正存储数据的地址时，这个地址所对应的空间就再也无法被调用，且被垃圾回收机制（GC）所回收。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们集中介绍了指针的相关概念，并通过一些例子形象地引出了指针的含义，然后我们对指针的定义、两个符号的关系、以及指针指向的数据类型的含义、野指针的问题进行了讲解。最后又对值类型与引用类型做出了引出，在后续讲解其他知识点的时候会反复提及。</p><p>&emsp;&emsp;在下一小节中，我们将集中地详细地介绍Go语言中的运算符，内容比较散碎，依旧会通过一些例子讲解不同类型的运算符在使用过程中所需要注意的问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;12&gt; 基本数据类型的转换</title>
      <link href="/2020/02/15/12-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
      <url>/2020/02/15/12-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-12-gt-基本数据类型的转换"><a href="#Go语言从入门到放弃系列-lt-12-gt-基本数据类型的转换" class="headerlink" title="Go语言从入门到放弃系列&lt;12&gt; 基本数据类型的转换"></a>Go语言从入门到放弃系列&lt;12&gt; 基本数据类型的转换</h2><p>&emsp;&emsp;在上几个小节中，我们针对Go语言中的基本数据类型进行简要的描述，以及对各个基本数据类型在使用过程中可能出现的问题以及需要注意的点进行了详细的说明。在这一节中，我们将继续集中讲解Go语言中基本数据类型的互相转换方式，以及所用到的相关的函数等。</p><h3 id="不同数据类型的转换"><a href="#不同数据类型的转换" class="headerlink" title="不同数据类型的转换"></a>不同数据类型的转换</h3><p>&emsp;&emsp;我们首先介绍同类型的相互转换方式，例如int8转换为int32、float64转换为float32等。Go语言在这点上与C语言、Java语言等不同，Go语言在不同类型的变量之间赋值时需要进行显式转换，而不能自动转换。例如在Java语言中，我们完全可以将byte类型的数据直接赋值给int类型的数据完成自动转换，因为变量可容纳的空间是由小到大，因此不会出现数据溢出的问题，但是在Go语言中，我们需要明确地显式转换。 </p><p>&emsp;&emsp;大致上来说，Go语言中的类型转换都可以遵循一个语法：T(V)，其含义为将V的数据类型转换成T的数据类型。T是转换后的类型，如int32、float32等等，V是需要转换的变量，我们先写一段程序举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float32</span> = <span class="keyword">float32</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="keyword">uint8</span> = <span class="keyword">uint</span>(i)</span><br><span class="line">fmt.Println(i,f,u)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从以上程序中我们可以看出，我们首先定义了一个int类型的变量，并初始化为10，接着我们希望将这个int变量中的值赋给一个float32和uint8类型的变量，然后再输出，其输出结果为三个10，也就是说在这个类型转换过程中是成功的。接下来我们验证一下Go语言中数据类型不可以自动转换的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int8</span> = <span class="number">127</span></span><br><span class="line"><span class="keyword">var</span> bi <span class="keyword">int64</span> = i</span><br><span class="line">fmt.Println(bi)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在编译这段代码的时候，系统就会报出错误，其错误类型是：cannot use i (type int8) as type int64 in assignment。也就是int8类型的数据不能直接赋值给int64类型的数据，尽管理论上不会出现数据溢出的现象，也不会有任何的数据方面的问题。所以说Go语言对于数据类型的定义以及赋值限制是十分严格的。</p><h3 id="类型转换过程中的数据精度问题"><a href="#类型转换过程中的数据精度问题" class="headerlink" title="类型转换过程中的数据精度问题"></a>类型转换过程中的数据精度问题</h3><p>&emsp;&emsp;既然数据类型可以相互转换，则势必会出现数据精度丢失的问题，以及数据溢出的问题，例如我们将多字节的整数的值赋给一个少字节的整数，则可能会出现数据溢出，将浮点型数据向整数转换时小数的值会丢失。接下来我们写程序验证一下这两种事情发生时的情况。</p><h4 id="整数数据溢出"><a href="#整数数据溢出" class="headerlink" title="整数数据溢出"></a>整数数据溢出</h4><p>&emsp;&emsp;这个问题我们其实在整数精讲的部分时候已经提及过数据溢出的现象以及成因了，在这里我们只是通过程序验证一下这个现象并且通过例子更为深入地了解一下这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i32 <span class="keyword">int32</span> = <span class="number">456</span></span><br><span class="line"><span class="keyword">var</span> i8 <span class="keyword">int8</span> = <span class="keyword">int8</span>(i32)</span><br><span class="line">fmt.Println(i8)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出结果为-56，从程序中，我们可以明显地看出来456这个数值已经超出了int8所能表示的数据范围，如果强行将其赋给int8，我们会发现编译过程中是不报错的，同时也是可以正确输出结果的。下面我们就解释一下-56这个数字的由来，也顺便复习一下二进制与码制的知识点。</p><p>&emsp;&emsp;首先我们看到456是一个正数，因此其补码与原码相同，我们将其转换为二进制后可以得到如下的结果（除模取余，倒序输出）:0111001000，然后由于int8数据类型只分配到了8个二进制位的空间，因此超出8个二进制位的部分被全部舍弃，其结果变为11001000（第一个1溢出舍弃）。现在我们观察一下当前的结果，我们发现符号位为1，因此得到的这个数字是个负数，我们再根据补码规则，将其还原为原码：10111000（符号位不变，从右向左从第一个1以后所有位取反），根据二进制向十进制的转换关系为-56。</p><h4 id="浮点型向整数转换"><a href="#浮点型向整数转换" class="headerlink" title="浮点型向整数转换"></a>浮点型向整数转换</h4><p>&emsp;&emsp;由于整数是无法显示小数的，且整数与浮点型的表示方式也不甚一致，因此我们通过下面的一段程序来探究浮点型向整数转换时的小数问题，以及依旧可能出现的精度丢失问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">float32</span> = <span class="number">456.5</span></span><br><span class="line"><span class="keyword">var</span> i8 <span class="keyword">int8</span> = <span class="keyword">int8</span>(f)</span><br><span class="line">fmt.Println(i8)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据输出结果，我们会发现输出结果依旧是-56，也就是说，在浮点型数据向整型数据转换的时候，其小数位全部丢失，整数位根据整数之间的转换的原则进行数据溢出判断。所以相当于依旧是456向int8进行转换，根据上述的分析过程，我们依旧可以得到结果为-56。</p><h4 id="其他转换细节"><a href="#其他转换细节" class="headerlink" title="其他转换细节"></a>其他转换细节</h4><p>&emsp;&emsp;在大型的程序开发，或者说在多人的合作开发中，每个人完成特定的函数编写，因此可能存在数据类型不一致的情况，因此在计算过程中也可能会出现数据类型的转换，接下来我们举两个例子来完成类型转换的细节讲解。</p><p>&emsp;&emsp;首先我们看如下的一段程序，判断这段程序能否通过编译：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1 <span class="keyword">int32</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> n3 <span class="keyword">int8</span></span><br><span class="line">n2 = n1 + <span class="number">20</span></span><br><span class="line">n3 = n1 + <span class="number">20</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;答案是不能通过编译，因为数据类型不匹配，第一个错误类型依旧为：cannot use n1+20 (type int32) as type int64 in assignment。因此一个数据类型加一个常数，所得到的数据类型依旧是当前的数据类型。所以int32加20之后依旧是int32。接下来我们下面的一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1 <span class="keyword">int32</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="keyword">int64</span> = <span class="number">20</span></span><br><span class="line">n3 := n1 + n2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序中我们分别定义了int32和int64的值，并将两个值相加赋值给n3，我们利用类型推导来完成赋值，现在我们猜n3是什么数据类型。接触过C或者Java的人可能会回答n3的类型为int64，实则不然，因为这段程序根本无法编译，错误类型为：invalid operation: n1 + n2 (mismatched types int32 and int64)。因此不仅仅是赋值过程中不能隐式转换，就是运算过程中也不可以。如果我们将n2显式转换为int32后，编译通过，n3当然也就是int32类型。</p><p>&emsp;&emsp;第二个细节，是程序运算过程中的数据溢出判定，我们先看下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1 <span class="keyword">int32</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="keyword">int8</span></span><br><span class="line"><span class="keyword">var</span> n3 <span class="keyword">int8</span></span><br><span class="line">n2 = <span class="keyword">int8</span>(n1) + <span class="number">127</span></span><br><span class="line">n3 = <span class="keyword">int8</span>(n1) + <span class="number">128</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述程序中，是否能通过编译呢，答案依旧是不能，其错误的语句在于n3 = int8(n1) + 128，报出的错误为128溢出了int8数据类型，因此我们说，即便是’+’号两边的数据类型一致了，编译器也会检查两边的数据是否出现溢出的现象。对于加127那行语句，我们逻辑上可以看出数据溢出了，但是不会报错，程序运行也不受影响，但是128那一行会报错，因此在实际开发中需要注意。</p><h3 id="其他类型与string相互转化"><a href="#其他类型与string相互转化" class="headerlink" title="其他类型与string相互转化"></a>其他类型与string相互转化</h3><p>&emsp;&emsp;在实际开发中，我们常常会将其他基本数据类型与string类型相互转换，例如在网络传输过程中，我们会将实体类的各个属性转换成为一个字符串进行传输，在另一端收到字符串后会将其反序列化为实体类，其中的过程就是类型之间的互相转换。</p><h4 id="其他类型转string"><a href="#其他类型转string" class="headerlink" title="其他类型转string"></a>其他类型转string</h4><p>&emsp;&emsp;总体来说，其他数据类型向string类型转换时有两个常用的方法，分别是fmt包中的Sprintf函数以及strconv包中的几个函数，我们分别举例讲解：</p><ol><li>Sprintf函数，这个函数的签名为：fmt.Sprintf(“%参数”,表达式)，这个类型与fmt包中Printf输出函数十分的类似，如果我们使用Printf函数十分熟练的话，这种方式就非常简单了。无非就是将数据转成字符换和将数据转换成字符串后打印到屏幕上的区别，我们举一个例子：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"Devin"</span></span><br><span class="line"><span class="keyword">var</span> isAdult <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> info <span class="keyword">string</span></span><br><span class="line">info = fmt.Sprintf(<span class="string">"Name is %s age is %d isAdult is %t"</span>, name, age, isAdult)</span><br><span class="line">fmt.Println(info)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的程序的含义为：定义了几种数据类型的变量，并通过Sprintf方式将其格式化形成一个字符串，最后将这个字符串打印到屏幕上。经过运行后，我们会发现屏幕上输出了：Name is Devin age is 25 isAdult is true。也就是说，我们成功地将属性转换成了字符串，格式中的%d之类的表示方法与输出函数相同，可以参考前几节中我们讲到的知识点。</p><ol start="2"><li>strconv包中函数，这个包中的函数在转换过程中主要会用到以下4个函数，分别为：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatBool</span><span class="params">(b <span class="keyword">bool</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="keyword">float64</span>, fmt <span class="keyword">byte</span>, prec,bitSize <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="keyword">int64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatUint</span><span class="params">(i <span class="keyword">uint64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这些函数我们直接就在代码实践中以注释形式解释参数的含义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> num1 <span class="keyword">int32</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="keyword">float64</span> = <span class="number">12.345</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">str1 := strconv.FormatInt(<span class="keyword">int64</span>(num1), <span class="number">8</span>)</span><br><span class="line"><span class="comment">//注意输入参数的数据类型，参数是int64，因此要强转，8为基数，即以8进制形式转换，可选为2,8,10,16</span></span><br><span class="line">str2 := strconv.FormatFloat(num2, <span class="string">'f'</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"><span class="comment">//参数为float64，fmt表示格式: 'f':ddd.dd ,'b':dddp(+-)ddd(二进制科学计数法),'e':ddde(+-)ddd(十进制科学计数法)...</span></span><br><span class="line"><span class="comment">//10为保留10位小数，64指代传入的是float64，可选值为64和32</span></span><br><span class="line">str3 := strconv.FormatBool(b)</span><br><span class="line"><span class="comment">//传入布尔值，将其转换成字符串</span></span><br><span class="line">fmt.Println(str1)</span><br><span class="line">fmt.Println(str2)</span><br><span class="line">fmt.Println(str3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">144</span></span><br><span class="line"><span class="number">12.3450000000</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中FormatInt函数和FormatUint函数参数相同，也不做过多介绍了。</p><h4 id="string转其他基本类型"><a href="#string转其他基本类型" class="headerlink" title="string转其他基本类型"></a>string转其他基本类型</h4><p>&emsp;&emsp;string转向其他基本数据类型依旧使用的是strconv包中的函数，我们将其列出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="keyword">string</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(f <span class="keyword">float64</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(i <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseUint</span><span class="params">()</span><span class="title">s</span> <span class="title">string</span>, <span class="title">base</span> <span class="title">int</span>, <span class="title">bitSize</span> <span class="title">int</span>) <span class="params">(n <span class="keyword">uint64</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述的函数描述中，我们首次看到了两个返回值的函数，即bool值和error值，因此我们在调用的时候需要两个变量进行承接。我们依旧采用程序例子的方式进行说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str1 := <span class="string">"true"</span></span><br><span class="line">str2 := <span class="string">"100"</span></span><br><span class="line">str3 := <span class="string">"12.345"</span></span><br><span class="line">v1, _ := strconv.ParseBool(str1)</span><br><span class="line"><span class="comment">//暂时不关心error，所以采用_标识符进行接收</span></span><br><span class="line">v2, _ := strconv.ParseInt(str2, <span class="number">10</span>, <span class="number">32</span>)</span><br><span class="line"><span class="comment">//10表示以10进制形式转换，如果该值为0则根据字符串判断，出现0x为16进制，以0开头为8进制，否则10进制</span></span><br><span class="line"><span class="comment">//32表示结果可以赋值给int32，该值可选为0,8,16，32,64，分别对应int，int8，int16，int32，int64</span></span><br><span class="line"><span class="comment">//要求该数值指定结果必须能够无溢出地赋值</span></span><br><span class="line">v3, _ := strconv.ParseFloat(str3, <span class="number">32</span>)</span><br><span class="line"><span class="comment">//32表示：结果可以不改变精确值地赋给float32，可选值为32和64</span></span><br><span class="line">fmt.Printf(<span class="string">"v1的类型为%T,v1的值为%t\n"</span>, v1, v1)</span><br><span class="line">fmt.Printf(<span class="string">"v2的类型为%T,v2的值为%d\n"</span>, v2, v2)</span><br><span class="line">fmt.Printf(<span class="string">"v3的类型为%T,v3的值为%f\n"</span>, v3, v3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v1的类型为<span class="keyword">bool</span>,v1的值为<span class="literal">true</span></span><br><span class="line">v2的类型为<span class="keyword">int64</span>,v2的值为<span class="number">100</span></span><br><span class="line">v3的类型为<span class="keyword">float64</span>,v3的值为<span class="number">12.345000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据输出结果，我们可以看出其转换过程是成功的，且返回值分别是bool，int64，以及float64，当我们得到结果并且向转换成其他数据类型如int32时，可以再行显式转换。</p><p>&emsp;&emsp;值得注意的问题是，假如类型转换失败会发生什么现象，例如我们将”true”转换为整数，这时就需要用到error的值了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"true"</span></span><br><span class="line">v1, err := strconv.ParseInt(str, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">fmt.Println(v1)</span><br><span class="line">fmt.Println(err)</span><br><span class="line">v2, err := strconv.ParseBool(str)</span><br><span class="line">fmt.Println(v2)</span><br><span class="line">fmt.Println(err)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">strconv.ParseInt: parsing <span class="string">"true"</span>: invalid syntax</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以发现当数据转换成功的时候，是可以输出正确的值的，并且error的类型为nil，当数据转换不成功的时候，得到的值为该数据类型的<strong>零值</strong>，且error的类型是invalid syntax，因此在做数据类型转换的时候我们往往会根据err是否为nil来判断转换是否成功，所以我们一般会如下去写（使用到分支结构后续会详细讲解）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"Hello"</span></span><br><span class="line">v, err := strconv.ParseInt(str, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"类型转换出错"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在本小结中，我们集中讲解了Go语言的基本数据类型之间的互相转化，讨论了由高精度到低精度，高容量到低容量的转换过程中出现的问题，以及string类型与其他基本类型转换过程中使用到的函数与注意事项。整体来说，本节讲的知识点偏细，且比较杂，但难度不大。读者可以不必现在完全记住这些，当使用的时候，再回来仔细看即可。</p><p>&emsp;&emsp;在下一节中我们将集中介绍另一个数据类型：指针，并对指针数据类型的定义、使用、注意事项等进行详细地说明。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;11&gt; 基本数据类型精讲-字符和字符串</title>
      <link href="/2020/02/14/11-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/02/14/11-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-11-gt-基本数据类型精讲-字符和字符串"><a href="#Go语言从入门到放弃系列-lt-11-gt-基本数据类型精讲-字符和字符串" class="headerlink" title="Go语言从入门到放弃系列&lt;11&gt; 基本数据类型精讲-字符和字符串"></a>Go语言从入门到放弃系列&lt;11&gt; 基本数据类型精讲-字符和字符串</h2><p>&emsp;&emsp;在介绍Go语言的基本数据类型时，我们同时也提及了布尔型变量、复数类型以及字符串，并单独介绍了Go语言中不存在但是一些其他语言存在的字符型变量。复数类型在开发过程中不怎么常用，而布尔型变量我们会在条件结构的章节中详细地介绍，因此在这一节中，我们将集中讲述字符和字符串类型的各个注意事项以及一些细节点。</p><h3 id="（字符型）"><a href="#（字符型）" class="headerlink" title="（字符型）"></a>（字符型）</h3><p>&emsp;&emsp;我们在这里用括号括起来依旧是表示这个类型是不存在的，但是为了介绍方便以及引出字符串的注意点，我们依旧将它作为一种数据类型进行讲解。在前面的介绍中，我们可知Go语言中的字符不仅仅局限于数字、字母等传统ASCII字符集，而是囊括了各个国家的各种语言。因此虽说byte和rune类型均表示字符型类型，但是除非明确运用在英语国家，我们一般还是会运用rune类型。</p><h4 id="ASCII字符集"><a href="#ASCII字符集" class="headerlink" title="ASCII字符集"></a>ASCII字符集</h4><p>&emsp;&emsp;ASCII字符集是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他的西欧类语言。同时也是在西方英语国家中最为常用且通用的单字节编码系统，现在包括UTF-8编码在内的UNICODE编码均向下兼容了ASCII编码模式。一般来说，ASCII码是使用7位或8位二进制位的组合来表示128种或256种可能的字符。在早期ASCII码用于传输的时候是128个，也就是占据了7个二进制位，后来IBM公司根据字节这个最小单位所拥有的位数拓展成了256个字符，但日常编程中常用的是前128个。</p><p><img src="/2020/02/14/11-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/1.png" alt></p><p>&emsp;&emsp;上图即为ASCII码与字符之间的匹配关系（图片来源于网络），从图中看，我们可以找到几点规律：</p><p>&emsp;&emsp;1. 从编号为33的字符开始直到编号为126的字符，均是我们日常开发中在键盘上可以见到的、常用的字符，包括数字、字母、与众多标点等。其余的字符均是控制类与传输类的字符，往往需要转义才能得到。</p><p>&emsp;&emsp;2. 数字从0到9，字母从a到z，字母从A到Z的编码值分别是连续的，但是其之间是不连续的。在字符参与运算过程中，例如’A’+2，其结果为’C’，原理与整数相加是相同的。</p><p>&emsp;&emsp;3. 在编程过程中需要尤其注意0，’0’，与’\0’的关系，在上一节介绍用字符串表示浮点数与整数以消除其误差的时候，过程中的一环便是将字符型的数字转换成内存中的相应的数字，解决办法便是对每一位的值均实行减48的操作，这样计算结果才是正确的，前期练习的时候可能会在这个地方犯错。</p><p>&emsp;&emsp;接下来我们利用循环（后面会讲到）在控制台输出前128个字符，我们会发现还是有许多有趣的字符的：</p><p><img src="/2020/02/14/11-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/2.png" alt></p><p>&emsp;&emsp;从中我们看到了笑脸、看到了心、还看到了许多莫名其妙的字符，这些奇怪的字符代表的均是控制类和传输类的字符，如果仔细听，我们还会听到计算机的蜂鸣器发出了‘嘟’的一声，这个是因为ASCII码为7的字符发出的，其结果就是令蜂鸣器发出声音。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>&emsp;&emsp;在前面的阐述中，我们将字符串阐述成为字符的有序合集，是由一个个字符所构成的，但是这种说法不甚确切，准确地说Go语言的字符串是由字节所构成的。根据UTF-8编码规则可知，每个字符占据三个字节，所以Go语言中的字符串长度与其占据的字节数是不相同的。在Go语言的字符串使用中，我们需要注意以下的几个点：</p><h4 id="字符串是常量"><a href="#字符串是常量" class="headerlink" title="字符串是常量"></a>字符串是常量</h4><p>&emsp;&emsp;这个特性在很多语言中均是如此，字符串在定义过程中就已经分配好了空间，且不能通过类似数组方式进行单个字符的替换，例如如下程序，我们希望将Hallo中的’a’字符替换成’e’字符，这个操作是非法    的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hallo"</span></span><br><span class="line">str[<span class="number">1</span>] = <span class="string">'e'</span></span><br><span class="line">fmt.Println(str)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其报错信息为：cannot assign to str[1]，所以字符串一旦赋值了，字符串就不能更改了。当对字符串进行拼接操作时，例如如下程序，将Hello与World拼接起来，可以采用+号进行拼接:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello"</span></span><br><span class="line">str = str + <span class="string">" World"</span></span><br><span class="line">fmt.Println(str)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;程序输出结果为Hello World，将两个字符串拼在了一起，看起来像是将World单词拼接在了Hello的后面，实则不是。在执行这个操作的时候，内存中生成了两个字符串，分别为Hello和Hello World，只是str由原来的指向Hello变成了指向Hello World字符串。原来的Hello字符串由于没有任何变量指向它了，就被Go的GC机制回收并释放了内存。</p><h4 id="字符串的两种表示方式"><a href="#字符串的两种表示方式" class="headerlink" title="字符串的两种表示方式"></a>字符串的两种表示方式</h4><p>&emsp;&emsp;在前面的举例中，我们都用双引号进行字符串的表达，这个就不再举例了，前面的例子已经足够说明这种方式了，在这里我们介绍的是第二种表示方式，即利用反引号进行表示。反引号是我们键盘上左上角，esc按键下的那个按键，利用反引号可以使字符串以原生的形式进行表示，其中就包含了换行与特殊字符，可以实现防止攻击，输出源代码等效果，例如我们想输出一句Hello “World”，在World的两边输出双引号，如果利用双引号我们将需要写成如下的字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello \"World\""</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也就是说我们需要使用转义字符来手动控制字符串中的格式，否则遇见双引号字符串就提前结束了，因此这点在输出源代码的时候就会非常的困难，取而代之，我们可以利用如下的定义方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">`Hello "World"`</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样就可以将双引号原样输出，我们再举个例子，将程序的源代码输出：</p><p><img src="/2020/02/14/11-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/3.png" alt> </p><p>&emsp;&emsp;从上述代码中，我们可以发现使用反引号时可以将双引号、换行符、乃至于制表符都可以直接输出出来，这个特点在用Go做服务器的时候可以得到很多的使用。</p><h4 id="len函数与Sizeof函数"><a href="#len函数与Sizeof函数" class="headerlink" title="len函数与Sizeof函数"></a>len函数与Sizeof函数</h4><p>&emsp;&emsp;在字符串中我们往往需要知道其长度或占据了多少个字节，我们就因此引入两个函数，len函数的返回值表示了字符串的长度。而unsafe包下的Sizeof函数不太一致，其代表了字符串数据类型在内存中占用的空间，这个问题需要说明一下，否则很容易理解错误。我们首先来看纯英文的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">   <span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"unsafe"</span></span><br><span class="line">   )</span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello"</span></span><br><span class="line">   fmt.Println(<span class="built_in">len</span>(str))</span><br><span class="line">   fmt.Println(unsafe.Sizeof(str))</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过程序编译运行后，我们会发现输出的结果分别为5和16，也就是说，Hello这个字符串的长度为5，在内存中被分配了16个字节。相信字符串长度为5这个很好理解，但是字符串占据16个字节就有些问题了，我们先记下不表，现在我们将视线放在中文字符串上（只写main函数中）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"中国"</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(str))</span><br><span class="line">fmt.Println(unsafe.Sizeof(str))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序的输出结果为6和16，这个6也相对好理解，因为每个汉字都占据3个字节，两个汉字占据了6个字节是没问题的，但是通过Sizeof输出的结果依旧是16，而且不论什么字符串，结果都是16。可见通过Sizeof得到的值与字符串本身内容是不相关的。我们接下来解释一下这个问题。</p><p>&emsp;&emsp;有些人最初可能会将它与C语言中的sizeof函数进行类比，但通过分析它与C语言中的是完全不同的。Go语言中的Sizeof总是在编译期就进行求值而不是在运行期间求值。在Go语言中字符串类型其实对应于一个结构体，该结构体中有两个属性，换句话说字符串类型是由两部分构成的。第一部分为指向该字符串的指针（后续会讲到），第二部分为字符串的长度，每个部分都用了8个字节来存储各自的内容，而字符串的值本身则是在另一段连续的内存中储存着。就如同一个遥控器，一台电视一般，字符串数据引用是遥控器，字符串中的值是电视，Sizeof所测量的是遥控器的尺寸，而不是电视的大小。</p><h4 id="字符串拼接时’-’的位置"><a href="#字符串拼接时’-’的位置" class="headerlink" title="字符串拼接时’+’的位置"></a>字符串拼接时’+’的位置</h4><p>&emsp;&emsp;这个问题十分的简单，我们就举两个例子进行说明，这只是一个规定：当字符串过于长而不得不使用多行来赋值时，’+’的位置需要出现在字符串该行的结尾，而不是下一行的开头：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello"</span> +</span><br><span class="line"><span class="string">" World"</span></span><br><span class="line">fmt.Println(str)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码的编译是可以通过的，并且可以得到正确的结果。如果程序写成如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello"</span> </span><br><span class="line">+ <span class="string">" World"</span></span><br><span class="line">fmt.Println(str)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在编译过程中就会出现错误，错误的类型为：invalid operator: + untyped string。这个问题注意一下即可。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小结中，我们集中介绍了字符型数据类型的注意事项，包括ASCII码与字符的对应关系，以及其遵循的规律等。以及字符串在定义、使用过程中所需要注意的几点问题。包括常量的属性、表示方式、字符串长度函数以及拼接过程中+符号所需要处在的位置。在下几节中，我们将继续对基本数据类型进行讲解，集中举例说明数据类型之间的转化方式，例如将整数的值转换为字符串等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;10&gt; 基本数据类型精讲-整型和浮点型</title>
      <link href="/2020/02/13/10-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E6%95%B4%E5%9E%8B%E5%92%8C%E6%B5%AE%E7%82%B9%E5%9E%8B/"/>
      <url>/2020/02/13/10-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E6%95%B4%E5%9E%8B%E5%92%8C%E6%B5%AE%E7%82%B9%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-10-gt-基本数据类型精讲-整型和浮点型"><a href="#Go语言从入门到放弃系列-lt-10-gt-基本数据类型精讲-整型和浮点型" class="headerlink" title="Go语言从入门到放弃系列&lt;10&gt; 基本数据类型精讲-整型和浮点型"></a>Go语言从入门到放弃系列&lt;10&gt; 基本数据类型精讲-整型和浮点型</h2><p>&emsp;&emsp;在前几节中我们详细地讲述了Go语言中二进制的基础，基本数据类型和Go语言中标识符的规定及使用。在接下来的几节中，我们将针对之前提到的几种基本数据类型进行详细地讲解，并对程序开发中可能出现的问题进行讲解和原因的解释。</p><h3 id="整型变量的细节讨论"><a href="#整型变量的细节讨论" class="headerlink" title="整型变量的细节讨论"></a>整型变量的细节讨论</h3><p>&emsp;&emsp;首先，我们先复习一下之前所讲的基本数据类型中的整型变量，整型变量的定义按是否有符号可以分为有符号整数和无符号整数。有符号整数的最高位表示符号位，且0代表正数，1代表负数，无符号整数的最高位参与数字的表示，即只能表示正数。在intN类型中的N代表计算机系统为该类型分配多少个二进制位数，即int8为8位，int16为16位。不同的整数类型对于数值的表示大小是不相同的，我们在接下来的讲解中会以int8为例。</p><p>&emsp;&emsp;既然每种整数类型可以表示的数值范围大小是一定的，那么一旦其中存储的数据超出了其可以表示的最大的范围会发生什么呢，我们将以以下的几个例子进行详细地说明：</p><h4 id="赋值时越界"><a href="#赋值时越界" class="headerlink" title="赋值时越界"></a>赋值时越界</h4><p>&emsp;&emsp;首先我们知道，int8可以表示的范围为-128到127，我们看下面的一段代码（只写main函数中的代码了）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="keyword">int8</span> = <span class="number">128</span></span><br><span class="line">fmt.Println(num)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过对上述程序的分析，我们知道，将128赋值给int8是会出现数值越界的情况的，因为其可表示的最大的数值只为127。在开发阶段出现了这类数值越界的代码时，编译器会帮助我们进行检查，因此这段代码是无法编译通过的，而且其错误类型显示为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constant <span class="number">128</span> overflows <span class="keyword">int8</span></span><br><span class="line">即常量<span class="number">128</span>溢出了<span class="keyword">int8</span>所能表示的范围</span><br></pre></td></tr></table></figure><h4 id="运行时越界"><a href="#运行时越界" class="headerlink" title="运行时越界"></a>运行时越界</h4><p>&emsp;&emsp;既然在变量的赋值过程中是不会出现数据溢出的（否则编译不通过），那么在运行时是否会出现数据越界呢，一旦出现的数据越界程序是否会做出相应的响应，例如程序停止运行等行为。现在我们进行验证一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="keyword">int8</span> = <span class="number">127</span></span><br><span class="line">num = num + <span class="number">1</span></span><br><span class="line">fmt.Println(num)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;程序中出现的num=num+1的意思是，取出num所代表的值，进行加1运算后将结果再赋值给num。在这个过程中，我们会预见在做完加1运算后就又出现了数值溢出现象，经过编译运行后，我们会发现编译过程是不报错误的，同时运行过程中也没有任何的错误消息产生的，当我们看到输出结果时，我们会发现其结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-128</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在我们可以考虑一下为什么会是这个结果，在介绍原码、反码与补码的章节中，我们提到了正0和负0的问题，即00000000和10000000的问题，我们人为地将10000000所代表的数定为-128。首先我们将127转换为2进制表示方法，其结果为01111111，现在我们在此基础上加1，我们会发现通过进位后其结果成为10000000，而这个数字刚好是-128。</p><p>&emsp;&emsp;反过来思考，如果我们首先将num赋值为-128，然后在此基础上减1，其结果会显示为127，也正如当初举的时钟的例子一般，正数最大值和负数最小值是相连的。分析过程是相似的，读者可以自行思考。</p><p>&emsp;&emsp;接下来我们将目光放置在无符号整数上，例如uint8，之前我们曾经介绍过，uint8的表示范围为0到255，那么同样在开发过程中赋越界的值时会编译错误，所以我们依旧关注的是运行过程中数据越界的问题，看如下的程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="keyword">uint8</span> = <span class="number">255</span></span><br><span class="line">num = num + <span class="number">1</span></span><br><span class="line">fmt.Println(num)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以分析得，按照上述最大值和最小值相连的规律，其输出结果为0，由于该整数是一个无符号整数，因此最高位参与了计数，所以255用二进制表示为11111111（8个1），我们在其基础上加1后，经过一系列的进位运算，其结果应该是100000000（1后面有8个0），但是uint8数据类型只得到了8个二进制位的空间，因此最高位（第9位）的数据溢出并舍弃，所以计算结果为： 00000000（8个0）也就是0。逆过程可以自行思考。</p><p>&emsp;&emsp;在应用过程中有一个十分常见的例子，便是字符的表示方式。如果表示ASCII码，byte型就可以完全存储了，但是如果想存储汉字，那么byte就会出现越界，需要用rune类型数据进行存储。当然，用rune类型来存储ASCII字符也是没有问题的，程序验证如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">byte</span> = <span class="string">'中'</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其编译过程中会出现错误，异常信息为：const 20013 overflows byte，由此看出，’中’这个字符在UTF-8编码中的数值为20013，这个数值明显超出了byte所存储的范围，因此会报错。</p><p>&emsp;&emsp;所以，在整数的定义与表示过程中，无论定义了空间多大的整数，都会出现数据溢出的可能，因为每个整数都有确定的数据表示范围。因此针对不同的数据范围需求来选择对应的数据类型是十分重要的，否则在程序运行中会出现意想不到的问题，而这个问题并不涉及任何的逻辑上的错误。比如说我们定义一个变量，令该变量每次都加1，一直加到该变量为500为止，如果我们使用了uint8类型，那么这个程序就永远也停不下来了，因为255后的值又回归到0了。当然我们也可以采用int64来存储，但是针对这个需求而言，int64又有些内存的浪费了（虽说现在基本上不缺这点内存），所以选择适合的数据类型来完成特定的工作是一件需要考虑乃至于优化的事情。</p><h3 id="浮点型变量的细节讨论"><a href="#浮点型变量的细节讨论" class="headerlink" title="浮点型变量的细节讨论"></a>浮点型变量的细节讨论</h3><p>&emsp;&emsp;浮点型的存储过程中精度丢失一直都是一个无法回避的问题，这个问题在大规模的精确计算过程中十分的常见，精度丢失的问题甚至可能会导致逻辑上的问题。根据我们之前对数据类型的介绍，不论是float32还是float64类型的变量，其可表示范围都十分的广阔，同时我们也讲解了浮点型数据在内存中的存储方法，因此一般来说float32所能精确地表示小数位数为6<del>7位，而float64能表示为15</del>16位，超出的精度部分往往就会丢失了，我们来看下面的一段程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">1.00000001</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span> = <span class="number">1.0000001</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(b)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的一段程序中，我们为a和b两个变量分别赋值，并且在程序的最后输出这两个值。根据我们刚提及的精度丢失问题以及小数保留位数，我们会发现：最终的结果为a=1，b=1.0000001。可以说b的值的输出是正常的，但是a的值却产生了错误。其原因便是超出精度范围的数值被忽略了。如果我们依旧对于精度丢失所产生的问题不甚理解的话，那么我们可以再看一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">3.3333333</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span> = <span class="number">6.6666666</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">float32</span> = a + b</span><br><span class="line">fmt.Println(c)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可能令人大跌眼镜的是，这个运算结果也就是c的值为10，第一个例子中超出精度的部分被舍弃了，而在第二个例子中超出精度的部分就进了1位。这种问题既不可以被归结为编译的错误，也不可以归结为逻辑的错误，而是说这个错误出现的原因是由语言本身和机器本身所导致的。更确切地说是由浮点型数据的存储方法和二进制十进制对应关系所导致的。接下来我们从两个角度简要说明一下精度丢失的成因。</p><p>&emsp;&emsp;第一个成因便是<strong>进制转换时的精度丢失</strong>，在进制转换的那一小节中，我们抛出了一个问题，是否每一个有限的十进制数都有一个有限位数的二进制数相对应，我们对这个问题的解答是否定的。也就是说我们在用十进制数编程时，再用计算机转换成二进制码的时候，精度就已经丢失了一次了，这个丢失是内部原因导致的，也是基本无法避免的。</p><p>&emsp;&emsp;第二个成因便是<strong>浮点数的表示方法</strong>，按常理来说，一个有限位数的浮点型变量居然能表示那么大的范围，其精度必然是不会非常高的。我们在前几节介绍了浮点数的存储方式，即符号位、指数部分、和尾数部分。指数部分代表了科学计数法中的幂次，剩余的部分则表示在尾数部分，由于尾数部分也是有位数限制的，因此也会出现类似于整数一样的数据溢出问题的。因此太多的小数位数将溢出尾数部分，而保留的就是前几位未溢出的部分，因此在浮点数的存储方法中，会出现二次的精度损失。</p><p>&emsp;&emsp;那么一旦真的需要精度十分高的浮点型乃至于数值极为庞大的整数运算时，有一种解决办法便是利用字符串，字符串中的每一个字符值都是一个精确的数字。换句话说，利用字符串，在内存中所保存的是一系列的int8类型，每个int8对应于真值的每一位。同时Go语言开发者也向用户封装了基于字符串所表示的数据的数学运算函数，在需要时可以调用。详细源码可以研读Go语言中的math/big包。</p><p>&emsp;&emsp;利用字符串表示数据虽解决了数据存储与表示的问题，但是这种方式也有其特定的弊端。当我们利用int、float32等提供的数据类型进行运算操作时，系统在计算机底层予以其特殊的优化手段，使之计算速度有极大的提升。而利用字符串进行运算，则会拖慢运行速度，在一些已定义的函数中无法作为参数而不得已只好自行包装、改写函数。</p><p>&emsp;&emsp;不过话说来，浮点数精度丢失的问题一般不会影响到我们程序开发，在应用级的开发中往往不会用到8位小数之后，而且float64所提供的有效精度也足够使用了。但是在科学计算中，或在大规模的银行系统中，精度就会成为一个不得不慎重考虑的问题。曾经有一个生物信息专业的同学给我讲述过一个事情，在做DNA匹配计算过程中需要将各种的变异均考虑进去，并且得到的匹配结果十分的相似。此时问题就是，究竟是这两个DNA相同但是因为计算精度问题而显示成不同，还是说两种DNA真的是不同只是不同点比较少但是比较重要。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们主要讲述了Go语言中整数和浮点数使用注意事项，集中说明了整数中的数据溢出问题和浮点型数据中的精度丢失问题。这两个问题在计算机语言中是普遍存在的问题，不仅仅是Go语言中单独的问题。这两种问题在日常开发中几乎不会遇到，但是在实际工作中一旦出现了某种周期性问题或没有明显逻辑错误的问题时，这两个原因不失为一种考虑方向。</p><p>&emsp;&emsp;在下一节中，我们将针对于剩下的几种基本数据类型进行精讲，同时也将讲解在开发过程中可能出现的问题及原因。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;9&gt; 标识符、输出及转义字符</title>
      <link href="/2020/02/12/9-%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%8C%E8%BE%93%E5%87%BA%E5%8F%8A%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"/>
      <url>/2020/02/12/9-%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%8C%E8%BE%93%E5%87%BA%E5%8F%8A%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-9-gt-标识符、输出及转义字符"><a href="#Go语言从入门到放弃系列-lt-9-gt-标识符、输出及转义字符" class="headerlink" title="Go语言从入门到放弃系列&lt;9&gt; 标识符、输出及转义字符"></a>Go语言从入门到放弃系列&lt;9&gt; 标识符、输出及转义字符</h2><p>&emsp;&emsp;在上一小节中，我们集中介绍了变量的定义、变量的使用过程、初始化过程以及多变量的赋值。同时，我们也验证了每种基本数据类型的初始值的设定。在这一节中，我们将分别介绍Go语言中标识符的概念、合法性以及两个输出函数的使用方式，最后将对（字符型）数据中的转义字符进行介绍。</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>&emsp;&emsp;在上一节中我们介绍变量的时候提到了变量名，严格来说变量名就是一种标识符，标识符不仅仅针对于变量名，而是变量、方法、函数等命名时所使用的字符序列，均称之为标识符。简而言之便是：程序中但凡需要自己取的名字就是标识符。</p><h4 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h4><p>&emsp;&emsp;同其他的编程语言相似，Go语言中的标识符的规则也是可以由三部分构成：字母、数字、下划线，且不能以数字开头。在Go语言中，变量也是大小写敏感的，换句话说就是大写字母构成的标识符和同样字母但是小写所构成的标识符是不同的。既然标识符只能通过这三种字符构成，其他的如空格、回车、美元符号等都是非法的。我们举一些例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello <span class="keyword">int</span><span class="comment">//合法</span></span><br><span class="line"><span class="keyword">var</span> hello123 <span class="keyword">int</span><span class="comment">//合法</span></span><br><span class="line"><span class="keyword">var</span> Hello <span class="keyword">int</span><span class="comment">//合法，且与hello是不同的</span></span><br><span class="line"><span class="keyword">var</span> is_adult <span class="keyword">bool</span><span class="comment">//合法</span></span><br><span class="line"><span class="keyword">var</span> <span class="number">1</span>hello <span class="keyword">int</span><span class="comment">//不合法，数字不可以开头</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中需要说明的是，只由一个下划线所构成的标识符（’_’）是具备特殊含义的，在Go语言中称之为空标识符，其可以代表任何一个标识符，其中的值也是被忽略的。一个经典的例子便是，在Go语言中一些函数的返回值可能有多个，我们在使用的时候可能只希望获得其中的一个或忽略其中的某些，就可以通过下划线标识符来接收，这样程序不会因为返回值数量不匹配而报错，也不会因为定义了变量但没有使用而报错。举例如下（涉及函数知识，可后期再理解）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMaxAndMin</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> num1 &gt;= num2 &#123;</span><br><span class="line"><span class="keyword">return</span> num1, num2</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num2, num1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, b := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">c, _ := getMaxAndMin(a, b)</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;假设getMaxAndMin函数是其他人所实现的函数，我们无法去修改其内容，并且其中会返回最大值和最小值两个数，而我们只希望使用最大值而忽略掉最小值，就可以用’_‘来接收最小值并将其抛弃。那么问题来了，在上述的程序中我们能否输出’_‘以查看其中的值呢，答案是不能，报错的信息就是”不能把_视为一个值”。</p><p>&emsp;&emsp;除此之外，在为标识符取名的时候，还存在一些限制，即不能以系统保留的关键字作为表示符，如break、if、import、func等等。我们将会在下表中列举出系统保留的关键字：</p><table><thead><tr><th align="center">if</th><th align="center">else</th><th align="center">switch</th><th align="center">case</th><th align="center">default</th></tr></thead><tbody><tr><td align="center">break</td><td align="center">continue</td><td align="center">package</td><td align="center">import</td><td align="center">func</td></tr><tr><td align="center">for</td><td align="center">goto</td><td align="center">select</td><td align="center">interface</td><td align="center">defer</td></tr><tr><td align="center">go</td><td align="center">map</td><td align="center">struct</td><td align="center">chan</td><td align="center">const</td></tr><tr><td align="center">fallthrough</td><td align="center">range</td><td align="center">type</td><td align="center">return</td><td align="center">var</td></tr></tbody></table><p>&emsp;&emsp;上述提到的25个系统保留的关键字是绝对不可以使用在标识符里的，这些关键字在我们当使用集成开发工具编程的时候会自动变色，以提醒开发者这些词是不可以使用的。这些关键字中暂时有好多我们都不曾见过，不过我们会在后续的小节中一一接触到。</p><p>&emsp;&emsp;除了25个系统保留的关键字以外，Go语言中还提供了36个预定的标识符，这些标识符包括了期初数据类型和系统内建函数。这个特性是其他编程语言中所没有的特性，这36个标识符如下：</p><table><thead><tr><th align="center">int</th><th align="center">int8</th><th align="center">int16</th><th align="center">int32</th><th align="center">int64</th><th align="center">uint</th></tr></thead><tbody><tr><td align="center">uint8</td><td align="center">uint16</td><td align="center">uint32</td><td align="center">uint64</td><td align="center">byte</td><td align="center">rune</td></tr><tr><td align="center">uintptr</td><td align="center">float32</td><td align="center">float64</td><td align="center">complex64</td><td align="center">complex128</td><td align="center">string</td></tr><tr><td align="center">bool</td><td align="center">complex</td><td align="center">real</td><td align="center">append</td><td align="center">cap</td><td align="center">close</td></tr><tr><td align="center">copy</td><td align="center">false</td><td align="center">true</td><td align="center">imag</td><td align="center">iota</td><td align="center">len</td></tr><tr><td align="center">make</td><td align="center">new</td><td align="center">nil</td><td align="center">panic</td><td align="center">error</td><td align="center">recover</td></tr></tbody></table><p>&emsp;&emsp;在上述的表格中，我们依旧发现有好多我们都见过，并且在变量定义的时候也曾经用过。而且与一般编程语言所不同的是，这些标识符是可以被使用的。例如在Java语言中，int不可以被定义为标识符，但在Go语言中是可以的，换句话说 var int int 这条语句是成立的。但是，对于具备其他语言开发经验的开发者，这个用法是受到绝对抵制的，即便是编译器能正常运行。例如下面的这段程序，会对初学者产生极大的困惑和误导：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">byte</span> <span class="keyword">int</span> = <span class="string">'A'</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">string</span>, <span class="keyword">float32</span> = <span class="keyword">byte</span>, <span class="keyword">byte</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span> + <span class="keyword">float32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出结果是130，看起来各种的变量类型名都出现了一遍，但是其中只有一个数据类型：整型。所以这种用法十分不被推荐，如果哪个开发者以这种形式进行开发，这个人就很，，，不走寻常路。</p><h3 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h3><p>&emsp;&emsp;在这里我们只是简要地讲解几个常用的基本的输出函数，分别为Print()函数、Println()函数、以及Printf()函数。这三个函数都在fmt包中，也就是说如果使用这三个函数，都需要引入fmt包。接下来我们分别对这三个函数进行简要的叙述：</p><ol><li>Print函数和Println函数</li></ol><p>&emsp;&emsp;这两个函数的唯一区别便是输出的时候是否换行，当用Println函数的时候，函数将一个字符串输出之后会换到下一行，而Print函数则会接着当前的输出继续执行。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"Hello "</span>)</span><br><span class="line">fmt.Println(<span class="string">"Devin"</span>)</span><br><span class="line">输出结果为：</span><br><span class="line">Hello</span><br><span class="line">Devin</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;而</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Print(<span class="string">"Hello "</span>)</span><br><span class="line">fmt.Print(<span class="string">"Devin"</span>)</span><br><span class="line">输出结果为：</span><br><span class="line">Hello Devin</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Println函数的括号中（Print函数相同），我们可以传入一些任何类型的变量，而不单单只能传入字符串。例如我们在打印多个信息的时候，我们可以将多个信息通过逗号的形式进行分割，并在输出的时候进行拼接，例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age :=<span class="number">25</span></span><br><span class="line">name := <span class="string">"Devin"</span></span><br><span class="line">fmt.Println(<span class="string">"age is "</span>, age , <span class="string">" name is "</span> , name)</span><br><span class="line">输出结果为：</span><br><span class="line">age is <span class="number">25</span> name is Devin</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也就是说在输出过程中我们将三个字符串类型和一个整数类型的变量传给Println函数，这个函数将所有的参数均转换成了字符串并且按传入的顺序输出。</p><ol start="2"><li>Printf函数</li></ol><p>&emsp;&emsp;Printf函数往往被称之为格式化输出函数，我们可以将希望输出的格式预先规定好，然后向这个格式中填入数据，而不需要像Println函数一样拼接那么多的字符串，那么多的变量。例如：我们希望输出的是age is ‘占位符’ name is ‘占位符’，然后我们再向这个模板中填入25和Devin，就可以输出为age is 25 name is Devin。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"age is %d name is %s"</span>, age , name)</span><br><span class="line">其输出结果为：</span><br><span class="line">age is <span class="number">25</span> name is Devin</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中的%d和%s均为占位符，后面的age和name与这两个占位符分别对应，需要注意的是，后面的变量个数要与占位符的个数相同，且输入的数据类型要与占位符规定的数据类型相同，接触过C语言的开发者对这个应该十分的熟悉。</p><table><thead><tr><th>格式</th><th align="center">含义</th></tr></thead><tbody><tr><td>%%</td><td align="center">输出一个%</td></tr><tr><td>%d</td><td align="center">以十进制形式输出一个整数</td></tr><tr><td>%b</td><td align="center">以二进制形式输出一个整数</td></tr><tr><td>%o</td><td align="center">以八进制形式输出一个整数</td></tr><tr><td>%x(X)</td><td align="center">以十六进制形式输出一个整数且用小写字母（大写字母）表示</td></tr><tr><td>%c</td><td align="center">以字符形式输出一个整数（字符与整数一一对应）</td></tr><tr><td>%f</td><td align="center">输出一个浮点型数据（float32和float64均可使用）</td></tr><tr><td>%t</td><td align="center">以true或者false形式输出一个布尔值</td></tr><tr><td>%T</td><td align="center">输出对应的变量的数据类型</td></tr><tr><td>%v</td><td align="center">自动识别输出类型并输出（会把byte和rune识别成为整数形式）</td></tr></tbody></table><p>&emsp;&emsp;以上的这些就是常用的在输出的过程中使用到的占位符，在Printf函数中会经常使用到。</p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>&emsp;&emsp;这个小知识点我之前在写Java的时候将其写在了字符型数据的讲解中，但是在Go语言中没有这个数据类型，但是放在字符串中又不太合适，就单独写在这里了，转义字符的个数十分地多，我在这里也不一一罗列了，在实际使用的过程中慢慢积累，而且在网络中搜索转义字符也有许多的列表。</p><p>&emsp;&emsp;之前我们说起过计算机中的英文相关的字符可以用一个byte数据类型所存储，我们接触到的也一般都是字母、数字、格式的标点符号等这些能够通过键盘所打出来的字符，然而还有许多的字符是键盘打不出来的，比如说我们希望在一个字符串中存储一个换行的字符（也就是回车），当打印这个字符串时，遇到这个换行字符时自动到下一行输出。而当我们在编程的时候，按下回车键后光标就到了下一行了，字符串中并不能保存这个换行的字符。</p><p>&emsp;&emsp;再举一个例子便是，当我们在输出的时候希望输出的内容具有一些格式，使输出更为规范、有序。其中一个方法就是使用制表符（也就是Tab键），但是当我们编程的时候按下tab键，就直接将源代码向后空出制表间隔了，字符串中依旧没有存下来。因此，我们需要转义字符。</p><p>&emsp;&emsp;转义字符也是一种字符，我们通过键盘可以打出来的字符通过转义的形式，使其代表那些键盘打不出来的字符。转义的方式为’\字符’，例如’\n’，’\t’、’\0’,也就是’\‘这个字符可以将它后面的这个字符合起来共同表示一个其他的含义，比如’\n’代表回车，’\t’代表制表符，’\0’代表字符串的结尾。它们不是两个字符而是一个字符，那么当我们真的就希望输出一个\该如何去做，如果单单输出一个\，它会和后面的字符进行转义，因此，我们想输出\的时候，我们依旧需要将其转义，使用’\\‘（直接复制markdown的话会出现四个\，因为markdown中也要转义），其意思为第一个\表示后面的要转义了，第二个\表示转义后的字符就想输出为\。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info := <span class="string">"Hello World \nI am \t\t Devin"</span></span><br><span class="line">fmt.Println(info)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果为：</p><p><img src="/2020/02/12/9-%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%8C%E8%BE%93%E5%87%BA%E5%8F%8A%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/1.png" alt></p><p>&emsp;&emsp;Hello World后有回车，am和Devin中间有两个水平制表符。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们集中讲述了Go语言的标识符的概念，以及标识符的命名规则，系统定义的关键字的内容以及保留标识符的内容。同时我们也集中介绍了两种输出的形式，在后续的代码中会经常使用到的两种输出形式。最后我们介绍了转义字符的引出和概念，也提到了几个常用的转义字符，转义字符需要在平时进行慢慢地积累。</p><p>&emsp;&emsp;在之后的几个小节中，我们将针对不同的基本数据类型进行精讲，集中说明在使用这些数据的时候需要注意到的问题，以及出现问题的内部的原因以和解决方案等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;8&gt; 变量的定义及使用</title>
      <link href="/2020/02/11/8-%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/02/11/8-%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-8-gt-变量的定义及使用"><a href="#Go语言从入门到放弃系列-lt-8-gt-变量的定义及使用" class="headerlink" title="Go语言从入门到放弃系列&lt;8&gt; 变量的定义及使用"></a>Go语言从入门到放弃系列&lt;8&gt; 变量的定义及使用</h2><p>&emsp;&emsp;在上一小节中，我们集中说明了数据在内存中的存储形式，以及Go语言的各个基本数据类型、所分配的字节数、以及其可以表示的数据范围的大小。在这一节中，我们将使用之前说到的数据类型，结合变量的概念，讲述程序中的变量以及需要注意的地方。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>&emsp;&emsp;首先我们需要解释一下什么是变量，变量来源于数学，是计算机语言中存储计算结果或能表示值得抽象概念。根据字面的理解为可以变化的量，在生活中也具备许多的常用的例子，比如说人的年龄会随着时间而变化，日期会随着月份周期性变化。在计算机中，一个变量的值也可以发生变化。可以发生变化的值为变量，不能发生变化的值为常量，如圆周率等。</p><p>&emsp;&emsp;一般来说，在计算机语言中，每个变量都存在一个名字，这个名字与这个变量在一定的空间内是一一对应的。也就是说，程序开发者可以通过该名字来访问该变量的值，也可以通过名字来修改该变量的值。我们可以将其比喻为一间屋子，且每间屋子中都只能有一个人，屋子为变量本身，屋子中的人为变量的值，屋子的门牌号为变量的名字。</p><h4 id="变量使用的基本步骤"><a href="#变量使用的基本步骤" class="headerlink" title="变量使用的基本步骤"></a>变量使用的基本步骤</h4><p>&emsp;&emsp;一般来说，变量的使用可以分为三个步骤，分别为：变量的定义、变量的赋值、变量的使用。在这里，我们将通过几个例子分别对着三个过程进行简要的阐述。</p><h5 id="1-变量的定义（变量的声明）"><a href="#1-变量的定义（变量的声明）" class="headerlink" title="1. 变量的定义（变量的声明）"></a>1. 变量的定义（变量的声明）</h5><p>&emsp;&emsp;在这个阶段中，我们需要首先做的是确定这个变量的类型。比如说，如果我们希望存储的是一个人的年龄，我们当然会选择使用整数来存储，如果我们希望存储的是一个人的成绩或工资，那么我们将会采用浮点数的形式来存储。如果我们使用了错误的数据类型，我们可能将会面临因为精度丢失而导致的计算结果错误的风险，乃至于程序编译时发生编译错误。</p><p>&emsp;&emsp;基本数据类型的变量的定义基本满足于一个公式：var 变量名 数据类型，我们举一些例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span><span class="comment">//定义一个字符串用来存姓名</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int32</span><span class="comment">//定义一个整数用来存年龄</span></span><br><span class="line"><span class="keyword">var</span> salary <span class="keyword">float32</span><span class="comment">//定义一个浮点型用来存工资</span></span><br><span class="line"><span class="keyword">var</span> character <span class="keyword">byte</span><span class="comment">//定义一个整型（字符型）用来存字符</span></span><br><span class="line"><span class="keyword">var</span> isAdult <span class="keyword">bool</span><span class="comment">//定义一个布尔值用来存是否成年</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么在数据定义过程中会内存中发生什么变化，在程序执行到定义这一行的时候，内存会分配给这个变量名一段连续的空间，空间的大小根据数据类型而定。在这段内存空间中存在一个初始的值，我们称之为零值，不同的数据类型的零值不同，我们会稍后列出。</p><h5 id="2-变量的赋值"><a href="#2-变量的赋值" class="headerlink" title="2.变量的赋值"></a>2.变量的赋值</h5><p>&emsp;&emsp;在变量定义过后，即内存中已然出现了连续的空间后，我们便可以为之填充新的数值，这个过程可称之为赋值。由于变量中本身存在于一个零值，而赋值过后新的值将会代替原来的零值，因此在变量的多次赋值时，后一次的值将会覆盖掉原来的值，而保留的是最后一次修改后的值。依旧用房间打比方，我们为这个房间分配新的住户时，原来的住户需要搬离。变量的赋值过程如下（采用上述的数据的定义）:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"Devin"</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line">slary = <span class="number">1234.5</span></span><br><span class="line">chracter = <span class="string">'A'</span></span><br><span class="line">isAdult = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里需要注意的一点是，在Go语言中，数据类型的区别是十分严格的，在一些编程语言中存在着数据类型的隐式转换与显式转换，例如，可以利用‘+’将整数转为字符串，而在Go中是不允许的。</p><h5 id="3-变量的使用"><a href="#3-变量的使用" class="headerlink" title="3.变量的使用"></a>3.变量的使用</h5><p>&emsp;&emsp;变量的使用便不需要多做描述了，如何去使用这个变量也很难穷尽，不论是进行再赋值操作还是参与数学运算都是可以的。我们便举一个完整的例子表明变量的使用的全部过程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span><span class="comment">//变量的定义</span></span><br><span class="line">age = <span class="number">25</span><span class="comment">//变量的赋值</span></span><br><span class="line">fmt.Println(age)<span class="comment">//变量的使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-变量的初始化"><a href="#4-变量的初始化" class="headerlink" title="4.变量的初始化"></a>4.变量的初始化</h5><p>&emsp;&emsp;在上述的过程中，我们会发现变量的使用都要通过定义、赋值后才能进行使用，我们可能会觉得这个操作十分的麻烦，因此变量的初始化可以将变量的定义与赋值过程结合在一起，这样就会十分简便了。初始化的定义也是在变量定义时直接给与赋值操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"Devin"</span></span><br><span class="line"><span class="keyword">var</span> isAdult <span class="keyword">bool</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="变量使用中的注意事项及细节"><a href="#变量使用中的注意事项及细节" class="headerlink" title="变量使用中的注意事项及细节"></a>变量使用中的注意事项及细节</h3><h4 id="1-类型自动推导"><a href="#1-类型自动推导" class="headerlink" title="1.类型自动推导"></a>1.类型自动推导</h4><p>&emsp;&emsp;在上述的讲解中，我们提到了：数据定义过程中需要明确这个变量的数据类型，之后再进行其他的操作，但是在变量的初始化过程中其实已经出现了数据类型。因此，Go语言底层有一种机制，即根据用户所输入的值自动推导这个值得数据类型，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Devin"</span></span><br><span class="line"><span class="keyword">var</span> isAdult = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> salary = <span class="number">1000.0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;即相比于初始化过程，略去了数据类型定义的部分。在上述的例子中，Go语言底层会将age的类型自动识别为整数（int类型），name识别为字符串（string类型），isAdult识别为布尔值（bool类型），salary识别为浮点型（float64类型）。在这里需要注意的是浮点型的自动类型推导，我们需要在后面加入小数点，否则将会被推导成为整数。</p><p>&emsp;&emsp;在自动推导的定义过程中，我们会发现，几乎每个定义都有一个var的关键字，因此这个关键字也是可以省略的，不过如果仅仅是这样就会与变量的赋值相混淆了，因此在省略var关键字且初始化数据时，需要采用<strong>:=</strong>的方式进行定义，上述的程序可以改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age := <span class="number">25</span></span><br><span class="line">name := <span class="string">"Devin"</span></span><br><span class="line">isAdult := <span class="literal">true</span></span><br><span class="line">salary := <span class="number">1000.0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用变量的定义时，有一个需要注意的地方，即定义的变量名在相同的作用域中是不应该被定义过的，否则将会出现重定义，导致编译过程的错误（作用域的概念在后期会介绍到）。这一点在使用自动类型推导时容易出现错误。</p><h4 id="2-多变量的声明"><a href="#2-多变量的声明" class="headerlink" title="2.多变量的声明"></a>2.多变量的声明</h4><p>&emsp;&emsp;当我们需要定义多个同类型的数据时，比如说我们需要存储一个人的学号、姓名、住址等几个字符串信息时，我们当然可以分为多行进行定义，每一行定义一个数据，我们也可以在一行中将同样数据类型的变量同时定义，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, id, address <span class="keyword">string</span><span class="comment">//一行中定义三个字符串变量</span></span><br><span class="line">name = <span class="string">"Devin"</span><span class="comment">//分别使用</span></span><br><span class="line">id = <span class="string">"123456"</span></span><br><span class="line">address = <span class="string">"Liaoning Province"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们也可以采用初始化的形式，在一行中定义后直接使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, id, address <span class="keyword">string</span> = <span class="string">"Devin"</span>, <span class="string">"123456"</span>, <span class="string">"Liaoning Province"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;甚至直接类型推导:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, id, address = <span class="string">"Devin"</span>, <span class="string">"123456"</span>, <span class="string">"Liaoning Province"</span></span><br><span class="line">name, id, address := <span class="string">"Devin"</span>, <span class="string">"123456"</span>, <span class="string">"Liaoning Province"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;多个不同的数据类型的定义中，我们也可以采用小括号的形式进行定义以及初始化，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">age <span class="keyword">int</span> = <span class="number">25</span></span><br><span class="line">name <span class="keyword">string</span> = <span class="string">"Devin"</span></span><br><span class="line">isAdult = <span class="literal">true</span></span><br><span class="line">) </span><br><span class="line">或者</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">age = <span class="number">25</span></span><br><span class="line">name = <span class="string">"Devin"</span></span><br><span class="line">isAdult = <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要说明的一点是，在数据类型的自动推导过程中，可以不限制于同样的数据类型，不同的数据类型也是可以在同一行定义推导的，不过这种用法相对来说比较奇怪，习惯于传统语言开发的开发者可能会觉得相对不习惯：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name, age, isAdult := <span class="string">"Devin"</span>, <span class="number">25</span>, <span class="literal">true</span>   <span class="comment">//自动推导name为string，age为int，isAdult为bool</span></span><br></pre></td></tr></table></figure><h4 id="3-基本数据类型的零值"><a href="#3-基本数据类型的零值" class="headerlink" title="3.基本数据类型的零值"></a>3.基本数据类型的零值</h4><p>&emsp;&emsp;在这里我们将介绍Go语言中基本数据类型的零值。在一些编程语言中，为数据定义但不进行赋值是一种危险的行为，其值可以是一个没有意义的值。为了防止这种现象的发生，Go语言中明确定义了各种基本数据类型的零值。在一些开发过程中，有些人可能会利用零值的数值进行部分代码的省略，比如定义一个整数并为这个整数赋值为0。然而整数的零值就是0，所以一些开发者便只定义而不赋值，但是这种做法不是很推荐。</p><p>&emsp;&emsp;为了表明各个基本数据类型的零值，我们便采用下方的程序进行简单的验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">complex64</span></span><br><span class="line">fmt.Println(<span class="string">"a="</span>, a, <span class="string">" b="</span>, b, <span class="string">" c= "</span>, c, <span class="string">" d= "</span>, d, <span class="string">" e = "</span>, e, <span class="string">" f= "</span>, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其结果分别为：</p><p><img src="/2020/02/11/8-%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E4%BD%BF%E7%94%A8/1.png" alt></p><p>&emsp;&emsp;从中可知，整数的零值为0，浮点型的零值也为0，字符串的零值为空串（即””），字符型（整型）为0， 布尔值的零值为false，复数的零值为（0+0i）。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们集中介绍了变量的定义以及使用的过程，即定义、赋值、使用。同时我们也介绍了变量的初始化、自动推导类型等简便的使用方式。除此之外，我们也讲述了变量定义中的一些细节，如多变量的声明，以及各个基本数据类型的零值。在接下的几节中，我们将针对不同的数据类型进行更为详细的讲解，以及各个基本数据类型的互相转换等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;7&gt; 数据与数据的存储&lt;二&gt;</title>
      <link href="/2020/02/10/7-%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BA%8C/"/>
      <url>/2020/02/10/7-%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-7-gt-数据与数据的存储-lt-二-gt"><a href="#Go语言从入门到放弃系列-lt-7-gt-数据与数据的存储-lt-二-gt" class="headerlink" title="Go语言从入门到放弃系列&lt;7&gt; 数据与数据的存储&lt;二&gt;"></a>Go语言从入门到放弃系列&lt;7&gt; 数据与数据的存储&lt;二&gt;</h2><p>&emsp;&emsp;在上一节集中介绍了二进制的原码，反码和补码之后，我们在这一章简要地介绍一下Go语言中的基本数据类型，简单地列举一下几个基本数据类型所能存储的数字范围，并对数据范围的大小作出讲解。</p><h3 id="Go语言中的基本数据类型"><a href="#Go语言中的基本数据类型" class="headerlink" title="Go语言中的基本数据类型"></a>Go语言中的基本数据类型</h3><h4 id="（计算机内存进制）"><a href="#（计算机内存进制）" class="headerlink" title="（计算机内存进制）"></a>（计算机内存进制）</h4><p>&emsp;&emsp;在介绍数据类型之前，我们首先介绍计算机中的几个表示内存的单位，分别为：bit、byte、kb、mb、gb等等。在bit和byte转换规则中存在一个等式：1byte=8bit，换句话说1个字节的长度等于8个二进制位的长度。而在bit和kb之间、kb和mb之间的进率这个现在很难讲。从我接触到计算机开始，我所学到的进制表示法始终是1kb=1024bit，也就是进制为1024，不过近来我在网上查资料的时候，发现了一种进制表示是1kb=1000bit，而且这两种表示方法均存在，在不同的计算机系统中（如Windows和Mac）也是不同的。此时此刻我依旧为这个问题而感到费解，因此这个进制我不做说明，希望读者自行去查找。 </p><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>&emsp;&emsp;正如我们所理解的一般，整型所代表的就是计算机存储的整数，是不具备小数位的数字。根据不同的定义，整数可以分为有符号整型以及无符号整型。根据上个小节对码制的介绍，有符号整数的最高位代表符号位，并且负数的表示方式为补码方式。而对于无符号整数来说，其最高位表示的是数字中的一部分，不代表符号，是计入数字的计数的，同时因为其无符号的特性，该值永远是正值。下表将列出Go语言中整数的定义方式，以及其分配的bit空间和可表示的范围：</p><table><thead><tr><th>类型名称</th><th align="left">是否有符号</th><th align="left">分配的bit数</th><th align="center">可表示范围</th></tr></thead><tbody><tr><td>int8</td><td align="left">有</td><td align="left">8</td><td align="center">-128到127</td></tr><tr><td>int16</td><td align="left">有</td><td align="left">16</td><td align="center">-32768到32767</td></tr><tr><td>int32</td><td align="left">有</td><td align="left">32</td><td align="center">-2^31到2^31-1</td></tr><tr><td>int64</td><td align="left">有</td><td align="left">64</td><td align="center">-2^63到2^63-1</td></tr><tr><td>uint8</td><td align="left">无</td><td align="left">8</td><td align="center">0到255</td></tr><tr><td>uint16</td><td align="left">无</td><td align="left">16</td><td align="center">0到65535</td></tr><tr><td>uint32</td><td align="left">无</td><td align="left">32</td><td align="center">0到2^32-1</td></tr><tr><td>uint64</td><td align="left">无</td><td align="left">64</td><td align="center">0到2^64-1</td></tr><tr><td>int</td><td align="left">有</td><td align="left">与CPU位数相关</td><td align="center">与CPU位数相关</td></tr><tr><td>uint</td><td align="left">无</td><td align="left">与CPU位数相关</td><td align="center">与CPU位数相关</td></tr><tr><td>rune</td><td align="left">有</td><td align="left">与int32等价</td><td align="center">暂不做介绍</td></tr><tr><td>byte</td><td align="left">无</td><td align="left">与uint8等价</td><td align="center">暂不做介绍</td></tr><tr><td>uintptr</td><td align="left">无</td><td align="left">-</td><td align="center">-</td></tr></tbody></table><p>&emsp;&emsp;其中需要说明的是，int和uint整形变量分配的位数，这个是与CPU位数相关，如果计算机的CPU位数是32位，则为之分配32个bit位，即4个字节的空间。如果计算机CPU位数是64位，则为之分配64个bit位，即8个字节的空间。至于rune以及byte我们会在字符部分为之说明。</p><p>&emsp;&emsp;uintptr是一种无符号的整数，没有指定具体大小，但是足以容纳指针，一般来说是内存地址的哈希值，关于指针我们会在后续介绍到。uintptr类型一般用在底层编程中，在我们入门级别的学习中往往并不常见，在GO语言与C语言函数库的对接以及与操作系统底层硬件交互时才会经常用到。</p><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>&emsp;&emsp;浮点数在计算机中可以被理解为小数，Go语言提供了两种不同精度的小数，分别为float32以及float64，它们的定义符合IEEE754规范的定义，与整数的表示方式不同。这个规范是被现有的所有的各式CPU所支持。根据定义可以看出，float32的浮点数被分配的空间是32个二进制位，float64则分配64个二进制位。</p><p>&emsp;&emsp;那么我们可能会思考，一个整数，即便是64个二进制位，也不过是1.8*10^19（大约）这么大的数字。对于一个小数而言，既有整数部分，也有小数部分，其表示的数字范围岂不是小的可怜。为了防止出现这个结果，浮点数的存储方式与整数的存储方式是截然不同的。</p><p>&emsp;&emsp;一个浮点数可以被分为三个部分，我们以32位浮点数为例，其第一部分为最高位，也就是符号位，同整数相同，0代表正数，1代表负数。第二部分为指数位，被分配8个二进制位并通过移码后专门表示指数。最后剩下23位是第三部分，为尾数部分，这部分将代表这个小数以科学计数法表示后的整数部分。对于float64而言，则是1位的符号位，11位的指数部分，和52位的尾数部分。</p><p>&emsp;&emsp;我们举一个例子，十进制的135.5这个数字用二进制来表示为:1000 0111.1，我们采用二进制的科学计数法为：1.00001111*2^7，首先我们知道，这个数字为正数，因此符号位为0。然后指数部分采用移码的形式，即32位小数用127移，64位小数用1023移，所以7+127=134，将134化成二进制为：10000110，最后是尾数部分，由于科学计数法表示后，整数位一定是1，因此这个位可以被忽略掉，只表示00001111即可，在后面补充0，直到23位，所以结果如下：</p><table><thead><tr><th>符号位</th><th align="left">指数部分</th><th align="center">尾数部分</th></tr></thead><tbody><tr><td>0</td><td align="left">10000110</td><td align="center">00001111000000000000000</td></tr></tbody></table><p>&emsp;&emsp;因此，这个数字在内存中表示为：01000011000001111000000000000000(图片来自于binaryconvert)</p><p><img src="/2020/02/10/7-%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BA%8C/1.png" alt></p><p>&emsp;&emsp;通过这种存储方式，浮点数可以表示的范围就会极大了，粗略来说，float32表示范围可为：-3.4*10^38到3.4*10^38，对于float64而言，其范围可以是：-1.79*10^308到1.79*10^308。</p><h4 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h4><p>&emsp;&emsp;Go语言支持对复数的定义，同样也具备两种精度的复数类型，分别为complex64和complex128，正如我们所了解的，复数一般是由实部和虚部构成，因此这两种复数类型的实部和虚部分别相对应float32和float64。一般来说，复数的使用在应用开发中很少会出现，在数学计算中可能会得到应用。在此不做详细的说明了。</p><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><p>&emsp;&emsp;布尔值一般代表逻辑值，一般来说只有真或假，所对应的值为true或false。在程序中分支控制和循环控制中往往会用到布尔值。布尔值可以通过“与或非”三种逻辑进行运算，但是并不参与数学运算。在有些开发语言中，true可以表示为1，而false可以表示为0，这两种值可以被替换为整数进行数学运算。而在Go语言开发中，这个是不成立的，因此不能参与数学运算。布尔值的具体用法我们将会在分支结构中更为详细地讲述。</p><h4 id="（字符型）"><a href="#（字符型）" class="headerlink" title="（字符型）"></a>（字符型）</h4><p>&emsp;&emsp;这个字符型为什么会打了一个括号，是因为这个数据类型在Go语言中不存在，不过在其他语言中是存在的，对于后面字符串的引出也是即为重要的，因此单独做出介绍。在前面我们介绍编码的时候就提及过，最初的计算机只能应用在英语的环境中，而大小写英文字母的数量加一些转义字符的数量也不超过256个。因此最初字符是可以通过一个8位的整数来表示，这便是我们在介绍整数的时候byte的用法。</p><p>&emsp;&emsp;在后面计算机到了各国之后，不同国家开始应用各个国家的字符集，例如中国汉字，其个数就远超了256个，因此一个byte的空间就没有办法进行存储汉字了，而UTF-8编码格式又融入了所有国家的所有的字符编码，于是就需要寻找容量更大的存储方式，在Go语言中我们采用int32的数据类型来存储汉字，为了区分字符与整数的表示方式，我们采用rune的方式表示。</p><p>&emsp;&emsp;虽说字符一般采用byte和rune的方式进行定义与表示，其核心本质依旧是uint8和int32，所以说Go语言中不存在字符型的变量，传统的字符型都用整数来表示了。</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>&emsp;&emsp;在其他的编程语言中，往往会把字符串作为复杂数据类型来划分，但是字符串同时在编程中应用地十分地普遍，因此Go语言便也把它划分在基础数据类型中。字符串是一个不可改变的字节序列，可以理解为多个字符拼接而成的常量，用双引号所包含（如入门程序中的”Hello World”）。字符串可以包含任何的数据，文本字符串通常会表示为UTF-8编码的rune序列。在这里只是提一句字符串的概念，在后续学习中，我们会针对于字符串及其自带的函数做出详细地讲解。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这两个小节中，我们集中介绍了数据的存储形式，介绍了原码，反码和补码。并通过对这三种码制引出了Go语言的基本数据类型，这几种类型将会在下几小节中详细地叙述。在下一节中，我们将会主要介绍变量与常量的概念，命名规则以及针对基本数据类型定义过程的一些例子。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;6&gt; 数据与数据的存储&lt;一&gt;</title>
      <link href="/2020/02/09/6-%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%80/"/>
      <url>/2020/02/09/6-%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-6-gt-数据与数据的存储-lt-一-gt"><a href="#Go语言从入门到放弃系列-lt-6-gt-数据与数据的存储-lt-一-gt" class="headerlink" title="Go语言从入门到放弃系列&lt;6&gt; 数据与数据的存储&lt;一&gt;"></a>Go语言从入门到放弃系列&lt;6&gt; 数据与数据的存储&lt;一&gt;</h2><p>&emsp;&emsp;在上一个小节中，我们集中说明了一些二进制相关的事，介绍了不同进制之间的转换规律以及该规律的原理，并对二进制有了最基本的认识。那么在这个小节中，我们将基于二进制的知识，引出基本数据类型的存储格式，介绍到原码，反码和补码的知识，进而对Go语言的数据类型进行简要的引出。</p><h3 id="原码，反码，和补码"><a href="#原码，反码，和补码" class="headerlink" title="原码，反码，和补码"></a>原码，反码，和补码</h3><p>&emsp;&emsp;我们回顾一下自己对数字的认识过程，相信大多数人都经历了如下的过程。在很小的时候只知道正数，然后到了初中开始接触负数，之后再考虑到0这个特殊的数字。那么我们就暂时遵循这个过程，对这几种码制作出阐述。可以说，大家对于正数的了解是普遍的，日常生活中也经常会出现与正数打交道的情况。那么对于正数，计算机是如何存储的呢。</p><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>&emsp;&emsp;读过上一个小节的人们可能会直接想到，无非就是把十进制的正数转换成二进制的数而已，这个想法是正确的，只不过是在现有的想法上加上一个符号位，而这个符号位则是最高位，同时我们将符号位的0作为正数的标志，符号位的1就作为负数的标志，因此，对于106这个十进制正数而言，其带符号位的二进制数是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01101010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最高位的0代表了正数。相信大家很容易接受这种表示方式，毕竟改变不是很大。当我们对正数做完阐述之后，我们可能会想到，既然如此，我们将符号位置1，其余的不变，就可以表示对应的负数了。确实这是一种表示方法，也就是我们今天所提及的原码方式。对于-106而言，其二进制数为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11101010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是现在问题就来了，这种方式虽然存储起来很方便，但是对计算而言是极为的不利的。例如，我们每个人都知道的一个等式&nbsp;-1+1=0&nbsp;在计算机用原码表示来计算就会出现错误，我们列举一下计算过程，假设我们依旧用8位来表示每一个数字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000001</span>+<span class="number">10000001</span>=<span class="number">10000010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们会发现结果是-2，而不是0。不仅如此，任何一个正数与一个负数相加，其结果都是负数，因为符号位的0+1=1。很显然，这种数制的表示方法并不能完成计算的任务，因此我们引进了反码。</p><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>&emsp;&emsp;正数的反码与原码是相同的，负数的反码则是符号位不变，其余的位数取反。比如说，对于-106而言，其反码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10010101</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么反码的好处在哪里呢，我们依旧回到-1+1=0的问题上，根据我们上述所说，-1的反码为：11111110，+1的反码为：00000001，那么两个数字相加，我们会得到11111111，对此结果我们再取反码，得到了10000000，换算成十进制为-0，其计算结果是可以接受的，但是现在我们依旧存在一个问题，即+0与-0的问题。</p><p>&emsp;&emsp;不仅如此，即便是在一次计算中真值部分得到了正确的结果，但涉及到中途结果为-0的时候，就又一次出现了问题，我们举一个简单的例子，我们都知道，-1+1+1=1，那么我们采用反码的形式再一次做出计算：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11111110</span>+<span class="number">00000001</span>+<span class="number">00000001</span>=<span class="number">100000000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在计算之前，我们首先假定了由8位构成一个数字，那么计算结果应该也是由8位构成，但是我们的到的结果是9位，因此计算机选择的是忽略掉溢出的位置，因此结果为00000000，也就是我们所说的10进制的0。这个结果显然是不能接受的，而导致这个不可接受的结果的原因则是这个-0的参与运算。因此，单纯地采用补码来运算依旧不是一个很好的方法，接下来，我我们将对补码进行简要地介绍。</p><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>&emsp;&emsp;首先，我们需要对补码有一个相对直观的认识，举一个很常见的例子，就是我们平日生活中的钟表。我们假设时针指向12的时候为0点，时针顺时针为正，逆时针为负，并且以时针指向6为分界，即小于6的时候为正值，大于6点为负值。同时我们采用上一章节所提及的“模”的概念，即在时钟的周期中模为12。</p><p>&emsp;&emsp;现在我们转换一下思想，在上述情况下所说的-1点，就是平时我们称的11点，同时上述情况下所称的1点依旧是平时我们所想的1点，这便是补码的一种直观的思想。即负数可以表示为：<strong>周期的模减去该负数的绝对值</strong>，比如说：-1点即11点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>-abs(<span class="number">-1</span>)=<span class="number">11</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么现在我们回过头来看一下-3用补码是怎样表示的，首先我们依旧假设用8位来表示一个数字，那么8个二进制位所能表示的数字的模是多少。十进制的模是十，是个位为0同时其高位为1，那么8个二进制位的模当然就是八个位都是0，而其高位（借来的第九位）为1：100000000。同时，-3的绝对值是3，其二进制表示方法为：00000011。现在我们将其相减，得到的-3的补码是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11111101</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在我们对-3的补码和-3的原码进行对比，并从中寻找一个转换的规律。我们说，-3的原码为：10000011，-3的补码为：11111101，我们可以发现，补码的转换规则为：<strong>正数的补码是原码本身，负数的补码是，符号位不变，从右向左找到第一个1不变，这个1向左的各位取反。</strong></p><p>&emsp;&emsp;再一次回到-1+1+1的问题上，我们知道-1的表示方法为：模-1，那么-1+1便是：模-1+1=模。根据上述的说明，模的表示方法为：各个位数为0，高位为1，而高位在计算中会溢出而不做计算，因此结果为0，这个+0再加上任何的数字就是正常的数字了。现在我们已然解决了正0的问题，那么原来的-0究竟表示了什么呢。</p><p>&emsp;&emsp;通过上述的描述，我们知道了负数的表示方法，那么我们可以这样来想，模减去某个负数的绝对值等于了“-0”，因此这个“某个负数”的绝对值便是模的大小，取负数之后便是其可以表示的数。因此，原来的-0即表示了-模长。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在本节中，我们集中介绍了计算机存储数据的方法，即原码、反码、和补码的概念，并分别阐述了这三种表示方式的来由。在下一小节中，我们将介绍数据类型的概念，计算机内存中如何表示整数、小数、字符等等，并对其可表示范围作出讲解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;5&gt; 二进制浅谈</title>
      <link href="/2020/02/08/5-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%85%E8%B0%88/"/>
      <url>/2020/02/08/5-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%85%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-5-gt-二进制浅谈"><a href="#Go语言从入门到放弃系列-lt-5-gt-二进制浅谈" class="headerlink" title="Go语言从入门到放弃系列&lt;5&gt; 二进制浅谈"></a>Go语言从入门到放弃系列&lt;5&gt; 二进制浅谈</h2><p>&emsp;&emsp;在上一个小节中，我们集中阐述了Go语言的一些命令，并对其中的几个常用命令进行讲解，在这一小节中，我们将对进制的概念进行阐述，并且对进制之间的相互转换进行详细地说明。</p><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>&emsp;&emsp;说起进制，大家似乎都不陌生，因为我们每天都在以十进制的形式计数，那么什么是十进制呢，便是逢十进一。换句话说，在十进制数中每一个位都可以存放十种不同的数字，分别为0到9，当当前的数字为9的时候，再向上加1，就需要向更高的位进1，而自身的数字归零。在这里，我们也可以称这种计数单位的模为10。</p><p>&emsp;&emsp;如果我们沿用上述的方式，换一种思路，将逢十进一的概念转变为逢二进一，似乎二进制的概念就会比较好理解了。在十进制中，每个位都可以有10种数字，在二进制中，每个位只有两种形式，分别为0和1。在当前位为1的时候再加1，便向更高位进1，自身的数字归零。这便是二进制的计数方式。</p><p>&emsp;&emsp;为什么计算机会采取二进制的形式用来表示数据，是因为二进制是世界上比较常见的一种进制方式，尽管我们我日常生活中并不常用。开关的闭合或开启、逻辑的真与假、电容器是否具有电势等，都是两种状态之间的互相转换。在数字电路中，高电平与低电平也代表两种不同的逻辑态。对于完全由电路构成的计算机而言，主要处理的便是逻辑运算，因此二进制当然也就再合适不过了。</p><h3 id="二进制向十进制的转换"><a href="#二进制向十进制的转换" class="headerlink" title="二进制向十进制的转换"></a>二进制向十进制的转换</h3><p>&emsp;&emsp;虽说计算机非常喜欢二进制的计数方式，但是似乎人们并不喜欢，因为从小到大所接触到的都是十进制的世界，为了更好地理解数字的本质，我们需要了解不同进制之间的转换规则。同样地，我们先从十进制出发，例如我首先写下一个数字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不出意外的话，每个人都能迅速地说出来这个数字是十二万三千四百五十六，那么为什么这个一串的字符就可以表示出这个数字呢，是因为这个结果是可以通过某种计算方式而得到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X=<span class="number">1</span>*<span class="number">10</span>^<span class="number">5</span>+<span class="number">2</span>*<span class="number">10</span>^<span class="number">4</span>+<span class="number">3</span>*<span class="number">10</span>^<span class="number">3</span>+<span class="number">4</span>*<span class="number">10</span>^<span class="number">2</span>+<span class="number">5</span>*<span class="number">10</span>^<span class="number">1</span>+<span class="number">6</span>*<span class="number">10</span>^<span class="number">0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果理解了上述的这个公式，那么对于二进制而言，我们仿照这个计算模式，将其迅速地转换为十进制的表达方式，例如如下的这个二进制数字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11001010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X=<span class="number">1</span>*<span class="number">2</span>^<span class="number">7</span>+<span class="number">1</span>*<span class="number">2</span>^<span class="number">6</span>+<span class="number">0</span>*<span class="number">2</span>^<span class="number">5</span>+<span class="number">0</span>*<span class="number">2</span>^<span class="number">4</span>+<span class="number">1</span>*<span class="number">2</span>^<span class="number">3</span>+<span class="number">0</span>*<span class="number">2</span>^<span class="number">2</span>+<span class="number">1</span>*<span class="number">2</span>^<span class="number">1</span>+<span class="number">0</span>*<span class="number">2</span>^<span class="number">0</span>=<span class="number">202</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果继续向下总结的话，我们可以得到一条规律，从任何进制向十进制的转换规律为：第i位的数字乘以模的i次幂的求和（i从0开始）。根据这个规则，我们就可以自行理解八进制和十六进制，乃至于其他进制向十进制转换的规则了。</p><h3 id="十进制向二进制的转换"><a href="#十进制向二进制的转换" class="headerlink" title="十进制向二进制的转换"></a>十进制向二进制的转换</h3><p>&emsp;&emsp;在这个部分中，我们换一种方法来表示二进制向十进制转换过程，所举的例子依旧是上方提到的两个数字，我们可以分别表示为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123456</span>=(((((<span class="number">1</span>*<span class="number">10</span>)+<span class="number">2</span>)*<span class="number">10</span>+<span class="number">3</span>)*<span class="number">10</span>+<span class="number">4</span>)*<span class="number">10</span>+<span class="number">5</span>)*<span class="number">10</span>+<span class="number">6</span></span><br><span class="line"><span class="number">202</span>=(((((((<span class="number">1</span>*<span class="number">2</span>)+<span class="number">1</span>)*<span class="number">2</span>+<span class="number">0</span>)*<span class="number">2</span>+<span class="number">0</span>)*<span class="number">2</span>+<span class="number">1</span>)*<span class="number">2</span>+<span class="number">0</span>)*<span class="number">2</span>+<span class="number">1</span>)*<span class="number">2</span>+<span class="number">0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们会发现这种表达方式和上述的表达方式的结果是一致的，那么我们为什么采用这种表述方式，是因为在这种表达方式中，我们可以很直观地理解如何从十进制转回到二进制中。如果我们将转回的过程看做上述过程的一个逆过程，答案就会很简单了。我们用两个未知数来表示上述表达式中的两个部分，我们会发现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">202</span>=X*<span class="number">2</span>+Y  （X，Y为整数）</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;虽说这个二元一次方程具备很多的解，但是联合二进制的规定，我们会加一个条件，即Y&lt;2。这样，我们就会轻而易举地得出X为101，Y为0，也就是说，我们得到了二进制的最后一位。接下来，我们针对101进行分析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">101</span>=X*<span class="number">2</span>+Y</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个方程中，我们可以得到X为50，Y为1，这样我们就得到了倒数第二位的数值，如果一直重复上述过程，我们将会得到二进制的最终结果。换句话说，十进制整数向二进制的转换规则为：该数字除以模数向下取整，取余数，最后将余数倒序输出，即为二进制数。这个规则同样也适用于十进制向任何一个进制转换的过程。</p><h3 id="浮点数的进制转换"><a href="#浮点数的进制转换" class="headerlink" title="浮点数的进制转换"></a>浮点数的进制转换</h3><p>&emsp;&emsp;说完整数的数制转换后，我们对浮点数（小数）的进制转换做出简要的说明。在说明之前，我们首先思考一个问题，根据上述的二进制转十进制的规则来看，对于一个<strong>有限位数的整数</strong>而言，是否每一个二进制数都有一个有限位数的十进制数相对应，是否每个十进制数都有一个有限位数的二进制数相对应。两个答案都是肯定的。那么对于小数而言，上述两句话还是否依旧成立？</p><p>&emsp;&emsp;我们以以下的这个二进制数为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1011</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个二进制数转换成十进制数是多少呢，根据刚刚所讲的计算规律，我们将之拓展，就会发现它可以通过这种方式来表示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X=<span class="number">1</span>*<span class="number">2</span>^(<span class="number">-1</span>)+<span class="number">0</span>*<span class="number">2</span>^(<span class="number">-2</span>)+<span class="number">1</span>*<span class="number">2</span>^(<span class="number">-3</span>)+<span class="number">1</span>*<span class="number">2</span>^(<span class="number">-4</span>)=<span class="number">0.6875</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种二进制小数向十进制小数的转换方式是非常容易的，可以说依旧遵循着第i位的值乘以模的i次幂的求和。那么对于小数而言，如何将这个小数转回到二进制的表示方式。现在我们首先假设二进制的每一位为Xi，那么对于上述的小数我们可以表示为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.6875</span>=(X0)*<span class="number">2</span>^(<span class="number">-1</span>)+(X1)*<span class="number">2</span>^(<span class="number">-2</span>)+(X2)*<span class="number">2</span>^(<span class="number">-3</span>)+(X3)*<span class="number">2</span>^(<span class="number">-4</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来，我们在等式两边同时乘以2，我们即可以得到如下的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.375</span>=(X0)+(X1)*<span class="number">2</span>^(<span class="number">-1</span>)+(X2)*<span class="number">2</span>^(<span class="number">-2</span>)+(X3)*<span class="number">2</span>^(<span class="number">-3</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么对于上述这个等式进行分析，以及二进制的限制我们还可以知道X0、X1、X2、X3均小于2，并且只有X0可以代表整数位，我们便可以得到X0的值为1。接下来等式两边再同时减去X0的值，我们可以得到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.375</span>=(X1)*<span class="number">2</span>^(<span class="number">-1</span>)+(X2)*<span class="number">2</span>^(<span class="number">-2</span>)+(X3)*<span class="number">2</span>^(<span class="number">-3</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;重复上述的过程，我们可以得到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.75</span>=(X1)+(X2)*<span class="number">2</span>^(<span class="number">-1</span>)+(X3)*<span class="number">2</span>^(<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因此，只有X1的值可以表示整数位的值，即X1的值为0，以此类推，我们最终是可以得到1011的值的。通过这个过程，我们可以得到这样的一个小数的转换规则：该小数乘以模，取整数位的值，顺序输出。</p><p>&emsp;&emsp;我们回到刚刚提出的那个问题，是否每一个有限位数的二进制小数都有一个有限位数的十进制小数向对应，这个结果是是的，根据本节提到的公式也可以得到这个结果。那么是否每一个有限位数的十进制小数都有一个有限位数的二进制小数相对应，这个结果是否定的，比如十进制中的0.1就无法用有限位数的二进制进行表示，它是一个无限的循环小数。计算机只能无限地去接近这个数，却永远也无法精确地达到这个小数的真值。其具体原因，我目前尚不能明确地说清楚，也希望大家可以考虑一下，相信在考虑的过程中会有一定的收获。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;经过上述的一些讨论过后，我们集中说明了十进制与二进制的互相转化规律，将此推广，其他进制之间的转换规律也如出一辙，简而化之的记忆口诀就为<strong>除模取余，逆序排序，乘模取整，顺序输出</strong>。我们最后再用一张图片演示进制的过程。（图片转自网络）</p><p><img src="/2020/02/08/5-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%85%E8%B0%88/1.jpg" alt></p><p>&emsp;&emsp;在下一个小节中，我们将介绍二进制表示数字的几种形式，原码，反码以及补码，通过对这三种码制的介绍，我们引出基本数据类型的概念，以及变量和常量的问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;4&gt; 常用的Go命令</title>
      <link href="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-4-gt-常用的Go命令"><a href="#Go语言从入门到放弃系列-lt-4-gt-常用的Go命令" class="headerlink" title="Go语言从入门到放弃系列&lt;4&gt; 常用的Go命令"></a>Go语言从入门到放弃系列&lt;4&gt; 常用的Go命令</h2><p>&emsp;&emsp;在上一节中，我们集中对快速入门程序Hello World的编写做出了简要的讲解，同时对包的概念，引入的方式，主函数的执行流程做出基本的介绍。在这一节中，我们将对Go语言的中命令行的常用命令进行介绍。</p><p>&emsp;&emsp;相信许多初学者通过集成开发工具进行入门开发时，将两个go文件写在了同一个文件夹下，同时又都具备main函数，在用ide运行的时候报出了错误，我们从这个错误引入到今天的命令的介绍中。</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/1.png" alt><br><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/2.png" alt></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>&emsp;&emsp;在上一节中，我们提出了包的概念，并且说明了一个项目中只能存在一个main函数，而一般来说，ide的编译运行是以工程为基础。换句话讲，便是以文件夹为基础的编译。因此当开发工具检测到同一个文件夹中含有两个或多个main函数时，会报出主函数重定义的错误。</p><p>&emsp;&emsp;1. 第一个解决办法当然便是将不同的go文件分放在不同的文件夹下，这样使得每个文件夹即每个工程都可以单独地进行编译以及运行，不过对于初学者来说这种做法尚不甚方便，到目前为止乃至于之后一段时间内所写的Demo性质的程序往往都是以单个文件为基础的，因此这个方法对于目前来说不是很适用。</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/3.png" alt></p><p>&emsp;&emsp;2. 第二个解决办法便是通过Go语言的命令行形式进行编译运行，就如同在前几节所提及的那样，通过控制台的cd命令进入到go文件所在的目录，然后运用go run命令进行运行，这种方式是以单个文件的方式进行编译的，因此不会报出重定义的错误。go语言的命令相对来说并不多，常用的也就更少了，我们会在下面着重讲述几个命令。</p><h3 id="常用的Go命令"><a href="#常用的Go命令" class="headerlink" title="常用的Go命令"></a>常用的Go命令</h3><p>&emsp;&emsp;如果在控制台直接输入go help命令，我们会发现系统提示了许多的可用命令，在这里便列一个表格，分别简单解释一下每个命令的含义。在后面我们也会针对其中的几个进行详细地讲解。</p><table><thead><tr><th>Go命令</th><th align="center">含义</th></tr></thead><tbody><tr><td>build</td><td align="center">编译包和依赖</td></tr><tr><td>clean</td><td align="center">移除对象文件</td></tr><tr><td>doc</td><td align="center">显示包或者符号的文档</td></tr><tr><td>env</td><td align="center">打印go的环境信息</td></tr><tr><td>bug</td><td align="center">启动错误报告</td></tr><tr><td>fix</td><td align="center">运行go tool fix</td></tr><tr><td>fmt</td><td align="center">运行gofmt进行格式化</td></tr><tr><td>generate</td><td align="center">从processing source生成go文件</td></tr><tr><td>get</td><td align="center">下载并安装包和依赖</td></tr><tr><td>install</td><td align="center">编译并安装包和依赖</td></tr><tr><td>list</td><td align="center">列出包</td></tr><tr><td>run</td><td align="center">编译并运行go程序</td></tr><tr><td>test</td><td align="center">运行测试</td></tr><tr><td>tool</td><td align="center">运行go提供的工具</td></tr><tr><td>version</td><td align="center">显示go的版本</td></tr><tr><td>vet</td><td align="center">运行go tool vet</td></tr></tbody></table><h4 id="build和run命令"><a href="#build和run命令" class="headerlink" title="build和run命令"></a>build和run命令</h4><p>&emsp;&emsp;正如同其他的静态语言一般，Go语言也是需要先编译再运行的。编译过程产生可执行文件，如Windows中的exe文件，之后再运行该可执行文件。而go build命令就是用来编译的，并不是所有的go程序都会编译出可执行文件，其条件即为：go程序属于main包、main包中包含main函数。现在假如在test文件夹中只有一个TestDemo.go文件，我们通过命令行定位到该位置后，键入go build TestDemo.go后，结果将如下图所示：</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/4.png" alt></p><p>&emsp;&emsp;从上图我们可以发现，build命令会生成一个与go文件相同名的可执行文件，进而执行该文件可以得到输出结果。可是往往我们在实际开发中，并不希望生成的可执行文件与go文件是同名的，在另一些情况下多个go程序生成的名字是相同的时候，会覆盖旧版本的exe文件（在大工程中很容易出现）。因此我们希望在编译过程中将生成的结果修改名字，其命令为： go build -o 新名字 go文件。</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/5.png" alt></p><p>&emsp;&emsp;而go run的方法则是将编译和运行两个步骤合并为一个步骤，因此我们在使用go run命令时，在当前的文件夹中或其他的位置是找不到可执行文件的生成的，这很适用于程序开发中的调试阶段，具体便不做演示了。</p><h4 id="fmt以及doc命令"><a href="#fmt以及doc命令" class="headerlink" title="fmt以及doc命令"></a>fmt以及doc命令</h4><p>&emsp;&emsp;在上一节中我们演示到一个问题，就是大括号的位置问题。同时，Go语言有一个特性，便是对格式的要求十分的严格。不同的开发者对这个特性的看法不一，不过也是需要遵守这个格式的。各个开发者的格式是统一的，便利于组合开发以及代码的清晰。go fmt命令便是格式化代码，将代码根据规定的格式进行调整。其格式为：go fmt xxx.go，这个也不做演示了，而且一般情况下也不要手动去调用，一般的集成开发工具都会自动帮助我们去调整。</p><p>&emsp;&emsp;doc命令是查看文档的命令，例如我们在使用fmt包的时候忘记了某个函数如何去写，或希望查到某个函数的具体含义，可能就会用到这个命令，其格式为:go doc package，在终端上就会显示这个包的文档。由于控制台的大小有限，一般来说直接go doc一个包会显示不全。不过我们可以使用go doc package.function来查具体的功能。</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/6.png" alt></p><p>&emsp;&emsp;还有一个比较好的一点是，这个命令可以启动我们自己的文档服务器，比如说我们使用godoc -http=:10000(数字可以随意，不过需要大于1024)，之后打开一个浏览器，在网址栏中输入localhost:10000我们会发现出现了图形界面的帮助文档，可以离线地、更方便地查询信息。</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/7.png" alt></p><h4 id="get和install命令"><a href="#get和install命令" class="headerlink" title="get和install命令"></a>get和install命令</h4><p>&emsp;&emsp;get命令也是十分常用的命令，我们可以通过这个命令来直接从网上下载第三方的包，调用方式为go get source。如果本地已经存有该文件，便会更新指定的代码和依赖，如果使用go语言操作redis数据库，下载并使用beego的web框架时等，会通过这个命令进行下载。</p><p>&emsp;&emsp;install命令与build命令十分的相像，其结果都是生成一个可执行程序，不同点便是生成的可执行文件的路径、名字、以及依赖包。这时我们需要在环境变量中配置GOBIN变量，这个变量的值便是GOPATH下的bin目录，在这里我们简要地演示一下。</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/8.png" alt></p><p>&emsp;&emsp;那么install和build的区别具体可用如下的表格来表示:</p><table><thead><tr><th>区别</th><th align="left">install</th><th align="center">build</th></tr></thead><tbody><tr><td>生成可执行文件路径</td><td align="left">在工作目录的bin目录下，或GOBIN下</td><td align="center">当前目录下</td></tr><tr><td>可执行文件名</td><td align="left">和源码所在的目录同名</td><td align="center">与go文件同名，或-o设定</td></tr><tr><td>依赖包</td><td align="left">在工作目录的pkg文件夹中</td><td align="center">-</td></tr></tbody></table><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小结中，我们初步解决了在Demo演示过程中出现的主函数重定义问题，以及介绍了一些Go语言中相对常用的几个命令。在下一小节中，我们将集中讲解进制相关的一些问题，进而在后续的文章中引出数据类型的概念以及其可以表示的大小的限制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;3&gt; 基于Hello World的几点讨论</title>
      <link href="/2020/02/06/3-%E5%9F%BA%E4%BA%8EHelloWorld%E7%9A%84%E5%87%A0%E7%82%B9%E8%AE%A8%E8%AE%BA/"/>
      <url>/2020/02/06/3-%E5%9F%BA%E4%BA%8EHelloWorld%E7%9A%84%E5%87%A0%E7%82%B9%E8%AE%A8%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-3-gt-基于Hello-World的几点讨论"><a href="#Go语言从入门到放弃系列-lt-3-gt-基于Hello-World的几点讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;3&gt; 基于Hello World的几点讨论"></a>Go语言从入门到放弃系列&lt;3&gt; 基于Hello World的几点讨论</h2><p>&emsp;&emsp;在第一个小节中，我们阐述了Go语言环境的安装与配置，同时也写了一小段的程序来验证开发环境是否正确配置。那么在这一节中，我们集中针对于这段代码自上而下进行几点简要的讲解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hello World的编写</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go语言代码注释"><a href="#Go语言代码注释" class="headerlink" title="Go语言代码注释"></a>Go语言代码注释</h3><p>&emsp;&emsp;Go语言的注释风格依旧遵循了C语言的注释风格，即采用两个斜杠（//）对单行注释，同时也支持/*…*/的方式对代码块进行注释。一般来说，行注释更为通用，块注释主要是针对包的详细说明或者屏蔽更大的代码块而使用的。 </p><p>&emsp;&emsp;注释的作用往往是为了标注某个变量、代码块、或者函数等的具体功能，以备后续维护时能够快速地理解代码的含义。因此在实际开发中，强烈建议每个包都具备一个注解，即package前的注解，这个注解会详细介绍此包、提供相应的包信息、注明作者引用等等。</p><p>&emsp;&emsp;处在注释中的语句是不执行的，同样地，在编译的过程中也不会参与编译的过程。因此，不必担心写太多的注释会令可执行文件增大。注释出现的位置也是十分地灵活，可以出现在某行中，也可以出现在某条语句的结尾，但不可以出现在某条语句的中间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//注释可以出现在某行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;<span class="comment">//也可以出现在某语句的结尾</span></span><br><span class="line">fmt.Println(<span class="string">"您好世界"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go语言的包"><a href="#Go语言的包" class="headerlink" title="Go语言的包"></a>Go语言的包</h3><p>&emsp;&emsp;同一些其他的语言一样，Go语言是以包package作为管理单位，如果针对于文件系统可以理解为以文件夹为管理单位。因此，每个Go文件都需要声明包，并且只能存在于一个包内。不仅如此，每个程序中都必须要有一个main包，如果没有main包是无法编译通过的。</p><p><img src="/2020/02/06/3-%E5%9F%BA%E4%BA%8EHelloWorld%E7%9A%84%E5%87%A0%E7%82%B9%E8%AE%A8%E8%AE%BA/2.png" alt></p><p>&emsp;&emsp;在日后的开发过程中，package的名字当然可以不是main，但是具备main函数的go文件必须是main包，因此在开发中，尤其指多人的开发中，每个程序员负责自己的部分，便会以包的名字建立一个文件夹，只是不在其中写main函数，这个问题我们在后面的一些章节会再次提及。由于我们目前的开发均在一个文件中，不需要跨越文件编程，因此在习惯上暂且先都写package main即可。</p><h3 id="包的引入"><a href="#包的引入" class="headerlink" title="包的引入"></a>包的引入</h3><p>&emsp;&emsp;在开发的过程中往往需要使用开发者所提供的函数，或者其他人的代码，这时就需要将这个包进行引入操作，所用的关键字为import。fmt包是我们接触到的第一个引用的包，这个包的作用是提供了许多的格式化输出的函数。当我们希望在屏幕上打印出某行汉字的时候，我们不需要了解其内部的过程，如何让屏幕的像素点亮起来，我们只需要知道调用该包的特定函数可以完成需求。当然，fmt包中不仅仅具备格式化输出的函数，随着学习的深入，我们将会接触到更多的包和相应的函数。</p><p>&emsp;&emsp;有时候在程序开发的过程中，我们可能不仅仅需要引用一个包，而是需要引入多个包。比如说，我希望生成一个随机数，并且采用当前时间为种子进行随机生成，最后将这个随机数打印在屏幕上（这个案例我们后续会讲到）。那么，我们可能需要多个包，生成随机数需要一个包，获取时间需要一个包，打印在屏幕上需要一个包，因此需要多个包的引入。引入的方式有两种，分别为：多个import关键字，一个import后加一个小括号，将包写于括号中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"math/rand"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="主函数及大括号"><a href="#主函数及大括号" class="headerlink" title="主函数及大括号"></a>主函数及大括号</h3><p>&emsp;&emsp;每一个项目中都需要有一个主函数，注意这不是指每一个Go文件都有一个主函数。主函数作为程序的入口，往往会最先被执行（这个说法不好，后面会对这句话进行更正，初期可以先这样理解）。声明函数的关键字func即function的前四个字母，main为函数名，后面的括号为函数参数，大括号所包裹的代码即为函数体（在函数的章节中会详细讲）。程序便从大括号后的第一行开始执行，直到函数的结束。</p><p>&emsp;&emsp;与一些传统的编程语言相不同的是，Go语言语句后不需要以分号为结尾。同时，大括号的位置也不如C语言等那样灵活。Go语言的规定是：左大括号的位置一定需要是某个块定义的结尾，而不能单独另取一行，否则在编译时是无法通过的。</p><p><img src="/2020/02/06/3-%E5%9F%BA%E4%BA%8EHelloWorld%E7%9A%84%E5%87%A0%E7%82%B9%E8%AE%A8%E8%AE%BA/5.png" alt></p><h3 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h3><p>&emsp;&emsp;在日后的计算机的学习中，我们将会接触到计算机程序的三大流程控制，分别为：顺序结构、分支结构、和循环结构。我们今天所接触到的便是其中的第一个：顺序结构。</p><p>&emsp;&emsp;顺序结构的核心思想是，程序从上至下逐条依次执行，每一条都会被执行，而且每条都会被执行一次。例如我们在程序中令其多次输出几个字符串，我们会发现结果的输出与程序中的输出顺序是相一致的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"您好世界 1"</span>)</span><br><span class="line">fmt.Println(<span class="string">"您好世界 2"</span>)</span><br><span class="line">fmt.Println(<span class="string">"您好世界 3"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段代码的输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">您好世界 <span class="number">1</span></span><br><span class="line">您好世界 <span class="number">2</span></span><br><span class="line">您好世界 <span class="number">3</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在我们后续讲到函数，并且提及defer关键字时，会对现有的理解的顺序结构产生冲击，这个问题我们在日后会详细地进行讲解。</p><p>&emsp;&emsp;在程序中，我们可以看到的是，函数的调用往往是需要包的存在的，也就是说Println函数是属于fmt包的，即便是自己定义的函数，也是属于当前的package的。如果不通过fmt包，就无法直接使用Println函数，也就无法通过这个函数向屏幕中输出了。还有一个需要注意的点是：当引入了某个包，但是这个包并没有在程序中被使用，也是不允许的。在编译过程中会报如下的错误： </p><p><img src="/2020/02/06/3-%E5%9F%BA%E4%BA%8EHelloWorld%E7%9A%84%E5%87%A0%E7%82%B9%E8%AE%A8%E8%AE%BA/7.png" alt></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们针对快速入门程序，Hello World的输出程序，进行了几点简要的讨论，分别讲解了注释的用法，包的概念的入门，主函数的作用，以及函数体中的顺序结构。同时，也对开发中的几点小细节做出了说明，如大括号位置，包的使用等等。</p><p>&emsp;&emsp;在下一小节中，我们将讲解一些cmd命令行中与Go相关的一些命令，并集中讲解几个常用的命令以及实际过程中的运用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;2&gt; 编码及几种ide的介绍</title>
      <link href="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-2-gt-编码及几种ide的介绍"><a href="#Go语言从入门到放弃系列-lt-2-gt-编码及几种ide的介绍" class="headerlink" title="Go语言从入门到放弃系列&lt;2&gt; 编码及几种ide的介绍"></a>Go语言从入门到放弃系列&lt;2&gt; 编码及几种ide的介绍</h2><p>&emsp;&emsp;在这个小节中，我们首先介绍几个实用的常用的Go语言的集成开发工具，并对几种工具做一个简要的比较，集成开发工具的选择会方便程序员对程序的编写，但对于语言本身来说是基本没有关系的。因此，不必过于纠结于集成开发工具的选择，做到能用、方便、正确即可以。同时，对于初学者来说，建议使用功能不是十分强大的开发工具，这样能相对强制性地记住更多的基本的语法与应用。</p><h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p>&emsp;&emsp;在这一小节中，我们首先介绍计算机中的编码格式，通过对编码格式的叙述引入对ide的介绍。编码是用预先规定的方法将文字、数字或其它对象编成数码，或将信息、数据转换成规定的电脉冲信号（引用自百度百科）。通俗一点解释便是，将每个字符（汉字、字母等）与计算机中的数字相关联。字符是有限的，而数字是无限的，因此，每一个字符必定能对应于一个数字，这个对应关系便是编码。 </p><p>&emsp;&emsp;目前来说，对于中国的用户而言，常见的编码格式有ASCII、ANSI、GBK、GB2312、UTF-8等等。不同的编码格式有不同的对应关系，因此在网络传输时，或者在打开文件时，如若对应的编码格式是不一致的，内容就会显示为乱码。</p><p>&emsp;&emsp;从计算机对多国语言的支持程度上来分，编码可以分为三个阶段。第一个阶段是计算机的初期，只在美国国内通用时，是只支持英文显示的，而其他国家的语言是无法显示的。在这个阶段的代表性编码规则为ASCII码。随着计算机的国际通用，各国均开始研发适应于本国的编码规则，也为第二阶段，不同的国家制定了不同的标准，出现了采用两个字节代表一个字符的汉字延伸编码方式，称为ANSI编码，如GB2312等。然而不同国家的ANSI编码依旧不兼容。所以便进入了第三个阶段，UNICODE编码，这种编码为每一个国家、每一种语言、每一个字符均设定了统一的且是唯一的数字编号，以满足跨语言，跨平台的特性，代表字符集为UTF-8编码。</p><p> &emsp;&emsp;对于Go语言来说，为了出现字符集的冲突与乱码的形成，官方规定：所有的字符编码均为<strong>UTF-8</strong>编码，如果采用了其他的编码样式，程序是无法编译通过的。采用上一个小节所举的例子，将编码改为ANSI后并输入对应的中文，运行时会出现如下的效果：</p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/1.png" alt></p><p>&emsp;&emsp;在将字符集恢复成UTF-8编码之后，就恢复了正常的显示。所以在各个集成开发工具中，默认的字符编码均为UTF-8编码，所以在使用工具时，可以不需要担心这个问题。</p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/2.png" alt></p><h3 id="几种集成开发工具的介绍"><a href="#几种集成开发工具的介绍" class="headerlink" title="几种集成开发工具的介绍"></a>几种集成开发工具的介绍</h3><h4 id="1-LiteIDE"><a href="#1-LiteIDE" class="headerlink" title="1. LiteIDE"></a>1. LiteIDE</h4><p>&emsp;&emsp;LiteIDE是一款开源的简单的IDE，同时也是Go语言的首个发布的正式版的IDE，通过QT开发，是专门为了Go语言而设计的。在LiteIDE中，可以直接配置构建命令，高级代码编辑，代码管理，自动完成格式化等多个功能。是一个十分轻量级且功能强大的小开发工具。</p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/3.png" alt></p><h4 id="2-VSCode"><a href="#2-VSCode" class="headerlink" title="2. VSCode"></a>2. VSCode</h4><p>&emsp;&emsp;VSCode是微软开发的一个开源IDE，单独这款IDE本身不支持Go语言开发，需要在IDE中进行Go语言的扩展，也是十分方便的。同样地，VSCode的诸多插件也为开发者提供了许多的功能。不仅如此，它也提供了多种语言的支持，使之成为广受欢迎的集成开发工具。</p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/4.png" alt></p><h4 id="3-GoClipse插件"><a href="#3-GoClipse插件" class="headerlink" title="3. GoClipse插件"></a>3. GoClipse插件</h4><p>&emsp;&emsp;看到这个名字可能会比较熟悉，会想起一款名为eclipse的开发工具，GoClipse正是eclipse的插件，通过使用这个插件，开发者可以通过流行的eclipse开发工具进行go语言的开发，其优点是高度的可扩展性，包括源代码编辑器，项目向导，以及GDB项目调试器等等。eclipse和GoClipse插件均为开源的，因此也是免费的。 </p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/5.png" alt></p><h4 id="4-VIM编辑器"><a href="#4-VIM编辑器" class="headerlink" title="4. VIM编辑器"></a>4. VIM编辑器</h4><p>&emsp;&emsp;这个想必也不需要多说，经常使用Linux和MacOS操作系统的对于这个简直不能更熟悉，通过VIM-Go插件使得该编辑器具备了编译器，增强的语法高亮、代码折叠等等功能。除此之外，也可以集成一些高级的源分析工具。可以讲，VIM编辑器的强大之处完全不仅仅在于对Go语言的支持上。</p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/6.png" alt></p><h4 id="5-Goland"><a href="#5-Goland" class="headerlink" title="5. Goland"></a>5. Goland</h4><p>&emsp;&emsp;Goland是由JetBrains公司开发的，旨在为Go语言开发者提供一个更为简便、快速的开发环境。这个商业的IDE整合了IntelliJ平台的Go相关的辅助编码功能和其他的工具。Goland是一个极为强大的开发工具，具备智能补全，检查和快速修复，格式化程序，以及调试器，版本控制器等功能。当然商业工具是需要付费的，对于个人使用可以采用破解<strong>（划掉，改为购买~）</strong>的方式。</p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/7.png" alt></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们首先介绍了编码的含义以及Go语言对编码的要求，同时也介绍了几款相对好用的集成开发工具可供选择，在下一个小节中，我们将集中对第一个Go语言程序，Hello World的输出程序，进行简要的讲解以及对初期开发过程中所需要注意的问题和要求进行说明。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;1&gt; 环境安装及设置</title>
      <link href="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/"/>
      <url>/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-1-gt-环境安装及设置"><a href="#Go语言从入门到放弃系列-lt-1-gt-环境安装及设置" class="headerlink" title="Go语言从入门到放弃系列&lt;1&gt; 环境安装及设置"></a>Go语言从入门到放弃系列&lt;1&gt; 环境安装及设置</h2><p>&emsp;&emsp;首先第一节，今天便说一说Go语言开发环境的搭建。所谓工欲善其事，必先利其器，没有开发环境对于Go语言的开发简直如同空谈。因此在本章节中，我们会集中阐述开发环境的安装，环境变量的配置，以及对环境变量配置的结果进行验证。</p><h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><p>&emsp;&emsp;最先说明，在写这篇文章的时候，我采用的是windows环境，因此我的各项操作均是基于windows操作系统的，如果读者希望采用其他的系统进行开发，可以在网络上找到配置的方式。此处只介绍windows相关配置，其他系统暂不再赘述。</p><p>&emsp;&emsp;首先，作为最初的，便是在网络中下载Go的安装包，本文给出安装包的下载地址：<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a> </p><p>&emsp;&emsp;需要说明的是，这个网站可能需要翻墙才能进入，因此如果打不开可以尝试这个地址：<a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a> 因为本人是在国内开始写的这个连载，因此采用的是第二个网址。进入下载页面后如下图（图片将来可能会根据网站版本不同而改变）：</p><p><img src="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/1.png" alt></p><p>&emsp;&emsp;从图中可以看出，Go官方提供了基于不同系统的不同的安装包，只需要下载相应系统的安装包，再根据不同系统的命令进行安装即可，我们以下依旧采用windows为例。安装过程便不作具体描述了，一般来说不需要修改其中的设置，只需要下一步直到完成。值得说明的是，当选择Go语言开发环境的安装位置时如果不作修改便是C:\Go这个文件夹，修改的话需要记住修改后的位置，在后续配置中是需要的。同时，在安装过程中，尽量不要出现中文路径，以防止后续出现问题。</p><p>&emsp;&emsp;在安装过后，我们打开cmd命令控台，键入go version命令（中间有空格）</p><p><img src="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/2.png" alt></p><p>&emsp;&emsp;从上图我们可以看到的是，我的机器的Go开发环境版本为1.11.2，如果安装不同的版本，这个版本号会不同。在安装过后，我们进入环境变量中会发现，系统自动为我们设置了GOROOT环境变量，并且该值为 <strong>刚刚安装的目录</strong> ，如果发现该值与安装目录不同，需要进行修改。本人在安装的时候没有对安装目录进行修改，所以均为默认值。</p><p>&emsp;&emsp;除此之外，还需要检查Path变量是否进行了更新，对Path的配置便是在后面加入 <strong>安装目录下的bin\目录</strong> 的全路径，建议用分号将其与前后的其他设置分开。</p><p><img src="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/3.png" alt></p><p> &emsp;&emsp;到目前为止，可以说环境变量已经配置完了，可以进行初级的开发，不过为了后续的开发方便，我们继续配置GOPATH环境变量，在Go语言的包引入过程中，是采用%GoPath%\src为起始的目录引入的，因此建议单独生成一个文件夹，并将所有的源代码均写在这个文件夹的src目录中，而GOPATH的配置便是这个文件夹，本人在E盘下新建了GoProject，并且所有的源代码均写于E:\GoProject\src\xxx\yyy.go下，因此我的GOPATH为： <strong>E:\GoProject</strong></p><p>&emsp;&emsp;此时我们在cmd控制台中键入： go env，将显示出当前GO的所有环境配置，如下图所示。</p><p><img src="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/4.png" alt></p><h3 id="环境测试"><a href="#环境测试" class="headerlink" title="环境测试"></a>环境测试</h3><p>&emsp;&emsp;安装环境已经结束，接下来我们需要对环境的配置进行检测，便写一段简单的代码进行验证。代码也是众所周知的Hello World的输出。首先，我们在任意一个文件夹下建立一个.txt文件并将扩展名改为.go，本人便于桌面上建立一个test.go文件。请注意，在修改文件时一并修改的文件格式，也就是将隐藏已知文件名的选项去掉，否则会成为一个test.go.txt的文件。（windows各版本设置方式不同，windows7为例）</p><p><img src="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/5.png" alt></p><p>&emsp;&emsp;采用记事本的方式打开，并在其中输入如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hello World的编写</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后，打开cmd控制台，进入到桌面上，键入go run test.go后会立刻出现程序的执行结果，也就是在控制台输出了Hello World字样，如果成功输出则代表Go环境在本机配置正确，可以进行代码的编写了。</p><p><img src="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/6.png" alt></p><p>&emsp;&emsp;环境配置工作是相对简单的，本人也暂时没有发现在这个过程中出现什么问题，因此也不知如何去写问题的解答。不过一定要注意将环境配好，这可能会影响后续一些小节的内容的讲解。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;这个小节集中阐述了Go语言开发环境的安装，环境变量的配置，以及入门程序Hello World的编写。其版本号以及其他图片实例均与个人的配置相关，或在版本升级后将有其他的样式。在下一章，我们将集中介绍几款GO开发的集成开发环境，并选择其中一个进行安装。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
