<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;38&gt; 面向对象-方法</title>
      <link href="/2020/03/12/38-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95/"/>
      <url>/2020/03/12/38-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-38-gt-面向对象-方法"><a href="#Go语言从入门到放弃系列-lt-38-gt-面向对象-方法" class="headerlink" title="Go语言从入门到放弃系列&lt;38&gt; 面向对象-方法"></a>Go语言从入门到放弃系列&lt;38&gt; 面向对象-方法</h2><p>&emsp;&emsp;在上两个小节中，我们讲解了Go语言中面向对象部分的结构体的概念及使用。在结构体中，我们涉及到的最多的都是各种属性，例如一个人的类的结构体中会具备眼睛、鼻子、耳朵、嘴等属性，但是这些属性相对于面向对象而言更为”静态”。即它只说明了一个结构体中、一个类中具备什么样的性质，而没有指明这个类对应的实例能够做什么，例如一个人可以行走、可以观察等，这些相对”动态”的行为是由面向对象中的方法完成的。 </p><h3 id="方法快速入门"><a href="#方法快速入门" class="headerlink" title="方法快速入门"></a>方法快速入门</h3><p>&emsp;&emsp;在Go语言的面向对象体系中，有一个和函数十分类似的概念，我们称之为方法。在一些完全面向对象的计算机语言中，函数和方法是通用的，函数主要是指面向过程中的程序单元，方法主要是指面向对象中的类行为。可以说函数的说法是先于方法的，面向对象语言的发展是基于面向过程的，因此对于Java、PHP等语言来说函数和方法是等价的，而对于C++、Go等既包含面向过程部分也包含面向对象部分的语言来说，函数和方法是两个十分相似但是本质不同的概念。 </p><p>&emsp;&emsp;我们在方法的引出过程中也提及到了：方法(method)是针对于某一个类甚至是某几个类而言的，不同的类方法是可以不相同的，例如对于人类来说，我们可以具备使用工具、计算、行走等行为，但是对于鸟类来说他们具备飞行等行为，同理在Go语言中，每一个方法的出现往往会指定某一个类型作为”接收者”，即在某种情况下这个方式仅仅隶属于某一个类。在这里我们依旧沿用上一节中举的例子：学生类</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int</span></span><br><span class="line">    friends []stu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个类中，我们仅仅指明了一个学生结构体中具备姓名、年龄、以及朋友三个属性，而对于学生类的实例具体能做什么没有任何的说明。接下来我们假设一个学生实例可以完成计算两个数的加和的行为，此时根据上述的分析，方法在定义中需要指明某一个行为属于某一个类，那么此时计算的行为可以如下表示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s stu)</span> <span class="title">calculate</span><span class="params">(n1, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的程序段就可以称为一个方法，我们可以发现方法和函数不仅在概念上十分的相似，在定义方式上也是十分的相像。既然方法也是为了完成某一个目的而进行了抽象，那么方法的定义中也可以存在参数或者返回值，它与函数的唯一区别就是它需要指明这个方法归属于哪个类，在上述的方法定义中指明了归属于stu。 </p><p>&emsp;&emsp;在一些面向对象语言中，方法的定义是在class类中，和属性的定义相平行，这样的做法使方法得以访问到类中所定义的属性。在Go语言中，方法的实现是不相同的，它的方法是定义在struct结构体之外的，通过字段的指定来确定方法的归属。因此方法的调用是需要通过对应的类的实例来完成的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> student stu = stu&#123;&#125;</span><br><span class="line">    fmt.Println(student.calculate(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先通过学生类实例化一个对象，然后通过这个student对象来完成计算方法的调用。一个类具备某种行为，由该类实例化得到的个体对象当然也具备该方法的使用能力，因此此时可以通过”.”来完成从属关系的调用。</p><h3 id="方法的”传参”机制"><a href="#方法的”传参”机制" class="headerlink" title="方法的”传参”机制"></a>方法的”传参”机制</h3><p>&emsp;&emsp;在这个小部分中，我们所说的传参可以分为两部分来理解，一部分是方法的参数中的真的参数，另一部分则是方法归属类的抽象实例。方法的参数与函数的参数是相同的，即传入的数据类型是值类型的时候是在内存中复制一份原有数据再传入，传入的数据与原数据没有关系；当传入的数据类型为引用类型或指针时，则复制一份指向的地址传入，函数、方法中对数据的修改会影响到原数据。这个似乎不难理解，我们在函数的讲解中已经十分详细地介绍过了。 </p><p>&emsp;&emsp;现在我们回到Go语言对于面向对象特性的实现方式上，其他语言可以在方法中调用到类中的属性，那么在Go语言中这个特性也应该可以完成。由于方法的定义中已然指明了它所归属的类，所以此时<strong>假如</strong>我们再传入一个该类所对应的实例（对象），通过该对象来访问实例中的属性数据就可以了。在Go语言中也确实就是如此设计的，方法在指明对应类的同时直接传入一个抽象的实例，传入的方式和函数的传参一致，而又由于结构体本身是值类型，因此对应的抽象实例也就是和值传递相同。 </p><p>&emsp;&emsp;我们换一种理解方式：假如在一个函数中需要传入一个对象，在函数中输出对象所对应的一个属性，我们可能会采用如下的方式来完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span> <span class="params">(student stu)</span></span>&#123;</span><br><span class="line">    fmt.Println(student.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时的student对象是作为函数参数传入的，且传入的方式为值传递，我们通过该对象完成了name属性值的输出。那么对于方法而言，已然指出的类的归属，那么就可以如下来完成了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(student stu)</span> <span class="title">method</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(student.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个方法的定义中，student依然是值传递的方式传入的，从某种程度上讲，上述两种不同的函数与方法的实现方式，在理解过程中可以认为是相同的，即类的从属的指定作为方法的另一个参数。</p><h3 id="自定义类型的方法"><a href="#自定义类型的方法" class="headerlink" title="自定义类型的方法"></a>自定义类型的方法</h3><p>&emsp;&emsp;在Go语言中可以说通过type关键字所修饰的都是自定义数据类型，包括结构体的声明也可以被归结为自定义数据类型，因为不同的属性名、属性的数据类型、属性的个数所确定的结构体类型是完全不同的。既然Go语言中方法是作用于指定的数据类型上，那么只要是自定义类型，就都可以有方法，我们举一个例子： </p><p>&emsp;&emsp;现在我们的需求是为一个整数（int）添加一个方法，如果这个整数是奇数则返回false，是偶数则返回true。在此之前我们在程序中需要整数时直接定义一个int类型的变量，也不曾听说过整数类的概念，此时添加方法的途径就是将其变为一个自定义的数据类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Integer)</span> <span class="title">isEven</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num Integer = <span class="number">10</span></span><br><span class="line">    fmt.Println(num.isEven())</span><br><span class="line">    num++</span><br><span class="line">    fmt.Println(num.isEven())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如同声明结构体数据类型一般，我们通过type的方式将一个int类型自定义为Integer，此处的Integer数据类型就可以添加方法了，不仅如此，我们在main函数中将Integer变量进行自加操作，程序依旧可以完成对应的加法。由此可见：通过type的方式可以借助一些内置数据类型来自定义一些类型，这些类型可以添加方法，同时也同样具备数据本身的属性，如数学运算等。 </p><p>&emsp;&emsp;需要注意的一点是：我们通过type的方式为int类型自定义了一个Integer类型，如果在程序中有两个变量分别由int和Integer类型所定义，这两个变量的数据类型是不同的，在相互转化的时候需要进行强制转化。因此通过int定义的变量，是不具备isEven方法的，但是将其强转成Integer类型时就可以使用该方法了。</p><h3 id="String-方法"><a href="#String-方法" class="headerlink" title="String()方法"></a>String()方法</h3><p>&emsp;&emsp;在Go语言中我们经常通过fmt.Println()函数来完成数据向屏幕的输出，那我们可能会想了：当输出一个整数变量时编译器输出对应的值，当输出数组时编译器将数组中所有值都输出了，当输出引用类型的map时，编译器输出了指向的内存中的key和value的所有值，那么这个输出究竟遵循什么原则。 </p><p>&emsp;&emsp;在Go语言中一个数据类型如果实现了String()方法，那么当执行fmt.Println()时，输出到屏幕上的就是String()方法的返回值，我们举个例子：假如我们还是使用stu结构体，现在要求当我们使用fmt.Println(stu对象)的时候输出为：xxx(stu对象中的name属性)是个好人。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int</span></span><br><span class="line">    friends []stu</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s stu)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.name + <span class="string">"是个好人"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> student stu = stu&#123;<span class="string">"DENG"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    fmt.Println(student)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DENG是个好人</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样地我们也可以采用String方法来完成一些基本数据类型的其他形式的输出，当然前提条件是通过type关键字根据基本数据类型完成自定义类型的创建，然后再覆盖String方法，此处也不再做举例了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们引入了面向对象编程的另一个组成部分：方法，同时我们也通过一个入门案例完成了对方法的介绍。如果读者在之前掌握了Go语言中函数的概念与使用方式，那么对于方法的理解就轻而易举了，二者也有十分多的相似之处。最后我们又介绍了Go语言中独特的自定义数据类型的方法调用方式，以及String方法对一个数据类型的作用。 </p><p>&emsp;&emsp;在下个小节中，我们将继续讲解面向对象中方法的细节与注意事项，同时也会在下个小节中插入代码篇部分，简单针对几个小需求举几个方法的例子并进行简要地讲解。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;37&gt; 结构体细节讨论</title>
      <link href="/2020/03/11/37-%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/"/>
      <url>/2020/03/11/37-%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-37-gt-结构体细节讨论"><a href="#Go语言从入门到放弃系列-lt-37-gt-结构体细节讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;37&gt; 结构体细节讨论"></a>Go语言从入门到放弃系列&lt;37&gt; 结构体细节讨论</h2><p>&emsp;&emsp;在上一个小节中，我们引入了结构体的概念，讲解了Go语言中结构体内存对齐的原理，同时也简要提及了面向对象与面向过程的区别，准确地说Go语言并不是一个严格的面向对象的语言，但是它具备着面向对象的许多的特点。在这个小节中，我们依旧暂时不去讲解面向对象的其他特性，而是依旧针对于结构体进行一些细节上的讲解。 </p><h3 id="结构体的声明方式"><a href="#结构体的声明方式" class="headerlink" title="结构体的声明方式"></a>结构体的声明方式</h3><p>&emsp;&emsp;在Go语言中，结构体声明与使用可以由四种方式来完成，分别对应于熟悉不同开发语言的用户。在实际运用中均十分地常见，在这个部分中，我们将分别介绍这四种方式。首先我们先声明一个如下结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int</span></span><br><span class="line">    friends []stu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们定义了一个学生结构体，结构体中三个属性分别是指学生的姓名、学生的年龄、以及学生对应的朋友切片，切片的元素类型依旧是stu类型。由于上一个小节我们已经讲解了内存对齐的问题，因此在这里我们也就不再说这个结构体占据多大的内存空间了。接下来就是四种使用方式：</p><h4 id="1-先定义再赋值"><a href="#1-先定义再赋值" class="headerlink" title="1. 先定义再赋值"></a>1. 先定义再赋值</h4><p>&emsp;&emsp;这种方式与我们入门案例程序中的使用方式是相同的，即将其想象成为一个普通的数据类型，用同样的方式进行定义变量，之后再为每个属性进行赋值。值得说明的是：属性中的map映射需要进行make操作才能够正常使用，对于slice而言，如果直接用append操作就可以不用make了。我们举一个例子说明即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 stu</span><br><span class="line">stu1.name = <span class="string">"Devin"</span></span><br><span class="line">stu1.age = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> stu2 stu</span><br><span class="line">stu1.friends = <span class="built_in">append</span>(stu1.friends, stu2)</span><br><span class="line">fmt.Println(stu1)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们定义了一个stu结构体变量，之后我们再分别为每一个属性进行赋值，在为friends赋值时，我们又定义了一个新的变量，并将新的变量加入到切片中，由于stu2只进行了定义而没有做任何赋值，因此stu2的各个属性默认值均为其零值，即数字类型为0，字符串为空串，切片等引用类型及指针为nil。</p><h4 id="2-定义时初始化"><a href="#2-定义时初始化" class="headerlink" title="2. 定义时初始化"></a>2. 定义时初始化</h4><p>&emsp;&emsp;就如同普通变量在定义时直接赋值成为初始化一样，结构体在定义的时候也可以直接赋值进行初始化。其实通过上述的例子可以发现，当我们没有显式初始化而是只定义的情况下，编译器其实是通过属性对应的零值进行了初始化操作。如果我们不想使用其初值而是使用自己赋给的值时，可以直接进行初始化操作，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 stu = stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">fmt.Println(stu1)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于了解面向对象编程的读者而言，可以将其理解为stu类的构造函数，虽然在Go语言中并不存在构造函数的概念，同时也不支持函数的重载。但是这种定义方式可以直接为类中所有的变量进行数据的初始化，那么既然可以为所有的数据进行初始化，那么对某一部分属性进行初始化也应该是可以完成的。 </p><p>&emsp;&emsp;例如我们只希望初始化stu的对象中的name和age属性，而其他属性则保持其默认的零值。解决办法则是在结构体初始化过程中指明需要初始化哪个属性，不需要初始化的属性不予体现即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student stu = stu&#123;</span><br><span class="line">    name: <span class="string">"DENG"</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;既然我们在程序中指明了哪些属性需要初始化，且初始化的值也一一对应了，那么在运行时编译器就可以为特定的值进行赋值了。在这里需要尤其注意的一点是：在这种初始化过程中，每指定一对属性和值之后都有一个逗号，即便是对属性赋值这个操作是最后一个（age:25后面有一个逗号），如果没有逗号则会编译错误。 </p><h4 id="3-new函数实现内存分配"><a href="#3-new函数实现内存分配" class="headerlink" title="3. new函数实现内存分配"></a>3. new函数实现内存分配</h4><p>&emsp;&emsp;第三种方式可以说对于熟悉Java等语言的开发者十分地友好，因为开发者往往需要通过new关键字来完成对象的创建。Go语言的开发者考虑到类似的需求，便为结构体创建实例添加了这个方式。只是在Go语言中，new并不是其中的关键字，而是一个内建函数，其返回值也不是结构体变量，而是指向结构体变量的指针，我们通过程序来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 = <span class="built_in">new</span>(stu)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, stu1)</span><br><span class="line">(*stu1).name = <span class="string">"Devin"</span></span><br><span class="line">stu1.age = <span class="number">25</span></span><br><span class="line">fmt.Println(*stu1)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果运行上述的程序，我们可以看到第二行对应的输出结构为*main.stu，其含义为main包下的stu类的指针，因此new函数的返回值是一个结构体指针。既然它是一个指针变量，当然就需要遵守指针的原则，即先取出指针所指向的结构体，再进行成员操作。由于运算符的优先级中成员符号要高于取值符号，因此我们在取出对应的结构体时需要用括号进行修饰，即(*stu1).name。假如不使用括号进行修饰，则.运算符先进行运算，虽然Go语言底层对于指针进行了优化操作，将指针的成员默认为指针对应结构体成员，但是对一个变量做*运算依旧是错误的，因此括号是必须要加的。 </p><p>&emsp;&emsp;说起Go语言对底层的优化，我们在之前的小节中也有相应的讲解，上述代码中也运用到了这个优化操作，即stu1.age = 25这一行代码。对指针进行成员操作是无意义的，因此编译器就自动翻译成为了取值后再做成员操作。如果读者对于什么是指针、什么是值、什么时候应该怎样的操作都十分熟悉了，那么当然就可以利用这个优化进行简要的操作了。</p><h4 id="4-初始化时返回指针"><a href="#4-初始化时返回指针" class="headerlink" title="4. 初始化时返回指针"></a>4. 初始化时返回指针</h4><p>&emsp;&emsp;准确地说这个方式不算是一个特殊的方式，它只是将方式2中的结构体初始化结果以指针形式进行返回，当然其定义部分的数据类型也当然就是指针，这种方式在程序开发中也是十分常用，由于其只是方式2的变形，我们就只举个例子，不再过多说明了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 *stu = &amp;stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">fmt.Println(*stu1)</span><br></pre></td></tr></table></figure><h3 id="结构体的赋值"><a href="#结构体的赋值" class="headerlink" title="结构体的赋值"></a>结构体的赋值</h3><p>&emsp;&emsp;在之前的各个章节中，我们均介绍到了各个数据类型是值类型还是引用类型，在这个部分中，我们将针对结构体的性质进行讲解。我们采用的结构体声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name   <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int</span></span><br><span class="line">    class   *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-结构体是值类型"><a href="#1-结构体是值类型" class="headerlink" title="1. 结构体是值类型"></a>1. 结构体是值类型</h4><p>&emsp;&emsp;在Go语言中，结构体是值类型而不是引用类型，这也就说明了一旦将一个结构体变量赋值给另一个结构体变量，其内部属性的所有值将会全部复制，在内存中出现一个完全新的结构体变量，两者之间并不互相影响，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 stu = stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="keyword">var</span> stu2 stu = stu1</span><br><span class="line">stu2.name = <span class="string">"RuoShui"</span></span><br><span class="line">fmt.Println(stu1)</span><br><span class="line">fmt.Println(stu2)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们定义了一个结构体变量stu1，且将该变量直接赋值给另一个变量stu2，此时内存中存在着两个地址不同但内容相同的结构体变量。接下来我们将stu2的name属性修改后，分别输出两个结构体观察结果，最后可以发现，对stu2的修改并不影响stu1的属性。 </p><p>&emsp;&emsp;在这个特性上Go语言与Java语言是不同的，Java秉承了没有显式指针的思想，但核心是全部都是指针，因此熟悉Java的读者在使用Go语言结构体赋值的时候可能会不甚适应，那么如何让一个结构体变量的修改影响到另一个结构体，我们可以采用如下指针的方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1 *stu = &amp;stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="keyword">var</span> stu2 *stu = stu1</span><br><span class="line">stu2.name = <span class="string">"RuoShui"</span>    <span class="comment">//这里采用了编译器优化</span></span><br><span class="line">fmt.Println(*stu1)</span><br><span class="line">fmt.Println(*stu2)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们通过指针进行直接赋值，stu2也同样指向了结构体变量，就如同一个机器具备两个控制源，任何一个控制源发布命令，机器都会做出响应。这种实现方式可能更适合于熟悉Java开发的人们。 </p><h4 id="2-深浅拷贝"><a href="#2-深浅拷贝" class="headerlink" title="2. 深浅拷贝"></a>2. 深浅拷贝</h4><p>&emsp;&emsp;我们在这里介绍的概念在笔试乃至于面试中经常出现，即深拷贝与浅拷贝的区别，这两种拷贝方式并不局限于Go语言，而是适用于每一个编程开发语言，只是不同的语言可能采用着不同的拷贝策略，既然Go语言中结构体的赋值是将一个结构体在内存中完全复制、新建、粘贴，那么在这个过程中它究竟是深拷贝还是浅拷贝。 </p><p>&emsp;&emsp;首先我们介绍一下什么是深拷贝，什么是浅拷贝。这两种拷贝方式的区别十分简单：深拷贝就是完全复制，首先对外层对象进行拷贝，对内层引用也进行拷贝；而浅拷贝则是只复制了对象本身，其内部的引用其他对象不做复制，只做引用。 </p><p>&emsp;&emsp;用一个通俗的例子来讲便是，假如我们有一个收纳盒（结构体），盒子中有一个遥控器（引用），这个遥控器可以控制房间内的电视机（指针指向的值）。现在我们希望再建立一个收纳盒，且保持其中的物品不变，将这个收纳盒送给其他人（结构体赋值）。深拷贝的做法就是用一个新的收纳盒，装载一个新的遥控器，控制一个新的电视机，将这三样物品全部交给其他人；浅拷贝的做法就是用一个新的收纳盒，复制那个遥控器，电视机不做任何改动，将收纳盒与遥控器交给其他人，这两个遥控器均可以控制该屋子中的电视机。 </p><p>&emsp;&emsp;那么在Go语言中结构体的赋值是哪一种拷贝方式，我们做一个简单的验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> stu1 *stu = &amp;stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, &amp;a&#125;</span><br><span class="line"><span class="keyword">var</span> stu2 *stu = stu1</span><br><span class="line">fmt.Println(*stu1)</span><br><span class="line">fmt.Println(*stu2)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的程序中，我们依旧将stu1直接赋值给stu2，在最后的输出中，我们会将stu1与stu2中的class属性的地址直接输出。通过对结果的检验，我们可以发现两个结构体变量中class所指向的地址是相同的，因此可以验证得到Go语言中结构体的直接赋值过程是一个浅拷贝过程。 </p><p>&emsp;&emsp;通过这个结果我们可以想象到：当一个结构体中存在一个引用类型或者指针类型时，即便是结构体本身是值类型，其复制得到的结构体变量中的引用是不变的，从这个角度来说通过一个结构体变量修改引用类型或指针类型数据时是会影响到另一个结构体变量的，但是这与结构体值类型中两个结构体内存无关联是不相矛盾的。</p><h4 id="3-结构体类型强转"><a href="#3-结构体类型强转" class="headerlink" title="3. 结构体类型强转"></a>3. 结构体类型强转</h4><p>&emsp;&emsp;在我们之前讲解到的基本数据类型中，我们讲解过基本数据类型之间的相互转化，那么作为数据类型集合的结构体数据类型也可以发生强制转化。例如我们案例中的学生结构体是由姓名、年龄、班级所构成的，假如存在一个person类，且person类中的三个属性分别为姓名、年龄、以及性别（假如性别使用整数来表示），那么stu类与person类是否可以强制互相转化。 </p><p>&emsp;&emsp;在Go语言中，数据类型是十分严格的，即便是同一种数据类型精度不同也不可以不作声明地直接转化，结构体变量也是相同的。如果希望从一个结构体强制转换成另一个结构体，需要满足一个条件：两个结构体需要有完全相同的字段，完全相同是指属性的名字、个数、类型完全相同。我们举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> per <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">    class *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> stu1 stu = stu&#123;<span class="string">"Devin"</span>, <span class="number">25</span>, &amp;a&#125;</span><br><span class="line">    <span class="keyword">var</span> per1 per = per(stu1)</span><br><span class="line">    fmt.Println(per1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们又新建了一个结构体叫做per，它也是由三个属性构成的，分别为name，age，和class。在主函数中，我们定义了一个stu类型的变量，且将该变量强制类型转换成为per类型赋给per1，最后输出per1，这段程序在编译以及运行过程中均不会报错，也就证明了强制类型转化是成功的。现在我们将per结构体做一些改变：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> per <span class="keyword">struct</span> &#123;</span><br><span class="line">    name   <span class="keyword">string</span></span><br><span class="line">    age    <span class="keyword">int</span></span><br><span class="line">    gender   *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时由于两个结构体的字段（属性）并不是完全一致的，主函数中的程序是无法编译通过的，其报错的信息为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert stu1 (<span class="keyword">type</span> stu) to <span class="keyword">type</span> per</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在本章节中，我们深入Go语言的结构体进行了深入的讲解，包括结构体的四种定义方式：两种返回值、两种返回指针，结构体值类型的特性以及结构体赋值时的浅拷贝特性，再有就是不同结构体之间做类型转换的条件与错误类型。 </p><p>&emsp;&emsp;在下个小节中，我们将不再针对结构体的属性进行讲解，而是进入到面向对象的另一个小部分：成员方法的讲解。在讲解的过程中，我们也将会详细说明一个类中的方法的概念、使用方式、以及它与函数的区别。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;36&gt; 面向对象-结构体</title>
      <link href="/2020/03/10/36-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2020/03/10/36-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-36-gt-面向对象-结构体"><a href="#Go语言从入门到放弃系列-lt-36-gt-面向对象-结构体" class="headerlink" title="Go语言从入门到放弃系列&lt;36&gt; 面向对象-结构体"></a>Go语言从入门到放弃系列&lt;36&gt; 面向对象-结构体</h2><p>&emsp;&emsp;在这个小节之前，可以说我们一直在讨论面向过程的各个知识点。不论是否理解什么是面向过程，我们到目前为止所想到的解决办法都是基于过程的，即分析出解决问题所需要的所有步骤，通过函数逐一进行实现，最后再一个一个地依次调用，以达到解决问题的目的。这种编程思想的需求便是要对过程有着清楚的了解，对过程逻辑有较好的实现，但是在大型程序的后期维护上相对较难。 </p><p>&emsp;&emsp;从这个小节中，我们将开始介绍Go语言中面向对象思想以及Go语言的独特的面向对象的实现方式。由于我们是从面向过程部分开始讲解的，因此一开始可能会相对难从面向过程的思想中跳出，而转变这个编程思路的唯一方式就是多思考、多编程而已。</p><h3 id="面向对象概念"><a href="#面向对象概念" class="headerlink" title="面向对象概念"></a>面向对象概念</h3><p>&emsp;&emsp;准确地说，不同人对于面向对象的理解都不太一致，直接复制粘贴其他人的或者维基百科的理解并不能加深个人对面向对象思想的理解。况且面向对象只是一种思想，不同的语言对于这个思想的实现方式不同，其侧重点也不甚相同，在这个小节中，我也只是讲述的是我个人对面向对象思想的理解、以及Go语言前提下独特的对面向对象的实现。  </p><p>&emsp;&emsp;首先，我们举一个相对容易理解的例子来说明面向过程：贪食蛇游戏的开发。首先初始化地图与蛇身，之后判断蛇的运动方向，进行蛇移动操作，判断是否吃到食物，判断是否撞到障碍，判断是否游戏结束，之后再一次进行同样的循环。把以上的各个需求分别用函数完成，最后再以上述的顺序连接就完成了游戏的开发。 用这种方式思考得出结果的过程就是面向过程的思想。</p><p>&emsp;&emsp;如果采用面向对象的方式来解决这个问题，考虑的方式则完全不同。这个需求可以分为几个大的部分：1. 蛇的部分，它具备位置与是否死亡等多种属性，具备向四个方向移动、成长等多种行为；2. 食物的部分：它具备自己的自然属性即碰到后身体加长、随机生成初始位置等行为；3. 地图的部分：控制游戏的开始与结束行为，完成蛇头与墙壁、石头的碰撞逻辑等。最后通过一定的方式将不同部分的不同属性、行为联系在一起完成程序的开发。换句话说，就是几个实体之间的行为与属性的联系。</p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>&emsp;&emsp;在了解面向对象的各个特点之前，我们首先需要介绍一下对象的概念，对象就是指现实世界或虚拟世界中存在的任何的所有的事物实体，可以讲：一切均是对象。整体来说，对象可以由两部分构成：属性与行为。 </p><p>&emsp;&emsp;属性是用来描述某个抽象物体的特征的，例如我们将一个人作为对象来看，她的身高、体重、国籍、甚至家庭住址都是这个人的属性。属性是是对象的静态的一面，虽说身高体重等都可以发生改变，但是这些依旧是可以通过数值等来形容的。而行为则是对象中属于动态的一面，我们依旧以一个人为例：这个人可以跑、可以跳、会算数、能长大。这些动态的行为就是面向对象的方法，而类之中的方法往往是服务于类中的属性的。 </p><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>&emsp;&emsp;那么什么是类：具备同种属性的对象称之为类，这是个相对抽象的概念，具象地理解可以理解为模板。例如：人就是一个类，而具体到你我他都是人类所对应的对象。人类具备两个眼睛、两个耳朵、一个鼻子等，而具体到每个人都具备这些属性。因此来说，类就相当于一个模板，这个模板定义了对象们应该有的属性、公共特征以及行为功能，而对象则是类的一个实例化。我们在编写程序的时候经常会将一个类实例化，并且使用该对象，就类比于某个人会弹琴，而不是人类会弹琴。 </p><h4 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h4><p>&emsp;&emsp;面向对象编程中有三大特性，分别为继承、封装、多态。在这里我们先不做过多的讲述，因为这三个特性在后续的讲解中均是重点知识，而且Go语言对这三个特性的实现也与其他很多语言都不同。 </p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>&emsp;&emsp;现在我们回到技术层面来考虑问题，在Go语言中是如何实现面向对象编程的。在之前所讲解的map映射中我们一直在回避一个问题，这个问题就是一个学号对应一个学生姓名，但是往往并不是仅仅如此，我们需要存储更多的信息，例如学生姓名、学生性别、学生住址等。当输入学生的学号时，将对应学生的信息都打印出来，这个需求该如何去完成。如果采用之前讲解到的技术，可能为值为map类型的map映射： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stuInfo <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">stuInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">stuInfo[<span class="number">10001</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">stuInfo[<span class="number">10001</span>][<span class="string">"name"</span>] = <span class="string">"Devin"</span></span><br><span class="line">stuInfo[<span class="number">10001</span>][<span class="string">"gender"</span>] = <span class="string">"Male"</span></span><br><span class="line">stuInfo[<span class="number">10001</span>][<span class="string">"address"</span>] = <span class="string">"Melbourne"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(stuInfo[<span class="number">10001</span>][<span class="string">"gender"</span>])</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种实现方式虽然可以完成上述需求，但是这种方式实在是过于繁琐，假如需要根据平均分等指标进行排序就又会更复杂。因此我们可能会想在Go语言中是否存在这样一种数据结构：它可以是多个数据类型的集合，在逻辑上可以被看做一个整体，这样在做管理的时候会十分地方便。 </p><p>&emsp;&emsp;结构体就刚好可以满足上述的要求，它更贴近于类的概念。在之前我们的设想中采用多个数组分别存储这些属性，根据数组的下标值进行管理，可以讲这种方式是一种横向的方式，各个属性是相互分立的。而结构体则是一种纵向的方式，将一个对象的各个属性集合在一起，不同的对象是相互分立的。采用结构体完成上述需求的入门案例为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stuInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    gender <span class="keyword">string</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu stuInfo</span><br><span class="line">    stu.name = <span class="string">"Devin"</span></span><br><span class="line">    stu.gender = <span class="string">"Male"</span></span><br><span class="line">    stu.address = <span class="string">"Melbourne"</span></span><br><span class="line">    fmt.Println(stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们首先定义了一个结构体，即定义了一个数据模板，目前这个结构体中只含有三个属性。在主函数中，我们根据这个类实例化了一个对象stu，在这之后所有的操作都是针对对象stu的，为stu中三个属性进行赋值，最后再进行输出。</p><h3 id="结构体中内存对齐"><a href="#结构体中内存对齐" class="headerlink" title="结构体中内存对齐"></a>结构体中内存对齐</h3><p>&emsp;&emsp;在Go语言的结构体中，存在着一种叫做内存对齐的情况，熟悉旧版C语言但是没有接触过内存对齐的人可能会对这个问题比较陌生。我们举一个例子：假如一个结构体中按顺序含有一个byte，一个int64，两个bool，和一个float32数据，那么这个结构体在内存中占用了多大的空间。结构体体定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> str <span class="keyword">struct</span> &#123;</span><br><span class="line">    byte_field <span class="keyword">byte</span></span><br><span class="line">    int64_field <span class="keyword">int64</span></span><br><span class="line">    bool1    <span class="keyword">bool</span></span><br><span class="line">    float_field <span class="keyword">float32</span></span><br><span class="line">    bool2    <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在标准C语言的思想中，我们可能会想：byte是1个字节、int64是8个字节、bool是1个字节、float32是4个字节，所以这个结构体总共占据1+8+1+1+4=15个字节的空间，这种问题往往还会在考试中考。然而如果我们采用”unsafe”包中的Sizeof函数来测量这个结构体在内存中的空间时，其输出结构竟然是32个字节，而不是我们分析得到的15个字节。 </p><p>&emsp;&emsp;出现这个差异的原因就是Go语言中的结构体实行了内存对齐。计算机以及一些嵌入式设备在读取内存的时候往往不是一个字节一个字节的地读，而是一块一块地读。对于64位的机器而言，计算机一次读取8个字节的内存，对于32位机器而言则是读取4个字节。假如所有数据都是两两相邻的，例如一个bool变量和一个int64变量，计算机在读取的时候（64位机器），是先读取8个字节的空间，发现里面有bool变量，但是当计算机读取int64变量的时候，它需要先读取前8个字节并取其中的后7个字节，然后再读取后8个字节取其中的第一个字节，最后再将两部分拼接起来，这样读取速度就会受到影响。 </p><p>&emsp;&emsp;因此内存对齐的作用就体现出来了，其思想便是利用空间换取时间，让第一个bool单独占据8个字节的位置，然后int64占据8个字节，这样读取效率就会提升。不仅如此，在对齐的最后还会让结构体的空间再对齐，使得结构体数组中任意两个结构体的读取更快捷。Go语言结构体中内存对齐有两个原则：1. 每个变量相对于结构体地址的偏移量应该成为该数据类型所占字节的整数倍，例如int16相对于起始位置需要是2的整数倍，float64相对于起始位置需要是8的整数倍。对于数组等集合型数据类型，按其中元素的数据类型来算。 2.结构体整体占据的空间需要是4的整数倍（32位机器）或8的整数倍（64位机器）。 </p><p>&emsp;&emsp;因此针对于题目中的结构体我们需要做如下的分析：<br>&emsp;&emsp;&emsp;&emsp;1. 首先第一个属性是一个byte，其占据一个字节的空间。目前的内存为：     </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|x</span><br><span class="line">(x表示有数据，.表示空余)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;2. 第二个属性是一个int64数据，其占据8个字节，然而假如将其直接加在后面，其偏移量不是8的整数倍，因此对于这个变量需要进行内存对齐，对齐的方式是中间空余7个位置，内存表示如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;3.第三个属性是bool变量，应该占据1个字节，由于任何数都是1的整数倍，因此直接加在后面是满足于条件1的，内存表示如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|x</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;4. 第四个属性是float32类型变量，占据4个字节，如果直接加在bool的后面，其偏移量为17,而17并不是4的整数倍，因此需要进行内存对齐，对齐位置应该是偏移量为20的位置，内存如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|x...xxxx|</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;5. 最后一个变量还是bool类型，同理它可以直接加入到任何一个变量的后面，所以这个变量直接加在float32后面。此时的内存如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|x...xxxx|x</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;6. 此时结构体内部的各个变量的位置已经分好了，即每一个属性的位置都满足于条件1，而整个结构体此时的字节数为25，然而25并不是8的整数倍，其最近的整数倍为32，所以最终这个结构体在内存中的分布为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|x.......|xxxxxxxx|x...xxxx|x.......|</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述的解释中，我们可以发现：其实在第一个字节中有效位置只有一个二进制位，而浪费了七个二进制位，对于最后一个字节依旧是如此。那么在结构体的设计上，我们明明可以将两个bool变量定义到一起去，这样不仅第一个字节利用率变高，最后一个字节也不需要整体内存对齐，对于结构体的空间占用就减少了1/4。而解决办法，其实只是将属性定义的顺序修改一下即可。</p><p>&emsp;&emsp;但是一般的算法优化并不会针对结构体的设计方面进行优化，因为相比于主流的时间空间复杂度的优化方式，这种优化所得到的收益实在是太低了。因此，内存对齐的优化方式并不主流，但也不失为一种简单而有效的优化方式。</p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>&emsp;&emsp;在这个地方为了加强对内存对齐的理解，我们假设存在这样的一个结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int64</span></span><br><span class="line">    isAdult <span class="keyword">bool</span></span><br><span class="line">    grades [<span class="number">3</span>]<span class="keyword">float32</span> <span class="comment">//假设只有三门课</span></span><br><span class="line">    friends []stu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么请问，这个结构体变量在内存中会占据多大的空间。答案是64  ，读者可以自行分析。（注：string类型占16字节、切片占24字节，具体原因我们在前面都讲解过）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|xxxxxxxx|xxxxxxxx|xxxxxxxx| x...xxxx|xxxxxxxx|xxxxxxxx|xxxxxxxx|xxxxxxxx|</span><br><span class="line">|<span class="keyword">string</span>           |<span class="keyword">int64</span>   |<span class="keyword">bool</span>|[<span class="number">3</span>]<span class="keyword">float32</span>   |[]stu                     |</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们初步讲解了面向对象编程思想与面向过程编程思想的区别，同时引入了Go语言中结构体这种数据类型，并对结构体数据类型做了一个简单的快速入门举例。最后我们讲解了Go语言结构体中的内存对齐的现象，说明了这种语言与其他某些语言的不同点。 </p><p>&emsp;&emsp;在下一个小节中，我们依旧将针对于结构体数据类型的四种声明以及初始化方式进行讲解，并集中提及在代码实现过程中需要注意到的问题和细节。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;35&gt; map映射的细节讨论</title>
      <link href="/2020/03/09/35-map%E6%98%A0%E5%B0%84%E7%9A%84%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/"/>
      <url>/2020/03/09/35-map%E6%98%A0%E5%B0%84%E7%9A%84%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-35-gt-map映射的细节讨论"><a href="#Go语言从入门到放弃系列-lt-35-gt-map映射的细节讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;35&gt; map映射的细节讨论"></a>Go语言从入门到放弃系列&lt;35&gt; map映射的细节讨论</h2><p>&emsp;&emsp;在上一小节中，我们对Go语言中的map映射进行了引入，同时也讲解了map的定义初始化方式以及对其中数据的增删改查操作的方式。在这个小节中，我们依旧针对map映射的其他特性进行相对深入的讲解，以及在程序编写过程中需要注意的几个问题进行提及。 </p><h3 id="键值对类型"><a href="#键值对类型" class="headerlink" title="键值对类型"></a>键值对类型</h3><p>&emsp;&emsp;在上一个小节中，我们提到map映射中数据的存储方式是以键-值的方式存储的，同时每一个键都对应于一个值。在上一节的入门案例中，我们只使用了整数类型以及字符串类型作为map的键值，在这一部分中我们将介绍其他的可以作为键值的数据类型。 </p><p>&emsp;&emsp;到目前为止，我们已经讲解过的数据类型有：整数类型、浮点类型、布尔类型、字符串类型、数组、切片、函数类型、以及正在讲解的映射类型。那么这些数据类型是否全部都可以作为map的键值类型呢，答案是否定的。在Go语言中切片、映射、和函数是不可以作为map的键的类型的。 </p><p>&emsp;&emsp;对于这个规定的理解，我们可以想象一下如下的过程，当我们希望通过一个键来查找值的时候，map中是维护了一个键的列表的。当在这个列表中存在着当前键的时候，才将值进行输出，同时判断两个键值是否相同的方式只有通过==的方式。到目前为止我们所演示的所有案例中，均没有出现过判断两个切片是否相等、两个映射是否相等、以及两个函数是否相等。从某种意义上来说可以判断是否相等的两个值大小需要是固定的，而slice以及map刚好不满足，而function作为一个map的键一般来说也是没有意义的。 </p><p>&emsp;&emsp;那么对于map的值类型是否也存在着某些限制，理论上来说，map映射对于value的数据类型是没有限制的，即slice等不可以作为key的类型但是是可以作为value的类型的。不论某个数据类型是值类型还是引用类型，它在内存中都是可以被另一个指针所指向的，因此value的类型是可以任意的。我们通过两小段程序来说明这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sys <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">sys[<span class="string">"1"</span>] = slice</span><br><span class="line">fmt.Println(sys)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一段程序是可以成功编译运行的，这个map映射的key类型为string字符串，value类型为一个int切片。我们接下来为这个切片赋值，再添加到map中，最终的结果可以成功输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sys <span class="keyword">map</span>[[]<span class="keyword">int</span>]<span class="keyword">string</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[[]<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">sys2[slice] = <span class="string">"1"</span></span><br><span class="line">fmt.Println(sys)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第二段程序就无法编译通过了，因为他的key类型是一个int切片，由于int切片是无法通过==或!=来判断的，因此这个map是无法构成的。在编译过程中，会报出：invalid map key type []int的错误。</p><h3 id="map的无序性"><a href="#map的无序性" class="headerlink" title="map的无序性"></a>map的无序性</h3><p>&emsp;&emsp;在我们之前所接触到的多数据集合的类型中，例如数组切片等都是有序的集合，即先输入的数据排在前方而后输入的数据排在后方。我们也可以采用某些数据结构或独特的排序方式使之成为有序的状态，例如插入排序、堆排序等。而在Golang的map映射中，这两种特性均不存在，也就是说当遍历map中的数据时，往往不会遵循数据的大小规律以及输入的先后规律。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sys := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="string">"one"</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">"two"</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="string">"three"</span>,</span><br><span class="line">    <span class="number">4</span>: <span class="string">"four"</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">"five"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(sys)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中我们输出了10次map映射，在这里我就不将执行结果写出来了，因为不同的人在执行这样同一段代码的时候，其结果可能完全不同。但是可以保证的是：map映射中会存在5个数据，且这5个数据均是正确显示的，只是输出的顺序是不同的。 </p><p>&emsp;&emsp;出现这个效果的原因是每一次key的遍历顺序不同，而这个不同则是Go语言的设计者的有意为之（虽说我不太理解这个做法）。在其他语言中程序员对于map的遍历时往往依赖于其key的稳定输出顺序，在Go语言中是完全不可以的。不过奇怪的是：在早版本的golang中，输出的key并非是随机化的，无序这个特性是设计者在后续版本中加入的一个特性。 </p><p>&emsp;&emsp;再需要提及的一个问题是：map中的值的存储是不连续的，即不像是数组那样两个元素是相连的。在Go语言中键与值的对应关系满足哈希算法，即通过键的值经过某种计算直接得到值的物理地址，从而可以快速查找。因此值的存储是不连续的，不仅如此，value的访问是不可以通过指针访问的，即便是我们知道了value的物理地址，也不能通过*运算来访问。因为当map扩容时，所有的数据可能会采用新的hash算法进行计算，之前的物理地址可能就不再指向原来的数据了。</p><h3 id="map的排序"><a href="#map的排序" class="headerlink" title="map的排序"></a>map的排序</h3><p>&emsp;&emsp;既然map的key的遍历是无序的，value的输出也是无序的，当遇到了对map排序的需求时就需要对其做一些变通。此时我们需要用一个数组或切片进行辅助排序。我们就首先遍历map中的键，并将每一个遍历到的键加入到一个切片中。然后对这个切片进行排序，最后按排序后的key进行对应值的查找，进而完成按key的大小排序，程序如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sort"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sys := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="number">1</span>: <span class="string">"one"</span>,</span><br><span class="line">        <span class="number">2</span>: <span class="string">"two"</span>,</span><br><span class="line">        <span class="number">3</span>: <span class="string">"three"</span>,</span><br><span class="line">        <span class="number">4</span>: <span class="string">"four"</span>,</span><br><span class="line">        <span class="number">5</span>: <span class="string">"five"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> keys []<span class="keyword">int</span> = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> key, _ := <span class="keyword">range</span> sys &#123;</span><br><span class="line">        keys = <span class="built_in">append</span>(keys, key)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(keys)</span><br><span class="line">    <span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        fmt.Println(sys[key])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="键的唯一性"><a href="#键的唯一性" class="headerlink" title="键的唯一性"></a>键的唯一性</h3><p>&emsp;&emsp;这个特性是相对好理解的，因为在日常生活中处处存在类似的例子。例如，在一所学校中不会出现两个相同学号的学生，不会出现两个相同身份证号的人。因此这个特性就决定了map映射中每一个key都需要是不同的，而对于value则完全没有要求。例如“信用卡-用户”这个键值对，每个信用卡都可以独特地对应一个人，但是一个人可能对应的不止一个信用卡。对于键的唯一性我们通过代码举例说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">stu[<span class="number">1</span>] = <span class="string">"Devin"</span></span><br><span class="line">stu[<span class="number">2</span>] = <span class="string">"RuoShui"</span></span><br><span class="line">stu[<span class="number">3</span>] = <span class="string">"RuoShui"</span></span><br><span class="line">stu[<span class="number">1</span>] = <span class="string">"Evelyn"</span></span><br><span class="line">fmt.Println(stu)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们声明了一个map映射，并向其中插入了四条数据，在这四条数据中，我们验证了在Go语言中map的键、值是否可以重复。stu2和stu3的值是相同的，而Devin和Evelyn的键是相同的。通过结果我们可以发现：stu2和stu3是可以共存的，而stu1的Devin值是被Evelyn所覆盖了，因为根据哈希算法，通过一个键值的计算所得到的物理地址是一定的，因此对应于同一个键，只能存在一个值，也就是最后覆盖的那个值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="number">3</span>:RuoShui <span class="number">1</span>:Devin <span class="number">2</span>:Evelyn]</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们针对Go语言中的map映射进行了相对具体的讲解，并介绍了map的键类型与值类型的限制，以及map内key的遍历的无序性和对应的排序方式，最后我们也提及了map映射中键的唯一性。 </p><p>&emsp;&emsp;从下个小节开始，我们将开始进入面向对象的部分，讲解Go语言中面向对象的特性以及实现方式，同时也将针对Go语言对面向对象的几大特性的独特的设计理念进行讲解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;34&gt; map映射</title>
      <link href="/2020/03/08/34-map%E6%98%A0%E5%B0%84/"/>
      <url>/2020/03/08/34-map%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-34-gt-map映射"><a href="#Go语言从入门到放弃系列-lt-34-gt-map映射" class="headerlink" title="Go语言从入门到放弃系列&lt;34&gt; map映射"></a>Go语言从入门到放弃系列&lt;34&gt; map映射</h2><p>&emsp;&emsp;在之前的几个小节中，我们分别讲解了数组与切片两种相对复杂的数据类型，并讲解了其使用方式和注意事项。在这个小节中，我们将进入对下一个话题的讨论-map映射。在这几小节中，我们也将延续之前的讲解模式，以案例驱动快速入门程序，然后针对使用方式进行讲解，最后再面向一些使用细节做出更深入的讨论。 </p><h3 id="map映射引入"><a href="#map映射引入" class="headerlink" title="map映射引入"></a>map映射引入</h3><p>&emsp;&emsp;map映射与之前介绍到的数组等数据结构完全不同，数组包括切片都是同一种数据的有序集合，而map则是以键值对的形式进行数据存储，每一个键（key）对应于一个值（value）成对出现。 </p><p>&emsp;&emsp;首先我们举一个例子，在日常生活中具备很多的一对一键值的例子。例如：每一个公民都具备一个独一无二的身份证号码，且这个号码可以唯一且精确地代表这个人。再例如在某个班级或者学校中，每个学号可以对应于每一个人，且依旧是唯一且精确地代表。假如我们希望完成一个如下需求的程序：写一个小的管理系统，系统中需要存储用户的身份证号以及姓名，且需要通过身份证号来直接查找到用户。 </p><p>&emsp;&emsp;如果采用之前我们提及的各个技术来完成这个需求，其实还是比较有难度的，因为之前我们所介绍的名字与值唯一相对的只有变量名与变量值的相对关系，然而定义多个变量的方式很不现实，使用切片的方式也相对麻烦，我们实现一下： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ids []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> names []<span class="keyword">string</span> = []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    ids = <span class="built_in">append</span>(ids, <span class="number">10001</span>)</span><br><span class="line">    names = <span class="built_in">append</span>(names, <span class="string">"Devin"</span>)</span><br><span class="line">    ids = <span class="built_in">append</span>(ids, <span class="number">10002</span>)</span><br><span class="line">    names = <span class="built_in">append</span>(names, <span class="string">"RuoShui"</span>)</span><br><span class="line">    fmt.Println(ids)</span><br><span class="line">    fmt.Println(names)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们定义了两个切片分别来存储身份id以及用户姓名，当添加新的用户时，需要对两个切片进行append操作，通过id查找姓名时需要先查找id所在数组（切片）中的下标，然后再提取names切片中对应下标的元素，当删除时，同样需要先找到对应下标后再进行切片的删除。因此通过切片来完成这个需求只能说可以达到目的，但是这个实现方式非常的繁琐。 </p><p>&emsp;&emsp;所以我们进而引入map映射的概念，map映射有两个组成部分，分别是key和value，且每个键都需要唯一对应一个值，在上述的这个需求中，用户的身份id刚好可以唯一指定一个用户的用户名，因此是十分适用的。我们利用map的方式来完成上述的需求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sys <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    sys[<span class="number">10001</span>] = <span class="string">"Devin"</span></span><br><span class="line">    sys[<span class="number">10002</span>] = <span class="string">"RuoShui"</span></span><br><span class="line">    fmt.Println(sys[<span class="number">10002</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们定义且初始化了一个map映射，然后向该映射中添加了两组数据，分别是两个用户的身份id以及用户姓名，当通过id进行查找姓名时，可以直接通过map中的键得到对应的值，相比于用两个切片来保存，使用映射的技术更为合适。</p><h3 id="map的使用方式"><a href="#map的使用方式" class="headerlink" title="map的使用方式"></a>map的使用方式</h3><p>&emsp;&emsp;在这个小节中，我们不准备介绍map映射的内存构成，因为其构成方式十分的复杂，其核心是采用hashmap的算法方式进行的分布存储，且数据结构也包含了数组配合链表，且采用红黑树的原则进行存储。因此在没有讲解数据结构与算法相关知识之前，直接介绍map的内存构成不是一个好的选择，这对初学者来说也并不十分友好，因此就直接跳过这部分进而对map的使用进行讲解。 </p><h4 id="make函数的使用"><a href="#make函数的使用" class="headerlink" title="make函数的使用"></a>make函数的使用</h4><p>&emsp;&emsp;关于make函数，我们在讲解切片的时候就已然提及过了，我们曾用这个函数为切片分配空间。同理，在map映射中，我们依旧需要这个函数对映射进行初始化，否则该map只是一个空指针，输出时会出现nil。 </p><p>&emsp;&emsp;make函数在初始化map映射时有两种写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(映射类型,初始大小)</span><br><span class="line"><span class="built_in">make</span>(映射类型)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述两个方式中，唯一区别就是是否需要为map分配初始大小。如果省略该参数，编译器会自动为map分配默认的大小，而如果指定大小的话则会分配对应的空间，其特性与切片大致相似：当为map插入数据时一旦溢出该空间则会自动增长。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> , <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="1-先声明再初始化最后赋值"><a href="#1-先声明再初始化最后赋值" class="headerlink" title="1. 先声明再初始化最后赋值"></a>1. 先声明再初始化最后赋值</h4><p>&emsp;&emsp;同切片数据类型一样，map映射的使用方式也是这三个步骤。接下来我们将针对这三个步骤分别进行讲解：首先是声明部分，由于映射需要键的数据类型与值的数据类型两个部分，再加上变量名等等，因此map的声明方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 <span class="keyword">map</span>[键的数据类型]值的数据类型 = <span class="keyword">map</span>[键的数据类型]值的数据类型</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如采用上述的需求：用户的id号为整数类型，用户的姓名为字符串类型，因此其声明方式为：map[int]string。再举一个例子：我们需要存储用户的email以及用户的年龄，且email值可以唯一指定这个用户的年龄。因此此时的声明方式中键的类型为string，值的类型为int：map[string]int。 </p><p>&emsp;&emsp;在map映射声明后，我们暂时还无法使用它，因为此时它只是一个指向nil的指针类型，是没有分配空间的，因此声明过后需要通过make函数为map分配空间与资源：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> , <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个地方需要注意的问题是：在make函数中传入的参数类型要与map声明的类型相同，例如map的声明类型为键是字符串、值为整数，则传入的参数的类型也是需要是这个类型不可以改变。 </p><p>&emsp;&emsp;在为map分配的内存空间资源后，它就可以进行赋值等使用操作了，在后面我们将针对map结构的增加、删除、修改、查找分别进行举例讲解，所以在这里我们暂时不提map的使用。</p><h4 id="2-直接make初始化后再赋值"><a href="#2-直接make初始化后再赋值" class="headerlink" title="2. 直接make初始化后再赋值"></a>2. 直接make初始化后再赋值</h4><p>&emsp;&emsp;经过了前面多个小节的讲解，想必对Go语言中直接将声明和初始化合称为一条语句的做法都不陌生了，所以map映射也是可以在定义时直接初始化空间的，同理对于变量的类型自动推导也不难理解，此处就举一个例子而不全部讲解了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sys <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">sys := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="3-直接赋值初始化"><a href="#3-直接赋值初始化" class="headerlink" title="3. 直接赋值初始化"></a>3. 直接赋值初始化</h4><p>&emsp;&emsp;正如基本数据类型变量的初始化一样，map映射也可以直接在定义的时候初始化其初始值。初始化的方式与切片的初始化方式十分相似，其不同点就是map初始化的时候需要采用键：值的方式进行初始化。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sys := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="number">10001</span>: <span class="string">"Devin"</span>,</span><br><span class="line">        <span class="number">10002</span>: <span class="string">"RuoShui"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(sys)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面的这段程序中，类型自动推导sys的数据类型，且声明键为int，值为string的map过后直接用大括号进行初始化。初始化过程中的键和值的类型需要与定义完全一致。这里需要注意的一个地方就是初始化过程中的最后一个逗号，一般来说逗号是分割两组数组的符号，因此在最后一个数据后是没有逗号的，但是，在map的初始化过程中，这个逗号是必要的不可以被省略。 </p><h3 id="map映射的增删改查"><a href="#map映射的增删改查" class="headerlink" title="map映射的增删改查"></a>map映射的增删改查</h3><h4 id="1-增加数据与修改数据"><a href="#1-增加数据与修改数据" class="headerlink" title="1. 增加数据与修改数据"></a>1. 增加数据与修改数据</h4><p>&emsp;&emsp;之所以将这两个部分放在一起来讲是因为其使用形式是一样的，都是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名[键]=值</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当map中不存在当前的这个键时，执行上述形式的代码可以将对应的键和值加入到map中，即添加数据。当map中已经存在了这个键，则将新的value覆盖掉原来对应的值，即修改数据。具体的案例我们在入门程序中已然有所提及。 </p><h4 id="2-查询数据"><a href="#2-查询数据" class="headerlink" title="2. 查询数据"></a>2. 查询数据</h4><p>&emsp;&emsp;在执行网络编程等程序中，我们可能并不知道map中究竟含有什么数据，因此需要对数据进行通过键来查找。同样地，此时也会出现两种情况：键存在与键不存在。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value值, 键是否存在 = 变量名[键]</span><br><span class="line">value, exist = sys[<span class="number">10003</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的调用方式中，如果在map中存在希望查找的键，则exist的值为true，value就是map中对应的值，当map中不存在对应的键时，exist的返回值为false。 </p><p>&emsp;&emsp;除此之外，我们有时候不仅需要通过键来寻找对应的值，而是希望得知值中是否包含某个值，此时就需要对map进行遍历，然而map只支持通过键来得到值，因此map的遍历其实就是对key的遍历。当得到了key后，其value就自然可以得到了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sys := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="number">10001</span>: <span class="string">"Devin"</span>,</span><br><span class="line">        <span class="number">10002</span>: <span class="string">"RuoShui"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> key, value := <span class="keyword">range</span> sys &#123;</span><br><span class="line">        fmt.Println(key, <span class="string">" "</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3. 删除数据"></a>3. 删除数据</h4><p>&emsp;&emsp;既然查询数据是需要通过键来完成，那么删除数据当然也是需要通过键来完成。在map数据的删除中，我们使用的是系统内建函数:delete。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>名，键)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;即从指定的map中删除对应的键和值，这个调用方式与切片的追加append函数调用方式相同，只是append函数需要通过一个切片进行接收，而delete函数是可以不用变量来接收。 </p><p>&emsp;&emsp;在删除数据的过程中，当需要删除的键存在时，直接在map中删除对应的键和值，当需要删除的键不存在时，则什么都不做，程序运行过程中不会报错。 </p><p>&emsp;&emsp;在Go语言中，不存在一个函数用来完全清空一个map映射，如果用户希望清空一个map，则需要对map进行遍历，在遍历的同时逐个进行删除。亦或使用make函数为该map重新分配一个空间，而抛弃原有的空间，此时原有的空间可以被垃圾回收机制gc所回收，新的空间是空的，也算是另一种意义上的清空。 </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们对Go语言中的另一种数据类型map映射进行了引入，并使用它完成了一个简单的需求案例。除此之外我们也讲解了map映射的三种定义及使用方式以及在代码中对map进行数据增删改查的操作方式。在下一小节中我们将会依旧针对于map映射深入讲解一些细节以及注意事项。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;33&gt; 切片使用细节</title>
      <link href="/2020/03/07/33-%E5%88%87%E7%89%87%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/"/>
      <url>/2020/03/07/33-%E5%88%87%E7%89%87%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-33-gt-切片使用细节"><a href="#Go语言从入门到放弃系列-lt-33-gt-切片使用细节" class="headerlink" title="Go语言从入门到放弃系列&lt;33&gt; 切片使用细节"></a>Go语言从入门到放弃系列&lt;33&gt; 切片使用细节</h2><p>&emsp;&emsp;在上一个小节中，我们通过案例引入了切片的概念，同时也讲解了切片的定义方式、使用方式、独特的追加元素与拷贝的方式。不仅如此，我们也讲解了切片的内存构成，并得到一个结论是切片是一个引用类型，且引用的底层就是一个Go语言中的数组。在这个小节中，我们将继续针对Go语言中的切片数据类型进行深入的讲解，并对其使用过程中的注意事项进行讲解。 </p><h3 id="len与cap函数"><a href="#len与cap函数" class="headerlink" title="len与cap函数"></a>len与cap函数</h3><p>&emsp;&emsp;在上一小节中，我们在对切片的内存进行图解的讲解时，我们在图中不仅画出了切片所指向的数组的物理地址，我们还在其后画出了两个值，分别为：切片的长度与切片的容量。首先我们通过一个入门程序来通过这两个函数的调用完成切片的长度与容量的获取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice))</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从程序中，我们可以发现len函数和cap函数都是系统内建函数，是不需要引入任何的包的。同时len函数的返回值为切片的长度，cap函数的返回值为切片的容量。那么为什么会在切片的结构体中定义这两个变量，是因为切片的长度是可以动态变化的。 </p><p>&emsp;&emsp;如果我们将视角返回到数组中，如果我们有一个需求为当前已经满了的数组添加一个数字，我们可以能采用两种方式：第一种为将数组改变成为链表，这样就可以随意地添加、删减元素，但是此时数据的快速查找就变得非常不容易；第二种方式为：每当需要插入一个数据，就新申请一个长度+1的数组，并将原数组中的所有值复制给新的数组，并在最后加入新值，这种方式保存了数组的元素快速查找的特性，但是对于频繁增加数据的情况下就十分地浪费资源，因为做了极多次的申请与复制操作。 </p><p>&emsp;&emsp;而对于切片而言，由于其底层就是一个数组，因此将数组改为链表这个方式就基本不可能了，而每次都申请长度+1的数组又太过频繁了。因此解决方式是当数组元素个数已经满了，申请新的数组时就多申请一部分的空间以备用。当申请结束后新数组的长度成为切片的容量，新数组中存在元素的个数成为切片的长度，我们举一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice[<span class="number">0</span>])</span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice[<span class="number">0</span>])</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice))</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述程序中，我们定义了一个切片，且指定了长度为5，容量为10，此时由于切片定义后未修改值，所以输出的slice结果为：[0 0 0 0 0]，且输出了数组中第0个元素的物理地址，本次本机输出值为：0xc00008e000。然后我们为slice切片追加一个元素1，再一次输出该切片的元素，此时切片的长度变为了6，输出结果为：[0 0 0 0 0 1]，此时再次输出数组中的第0个元素的物理地址，本次本机为0xc00008e000。最后输出切片的长度为6，容量为10。 </p><p>&emsp;&emsp;从上述的输出结果中，我们可以总结出以下几点：每次执行append函数时，切片的长度会变为两个参数切片（或者可变参数）的长度的和，因为此时只追加一个元素，所以长度变为+1后的值；切片的容量在长度不超过容量数时不发生变化，一旦超出了我们下面会继续讲解；两次输出的切片所对应的数组的首地址是相同的，因此可以断定追加前与追加后是同一个数组，物理地址没有发生变化。 </p><p>&emsp;&emsp;上面的例子是追加元素后没有超出容量的情况，下面我们再举一个超出容量的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice[<span class="number">0</span>])</span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice[<span class="number">0</span>])</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice))</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序与上述程序的唯一区别就是：将切片定义时的容量由10变为5，所以最初状态就是切片的长度为5，且只能容纳5个值，即底层的数组处于满员的状态。此时再添加一个元素，由于原数组已经无法容纳这些值了，所以需要申请一个新的数组，其输出结果可以证明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"><span class="number">0xc000080060</span></span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"><span class="number">0xc000092000</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述的输出结果中，我们可以看出：数组的首地址是不相同的，所以当追加数据时数据溢出的情况下底层会新申请一个数组。不仅如此，新申请的数组的长度（切片的容量）由5变成了10。</p><h3 id="切片注意事项与细节说明"><a href="#切片注意事项与细节说明" class="headerlink" title="切片注意事项与细节说明"></a>切片注意事项与细节说明</h3><p>&emsp;&emsp;在接下来的部分中，我们将针对于切片的使用细节以及注意事项作出简要的说明，这些细节可能在之前的部分中有所提及，可以一并回忆一下之前的知识点。 </p><ol><li><p>切片通过数组初始化时var slice = array[start:end] 是从数组下标为start开始到end为止（不含）的截取，且截取方式为：<strong>左闭右开</strong>。 </p><p>&emsp;&emsp;例如：取出数组中的全部元素成为切片是array[0:len(array)]而不是array[0:len(array)-1]。</p></li><li><p>切片初始化时依然不可以越界，其范围依旧在0到len(array)之间（左闭右开），但是是可以动态增长的。在数组的截取过程中，有一些截取部分的简化操作：</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = array[<span class="number">0</span>:end]        ==&gt;  <span class="keyword">var</span> slice = array[:end]</span><br><span class="line"><span class="keyword">var</span> slice = array[start: <span class="built_in">len</span>(array)]  ==&gt;  <span class="keyword">var</span> slice = array[start:]</span><br><span class="line"><span class="keyword">var</span> slice = array[<span class="number">0</span>: <span class="built_in">len</span>(array)]    ==&gt;  <span class="keyword">var</span> slice = array[:]</span><br></pre></td></tr></table></figure><ol start="3"><li>cap是一个内置函数，不需要引入任何的包，用于统计切片的最大容量，在数据追加过程中，如果追加后长度没有超出容量则不变，一旦超出容量则新申请数组后容量变为二倍。在这里不做演示了，只放置一个示例程序，读者可以自行运行后观察数据规律：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"长度为：%d，容量为：%d\n"</span>, <span class="built_in">len</span>(nums), <span class="built_in">cap</span>(nums))</span><br><span class="line">    nums = <span class="built_in">append</span>(nums, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>切片的核心其实就是底层的数组，因此切片可以继续切片。</p></li><li><p>切片是引用类型，即作为函数参数传递时，被调用者对切片数据进行修改时会影响到调用者函数中的值。 </p><p>&emsp;&emsp;针对这个特性我们举一个例子：利用一个字符（整数）切片存储多个字符，并且在自定义函数中将该切片中所有大写字母转换成对应的小写字母。</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> info []<span class="keyword">byte</span> = []<span class="keyword">byte</span>&#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'L'</span>, <span class="string">'O'</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(info); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, info[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    change(info)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(info); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, info[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(slice []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> delta = <span class="string">'a'</span> - <span class="string">'A'</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> slice[i] &gt;= <span class="string">'A'</span> &amp;&amp; slice[i] &lt;= <span class="string">'Z'</span> &#123;</span><br><span class="line">            slice[i] += <span class="keyword">byte</span>(delta)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="string类型与切片"><a href="#string类型与切片" class="headerlink" title="string类型与切片"></a>string类型与切片</h3><p>&emsp;&emsp;在Go语言中，string类型是一种相对特殊的基本数据类型。说其特殊是因为它也是引用了某一个底层数组而存在的。可以说，string类型的底层就是一个byte数组，但是这个数组是不能够通过单个字符修改方式进行访问或修改，在string的引用中，依旧无法对其进行修改。 </p><p>&emsp;&emsp;那么既然string的底层是byte数组，而切片底层也可以是byte数组，所以string和切片可以有一些异曲同工之妙，同时string字符串类型是可以进行切片操作的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> info <span class="keyword">string</span> = <span class="string">"Hello World"</span></span><br><span class="line"><span class="keyword">var</span> slice = info[:<span class="number">6</span>]</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们之前只通过裁剪的方式对数组进行操作，而上述的程序中是可以直接通过裁剪的方式对string字符串进行操作的，这也侧面反映出了string的核心就是一个数组。 </p><p>&emsp;&emsp;除此之外，字符串类型是一种常量，一旦定义初始化后就不可以进行修改了，在数组中，我们可以通过a[i] = 10的方式对数组中任意一个元素进行修改，但是在string类型中，我们不可以通过str[0] = ‘a’的方式进行修改。这个是常量的属性所规定的。 </p><p>&emsp;&emsp;但有些时候可能就会出现类似如下的需求：输入一个字符串后，需要对每一个字符进行操作，例如把所有的大写字母转换成小写字母（程序核心实现函数已在上面的代码中提及）。既然string类型是常量无法被修改，我们只能通过将其转换成为一个切片来操作，我们只举一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> info <span class="keyword">string</span> = <span class="string">"Hello World"</span></span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">byte</span> = []<span class="keyword">byte</span>(info)</span><br><span class="line">...</span><br><span class="line">info = <span class="keyword">string</span>(slice)</span><br><span class="line">fmt.Println(info)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述程序中，我们首先定义了一个字符串string，然后将其强转成为一个byte切片（如果字符串中含有中文，需要转换成为rune切片），接下来对切片进行某种处理后，我们再将切片强转回string类型，这个过程结束后才相当于对字符串中的某些元素进行了操作。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们集中讲解了slice切片中的两个函数：len函数与cap函数的含义以及注意事项，同时也讲解了当执行append操作后slice中len和cap发生的变化，以及底层数组发生的相应的改变。除此之外，我们还讲解了slice类型在程序编写的过程中需要注意的问题，最后我们讲解了string基本数据类型与slice引用类型的相互关系。 </p><p>&emsp;&emsp;在下一个小节中，我们将开始介绍Go语言中map的含义以及使用方式，并将map这种数据类型与数组、切片等数据类型相结合做出相对具体的讲解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;32&gt; 切片引入</title>
      <link href="/2020/03/06/32-%E5%88%87%E7%89%87%E5%BC%95%E5%85%A5/"/>
      <url>/2020/03/06/32-%E5%88%87%E7%89%87%E5%BC%95%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-32-gt-切片引入"><a href="#Go语言从入门到放弃系列-lt-32-gt-切片引入" class="headerlink" title="Go语言从入门到放弃系列&lt;32&gt; 切片引入"></a>Go语言从入门到放弃系列&lt;32&gt; 切片引入</h2><p>&emsp;&emsp;在之前的各个小节中，我们集中讲解了数组的概念及其用法，同时我们也拓展了二维数组以及多维数组的概念，在这个小节中，我们将根据之前我们接触到的数组的概念，来讲解Go语言中的另一个数据类型：切片。同时，我们也会对切片的定义及使用通过入门程序进行讲解，读者在阅读过程中，可以将其与数组的相应的概念进行对比，找出其共同点与不同点，以免在后续的章节中混淆。</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>&emsp;&emsp;在这个部分中，我们依旧采用一个需求来引出切片的含义以及使用范围。我们假设一个简单的需求：为学校完成一个学生成绩管理系统，存储学生的单科的成绩信息。这个需求与数组的引入需求十分类似，因此如果使用之前所说的数组来完成，我们可能会写出如下的代码结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> grades [<span class="number">50</span>]<span class="keyword">int</span> = [<span class="number">50</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(grades); i++ &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么对于上述的代码块而言，依旧存在着一些不足，其关键的问题点是：数组究竟需要定义多么大。在上述的代码块中，我们硬编码了学生人数为50人，但是假如一个班的学生不足50人，则会出现内存空间的浪费，同时在对数组进行遍历的时候也会出现一些麻烦的事，后面的一些数据都是0。同理，假如一个班中的人数超过了50人，则数组定义的长度是无法足够存储的，会造成信息的缺失，乃至于数组的越界。因此，我们需要一个长度可以动态变化的数组，切片就刚好满足了这个特性。 </p><p>&emsp;&emsp;其实类似的需求还有很多，例如从文件中读取数据，但是并不知道文件中究竟有多少个数据。从网络输入流中读取信息，但不知道信息有多少字节。这种不确定性会对开发者造成很多不必要的麻烦，所以在工程项目中，切片所被运用的范围是比数组要广的，而在数学运算等领域，数组（矩阵）还是占据更多的位置。 </p><p>&emsp;&emsp;运用切片后，我们可以将上述的代码改写为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> grades [<span class="number">50</span>]<span class="keyword">int</span> = [<span class="number">50</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> slice = grades[:]</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">slice = <span class="built_in">append</span>(slice,<span class="number">100</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="切片的存储结构"><a href="#切片的存储结构" class="headerlink" title="切片的存储结构"></a>切片的存储结构</h3><p>&emsp;&emsp;介绍完切片的使用场景后，我们对切片的内存构造进行简要的讲解。首先我们考虑一个问题，在Go语言中这个数据类型为什么被称为切片，亦或说它究竟是谁的切片。弄清楚这个问题后，切片的内存构造就迎刃而解了，根据我们的入门程序来看可以知道：切片这种数据类型就是数组的切片，是数组的一部分。首先我们看一小段程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">fmt.Println(array)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序似乎并不难理解，因为我们只是在程序中定义并初始化了一个数组，这个数组具备自己的独立的对元素的控制权，此处也就不需要多做说明了，相信这个数组在内存中的存储形式也不需要多说了。接下来，我们在程序中添加两条语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">var</span> slice = array[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, array)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, slice)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从程序中，我们可以发现我们对array数组做出了某种操作并将结构赋值给一个slice变量，最后我们分别输出了array的数据类型以及slice的数据类型。其输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">[]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据两个输出结果，我们可以发现：对array进行的某种操作并没有改变array的任何属性，它依旧是一个10个元素的数组。而新定义的slice类型为[]int，这个结果我们在讲解数组的时候就提及过了，这个类型就是切片。接下来我们再输出此时array的值以及slice的值，我们可以发现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;切片内数据的输出值与数组内数据的输出值十分类似，只是说切片输出的值是数组中的某一部分，即数组的某个切片，那么切片数据在内存中是怎样存储的呢，它是不是像数组一样存储，我们进行分析。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">var</span> slice = array[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">slice[<span class="number">0</span>] = <span class="number">11</span></span><br><span class="line">fmt.Println(array)</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这一小段程序中，我们通过slice切片来对slice中的第0个值进行修改，并将其赋值为11，最后我们再次输出array的值以及slice的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">11</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span>]</span><br><span class="line">[<span class="number">11</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个结果中，我们可以发现，通过slice切片进行切片内的数据修改，直接影响到了数组中的数据，这与之前我们所说到的通过指针改变数据的现象十分相似。因此可以得到一个结论：切片的内存存储形式是与数组相关的，而且很大程度上切片是数组的某个引用，而不是相互独立的两个不同的连续的内存空间。我们再做一个小实验：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;array[<span class="number">0</span>])</span><br><span class="line">fmt.Printf(<span class="string">"%p"</span>, &amp;slice[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将切片中的第0个元素的物理地址输出来，并将数组中的第0个元素的物理地址输出来，我们会发现这两个输出结果是完全一致的，换句话说，slice和array是共用一套数据的。其内存构成我们用一个图来说明：<br><img src="/2020/03/06/32-%E5%88%87%E7%89%87%E5%BC%95%E5%85%A5/1.png" alt></p><p>&emsp;&emsp;所以说，Go语言中的切片是由三部分组成的，第一部分是数组中裁剪区的首地址，第二部分是切片目前的长度，第三部分则是当前切片的容量，len和cap这两个属性我们会在下一小节中精讲。由于数组的内存是连续的，因此对于切片而言，只需要明白裁剪部分的首地址和切片的数据类型，就可以轻松地通过加减法得到第i个值的内存地址及其数值，同时这也说明了为什么切片的数据发生修改会影响到其裁切的数组的值。</p><h3 id="切片的使用"><a href="#切片的使用" class="headerlink" title="切片的使用"></a>切片的使用</h3><p>&emsp;&emsp;由于切片的底层实现就是数组，因此切片的使用方式和数组的使用方式如出一辙。包括切片的两种遍历方式，切片下标初始值，是否出现溢出现象，这些特性都与数组完全相似。在这里我们再简要讲解一下。</p><h4 id="切片的定义与初始化"><a href="#切片的定义与初始化" class="headerlink" title="切片的定义与初始化"></a>切片的定义与初始化</h4><p>&emsp;&emsp;在Go语言中，切片的初始化方式有三种，在我们上一部分的代码讲解中，我们可以知道第一种定义方式就是借助一个定义好的数组进行裁剪得到一个切片。此时切片具备数组的引用，切片和数组同时可以控制内存中的数据。 </p><p>&emsp;&emsp;第二种方式便是采用Go语言中内建函数make的方式进行，通过make函数进行的内存分配是在堆区，且它只能运用在channel、map、以及slice的创建。其返回值的类型就是这三种类型本身。make函数的签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span> <span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以说make函数的参数中，需要指明返回值的类型是什么，如果我们传入了一个切片，则返回的就是一个切片。后面的可变参数中，在slice的内存分配上，往往是需要两个值的，分别为切片长度，以及切片容量。在这两个值中，切片容量可以省略，如若省略则代表其容量与长度是相同的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line">    slice[i] = i</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的这段程序中，我们通过make函数定义了一个切片，且对切片中的每个值进行赋值操作。在最后的输出中，我们可以发现输出结果中含有5个值，分别为0到4。此时在这段程序中，slice切片依旧与底层的一个数组向关联，只是此时这个数组是由切片所管理的，而不能像第一种定义方式一样控制底层数组。 </p><p>&emsp;&emsp;第三种初始化方式则和数组非常类似，唯一的区别就是在中括号中不写任何的值。我们在这里只简单地通过一个例子来讲解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过输出结果，我们可以看出：此时slice的数据类型是切片，且初始化过程是成功的。因此可以讲，数组与切片的初始化不同点只在于中括号中是否明确指定了固定的数字，一旦指定了或采用…来表示，则是数组。中括号中没有任何的值则是切片。</p><h4 id="切片的遍历与追加"><a href="#切片的遍历与追加" class="headerlink" title="切片的遍历与追加"></a>切片的遍历与追加</h4><p>&emsp;&emsp;在这个小部分中，我们首先简单地提及切片的遍历方式，由于其和数组的遍历方式完全一致，所以在这里我们只列出for循环以及for-range结构的遍历方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;既然我们讲切片相对于数组的优势就是切片是一种动态的数组，可以向切片结尾随时追加数据。而追加数据的方式则是Go语言的内建函数：append函数。其主要作用就是为了给某个切片追加元素，快速入门案例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段代码的含义是：为一个切片（[]int{1,2,3}）追加三个元素，且追加的元素为：4,5,6,追加元素过后将新的切片赋值给slice。其实在append的过程中，底层数组还是发生了一定的变化的，具体的变化我们会在下个小节的精讲中进行讲解。 </p><p>&emsp;&emsp;append函数可以将多个单独的元素追加到切片的结尾，同时也可以将另一个切片追加到某一个切片的结尾。当追加切片的时候，其传入的两个参数均是切片数据类型，并且在第二个切片后需要添加”<strong>…</strong>“这个特性则刚好可以满足于切片中删除某个元素的需求。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">slice = <span class="built_in">append</span>(slice[<span class="number">0</span>:<span class="number">2</span>], slice[<span class="number">3</span>:<span class="number">5</span>]...)</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们初始化了一个名为slice的切片，在接下来的一条语句中，我们提取出slice切片的前两个数据，又提取了切片的后两个数据，将这两个切片组合在一起后赋值给slice，最后输出结果。在结果中我们可以发现原切片中的第2个元素没有被任何一个切片所截取，因此相当于在slice切片中删除了一个元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在切片中删除第i个元素：</span><br><span class="line">slice = <span class="built_in">append</span>(slice[<span class="number">0</span>:i], slice[i+<span class="number">1</span>,<span class="built_in">len</span>(slice)...] )</span><br></pre></td></tr></table></figure><h4 id="切片的拷贝"><a href="#切片的拷贝" class="headerlink" title="切片的拷贝"></a>切片的拷贝</h4><p>&emsp;&emsp;在Go语言中，开发人员有专门为切片数据类型的拷贝封装了一个函数，也是内建函数copy，该函数具备两个参数，分别为两个切片，其含义为将第二个参数所代表的切片复制给第一个参数所代表的切片，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> slice2 = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">copy</span>(slice2, slice1)</span><br><span class="line">fmt.Println(slice2)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述代码案例中，我们可以发现copy函数成功地将slice1所代表的切片复制给了slice2所代表的切片。其中需要注意的一个问题为：当两个切片的长度不同的时候，复制过程是不会报错的，且复制结果是取两个切片中最短的切片作为最终的长度，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> slice2 = []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(slice2, slice1)</span><br><span class="line">fmt.Println(slice2)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，我们可以发现，slice1切片的长度为5，而slice2切片的长度为3。当将slice1复制给slice2的时候，其结果值保留了3个值，即slice1[0],slice1[1],slice1[2]。如果我们将copy中的slice1和slice2的位置对调，并输出slice1。我们可以发现，slice1中的前三个值发生了变化，变为了7,8,9，而后两个值依旧保持为4,5。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们通过数组的方式引入了切片的概念，并对切片的内存构成做出简要的讲解。同时我们也讲解了切片的定义方式、初始化方式以及追加数据删除数据等使用方式。可以说这个小节中的知识点都相对基础，且不难理解。在下个小节中，我们将针对切片进行更为深入的讲解、以及对一些使用时的注意事项进行列举。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;31&gt; 二维数组与多维数组</title>
      <link href="/2020/03/05/31-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
      <url>/2020/03/05/31-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-31-gt-二维数组与多维数组"><a href="#Go语言从入门到放弃系列-lt-31-gt-二维数组与多维数组" class="headerlink" title="Go语言从入门到放弃系列&lt;31&gt; 二维数组与多维数组"></a>Go语言从入门到放弃系列&lt;31&gt; 二维数组与多维数组</h2><p>&emsp;&emsp;在之前的章节中，我们已经讲解了一维数组的定义方式、使用方式以及需要注意的几个点，同时也针对数组排序的需求对数组这个知识点进行了代码的书写与讲解。在这个小节中，我们将基于一维数组的概念推广到二维数组乃至于多维数组。对二维数组的定义方式、使用方式等做出讲解，并在最后通过二维数组走迷宫的案例进行代码讲解。</p><h3 id="二维数组的引入"><a href="#二维数组的引入" class="headerlink" title="二维数组的引入"></a>二维数组的引入</h3><p>&emsp;&emsp;在一维数组的讲解中，我们介绍了一维数组的概念，如果我们将一维数组比作为一个线性的数据存储格式，那么二维数组就是一个平面向的存储方式，同理推广到高维数组就可以理解为数组存储的多维空间。我们首先提出一个需求：通过Go语言完成一个课程表的显示，假设每周除去双休日需要学习五天，每天只有八节课，没有课的地方用“-”来表示。 </p><p>&emsp;&emsp;针对这个需求，如果我们采用之前学到的知识来完成，我们可能会定义五个一维数组来完成。每个一维数组存储当天的课程信息。假设不同周的课程是相同的，那么可能会写出如下的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> monday [<span class="number">8</span>]<span class="keyword">string</span> = [<span class="number">8</span>]<span class="keyword">string</span>&#123;<span class="string">"Math"</span>,<span class="string">"Physics"</span>,...&#125;</span><br><span class="line"><span class="keyword">var</span> tuesday [<span class="number">8</span>]<span class="keyword">string</span> = [<span class="number">8</span>]<span class="keyword">string</span>&#123;<span class="string">"Math"</span>,<span class="string">"Physics"</span>,...&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种写法是可以满足需求的，但是如果联想到我们介绍一维数组时所举的例子，我们会发现程序需要改进的地方是基本相同的，我们依旧定义了太多的变量，尽管每个变量都是一维数组，所以我们希望存在这样一个一维数组，这个一维数组中的每一个元素都是一维数组。在一维的前提下再添一维，就引出了二维数组。 </p><p>&emsp;&emsp;我们再次回忆一维数组的定义方式：var num [3]int，通过这个定义方式我们可以知道num是一个具有3个元素的数组，且每个元素都是int。现在假如我们定义是 var num [3][4]int，依旧采用刚刚的分析方式，我们可以知道num是一个具有3个元素的数组，且每个元素都是具备4个int元素的数组，换句话说即申请了一个三行四列的二维数组。二维数组的定义方式就是如此。</p><h3 id="二维数组的内存构成"><a href="#二维数组的内存构成" class="headerlink" title="二维数组的内存构成"></a>二维数组的内存构成</h3><p>&emsp;&emsp;介绍这个问题的原因是：我们计算机中的硬件内存是一个线性内存，因此通过一维的线性内存来反映二维的乃至于多维的数组是需要通过一些方式的。而不同的计算机语言对于这个一维到二维的映射方式也是不同的。主流思想有两个：按行存储（例如C语言），按列存储（例如Fortran语言），因此明白数组在内存中的结构是需要的，它会决定数组定义的简化方式以及快速查找的计算模型。首先我们通过一个案例来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;nums)</span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;nums[<span class="number">0</span>])</span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;nums[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序构成十分简单，我们单纯地定义了一个2行3列的整数型的数组，由于我们未对其进行初始化或赋值，因此数组中的每一个值都是0，即该数据类型的零值。接下来，我们输出了数组的首地址、第0行的地址、以及第1行的地址，我们可以发现其结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xc000080060</span></span><br><span class="line"><span class="number">0xc000080060</span></span><br><span class="line"><span class="number">0xc000080078</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过程序的输出结果，我们可以发现数组的地址就是第0行数组的地址，这个似乎不需要解释。其次我们可以发现，nums[0]的物理地址与nums[1]的物理地址相差了18个字节（十六进制），换算成十进制则是相差了24个字节。由于笔者的计算机是64位操作系统，因此一个int类型占据了8个字节，这样看来相差的24个字节刚好满足了存储3个int类型数据。用一个图解来表示则为：<br> <img src="/2020/03/05/31-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/1.png" alt></p><p>&emsp;&emsp;现在我们通过二维数组的内存构成来推导出高维数组的表示方式，同样地，计算机内存是线性的因此需要通过映射来完成。例如我们定义了一个三维数组：var nums [2][3][4]int，我们可以推断出：nums[0]的地址与nums[1]的地址相差：3*4*8=96个字节，nums[0][0]与nums[0][1]的地址相差：4*8=32个字节，nums[0][0][0]与nums[0][0][1]的地址相差8个字节。 </p><p>&emsp;&emsp;因此我们可以推断出：在Go语言中，数组的存储形式是按行存储，否则连续的两个元素之间的地址差将会是该数据类型的整数倍，而不是单独的一个数据空间。</p><h3 id="二维数组的定义与初始化"><a href="#二维数组的定义与初始化" class="headerlink" title="二维数组的定义与初始化"></a>二维数组的定义与初始化</h3><p>&emsp;&emsp;参照于一维数组的定义与初始化形式，二维数组也有四种基本的初始化方式，接下来我们逐一地进行讲解。首先二维数组的定义方式我们在入门案例中已经提及了，这里就不过多的讲解了。我们着重说明初始化的方式。 </p><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>&emsp;&emsp;第一种方式就是将所有需要的信息完全写在初始化过程中，不省略任何一个元素，其初始化方式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 [大小][大小]数据类型 = [大小][大小]数据类型&#123;&#123;数据，...&#125;,&#123;数据，...&#125;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们举一个例子，定义一个两行三列的数组，且初始化其值为1到6：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line">fmt.Println(nums)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们可以发现，由于1,2,3处在同一行，4,5,6处在同一行，因此，将同一行所对应的元素用大括号包裹起来，这样也有助于编译器分别对不同的值进行初始化。同时，每一行只有三个元素，因此每行最多只能初始化三个值，一旦当前行中初始化的值不够定义的个数，则用零值来补全，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时由于我们在第0行中只初始化了两个值，因此这个数组的初始化结果其实为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>&emsp;&emsp;由于我们在初始化过程中用大括号对每行数据进行了指定，因此，程序在编译过程中就可以知道这个数组究竟有几行，因此行数的大小是可以不指定的，通过三个点号来代替，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums [<span class="number">2</span>][<span class="number">3</span>] = [...][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种初始化的方式相对来说比较鸡肋，因为在数据定义的时候已经指定了数组的行数和列数，那在后面通过三个点号来表示就完全没有意义了。其实这个特性主要是用在数据类型的自动推导中，在这里暂时不做讲解。</p><h4 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h4><p>&emsp;&emsp;基本数据类型可以通过自动推导得到，那二维数组当然也具备这个特性，因此，我们介绍的第三个初始化方式就是数组的自动推导，根据初始化过程完成数据类型的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 = [大小][大小]数据类型&#123;&#123;初值,...&#125;,&#123;初值,...&#125;...&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种方式与之前提及的各种数据类型的自动推导完全一致，如果明白了方式一的定义方式，这个就迎刃而解了。当然，我们也可以通过:=的方式来完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名 := [大小][大小]数据类型&#123;&#123;初值,...&#125;,&#123;初值,...&#125;...&#125;</span><br></pre></td></tr></table></figure><h4 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a>方式四</h4><p>&emsp;&emsp;第四种方式其实就是省略行数的自动推导类型方式，这个方式与我们提及的方式二有所不同，具体不同点我们会进行讲解。首先我们先列出方式四的初始化格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 = [...][大小]数据类型&#123;&#123;初值,...&#125;,&#123;初值,...&#125;...&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过大括号定义了具体的行元素，那么有几行就可以知晓了，因此省略行数的自动推导所得到的数据类型与初始化中的大括号对数相关。这点与方式二不同，方式二得到的数据行数是通过定义指明了的，而方式四的数据行数是推导的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span> = [...][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(nums))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的这段通过方式二初始化的程序是编译不通过的，其报错的原因是：自动推导出[1][3]int的数组而赋值给[2][3]int的数组，出现了数据类型不匹配的错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [...][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(nums))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;而这一段程序是不会出现错误的，输出的结果即二维数组的行数为1，此时的nums数组为一行三列。</p><h3 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h3><p>&emsp;&emsp;在介绍二维数组的定义过后，我们继续讲解二维数组的使用方式，而众多的使用方式中，遍历是最为常见之一，因此二维数组的遍历我们在这里简单地提及。</p><h4 id="双层for循环遍历"><a href="#双层for循环遍历" class="headerlink" title="双层for循环遍历"></a>双层for循环遍历</h4><p>&emsp;&emsp;在二维数组引入的过程中，我们将二维数组看作成元素为数组的数组，因此通过这个理解方式，我们可以发现：对外层的大数组取其长度，（即得到多少个一维数组）就是该二维数组的行数，同理进入到大数组中的元素（小数组）后，该长度就是二维数组的列数，因此二维数组的遍历方式可以为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i&lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j&lt; <span class="built_in">len</span>(nums[<span class="number">0</span>]); j++ &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//取元素时通过nums[i][j]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-range方式遍历"><a href="#for-range方式遍历" class="headerlink" title="for-range方式遍历"></a>for-range方式遍历</h4><p>&emsp;&emsp;for-range遍历方式与上述双重循环类似，因为for-range其本质也就是一个循环。在for-range结构中，我们通过传入的数组可以得到该数组中每个元素的位置以及值，而对于二维数组而言，通过for-range得到其元素其实就是得到了一个一维数组，再对该一维数组进行for-range操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, valuei := <span class="keyword">range</span> nums &#123;</span><br><span class="line">    <span class="keyword">for</span> j, valuej := <span class="keyword">range</span> valuei &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//此时valuej就是遍历到的元素，i，j就是该元素的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;介绍了以上两种二维数组的遍历方式之后，对于高维数组的扩展就不必多说了，无非就是多个for循环的嵌套，或者for-range结构的嵌套，当然for循环与for-range结构混用也是没有问题的。</p><h3 id="二维数组代码举例"><a href="#二维数组代码举例" class="headerlink" title="二维数组代码举例"></a>二维数组代码举例</h3><p>&emsp;&emsp;在这个部分中，我们将针对一个走迷宫的初级问题来对二维数组的使用进行举例，需求如下：假设有一个N乘以N的数组，在数组中0代表空地，1代表墙，2代表目的地，问给定一个数组和一个起点，是否存在一条路径使得从起点到终点有一条通路。 </p><p>&emsp;&emsp;例如，我们使用如下的一个迷宫矩阵，且设定起始位置为（1,1）点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这里我们采用递归的方式进行深度优先搜索，当然这个方式不是一个非常合适的方法，只是说其中涉及到递归的技术，以及逻辑表达式的一些问题，可以复习一下前面的知识，就用这种方式举例。当然，实现方式可以不同，面对一个问题多个人就有多个解法。解法之一的思想如下： </p><p>&emsp;&emsp;我们可以将数组中的点分为三类，第一类是可继续行动的点，第二类是不可行动的点，第三类就是终点。针对于这三种不同的点逻辑是不同的。假设我们有一个返回值是布尔变量的函数，参数是当前的x、y值，当当前的点为不可行动的点（如数组中的1）时，返回false，当这个点是终点的时候，返回值是true，当这个点是一个空地，那么就需要判断它的上下左右的点能否到达终点。且上下左右能到终点的逻辑呈现或的关系，即一旦有一个方向能到终点，该点就可以通向终点。回溯回去，就可以证明从起点出发可以到达终点。函数逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CanGetToDes</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> maze[x][y] == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> maze[x][y] == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> maze[x][y] == <span class="number">0</span> &#123;</span><br><span class="line">        maze[x][y] = <span class="number">1</span></span><br><span class="line">        <span class="comment">//在这里我们将其设定为1，代表这个点已经搜索过了，以后不要再搜索了，否则会出现无限循环。</span></span><br><span class="line">        <span class="keyword">return</span> CanGetToDes(x<span class="number">-1</span>, y) || CanGetToDes(x+<span class="number">1</span>, y) || CanGetToDes(x, y<span class="number">-1</span>) || CanGetToDes(x, y+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;主函数就负责调用该函数即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(CanGetToDes(<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后将maze数组定义为全局变量，使得各个函数都可以调用该变量，当然这只是为了简便，也可以通过函数参数将maze数组进行传递而不需要全局变量。全部的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maze [<span class="number">6</span>][<span class="number">6</span>]<span class="keyword">int</span> = [<span class="number">6</span>][<span class="number">6</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(CanGetToDes(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CanGetToDes</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> maze[x][y] == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> maze[x][y] == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> maze[x][y] == <span class="number">0</span> &#123;</span><br><span class="line">        maze[x][y] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> CanGetToDes(x<span class="number">-1</span>, y) || CanGetToDes(x+<span class="number">1</span>, y) || CanGetToDes(x, y<span class="number">-1</span>) || CanGetToDes(x, y+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据输出结果，我们可以发现输出为true，即存在一条通路使得起点到达终点，如果我们修改了maze数组，例如将maze[3][4]的值修改为1，则输出结果会成为false。当然，我们可以根据这个需求和方法进行加深，例如：求取从起点到终点的最短路径，如果无法到达则输入-1。程序实现也是可以基于当前的这个代码进行扩展的，如果读者有兴趣，可以自行探索并完成代码的书写。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们集中讲解了二维数组的定义以及使用方式，进而对多维数组进行引出和拓展。我们讲解了二维数组的内存构成、四种初始化方式以及常用的遍历方式。最后我们通过走迷宫这个小案例来完成二维数组的代码案例。在下一小节中，我们将会介绍到切片数据类型，这种数据类型与数组十分相似，在看下一小节之前一定明白数组的定义方式，否则容易相互混淆。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;30&gt; 数组代码篇-几种排序方式</title>
      <link href="/2020/03/04/30-%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81%E7%AF%87-%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/03/04/30-%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81%E7%AF%87-%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-30-gt-数组代码篇-几种排序方式"><a href="#Go语言从入门到放弃系列-lt-30-gt-数组代码篇-几种排序方式" class="headerlink" title="Go语言从入门到放弃系列&lt;30&gt; 数组代码篇-几种排序方式"></a>Go语言从入门到放弃系列&lt;30&gt; 数组代码篇-几种排序方式</h2><p>&emsp;&emsp;在上一小节中，我们集中讲解了数组的定义方式、使用方式、以及其使用的各个细节。在这个小节中，我们将针对数组的使用讲解一个代码篇，以对数组中的各个数字进行排序的需求讲解几个基本的排序算法。这几个算法原理十分简单，但是是之后学习数据结构的基础算法，因此是需要掌握的。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>&emsp;&emsp;首先我们先分析选择排序中大循环的一个循环体，选择排序的核心思想是每一次找到数组中最小的数（或最大的数），将该最小的数与第一个数相交换。这样一轮操作后，最小的数就到了最前面，然后我们取第二个数到最后一个数再实行同一个操作，就可以得到最小的数、次小的数。重复以上操作直到完全排序完成。 </p><p>&emsp;&emsp;首先我们完成内部循环的一轮操作，我们均以降序排序为例。</p><h4 id="1-寻找数组中最大的数"><a href="#1-寻找数组中最大的数" class="headerlink" title="1. 寻找数组中最大的数"></a>1. 寻找数组中最大的数</h4><p>&emsp;&emsp;给定一个数组，寻找数组中最大的数，可以借助一个临时变量来完成。遍历数组，将每一个元素与临时变量相比，当元素大于临时变量时，则用该元素替换临时变量的值，否则对比下一个数。由于我们再后续需要数组元素的交换，因此这里的临时变量我们将存储元素的下标，程序如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">10</span>]<span class="keyword">int</span> = [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> maxPos = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[maxPos] &#123;</span><br><span class="line">            maxPos = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"最大值为："</span>, nums[maxPos])</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们设定一个标兵maxPos，并令该值为0，即指代第一个元素。然后在遍历中，我们判断遍历到的值nums[i]与标兵所对应的值nums[maxPos]的大小关系，一旦遍历到的值比标兵对应的值大，标兵所指代的值就发生了变化。</p><h4 id="2-基于寻找最大值完成排序"><a href="#2-基于寻找最大值完成排序" class="headerlink" title="2. 基于寻找最大值完成排序"></a>2. 基于寻找最大值完成排序</h4><p>&emsp;&emsp;基于寻找到的最大值，我们可以将该最大值与数组的第一个元素交换，然后我们取后九个值做同样的操作，然后取后八个值……这个操作总共需要做10次，每次操作需要遍历的值逐次减小，因此其二重循环结构为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j:= i+<span class="number">1</span>; j&lt;<span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在我们将全部的代码完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">10</span>]<span class="keyword">int</span> = [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"排序前："</span>, nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">var</span> maxPos <span class="keyword">int</span> = i</span><br><span class="line">        <span class="comment">//找到最大值</span></span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[maxPos] &#123;</span><br><span class="line">                maxPos = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换顺序</span></span><br><span class="line">        nums[i], nums[maxPos] = nums[maxPos], nums[i]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"排序后："</span>, nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中需要注意的一个问题是：标兵的定义位置。由于每次寻找最大值都需要对标兵进行初始化操作，因此maxPos = i的这个操作一定放在外层循环里面，初学者可能会失手将其写在最外面或者忘记对其进行初始化值，排序结构就会出现错误。</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>&emsp;&emsp;插入排序的核心思想是，在前面的数组已经是有序的前提下，逐一地为每一个元素寻找到其合适的位置。我们可以先想象这样的一个场景：假如几个人在打牌，且正在处于抓牌的阶段，我们手中已经有了几个手牌，且是有序的，当我们再抓起一张牌的时候，我们会将其插入到手牌中的某个位置。然后手牌又变成了有序的状态直到抓下一张牌。</p><h4 id="1-寻找一个元素的合适位置"><a href="#1-寻找一个元素的合适位置" class="headerlink" title="1. 寻找一个元素的合适位置"></a>1. 寻找一个元素的合适位置</h4><p>&emsp;&emsp;这个问题是有一个假设的，这个假设我们在之前也提到了，即：最后一个元素之前的所有元素均是有序的，否则这一轮排序就是无用的。其做法为：数组从后到前进行遍历，跟踪最后一个无序的元素，当该元素与前一元素处于无序状态时，将这两个元素交换，我们用一个例子来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开始     ：   <span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line">第一次交换  ：  <span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line">第二次交换  ：  <span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line">第三次交换  ：  <span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line">结束</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的过程就相当于为4这个元素寻找到其正确的位置，我们用代码来实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">10</span>]<span class="keyword">int</span> = [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            nums[i], nums[i<span class="number">-1</span>] = nums[i<span class="number">-1</span>], nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中有两个需要注意的问题，第一个问题是i的初始元素。我们为i初始赋值为len(nums)-1是因为数组下标是从0开始到N-1位置，因此这个减一操作是必须要写的，否则会出现数组越界。第二个问题是循环的结束条件，我们设定的调试是i&gt;0而不是i&gt;=0，因为在循环体中我们判断i下标与i-1下标的值的大小，因此当i=0的时候，i-1的操作会令其数组越界。</p><h4 id="2-从没有元素开始进行插入排序"><a href="#2-从没有元素开始进行插入排序" class="headerlink" title="2. 从没有元素开始进行插入排序"></a>2. 从没有元素开始进行插入排序</h4><p>&emsp;&emsp;明白了上述的过程后，我们开始讲解插入排序。首先将数组分为两个部分，第一个部分是有序部分，第二个部分为无序部分。在第一轮循环时，我们将无序部分中的第一个值赋给有序部分，由于此时有序部分只有一个值，所以其自然有序。然后第二轮时，我们再将无序部分中的第一个值赋给有序部分，此时无序部分只有N-2个值，有序部分有2个值，我们将有序部分进行插入操作。然后执行第三轮…直到完全排序完，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">10</span>]<span class="keyword">int</span> = [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i; j &gt; <span class="number">0</span>; j-- &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j<span class="number">-1</span>] &#123;</span><br><span class="line">                nums[j], nums[j<span class="number">-1</span>] = nums[j<span class="number">-1</span>], nums[j]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，i所对应的外层循环可以表现为有序部分与无序部分的交界线，它的变化可以代表有序部分的个数。在内层循环中，j的初始值应该是有序部分的最后一个值，因此其初始化值就为i。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>&emsp;&emsp;在冒泡排序中，我们可以想象一个场景：在烧开的水中小的水泡处在更下的位置，大的水泡处于更靠上面的位置。每一次的循环都希望让最大的水泡跑到最上面就是这个算法的核心思想。</p><h4 id="1-单次循环的过程"><a href="#1-单次循环的过程" class="headerlink" title="1. 单次循环的过程"></a>1. 单次循环的过程</h4><p>&emsp;&emsp;单次循环的目的就是将最大的泡泡跑到最上面，其算法为：遍历整个数组，当当前的值大于其后面的下一个值时，将这两个值交换，否则不动。这个过程就类似于推着大的水泡向前进，当有更大的水泡时，就开始推动更大的水泡，我们举个例子说明一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始值为：    <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span>与<span class="number">1</span>的比较：    <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span>与<span class="number">2</span>的比较：    <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span>与<span class="number">3</span>的比较：    <span class="number">2</span> <span class="number">4</span> <span class="number">1</span> <span class="number">6</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span>与<span class="number">4</span>的比较：    <span class="number">2</span> <span class="number">4</span> <span class="number">1</span> <span class="number">3</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span>与<span class="number">5</span>的比较：    <span class="number">2</span> <span class="number">4</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">结束</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上述的演示，我们可以发现，在一轮的冒泡过程，最大的数据会被推到最后的位置（升序排序），正如同大的水泡在水中上升。我们通过程序实现该操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">10</span>]<span class="keyword">int</span> = [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">            nums[i], nums[i+<span class="number">1</span>] = nums[i+<span class="number">1</span>], nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在程序中需要注意的一个点为：循环变量i的循环条件。在数组中下标最大值为N-1，但是由于循环体中存在着i与i+1对应的值的比较，因此，循环条件需要为i&lt;N-1，而不是i&lt;=N-1，否则会出现数组越界的错误。</p><h4 id="2-冒泡排序全过程"><a href="#2-冒泡排序全过程" class="headerlink" title="2. 冒泡排序全过程"></a>2. 冒泡排序全过程</h4><p>&emsp;&emsp;基于上述的过程，我们可以知道在一轮冒泡中，最大的数据被推到了最后的位置，在这之前的数据可能是无序的。因此我们就重复上述的过程，第一轮将N个数中最大的推到顶，第二轮将N-1个数中的最大值推向次大的位置…直到完全排序结束。其程序实现为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">10</span>]<span class="keyword">int</span> = [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(nums)-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">                nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;依旧，这段程序中需要注意的点是i变量与j变量的相互关系，以及循环条件的判定，如若判定失误，则极有可能出现数组越界的问题。可以说冒泡排序是这几个排序方式中代码实现最为简单的方式了，也是最为基础的一个排序算法。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们讲解了三个数组的排序方式，分别为选择排序、插入排序、以及冒泡排序。在这三种排序方式中，当数据量相对较大的时候，插入排序的运行速度会快于选择排序的速度，选择排序的速度会快于冒泡排序的速度。尽管三种排序算法的时间复杂度均是相同的，但是实现的方式不同、比较的次数不同都会影响机器执行的速度。其具体为什么三种算法的速度不甚相同可以自行考虑一下，这个不会出现在考试中的任何角落的。 </p><p>&emsp;&emsp;在下一个小节中，我们将接触到二维数组乃至于推广到高维数组的概念、定义方式、以及使用方式和注意细节等知识。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;29&gt; 数组细节讲解</title>
      <link href="/2020/03/03/29-%E6%95%B0%E7%BB%84%E7%BB%86%E8%8A%82%E8%AE%B2%E8%A7%A3/"/>
      <url>/2020/03/03/29-%E6%95%B0%E7%BB%84%E7%BB%86%E8%8A%82%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-29-gt-数组细节讲解"><a href="#Go语言从入门到放弃系列-lt-29-gt-数组细节讲解" class="headerlink" title="Go语言从入门到放弃系列&lt;29&gt; 数组细节讲解"></a>Go语言从入门到放弃系列&lt;29&gt; 数组细节讲解</h2><p>&emsp;&emsp;在上一个小节中，我们对Go语言的数组的知识点进行了引出和简要的介绍，并通过一个快速入门案例来比较了数组实现方式与单纯定义多个变量的方式的不同点。不仅如此我们也讲解了数组的内存构成与两种不同的数组遍历方式。在这个小节中，我们将针对数组的知识点进行详细的细节讲解，并对每个细节做出一定的案例说明。</p><h4 id="1-数组是多个相同类型的数据的集合，其长度和数据类型一旦声明就不可以改变。"><a href="#1-数组是多个相同类型的数据的集合，其长度和数据类型一旦声明就不可以改变。" class="headerlink" title="1. 数组是多个相同类型的数据的集合，其长度和数据类型一旦声明就不可以改变。"></a>1. 数组是多个相同类型的数据的集合，其长度和数据类型一旦声明就不可以改变。</h4><p>&emsp;&emsp;在上一小节的数组定义中，我们就提到了这个概念。首先数组长度是不可以发生变化的，即数组定义中定义了N个数据，在使用过程中就只能用0到（N-1）的下标，一旦超出了这个范围就会数组越界，且不会自动改变长度。同样地，如果我们在数组中赋了一个其他类型的变量的值，编译时也会报错，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">10.5</span>    <span class="comment">//此处会报错</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将一个浮点数数据直接赋给一个int型的变量，在数据的相互转化那一小节中我们就明确提及过：Go语言中的数据类型转化是十分严格的，因此这段程序是根本无法执行的。</p><h4 id="2-var-arr-int这种定义方式不是数组定义。"><a href="#2-var-arr-int这种定义方式不是数组定义。" class="headerlink" title="2. var arr []int这种定义方式不是数组定义。"></a>2. var arr []int这种定义方式不是数组定义。</h4><p>&emsp;&emsp;有些人在刚接触到数组的时候在网上查资料，会发现如题一般的定义方式，且使用的方式以及注意的点都大致相同，因此会感到十分迷惑、认为数组定义是可以不需要指定长度的。在这里我们说明一下，这种定义方式是<strong>切片</strong>的定义方式，而不是数组。对于切片的讲解我们将会在下几个小节中进行详细的说明，此处暂时不做讲解。</p><h4 id="3-数组中的元素可以是任何的数据类型，包括值类型和引用类型，但是不可以相互混用。"><a href="#3-数组中的元素可以是任何的数据类型，包括值类型和引用类型，但是不可以相互混用。" class="headerlink" title="3. 数组中的元素可以是任何的数据类型，包括值类型和引用类型，但是不可以相互混用。"></a>3. 数组中的元素可以是任何的数据类型，包括值类型和引用类型，但是不可以相互混用。</h4><p>&emsp;&emsp;数组中可以存放多个值类型数据，这个我们就不再做过多的演示了，因为之前的例子几乎都是值类型的。不仅如此，数组中当然是可以存放引用类型的，我们简单地举一个小例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> points [<span class="number">3</span>]*<span class="keyword">int</span></span><br><span class="line">    fmt.Println(points)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的程序非常的简单，我们定义一个存放三个整数指针的数组，并且直接输出该数组中的值，由于我们并没有对数组中的指针进行任何的操作，因此这三个指针都是空指针，其输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;<span class="literal">nil</span>&gt; &lt;<span class="literal">nil</span>&gt; &lt;<span class="literal">nil</span>&gt;]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个输出结果也刚好证实了数组中是真实存放指针的。</p><h4 id="4-存放指针的数组和指向数组的指针。"><a href="#4-存放指针的数组和指向数组的指针。" class="headerlink" title="4. 存放指针的数组和指向数组的指针。"></a>4. 存放指针的数组和指向数组的指针。</h4><p>&emsp;&emsp;这两个概念在初学者看来是最为难以分清的两种概念，甚至再引出存放指针的数组的指针，概念上相对可以分得清，但是到了程序中看到其定义就会比较容易混淆，我们分别举出对应的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points [<span class="number">3</span>]*<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个对数组的定义我们在上一个细节点的例子中就已然提及了，并且我们根据其输出也知道了其含义。这种定义方式是<strong>定义了一个三个元素的数组，数组中的元素是int指针</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points *[<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">fmt.Println(points)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种定义方式和上一个不同的点为：星号位置和中括号位置不相同，这种定义方式星号的位置在中括号的前面，此时定义的其实是一个指向数组的指针，输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们依旧没有对指针进行任何操作，所以输出为空指针，同时我们也可以发现：输出结果只有一个值，且没有被中括号所包裹，因此这段程序<strong>*定义了一个指针，这个指针指向了一个数组，指向的数组存放三个整数</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points *[<span class="number">3</span>]*<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种第三个定义方式想必也不难理解了，在中括号的左右均有星号的存在，其含义为：<strong>定义了一个指针，这个指针指向了一个数组，这个数组存放了三个整数指针。</strong></p><p>&emsp;&emsp;造成这个现象的原因其实就是运算符优先级的问题，我们在运算符细节中讲解了运算符的优先级且列出了不同运算符的优先级的表格。根据表格我们可以看到中括号的优先级是高于星号的，因此在第三种定义中：中括号首先和后面的星号结合，代表数组中有三个指针，其次是第一个星号与后面向结合，代表定义结果是一个指针，最后是第二个星号与int相结合，代表数组中存放的指针是int型指针。</p><h4 id="5-数组创建后如果没有为元素赋值，其元素具备默认值。"><a href="#5-数组创建后如果没有为元素赋值，其元素具备默认值。" class="headerlink" title="5. 数组创建后如果没有为元素赋值，其元素具备默认值。"></a>5. 数组创建后如果没有为元素赋值，其元素具备默认值。</h4><p>&emsp;&emsp;我们在基本数据类型的小节中讲解到：每个数据类型都有一个默认值，也称之为零值，是当变量定义但是没有进行赋值的时候所存放的值。在数组中这个规则依旧适用，例如：定义一个整数的数组，定义后其中的所有元素都是0。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数值类型数组  ： 默认值<span class="number">0</span></span><br><span class="line">字符串数组  ： 默认值为<span class="string">""</span></span><br><span class="line"><span class="keyword">bool</span>型数组  ： 默认值为<span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="6-数组是值类型，因此在参数传递过程中是复制后再传递"><a href="#6-数组是值类型，因此在参数传递过程中是复制后再传递" class="headerlink" title="6. 数组是值类型，因此在参数传递过程中是复制后再传递"></a>6. 数组是值类型，因此在参数传递过程中是复制后再传递</h4><p>&emsp;&emsp;针对值类型与引用类型我们之前已然有所提及，其最显著的区别就是作为参数传递后，其他函数中对其修改是否会影响到原来的值。既然数组是值类型，那么就满足我们之前所说的运行时栈区结构等，我们举一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(nums [3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    nums[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">"modify函数中:"</span>, nums)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    modify(nums)</span><br><span class="line">    fmt.Println(<span class="string">"主函数中:"</span>, nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们在主函数定义了一个存放三个整数的数组，并初始化其值为1,2,3，然后我们又定义了一个modify函数并接受数组变量为参数，将该参数数组中的第1个值（从0开始）改变为10，然后输出，最后返回到主函数再对nums数组进行输出。我们得到的结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modify函数中: [<span class="number">1</span> <span class="number">10</span> <span class="number">3</span>]</span><br><span class="line">主函数中: [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从结果中我们可以看出：modify函数中对nums数组进行的修改并没有影响到main函数中的nums数据，尽管nums数组被当做参数传入了modify函数。这个特性与我们之前介绍的相符合，在程序执行过程中，main函数栈中存在一个nums数组，同时在modify函数中也存在一个数组，这两个数组只是值相同而地址完全不同。当modify函数进行修改的时候，只修改了其中的数组而没有修改主函数中的数组。 </p><p>&emsp;&emsp;数组的这种参数传递特性决定了在传参时必定要进行一次数组所有值的复制，因此当数组空间很大，且需要多个函数传递时（例如递归），每个函数中都有等大的数组，这对内存其实是一个很大的开销，因此在数组作为参数进行传递时，我们更多地使用的是指向数组的指针进行传递，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(nums *[3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    (*nums)[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">"modify函数中:"</span>, *nums)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    modify(&amp;nums)</span><br><span class="line">    fmt.Println(<span class="string">"主函数中:"</span>, nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们修改了modify函数的函数签名，即将传入数组修改成了传入一个指针，在函数体中根据指针进行修改数组的值。同时我们在主函数传入的参数则是nums数组的物理地址。由于变成了指针的传递，所以modify函数中对于数组中的值的修改就会影响主函数中的值了，其输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modify函数中: [<span class="number">1</span> <span class="number">10</span> <span class="number">3</span>]</span><br><span class="line">主函数中: [<span class="number">1</span> <span class="number">10</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结果中显示，主函数中的数组的第1个值也变成了10，执行过程可以理解为：主函数将数组的地址（其实是一个整数）传给了modify函数，因此modify函数根据地址进行修改就对主函数中的数组进行了修改。其过程与单个变量的指针传递相同，我们在函数的那一小节中也有所提及，这里就不做更多的讲解了。 </p><p>&emsp;&emsp;这里还有一个非常毁三观的彩蛋，Go语言开发者为了简化值类型与引用类型所产生的迷惑性，而对底层进行了优化，编译器可以自行判断变量是个值还是个指针，从而进行对应的正确的使用，例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*nums)[<span class="number">1</span>] = <span class="number">10</span>    改为：</span><br><span class="line">nums[<span class="number">1</span>] = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种改动丝毫不影响程序的编译以及运行，在一般的开发语言中，这是一个语法错误，但是在Go中优化后就自动免除了这个错误。但是，这个特性非常不建议新手来使用，区分值与指针是十分重要的。一旦开发者日后不进行Go开发而从事其他语言开发，在这一点上会出现很多的问题，因此：<strong>这个特性我只会在这个小节中提及一次，并在后面的所有小节中再不会出现。（此处来自后期钰的嘲讽：天真！太天真！）</strong></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们针对数组的诸多知识点总结出六条相对重要的细节，这些细节在平时的开发过程中需要注意。尤其对指针数组和数组指针的概念做出明确的划分，同时对于数组是值类型这个特性要有所了解以及对数组的指针传递进行良好的掌握。在下一小节中，我们将针对于数组的几个排序方式进行精讲，也算是对数组这个知识点进行集中的代码举例。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;28&gt; 数组引入</title>
      <link href="/2020/03/02/28-%E6%95%B0%E7%BB%84%E5%BC%95%E5%85%A5/"/>
      <url>/2020/03/02/28-%E6%95%B0%E7%BB%84%E5%BC%95%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-28-gt-数组引入"><a href="#Go语言从入门到放弃系列-lt-28-gt-数组引入" class="headerlink" title="Go语言从入门到放弃系列&lt;28&gt; 数组引入"></a>Go语言从入门到放弃系列&lt;28&gt; 数组引入</h2><p>&emsp;&emsp;在这之前的各个小节中，我们所接触到的都是简单的数据类型。包括指针类型在内，每一个变量都只可以表示一个值，且这个值的类型一旦确定就不可以改变。在这几个小节中，我们将会接触到Go语言中的一个复杂数据类型，数组。且在这一小节中，我们将引出数组的定义与使用场景，并对其基础操作进行简要的说明。</p><h3 id="数组的引入"><a href="#数组的引入" class="headerlink" title="数组的引入"></a>数组的引入</h3><p>&emsp;&emsp;现在我们依旧通过一个案例来完成数组的引入，我们现在有这样一个需求：假设一个小班级里面有五个人，要求输入每一个人的成绩，最后输出其平均成绩。这个需求我们如果使用之前的方式来完成也是没有难度的，我们可以定义五个变量，分别输入后再取平均值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> grade1, grade2, grade3, grade4, grade5 <span class="keyword">float32</span></span><br><span class="line">    fmt.Scanln(&amp;grade1)</span><br><span class="line">    fmt.Scanln(&amp;grade2)</span><br><span class="line">    fmt.Scanln(&amp;grade3)</span><br><span class="line">    fmt.Scanln(&amp;grade4)</span><br><span class="line">    fmt.Scanln(&amp;grade5)</span><br><span class="line">    <span class="keyword">var</span> average <span class="keyword">float32</span> = (grade1 + grade2 + grade3 + grade4 + grade5) / <span class="number">5</span></span><br><span class="line">    fmt.Printf(<span class="string">"平均成绩是:%.2f\n"</span>, average)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的代码显然可以正确地完成我们提及的需求，但是这种实现方式似乎不是很美观。首先定义五个变量的写法有些过于臃肿，然后输入成绩的操作显然是重复操作因此最好使用循环完成，再有求平均成绩的时候需要将所有的变量相加也是比较臃肿。同时还有一个最大的问题：一旦数据量变大，例如一个专业里面有300个学生，这样不论是变量定义还是代码书写，就都会是一个极大的挑战。 </p><p>&emsp;&emsp;因此在这里我们引出数组的概念：数组即有序的元素序列，是若干个连续的有限个数的相同类型的变量的集合。集合的名称我们称之为数组名，其中的变量称为数组的元素。我们先使用数组的方式将上述代码改写，然后再针对数组的基础知识进行讲解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> grades [<span class="number">5</span>]<span class="keyword">float32</span></span><br><span class="line">    <span class="keyword">var</span> average <span class="keyword">float32</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(grades); i++ &#123;</span><br><span class="line">        fmt.Scanln(&amp;grades[i])</span><br><span class="line">        average += grades[i]</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"平均成绩为:%.2f\n"</span>, average/<span class="keyword">float32</span>(<span class="built_in">len</span>(grades)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过数组的写法我们就弥补了我们所提及的几个缺点，我们不用定义五个变量，而是定义一个可以代表五个变量的变量。同时赋值操作与加和操作在循环中进行，不需要手动完成多个重复代码的书写。</p><h3 id="数组的定义与初始化"><a href="#数组的定义与初始化" class="headerlink" title="数组的定义与初始化"></a>数组的定义与初始化</h3><p>&emsp;&emsp;现在我们想，如果我们希望用一个变量来代表多个变量的集合，我们需要明确存储的变量的数据类型、以及需要存储的变量的个数，因此在数组的定义过程中，这两个要素是必不可少的。其定义方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 [数组大小]数据类型</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如，我们希望在数组中存储10个整数，我们可以定义为：var name [10]int,同理存储5个字符串可以定义为：var name [5]string，其他的例子我们就不过多地列举了。 </p><p>&emsp;&emsp;数组的定义可以通过上述的方式进行，接下来我们讲数组的初始化操作。初始化就是在定义的时候进行赋值，在Go语言中，数组的初始化可以有以下的五种表示方式，我们通过三个整数的数组举例： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">var</span> nums [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在第一种初始化的操作中，可以说十分的中规中矩，赋值号前面的部分是数组的定义部分，赋值号后的部分则指定了数组中三个元素分别对应的值。那么既然在赋值号前后都有[3]int的书写，这样完全重复了，因此我们也可以将定义部分的类型省略，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span> <span class="keyword">var</span> nums = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果继续向下说，其实在初始化的时候，甚至连数组的大小都不需要提供，编译器可以根据大括号里面的值的个数来确定其数组的大小。但是这只局限于数组中每一个数据都被初始化的前提下，一旦假如我们只初始化三个值而数组大小为四个值时就不适用了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span> <span class="keyword">var</span> nums = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的初始化形式中，我们可以使用…来代表数组的大小，其真实大小根据大括号中的个数而定。在有些情况下，我们需要分别对数组中的某个或某几个值进行初始化，且明确表明了这几个数的下标，也是可以的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span> <span class="keyword">var</span> nums [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>: <span class="number">100</span>, <span class="number">1</span>: <span class="number">200</span>, <span class="number">2</span>: <span class="number">300</span>&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这种状态下，我们通过冒号的方式，来完成对某些特定值的初始化，例如对第0个值初始化为100，第1个值初始化为200，第2个值初始化为300（数组中下标是从0开始）。当然，数组的初始化过程是支持类型推导的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.</span> nums := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="数组在内存中的形式"><a href="#数组在内存中的形式" class="headerlink" title="数组在内存中的形式"></a>数组在内存中的形式</h3><p>&emsp;&emsp;在数组的定义中，我们说数组是一段连续的同样数据类型的数据结构。换句话说，数组中每一个元素在内存中都是相连的。在之前的变量定义中，每一个变量所分配的内存空间可能是随机的，甚至说之间几乎没有任何的关系，而数组是不相同的。我们采用一个图片来表示（本次数组的首地址是0x0000580e0，不同的机器可能会不同）：<br> <img src="/2020/03/02/28-%E6%95%B0%E7%BB%84%E5%BC%95%E5%85%A5/1.png" alt></p><p>&emsp;&emsp;在上图中，我们可以发现，数组中的数据存储确实是连续的。同时，两个数之间的内存地址的差为8（十六进制），这个内存地址的差其实就是定义的数据类型所占据的内存空间。因此在数组定义的过程中，存放的数据类型是需要明确指明的，否则在空间的分配上会出现问题。我们举一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums [<span class="number">3</span>]<span class="keyword">int8</span> = [<span class="number">3</span>]<span class="keyword">int8</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%p,%p,%p"</span>, &amp;nums[<span class="number">0</span>], &amp;nums[<span class="number">1</span>], &amp;nums[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们在数组中定义了三个int8类型的变量，且在输出语句中我们将这三个变量的物理地址输出，得到的结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xc00005a080</span>,<span class="number">0xc00005a081</span>,<span class="number">0xc00005a082</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述输出，我们可以看出：由于int8整数在内存中占据了8个二进制位，即一个字节，因此两个元素所在的物理地址的差值为1。再换句话说，只要我们知道了数组的首地址和数据类型，我们就可以根据地址直接取出指定位置的数据，这也正是数组在做二分查找等算法优化时的一大优点。同时在Go语言中，对数组名进行取地址的运算，就相当于对数组的第一个元素（下标为0）进行取地址的运算：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%p,%p"</span>,&amp;nums, &amp;nums[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序语句中，其输出的结果是相同的。当进行数组作为函数参数进行传递时，数组名可以直接传入以代表整个数组，这个特性在使用过程中是十分常见的。</p><h3 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h3><p>&emsp;&emsp;在上述我们所举的各个案例中，我们可以发现<strong>数组的元素下标是从0开始的</strong>，不同的语言对这个特性的支持是不相同的。例如我们定义的var names [3]int，其取值范围为names[0],names[1],names[2]，而不会出现names[3]，一旦出现了这个问题，编译器会报出数组越界的错误。因此在数组的遍历过程中，我们往往会使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; <span class="built_in">len</span>(names); i++ &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也就是说，局部变量i的值是从0开始，一直取到数组长度-1位置，如果不小心将条件写为i&lt;=len(names)则一定会报出数组越界的错误。这个错误一般在实际开发中很少会出现，但是在认证考试中可能会成为一个迷惑考试的一个考点。 </p><p>&emsp;&emsp;在对数组遍历的时候，我们可以采用上述方式进行逐个遍历，其实在数组中还可以采用我们在讲解循环结构时讲到的for-range结构进行遍历。for关键字后跟随两个变量，分别代表当前遍历到的下标值和该下标值所对应的变量，range关键字后跟随的是需要被遍历的数组，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> names &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里需要说明的是，index和value两个变量是在for循环内部可见的局部变量，换句话说，其作用域只在for结构之中。同时，此处的index所表示的内容与上一段程序中i所表示的内容是相同的，因此我们依旧可以不使用value这个关键字而依旧使用names[index]来表示内容，但是Go语言中变量定义后不可以不使用，因此在value处需要用下划线(‘_’)来接收。这种用法一般不会有人这样使用。 </p><p>&emsp;&emsp;同理，当用户只需要关注遍历到的各个值而不需要关注这个值所在的位置序号时，index的值就可以被省略了，同时，index处需要用下划线所表示（下划线的含义在标识符小节中有提到）。</p><h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>&emsp;&emsp;在这个小节中，我们通过输入多个学生成绩的问题简述了之前的解决方式存在的问题，从而引出了Go语言中的数组的概念，同时也讲解了数组的定义方式以及几种初始化的方式。我们也介绍了数组在内存中的存储方式以及遍历数组时采用的两种循环方式。 </p><p>&emsp;&emsp;在下一小节中，我们将针对数组的使用的细节做出相对深入的讨论和讲解，并与之前所讲解到的值类型等知识相互关联对数组进行更为深刻的解释。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;27&gt; 闭包、defer与作用域</title>
      <link href="/2020/03/01/27-%E9%97%AD%E5%8C%85%E3%80%81defer%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2020/03/01/27-%E9%97%AD%E5%8C%85%E3%80%81defer%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-27-gt-闭包、defer与作用域"><a href="#Go语言从入门到放弃系列-lt-27-gt-闭包、defer与作用域" class="headerlink" title="Go语言从入门到放弃系列&lt;27&gt; 闭包、defer与作用域"></a>Go语言从入门到放弃系列&lt;27&gt; 闭包、defer与作用域</h2><p>&emsp;&emsp;在上一小节中，我们讲解了init函数与匿名函数的知识点，在这一小节中，我们会承接上一小节中的匿名函数的知识，进而引入这一小节的闭包的概念。介绍完闭包的概念后，我们再初步讲解作用域的几个细节以及defer关键字的用法。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>&emsp;&emsp;闭包是一种可以读取到其他函数内部变量的函数。在前几节我们讲到：程序在运行时会给每个函数分配栈内存，而不同内存之间的变量的地址是不同的，因此通过普通的方式是无法在一个函数中调用另一个函数内的局部变量的。而如果希望调用，则需要使用到闭包的概念。笼统而简单地讲，闭包就是一个函数与其需要的环境资源的集合体。 </p><p>&emsp;&emsp;在上一小节中，我们说到了匿名函数，也讲解了匿名函数赋给函数变量时的调用方式。同时我们也曾讲解过函数作为一个参数进行传递，同理，函数也可以作为另一个函数的返回值。我们在接下来的这个案例中就用到了函数作为返回值的情况。因此在读函数签名以及返回值时需要稍作注意。我们先讲解外层函数的签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的这个函数定义的含义为：有一个名字叫做adder的函数，这个函数没有参数，且返回值是另一个函数。返回值的函数是匿名的，且参数为一个整数，返回值为一个整数。相信这个不难理解。我们将函数写完：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        y++</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;函数定义我们已经讲解过了，我们分析函数体：首先在函数体中定义一个y变量且初始化其值为10，接下来我们返回一个匿名函数，在这个匿名函数的函数体中我们让y自增后，返回参数x与y的加和。接下来我们看主函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := adder()</span><br><span class="line">    fmt.Println(f(<span class="number">1</span>))</span><br><span class="line">    fmt.Println(f(<span class="number">2</span>))</span><br><span class="line">    fmt.Println(f(<span class="number">3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在主函数中，我们先调用adder函数，并将其返回的函数赋给f变量。然后我们通过f进行调用并参数传递。有人可能会猜测输出的三个值分别是12，13，和14。因为y等于10，然后y自增变成11，再加传入的1变成12，其他两个是同一个过程得到13和14。然而输出的结果是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这三个结果出现的原因其实是这样的：在adder函数中，局部变量y与其返回的匿名函数构成了一个闭包。在这个闭包中，y的变量相对于其匿名函数而言<strong>相当于</strong>是一个全局变量。因此函数内部修改值会直接影响到函数外的这个”全局变量”上。因此，第一输出为12是不需要解释的，我们跟踪一下第二个输出的过程，当我们再一次传入2的时候，y的值由于在第一次调用后已经自增了，所以y的初始值是11而不是10。因此再进入匿名函数后y已经自增变成了12，因此其结果输出为14。同理，在调用f(3)的时候，y的初始值经过了两次自增后变成12，进入函数后再自增是13，因此最后输出16。 </p><p>&emsp;&emsp;这个知识点其实只要理解了函数与其他变量的相关性就不会觉得难理解了，闭包的概念在其他的许多语言中都有或多或少的支持，例如：javascript、python、Java8等。接下来，我们做一个小案例来加强一下对闭包的理解： </p><p>&emsp;&emsp;首先指定一个文件的扩展名，例如png、txt等，再传入一个文件名，判断如果这个文件名是以这个扩展名为结尾则输出原串，否则输出文件名+扩展名，程序采用闭包完成。 </p><p>&emsp;&emsp;我们将这个案例套在上面的那段程序中，我们可以分析道：其核心是有两个函数，外层函数可以用一个变量接收传入的扩展名，匿名函数可以接收传入的文件名，并返回最终的结果，因此其函数构成可以写为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setExtension</span> <span class="params">(extension <span class="keyword">string</span>)</span> <span class="title">func</span> <span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们写函数体，内层匿名函数中我们采用strings包的HasSuffix函数来判断一个字符串是否以另一个字符串结尾：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setExtension</span><span class="params">(extension <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> strings.HasSuffix(name, extension) &#123;</span><br><span class="line">            <span class="keyword">return</span> name</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name + extension</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := setExtension(<span class="string">".png"</span>)</span><br><span class="line">    fmt.Println(f(<span class="string">"demo.png"</span>))</span><br><span class="line">    fmt.Println(f(<span class="string">"demo"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在主函数中我们采用了同样的调用方式，得到的结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">demo.png</span><br><span class="line">demo.png</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上就是闭包的说明，在实际开发中，其实闭包用到的不多，但是在资格考试等等却是一个重点与难点。当然能够用闭包完成的功能不用闭包是完全可以完成的。例如上述举的文件名和扩展名的例子，我们完全可以将文件名和扩展名作为两个参数传入到同一个函数中。闭包的优势就在与函数中可以调用其他函数中的变量，且能保存这个变量的现有的值，一旦没有这个需求，就不需要闭包了。</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>&emsp;&emsp;defer作为Go语言中的关键字，也是有十分广泛的作用的。它可以与init函数的作用相反，init函数是想在引入包或执行main函数之前完成某些初始化工作，defer则是在函数执行结束后进行关闭资源等等的收尾工作。例如在程序中打开文件，则需要在结尾处关闭文件，或连接数据库，进行查询过后需要释放连接，这些工作就可以在defer中使用。依旧，我们先举一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"第一条输出"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"第二条输出"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"第三条输出"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"第四条输出"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的这一段程序中，输出结果毫无疑问：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一条输出</span><br><span class="line">第二条输出</span><br><span class="line">第三条输出</span><br><span class="line">第四条输出</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在我们将其中的两条语句用defer进行修饰：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"第一条输出"</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"第二条输出"</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"第三条输出"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"第四条输出"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时其输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一条输出</span><br><span class="line">第四条输出</span><br><span class="line">第三条输出</span><br><span class="line">第二条输出</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述输出结果我们可以发现，defer的作用是将该语句延迟执行，我们将第二条和第三条都用defer修饰了，因此这两条会延迟到main函数执行结束后再执行，不仅如此，我们还可以发现，第二条输出与第三条输出的顺序是相反的。因此，在用defer修饰语句时，会将该语句压入<strong>栈</strong>中，我们姑且称之为defer栈。 </p><p>&emsp;&emsp;由于程序自上到下执行，先遇到了第二条输出，因此先压入栈中，然后才遇到了第三条输出，再压入栈中。当函数执行结束后，他们依次出栈，在栈顶的先出，在栈底的后出。我们再举一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"defer中的num:"</span>, num)</span><br><span class="line">    num++</span><br><span class="line">    fmt.Println(<span class="string">"main函数中的num:"</span>, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据上述的分析，我们可以知道，输出结果一定先是main函数中的num那句，然后才是defer中的num那句，现在问题是：输出时num的结果分别是多少。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main函数中的num: <span class="number">11</span></span><br><span class="line"><span class="keyword">defer</span>中的num: <span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以发现，尽管defer修饰的语句会最后再执行，但是其中所涉及到的值是不受后续程序影响的，换句话说在压入defer栈的时候，num的赋值就已经发生了。因此defer的作用不是仅仅将该语句简单地移动到程序的最后面，而是带有当时的数据环境的。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>&emsp;&emsp;作用域这个概念其实我们已经接触过很多次了，我们对它也是应该有一些了解了。我们之前所说的一个函数无法访问另一个函数的变量，其实就是作用域的问题。在这里我们简单地概述一下各个场景下作用域的用法。</p><h5 id="1-分支结构、循环结构中定义的变量"><a href="#1-分支结构、循环结构中定义的变量" class="headerlink" title="1. 分支结构、循环结构中定义的变量"></a>1. 分支结构、循环结构中定义的变量</h5><p>&emsp;&emsp;我们讲到在分支结构中是可以进行数据定义的，这个数据是只能够在分支结构中进行使用，一旦超出了其结构再使用，程序就会报错了，例如我们希望知道当跳出循环时，某个变量是多少：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span> ;i++ &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的这段程序是不行的，因为i这个变量是在for结构中定义的，出了这个大括号，就不能够再被访问了，如果我们希望访问这个i，就只能将i的定义提出到for结构之外：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因为此时的i变量的定义位置与使用它的位置处于同一个层级，因此是可以进行调用的。</p><h5 id="2-函数内部定义的变量"><a href="#2-函数内部定义的变量" class="headerlink" title="2. 函数内部定义的变量"></a>2. 函数内部定义的变量</h5><p>&emsp;&emsp;对于这种变量，我们可以称之为局部变量，局部变量顾名思义，只能在局部位置中使用，在其他的位置就无法使用了。这个问题我们之前就提及过了，这里我们就不做更多的讲解了。</p><h5 id="3-Go文件中定义的变量"><a href="#3-Go文件中定义的变量" class="headerlink" title="3. Go文件中定义的变量"></a>3. Go文件中定义的变量</h5><p>&emsp;&emsp;这个概念我们之前其实也提到过了，在Go文件中定义的变量被称之为全局变量，这种变量可以在整个Go文件中的任意一个函数中，任意一个位置使用。且在函数中对该变量进行修改会直接影响到该变量的值。</p><h4 id="整体规律"><a href="#整体规律" class="headerlink" title="整体规律"></a>整体规律</h4><p>&emsp;&emsp;在同一个Go文件中的变量定义中，我们可以总结出一条规律，即与变量定义位置同级以及下级的位置可以使用该变量，该位置的上级是不能使用的。换句话说，进入大括号可以使用，出了大括号就不能用了。</p><h4 id="包之间的变量调用"><a href="#包之间的变量调用" class="headerlink" title="包之间的变量调用"></a>包之间的变量调用</h4><p>&emsp;&emsp;假如一个包中的函数需要调用另一个包中的变量，则需要用包名.变量名的方式进行调用。且变量名的规则与函数名的规则是相同的：即首字母大写说明可以被其他包所使用，而首字母小写则只能够在本包中使用，否则会出现该变量无法导出的错误类型。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们集中讲解了闭包的概念、defer关键字的用法、以及变量作用域的规则。到这里对函数的知识的讲解就可以告一段落了，在下一小节中，我们将集中介绍几个Go语言中常用的字符串相关、日期相关的函数，对后期的编程可能会有所帮助。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;26&gt; init函数与匿名函数</title>
      <link href="/2020/02/29/26-init%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
      <url>/2020/02/29/26-init%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-26-gt-init函数与匿名函数"><a href="#Go语言从入门到放弃系列-lt-26-gt-init函数与匿名函数" class="headerlink" title="Go语言从入门到放弃系列&lt;26&gt; init函数与匿名函数"></a>Go语言从入门到放弃系列&lt;26&gt; init函数与匿名函数</h2><p>&emsp;&emsp;在很久之前我们曾说主函数是程序的入口且最先执行，当时我们在后面附了一句这个说法不是十分正确。在这个小节中，我们将介绍一个在主函数执行之前的函数:init函数，同时我们也会对匿名函数做出一定的讲解。整体来说，这个小节的知识点难度不大，读者可以很轻松地领会。</p><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>&emsp;&emsp;已经说明了main函数可以不是最先执行，那么先于main函数执行的有：全局变量的定义，以及init函数。同时当我们使用import命令来引入其他的包的过程中，执行顺序的先后就会相对更复杂一点，我们由浅入深开始讲解。</p><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>&emsp;&emsp;在之前的所有的案例中，我们所定义的变量可以说都是局部变量，可以理解为都是在函数内部定义的变量。这种变量的特点是只能在本函数，甚至本语句块之中可以使用。一旦超出了这个使用范围就会报出变量未定义的错误。全局变量与局部变量不同，他们是在包之内、函数之外定义的，因此这些变量或常量是可以在本包的任何一个函数中使用，我们举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNum</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    getNum()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很显然，这段代码一定是错误的，我们在getNum函数中想要调用main函数中的num变量，由于num是一个main函数中的局部变量，因此只可以在main函数中使用。现在我们将num这个变量改为全局变量，再从两个函数中分别使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNum</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num += <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">    getNum()</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的这段代码中，我们将num的定义放在了函数的外面，这个变量就成为了全局变量，在各个函数中均可以使用，不仅如此，在getNum函数中，我们对num变量的值进行了修改，在main函数进行输出，我们可以发现两次输出结果是不相同的。输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><h4 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h4><p>&emsp;&emsp;经过对上述全局变量的使用的介绍，我们可以发现：全局变量的定义是先于main函数执行的，因为这个定义过程并不在main中，而main函数使用这个变量却没有问题。这里我们再介绍一个先于main函数执行的函数，init函数。 </p><p>&emsp;&emsp;在一些情况下，我们希望在真正进行逻辑操作时，首先对程序进行一定的初始化操作。例如多个人进行协同编程时，每个人都有自己的分工，但是每个人所需要提交的代码只是逻辑部分，数据定义部分可能是通过网络接收到的数据。当开发者在测试环境下希望初始化一些数据，且提交时不需要将代码分离时，init函数可以是一个比较合适的选择。我们通过案例来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"init()函数执行了"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"main()函数执行了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们对上述的这段程序进行编译运行，会发现”init()函数执行了”这个字符串先被输出出来，而“main()函数执行了”这个字符串是后被输出来的。因此我们可以说，init函数是先于main函数被执行的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init()函数执行了</span><br><span class="line">main()函数执行了</span><br></pre></td></tr></table></figure><h4 id="全局变量定义与init函数先后关系"><a href="#全局变量定义与init函数先后关系" class="headerlink" title="全局变量定义与init函数先后关系"></a>全局变量定义与init函数先后关系</h4><p>&emsp;&emsp;既然两种操作均先于main函数，我们就需要对这两种操作顺序进行排序。我们此时可以想到，我们可能在main函数中使用全局变量，我们当然也有需求在init函数中使用全局变量，因此全局变量的定义也是早于init函数的，我们通过下面这个例子来验证这个关系：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span> = initNum()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initNum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"为全局变量赋值"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"init()函数执行了"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"main()函数执行了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们定义了一个全局变量num，且通过initNum这个函数进行初始化，在这个函数中我们输出了为全局变量赋值这个字符串，我们只需要看”为全局变量赋值”这个字符串和”init()函数执行了”这个字符串的先后关系，就可以明确其顺序了。执行结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为全局变量赋值</span><br><span class="line">init()函数执行了</span><br><span class="line">main()函数执行了</span><br></pre></td></tr></table></figure><h4 id="import其他包时的执行顺序"><a href="#import其他包时的执行顺序" class="headerlink" title="import其他包时的执行顺序"></a>import其他包时的执行顺序</h4><p>&emsp;&emsp;现在我们对刚刚的问题进行扩展，如果我们希望引入一个包，且使用这个包中的变量，那么这两个包中两个全局变量定义、两个init函数、以及一个main函数的执行顺序又是什么呢，我们通过下面这个例子来讲解。 </p><p>&emsp;&emsp;在这个例子中我们依旧采取demo包和test包，文件系统与对包的讲解的那一小节是相同的，即src下两个文件夹，每个文件夹都有一个go文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">demo文件夹下main包：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">package</span> main</span><br><span class="line">    <span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"test"</span></span><br><span class="line">    )  </span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = initNum()</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initNum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"main包中全局变量赋值"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"main包中init函数执行"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"main包中main函数执行了"</span>)</span><br><span class="line">        fmt.Println(test.Num)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">test文件下test包：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">package</span> test</span><br><span class="line">    <span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line">    <span class="keyword">var</span> Num <span class="keyword">int</span> = setNum()</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setNum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"test包中的全局变量赋值"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"test包中的init函数执行"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的这段程序中出现了我们所说的五个全部的过程，我们根据执行结果可以判断出在引用包的时候各个操作的执行先后顺序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test包中的全局变量赋值</span><br><span class="line">test包中的init函数执行</span><br><span class="line">main包中全局变量赋值</span><br><span class="line">main包中init函数执行</span><br><span class="line">main包中main函数执行了</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上述的执行结果，我们可以发现：在引入其他的包的时候，最先执行的是其他包中的全局变量定义，其次是其他包的init函数，然后才是本包中的全局变量定义，init函数以及main函数。相应地，我们根据这个规律进行扩展，main包中引用了A包和B包、main包中引用了A包，同时A包中引用了B包： </p><p><img src="/2020/02/29/26-init%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/1.png" alt></p><p>&emsp;&emsp;一个包调用多个包的情况</p><p><img src="/2020/02/29/26-init%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/2.png" alt></p><p>&emsp;&emsp;多个包相调用的情况</p><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><h4 id="一次性调用"><a href="#一次性调用" class="headerlink" title="一次性调用"></a>一次性调用</h4><p>&emsp;&emsp;匿名函数的思想其实十分的简单，即定义一个没有名字的函数，这个函数之所以不需要名字，是因为我们希望它只被调用一次，且是函数定义时直接调用。调用过后这个函数就被遗弃再也不调用了。这个语言上的特点在很多种语言中均存在，但是用到的不是很多。在Android开发过程中用到的比较多的也就是匿名内部类，因此这个知识点稍作了解即可，其难度也不是很大。我们看下面的案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result := <span class="function"><span class="keyword">func</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2</span><br><span class="line">    &#125;(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">    fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将上述的代码与正常的函数相比较，我们可以发现如下几个特点：func后直接加参数列表，即没有函数名。函数体与正常函数完全一致。在函数定义过后就直接传入相应的参数后使用，通过变量接收其结果。在后续的程序中只能使用其结果而无法再调用这个函数。</p><h4 id="匿名函数赋给函数变量"><a href="#匿名函数赋给函数变量" class="headerlink" title="匿名函数赋给函数变量"></a>匿名函数赋给函数变量</h4><p>&emsp;&emsp;这个用法相比而言就与普通函数没有什么区别了，在前几节中我们讲到函数可以作为一种数据类型也可以作为函数参数进行传递。因此，匿名函数当然也可以被赋值给函数变量，案例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myFunc := <span class="function"><span class="keyword">func</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(myFunc(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的这段程序中，我们将一个匿名函数赋给了myFunc这个函数变量，且在后续的程序中通过myFunc这个变量进行了函数的调用。由于我们可以通过变量进行调用，因此这个函数是可以在后续被调用的，因此说与正常函数没有什么区别。不过这里需要注意的是，我们是通过变量进行函数调用，而不是通过函数名进行调用，尽管这两者在使用上几乎没有任何的区别。</p><h4 id="匿名函数赋给全局函数变量"><a href="#匿名函数赋给全局函数变量" class="headerlink" title="匿名函数赋给全局函数变量"></a>匿名函数赋给全局函数变量</h4><p>&emsp;&emsp;这个小标题就更容易理解了，既然变量可以有全局变量，那么函数变量当然可以是全局变量了。这个时候，该函数变量可以被本包中的所有函数使用，也就意味着该函数可以被任意一个函数调用。相比于上一段程序，myFunc函数的作用域更大了。我们不详细说明了，只举一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">var</span> myFun = <span class="function"><span class="keyword">func</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(myFun(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们集中讲解了全局变量的含义与用法、init函数的执行顺序、以及匿名函数的三种使用方式。整体上而言，这个小节的知识点相对简单，且init函数用到的情况远比匿名函数多。对于init函数而言， 由于是编译器调用的函数，因此函数名、参数列表为空、无返回值这三个条件必须满足。而匿名函数用到的地方相对较少，能做到在真正遇到的时候想起匿名函数的概念与调用方式即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;25&gt; 函数使用细节&lt;二&gt;</title>
      <link href="/2020/02/28/25-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%BA%8C/"/>
      <url>/2020/02/28/25-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-25-gt-函数使用细节-lt-二-gt"><a href="#Go语言从入门到放弃系列-lt-25-gt-函数使用细节-lt-二-gt" class="headerlink" title="Go语言从入门到放弃系列&lt;25&gt; 函数使用细节&lt;二&gt;"></a>Go语言从入门到放弃系列&lt;25&gt; 函数使用细节&lt;二&gt;</h2><p>&emsp;&emsp;在上一小节中，我们讲解了函数的底层调用机制以及函数的嵌套调用、递归调用等知识点，同时也对Go语言中函数的使用细节做了初步的介绍。在这一小节中，我们将承接上一小节未能完全讲解完的使用细节进行相对深入的讲解。在本小节中讲解到的各个知识点在日常开发中也会经常使用到。</p><h5 id="1-基本数据类型和数组在函数参数传递中是以值形式传递，因此普通传递方式不能改变调用者栈区内的值。"><a href="#1-基本数据类型和数组在函数参数传递中是以值形式传递，因此普通传递方式不能改变调用者栈区内的值。" class="headerlink" title="1. 基本数据类型和数组在函数参数传递中是以值形式传递，因此普通传递方式不能改变调用者栈区内的值。"></a>1. 基本数据类型和数组在函数参数传递中是以值形式传递，因此普通传递方式不能改变调用者栈区内的值。</h5><p>&emsp;&emsp;根据底层调用的图解，我们可以得知在函数调用的过程中，栈区会开辟一段新的内存用来处理函数的各个操作。同时调用者传入的参数也是通过数值的拷贝进入到被调用者的，因此调用者内部的变量与函数中的变量是相互独立且不相互影响的。我们通过程序举一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temp <span class="keyword">int</span> = num1</span><br><span class="line">    num1 = num2</span><br><span class="line">    num2 = temp</span><br><span class="line">    fmt.Println(<span class="string">"In the swap function, num1 is"</span>, num1, <span class="string">"num2 is"</span>, num2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">20</span></span><br><span class="line">    swap(num1, num2)</span><br><span class="line">    fmt.Println(<span class="string">"In the main function, num1 is"</span>, num1, <span class="string">"num2 is"</span>, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的这段程序中，我们在主函数中定义了两个整数变量并传入到swap函数中，swap函数的函数体将传入的两个参数值相互交换，并且将交换后的值输出。在swap函数执行过后返回主函数，我们再次输出主函数中的两个变量，我们的到的执行结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In the swap function, num1 is <span class="number">20</span> num2 is <span class="number">10</span></span><br><span class="line">In the main function, num1 is <span class="number">10</span> num2 is <span class="number">20</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上述结果可以发现主函数中定义的变量并没有因为函数中的交换操作而受到任何的影响，因此值类型通过参数直接进行传递时，调用者是不会受到任何影响的。</p><h5 id="2-如果希望在函数中改变值类型，可以通过指针形式进行传递。（类似于引用）"><a href="#2-如果希望在函数中改变值类型，可以通过指针形式进行传递。（类似于引用）" class="headerlink" title="2. 如果希望在函数中改变值类型，可以通过指针形式进行传递。（类似于引用）"></a>2. 如果希望在函数中改变值类型，可以通过指针形式进行传递。（类似于引用）</h5><p>&emsp;&emsp;在这里，我们首先简要回顾一下指针的几个相关知识点：首先，指针本质就是内存地址，可以指代的是变量在内存中的物理地址，第二，*在变量定义的过程中代表该变量为指针变量，在变量的使用过程中代表取出该地址中的值，第三，&amp;符号在使用过程中代表取出该变量的物理地址。如果这三个概念没有完全想起来，可以返回到对应小节进行一些了解。 </p><p>&emsp;&emsp;现在我们可以通过这几个运算符进行指针传递了，我们依旧采用上述的代码段进行演示，同时需要注意一下下面的这段程序与值传递时所用到的程序的几个细微的差别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(num1, num2 *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temp <span class="keyword">int</span> = *num1</span><br><span class="line">    *num1 = *num2</span><br><span class="line">    *num2 = temp</span><br><span class="line">    fmt.Println(<span class="string">"In the swap function, num1 is"</span>, *num1, <span class="string">"num2 is"</span>, *num2)</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">20</span></span><br><span class="line">    swap(&amp;num1, &amp;num2)</span><br><span class="line">    fmt.Println(<span class="string">"In the main function, num1 is"</span>, num1, <span class="string">"num2 is"</span>, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们集中说明一下差别：首先在swap函数定义中，我们定义的两个形式参数为整数类型的<strong>指针</strong>，在函数体中对num1和num2的使用是通过获取指针所指向的值的方式进行的。在主函数中，调用swap函数的时候传入的实际参数是主函数中定义的num1和num2的物理地址。这段程序的运行结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In the swap function, num1 is <span class="number">20</span> num2 is <span class="number">10</span></span><br><span class="line">In the main function, num1 is <span class="number">20</span> num2 is <span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这里我们可以发现，函数中的交换数据的行为直接影响到了主函数中变量的值，这是因为参数传递的是地址而不是值。我们举一个易于理解的例子，我们将参数看作为一台电视机，值传递的意思就是我们保持这台电视机不动，买了另外一台同样型号电视机送给其他人，遥控器不同，两台电视机互相不影响。传递指针的时候，相当于电视机不同，我们又额外配了一个遥控器，并把这个新配的遥控器送给了其他人。当其他人通过遥控器变换频道的时候，唯一的电视机会进行响应。我们通过一个图解进行解释：<br> <img src="/2020/02/28/25-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%BA%8C/1.png" alt></p><h5 id="3-函数可以作为一种数据类型，也可以作为参数进行传递"><a href="#3-函数可以作为一种数据类型，也可以作为参数进行传递" class="headerlink" title="3. 函数可以作为一种数据类型，也可以作为参数进行传递"></a>3. 函数可以作为一种数据类型，也可以作为参数进行传递</h5><p>&emsp;&emsp;这个特性看起来似乎比较难以理解，因为这个点不论是在Go语言中还是在其他语言中都不是十分常用。我在这里也就是介绍一下函数作为一种数据类型的使用方式，当然这个知识点在后面讲解闭包的概念的时候还会被提及，因此在这个小节中需要对这个特性有所了解。我们首先看一段程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">20</span></span><br><span class="line">    funcVar := getSum</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, funcVar)</span><br><span class="line">    fmt.Println(funcVar(num1, num2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，getSum函数与之前的代码是相同的，不同点在于主函数中funcVar := getSum这里，这条语句的意思便是将getSum函数交个了一个名为funcVar的函数型变量。并且在后面的函数调用时就直接使用funcVar变量即可。我们可以简单地将其认为把一个函数的调用过程拆分成了两个：为函数变量赋值、通过该变量调用。程序的结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;讲解完了函数作为数据类型后，我们接下来讲解函数作为参数进行传递的过程。正如我们所知，在函数定义过程中，我们需要提供输入参数数数量和数据类型，因此当函数作为参数的时候也是需要指明参数类型的。对于一类函数而言，函数的签名（参数列表和返回值列表）可以唯一确定这一类的函数，因此当函数作为参数时，所需要提供的类型就是这样。我们看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testGetSum</span><span class="params">(testVar <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">num1</span> <span class="title">int</span>, <span class="title">num2</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> testVar(num1, num2)</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">20</span></span><br><span class="line">    fmt.Println(testGetSum(getSum, num1, num2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面的这段程序中，我们在主函数中调用了testGetSum函数，同时testGetSum函数的形式参数中就存在着一个func类型的参数。当调用的时候，我们传入的实际参数就是getSum函数的函数名，这也验证了函数是可以作为参数的。同时我们也可以向下联想到：但凡满足于两个整数参数且返回值为整数的所有函数均可以传入到testGetSum函数中，因为形式参数并没有指定调用哪个函数，而是根据输入的函数名而定的。</p><h5 id="4-Go语言中函数支持可变参数列表"><a href="#4-Go语言中函数支持可变参数列表" class="headerlink" title="4. Go语言中函数支持可变参数列表"></a>4. Go语言中函数支持可变参数列表</h5><p>&emsp;&emsp;由于Go语言中不支持函数的重载，因此当出现希望用同一个函数名来但具备不同参数列表的需求时候，就会比较困难。因此我们在这里引出对可变参数的讲解。首先我们看一个需求：写出一个名为getSum的函数，要求传入几个值就计算几个值的和。如果采用原来的方式，我们可能需要写多个函数，且函数名还不可以一致。当然这个需求可以通过传入切片来完成，但是目前我们还没有介绍到切片，就先介绍可变参数了。我们先看如下的一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(nums ...<span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        result += nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(getSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们从上述程序中可以发现，在getSum函数的参数列表中，我们使用了”…”的方式来定义可变参数。其使用规则为：变量名会被视为一个切片（这个我们会和数组一起讲解），且被”…”所修饰的类型为该切片中所具有数据的类型，在使用的时候可以通过nums[i]来表示传入的参数中的第i个值。通过解释后这个函数的意思就显而易见了：即遍历每一个传入的参数，将该参数累加到result中，最后返回。在主函数调用的过程中，我们传入了5个参数作为测试，当然也可以传入任意个数的参数。 </p><p>&emsp;&emsp;在使用可变参数的时候，我们需要注意以下几个问题： </p><ol><li>一个函数中只能出现一个可变参数，不可以出现多个，例如：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(nums ...<span class="keyword">int</span>, strs ...<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        fmt.Println(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(strs); j++ &#123;</span><br><span class="line">        fmt.Println(strs[j])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们定义getSum函数的参数列表时定义了两个可变参数，分别遍历输出，但是这段程序在编译时会发生错误，其错误类型为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">can only use ... with final parameter in list</span><br><span class="line">cannot use <span class="string">"Hello"</span> (<span class="keyword">type</span> <span class="keyword">string</span>) as <span class="keyword">type</span> <span class="keyword">int</span> in argument to getSum</span><br></pre></td></tr></table></figure><ol start="2"><li><p>参数列表中可以出现正常参数与可变参数混用的情况，但是可变参数必须要放在参数列表的最后面。 </p><p>&emsp;&emsp;编译器当看到可变参数后，会将在这之后的所有的参数均看做为可变参数的一部分，所以可变参数必须在最后，其前面有任何的普通参数均没有任何问题，我们举几个例子：</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(nums ...<span class="keyword">int</span>, extra <span class="keyword">int</span>)</span>    //错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(extra <span class="keyword">int</span>, nums ...<span class="keyword">int</span>)</span>    //正确</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(extra <span class="keyword">int</span>, str <span class="keyword">string</span>, nums ...<span class="keyword">int</span>)</span>    //正确</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(extra <span class="keyword">int</span>, nums ...<span class="keyword">int</span>, str <span class="keyword">string</span>)</span>    //错误</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们继续讲解了Go语言中函数的四个使用细节，分别为函数的两种参数传递方式，可变参数列表，和函数作为变量与参数。在下一小节中，我们将会针对init函数、匿名函数、闭包特点以及defer的使用进行详细的讲解，也会部分运用到这个小节的知识点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;24&gt; 函数使用细节&lt;一&gt;</title>
      <link href="/2020/02/27/24-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%B8%80/"/>
      <url>/2020/02/27/24-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-24-gt-函数使用细节-lt-一-gt"><a href="#Go语言从入门到放弃系列-lt-24-gt-函数使用细节-lt-一-gt" class="headerlink" title="Go语言从入门到放弃系列&lt;24&gt; 函数使用细节&lt;一&gt;"></a>Go语言从入门到放弃系列&lt;24&gt; 函数使用细节&lt;一&gt;</h2><p>&emsp;&emsp;在上一小节中，我们集中讲述了函数在调用过程中的底层实现，以及根据其底层实现方式引出了函数的嵌套调用以及递归调用两个知识点。在函数的调用过程中，被调用的函数会在栈区内存中得到分配，且当函数执行结束后，该段内存会被回收无法再使用。可以说，在前两节中均没有介绍到函数在定义以及使用时候的种种细节，在这个小节中，我们将针对这些细节进行讲解。</p><h3 id="无返回值无参数函数"><a href="#无返回值无参数函数" class="headerlink" title="无返回值无参数函数"></a>无返回值无参数函数</h3><p>&emsp;&emsp;这种模式的函数是相比而言最为简单的函数了，这种函数与其他的函数之间基本没有任何的关联。除了被调用之外，这种函数既不需要其他程序向其输入一些值，也不需要这个函数返回什么值。比如说，在进行开发的时候往往会出现列表选项界面，来询问用户想选取哪个功能。这个列表的展现工作就可能是无参数、无返回值的，只需要将写好的字符串输出出来，具体用户输入了什么可能会在其他函数中获取。其定义方式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">()</span></span> &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们举个例子，假如有这样一种需求：用户选择了列表项中的一个，且程序完成了对应的功能之后，这个列表项再次出现以供用户来选择。此时代码可以如下来写（伪代码）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        printMenu()</span><br><span class="line">        <span class="keyword">var</span> choice <span class="keyword">int</span> </span><br><span class="line">        fmt.Scanln( &amp;choice )</span><br><span class="line">        <span class="keyword">switch</span> choice &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMenu</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"欢迎进入XXX管理系统"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"1.登录系统"</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的一段伪代码中，我们可以发现printMenu函数的作用只是向屏幕输出一些字符串。在主函数中每次循环的起始位置都要输出一次这个列表。这个列表不包含其他的例如输入验证、进入不同模块的任何的作用。其函数执行也不会对main函数中任何一个值产生影响。可以说，无参数、无返回值的函数在程序开发中其实还是比较常见的。</p><h3 id="有参数无返回值函数"><a href="#有参数无返回值函数" class="headerlink" title="有参数无返回值函数"></a>有参数无返回值函数</h3><p>&emsp;&emsp;虽说无参无返回值在程序中比较常见，但是这种函数相比而言还是少了些许的交互性。一个函数和其他程序完全没有关系毕竟还是少数，因此有参数的函数是需要掌握的。例如我们希望通过一个函数计算两个整数的加和并输出，但是这个加和的值在主函数中并不需要。这种函数的定义格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数列表)</span></span> &#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个使用方式的其他部分与无参均相同，只是多了一个参数列表。既然说起是列表，那么这个参数的个数可以是多个。现在我们站在函数的角度来看问题，假如我们需要接收一些数据，我们不仅需要知道要接收多少个数据，还需要知道每个数据的数据类型是什么。因此在参数列表中，我们要需要对每一个形式参数都指明其类型。在这里我们多举几个例子： </p><ol><li>输入一个整数：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span> <span class="params">(num1 <span class="keyword">int</span>)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>输入两个不同类型的数据，例如num1为整数，num2为浮点数：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span> <span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">float32</span>)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>当传入的多个参数数据类型相同时，可以简写，例如传入两个整数：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span> <span class="params">(num1 <span class="keyword">int</span> , num2 <span class="keyword">int</span>)</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span> <span class="params">(num1,num2 <span class="keyword">int</span>)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>最后举一个多个参数的例子，传入两个整数，两个浮点型以及一个字符串</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span> <span class="params">(num1, num2 <span class="keyword">int</span>, num3, num4 <span class="keyword">float32</span>, info <span class="keyword">string</span>)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p> &emsp;&emsp;这里需要注意的是，参数列表中出现的各个变量在函数体中均可以直接使用而无需定义，因为在函数的调用过程中，这些变量已经定义好了，且这些变量的值也已经赋好了。例如求两个整数的和：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addNum</span> <span class="params">(num1, num2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(num1 + num2)          <span class="comment">//num1和num2无需再定义，直接使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有返回值的函数"><a href="#有返回值的函数" class="headerlink" title="有返回值的函数"></a>有返回值的函数</h3><p>&emsp;&emsp;函数的返回值的作用是将函数中的某个或某些值再反过来赋给调用者，否则当函数执行结束后，该段内存就会被释放且无法找到了。我们可以理解为参数列表的作用是调用者将数据传给函数的，返回值是将数据返回赋给调用者的。此时函数的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名 <span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span> &#123;</span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Go语言中，我们更习惯于将其称之为返回值列表，而在其他的函数中我们只会说返回值。这是因为在Go语言中是支持返回多个值的，这个特性在其他的语言中很少见。当然，此时我们站在调用者的角度来看，当有函数传数据给我们的时候，我们依旧需要知道有多少个数据，且每种数据是什么类型。因此返回值列表的写法与参数列表的写法也就如出一辙了。在需要返回的地方，用return关键字返回相应的变量。此处有些需要注意的几个点： </p><ol><li>当只有一个返回值时候，我们可以将返回值列表中的括号省略，例如：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span> <span class="params">(num1 <span class="keyword">int</span> ,num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的函数中，我们希望返回的是一个整数，在函数体中我们将两个整数相加之后进行返回。</p><ol start="2"><li>当函数具备多个返回值的时候，返回值列表的括号不可以省略，且return关键字后面的变量数需要相同，且顺序相同。例如我们对函数输入两个整数，然后返回两个数的和和差：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSumAndSub</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2, num1 - num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line">    c, d := getSumAndSub(a, b)</span><br><span class="line">    fmt.Println(c, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>返回值列表可以与参数列表相似，以变量-类型形式定义，此时return关键字可以直接返回对应的变量，例如：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSumAndSum</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span><span class="params">(sum <span class="keyword">int</span>, sub <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    sum = num1 + num2</span><br><span class="line">    sub = num1 - num2</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这种定义方式中，与参数列表相似，返回值列表中定义的变量也是可以直接使用的，同时在return的时候，默认就将返回值列表中的变量全部按顺序返回。</p><h3 id="函数的注意事项-lt-一-gt"><a href="#函数的注意事项-lt-一-gt" class="headerlink" title="函数的注意事项&lt;一&gt;"></a>函数的注意事项&lt;一&gt;</h3><p>&emsp;&emsp;在明确了几种函数的定义方式之后，我们对函数在使用的过程中可能出现的问题进行详细地讲解，在日常开发中可能会遇到类似的情况。同时接下来所列举的可能在前几节中提及过，我们就再一次地总结一下。 </p><ol><li><p>函数的命名规范遵循标识符的命名规范，首字母不可以是数字，大小写敏感。且函数名的首字母大写则可以被本包和其他包调用，相当于是public的，当函数名的首字母小写时，则只能在本包（文件夹）下使用，类似于private的属性。 </p><p>&emsp;&emsp;我们在对包的使用那一节所举的例子中，我们特殊地用括号强调了那个函数的首字母大写的规范，这样在main包中才可以调用到test包中方法，读者可以自行将函数名的首字母改为小写，然后看此时会报出什么错误。 </p></li><li><p>函数中定义的变量是局部的，在函数外不生效，我们在底层原理的那一节可以知道，当调用函数的时候是另外分配独立的空间的，两段空间基本没有关联，因此函数内部定义的变量在函数外是无法访问的。例如：</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo()</span><br><span class="line">    fmt.Println(num)    <span class="comment">//此处调用了demo函数中的num，会编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Go语言不支持函数的重载，换句话说两个函数的函数名相同但是参数列表不相同是不可以的，我们可以直接记成在同一个包中不可以出现同名的函数。例如：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span></span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(num1, num2, num3 <span class="keyword">int</span>)</span></span>&#123;...&#125;</span><br><span class="line">程序会报编译错误</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;由于篇幅的原因，在这个小节中我们只针对三个函数的细节进行了说明，在下一小节中，我们会对剩余的一些特性与注意事项进行讲解。在这一小节中，我们分别针对是否有参数、是否有返回值的函数定义方式进行了讨论，并对可能出现的几种参数列表与返回值列表的样式进行了讲解。下一个小节中，我们不仅会讲解剩余的细节，我们会对值传递与引用传递进行说明。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;23&gt; 函数的调用机制与嵌套调用</title>
      <link href="/2020/02/26/23-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8/"/>
      <url>/2020/02/26/23-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-23-gt-函数的调用机制与嵌套调用"><a href="#Go语言从入门到放弃系列-lt-23-gt-函数的调用机制与嵌套调用" class="headerlink" title="Go语言从入门到放弃系列&lt;23&gt; 函数的调用机制与嵌套调用"></a>Go语言从入门到放弃系列&lt;23&gt; 函数的调用机制与嵌套调用</h2><p>&emsp;&emsp;在上一节中，我们讲解了函数的引入过程，并且也讲解了函数的最基础的定义方式与使用方法。同时也对模块化编程中的包的使用规则进行了阐述。在这一小节中，我们会简要地讲解Go语言中函数调用过程中的底层实现方式，进而通过对这个方式的讲解对函数的嵌套调用与递归调用进行解释说明。</p><h3 id="函数调用的底层实现"><a href="#函数调用的底层实现" class="headerlink" title="函数调用的底层实现"></a>函数调用的底层实现</h3><p>&emsp;&emsp;在讲解这个底层实现之前，我们先明确几个概念：大部分的数据存储等都发生在内存中，且计算都发生在运算器中。且在计算机在逻辑上将内存分为四个部分，分别是栈区，堆区，常量区，以及代码区。这一部分知识可以再计算机原理中得到深入的讲解，在这里我们只是简要地提一下其作用。 </p><p>&emsp;&emsp;栈的特点是先入后出，例如我们向一个杯子中倒入沙土，最先倒进去的沙土在最下面，因此当倒出的时候是最后才被倒出的（如果有机会我会在数据结构部分说起这个知识点）。当程序对基本数据进行创建时，即之前我们所提到的值类型进行创建时，创建的位置处在栈区。不仅是基本数据，函数类型的调用也会在栈区中发生。堆区一般存储的都是引用类型，例如我们后面会学到的切片等数据类型。代码区当然存储的就是可执行的机器码本身，常量区存储的是程序中定义的全局变量与静态变量等。但是这个分类并不是百分百准确的，在Go语言的底层中，存在着内存逃逸的现象，即基本数据类型的变量可能会逃逸到堆区，引用类型也可能会被创建在栈区等。 </p><p>&emsp;&emsp;当然上述的说法如果实在不懂也没有太大的问题，这个对于顶层程序的编写与理解代码的执行没有特别大的相关性，但是如果理解了可能会对日后程序的书写有所帮助。现在我们针对下述的代码进行内存上的分析（我们便只分析栈区，而不看代码区了）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMax</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="params">(max <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num1 &gt;= num2 &#123;</span><br><span class="line">        max = num1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max = num2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num1 <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> num2 <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">    fmt.Println(num1, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于这一段程序相信不需要我过多的进行解释了，需要说明的是，我们定义了findMax函数，但是我们并没有调用这个函数。我们只是在主函数中定义了两个变量并将这个两个变量输出来。这时，栈区内存中与findMax函数是没有任何关系的，我们采用图解的方式来表示： </p><p><img src="/2020/02/26/23-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8/1.png" alt></p><p>&emsp;&emsp;从这个图解中我们可以发现，当程序开始执行的时候，计算机会在栈区内存中为main函数分配一段空间，在这段空间中又分配有两个变量，分别是num1和num2。接下来对这两个整数的输出也发生在main函数中，因此也相当于是在main栈区中提取数据。 </p><p>&emsp;&emsp;接下来我们上述的代码进行修改，在函数中我们将max输出，在main函数中调用findMax函数，修改后的代码如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMax</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="params">(max <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num1 &gt;= num2 &#123;</span><br><span class="line">        max = num1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max = num2</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"在函数中"</span>, max)</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num1 <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> num2 <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">    fmt.Println(<span class="string">"调用函数前"</span>)</span><br><span class="line">    findMax(num1, num2)</span><br><span class="line">    fmt.Println(<span class="string">"调用函数后"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，我们可以发现，此时main函数调用到了findMax函数，那么程序在调用函数的时候内存就会与findMax函数相关了。当程序运行到fmt.Println(“调用函数前”)的时候，内存图依旧与上述的图是一致的，因为还没有调用到findMax函数。 </p><p>&emsp;&emsp;当程序运行到findMax函数的时候，内存中就需要关联这个函数了，在这个函数中存在三个变量，分别是num1、num2、以及max，当程序刚进入到函数的定义部分时，此时的栈区内存图如下所示： </p><p><img src="/2020/02/26/23-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8/2.png" alt></p><p>&emsp;&emsp;我们可以发现当调用到其他函数的时候，编译器会为这个函数分配一块独立的内存，且这段内存中存在着自己三个变量。从这个图中我们也可以发现，findMax栈区所定义的三个变量与main栈区定义的两个变量是没有任何关系的，只是说我们将main栈区的两个变量的值拷贝给了findMax栈区的两个变量。这两个栈区的变量在内存中的地址是不同的，读者可以通过分别输出&amp;num1的方式进行验证。 </p><p>&emsp;&emsp;程序继续向下执行，当执行到函数中的return的时候，此时findMax栈区中的max值已然被得到，且在控制台中也输出了相应的”在函数中 20”。此时程序将会从findMax函数中跳转回main函数，当跳转的时候，在栈区内存中又会发生一件事情：</p><p><img src="/2020/02/26/23-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8/3.png" alt></p><p>&emsp;&emsp;通过这个图我们可以得到一个结论，当一个函数被执行完的时候，分配给这个函数的栈区内存会被回收释放，被释放后的这段内存可以再被分配给其他的函数等。那么可以想到的是，当主函数执行结束后，main函数的栈区内存也会被释放掉。 </p><p>&emsp;&emsp;从这段过程中，我们也可以侧面理解栈的含义：在内存分配的过程中，先分配了main函数的栈区，然后再分配的findMax函数栈区；当函数执行结束进行内存释放的过程中，先是findMax函数内存被释放，然后才是main函数栈区内存被释放。这也体现了先入后出的栈的含义。</p><h3 id="函数的嵌套调用"><a href="#函数的嵌套调用" class="headerlink" title="函数的嵌套调用"></a>函数的嵌套调用</h3><p>&emsp;&emsp;明白了函数的调用的底层含义之后，我们可以对函数的嵌套调用进行讲解。我们依旧类比于分支结构和循环结构的嵌套使用，我们可以得出一个结论：函数的嵌套调用就是在一个函数的函数体中调用了另一个函数。其实话说回来，我们在main函数中调用了findMax函数其实就是一种嵌套调用。 </p><p>&emsp;&emsp;在嵌套调用的过程中（我们依旧以main函数调用findMax函数为例），当main函数执行到调用findMax函数的那条语句时，main函数的执行流程会被阻塞在那条语句上，程序指针跳转到findMax函数中进行顺序执行。当findMax函数的函数体被执行完之后，程序指针又跳回了刚才被阻塞的地方进行继续执行。我们通过上述程序的输出结果可知：</p><pre><code>输出：    调用函数前    在函数中 20    调用函数后</code></pre><p>&emsp;&emsp;通过这个输出结果的顺序，我们可以发现：是先执行了”调用函数前”的那个部分， 然后main函数被阻塞，进入了findMax函数输出了”在函数中”，然后回到了阻塞地方输出了”调用函数后”，通过下述的一个图例可以更为直观地理解：</p><p><img src="/2020/02/26/23-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8/4.png" alt></p><p>&emsp;&emsp;根据对这个图的理解，我们继续向下联想：假如函数的嵌套并不只是这一层，而是呈现了多层，例如在findMax函数中我们又调用了另一个函数，这个图就会像在main函数中阻塞一样，在findMax函数中阻塞，进入另一个函数，当那个函数执行完后回到findMax函数继续执行，当findMax函数执行结束后回到main函数直到结束。 </p><p>&emsp;&emsp;接下来我们对这个概念进行延伸：假如我们在一个函数中调用的不是其他的函数，而是这个函数本身，例如findMax函数中调用findMax函数，这种调用方式就是递归调用。我们首先举一个例子说明：我们希望通过递归调用的方式求出1+2+3+…100的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getSum(index<span class="number">-1</span>) + index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(getSum(<span class="number">100</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的这段程序就是一个典型的递归调用，主函数中只是调用了getSum函数，并且将100这个整数传进去，此时程序指针进入了getSum函数中，进入getSum函数中首先判断index值是否为0，由于我们传入的是100，所以不为0。因此程序进入了getSum(99)，并且程序在这个地方阻塞，一旦getSum(99)执行完了，我们就将这个结果与index（此时为100）相加得到结果。 </p><p>&emsp;&emsp;我们继续向里面分析，当程序进入了getSum(99)的时候，首先判断index是否为0，由于输入的是99，因此不为0，所以进入了getSum(98)，且当getSum(98)执行结束后，将结果与index（此时为99）相加……上述过程往复循环直到出现了getSum(0)这个函数，当进入getSum函数且将0传入的时候，判断index是否为0，此时index刚好就是0，所以程序不会再进入到下一层的getSum函数了。 </p><p>&emsp;&emsp;这个getSum(0)函数结束，返回到getSum(1)函数的阻塞点继续执行，执行结束后返回到getSum(2)的阻塞点……重复上述循环直到返回getSum(100)这个函数的阻塞点。由于是main函数调用了getSum(100)，因此getSum(100)执行结束后就回到了main函数中进行输出，也就完成了整个的程序过程。整个程序的运行过程只是满足于一个公式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getSum(index) = getSum(index<span class="number">-1</span>)+index</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个公式完整地变现了整个递归的关系。我们再举一个例子，我们在三大流程总结的代码篇中实现了斐波那契数列的程序编写，其实这个数列也可以通过递归的方式进行。我们在那一小节中说明了斐波那契数列的数学表达式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fib(n)=Fib(n<span class="number">-1</span>)+Fib(n<span class="number">-2</span>)    (n&gt;=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们发现这个公式与求1到100求和的公式有异曲同工之妙，即想要求当前的值，必须要求前一个乃至于前两个值。那么对于这个数列我们进行程序的书写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fib</span><span class="params">(month <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> month == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> month == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Fib(month<span class="number">-1</span>) + Fib(month<span class="number">-2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(Fib(<span class="number">12</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序似乎不难理解，当第一个月的时候只有1对兔子，当第二个月的时候有2对兔子，在这之后的月数中，当月的兔子对数等于前两个月的兔子对数之和。 </p><p>&emsp;&emsp;对于初学者来说，函数的递归调用是一个非常难以理解的知识点，有时候即便是懂了函数自己调用自己的模式，但是一旦跟踪代码执行情况就又会把自己绕进去，因此当初学者读到这个小节时候，一定要将上述的两个例子琢磨明白。不仅要明白其中的数学表达式，也要清楚在实现递归调用的时候栈区内存中到底发生了什么，这个结果是怎样出来的。 </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节的最后，我们将会留下一个经典的面试题作为本小节的一个练习，面试官是这样问的：在Go语言中，在不使用for关键字的前提下，让程序输出100句”Hello World”。当然如果回答了用goto关键字，这场面试可能就立刻有结果了，面试官可能更希望你回答的是利用递归来完成，那么这个需求的代码请自行练习写一下。如若这段程序能够独立地写出来，那么函数递归这个知识点就可以说初成了。    </p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;22&gt; 函数入门与包的使用</title>
      <link href="/2020/02/25/22-%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E4%B8%8E%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/02/25/22-%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E4%B8%8E%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-22-gt-函数入门与包的使用"><a href="#Go语言从入门到放弃系列-lt-22-gt-函数入门与包的使用" class="headerlink" title="Go语言从入门到放弃系列&lt;22&gt; 函数入门与包的使用"></a>Go语言从入门到放弃系列&lt;22&gt; 函数入门与包的使用</h2><p>&emsp;&emsp;从这一小节开始，我们将会进入模块化编程的阶段，与之前的流程控制不甚相同，但是其基础核心依旧在于流程控制编程。可以说模块化编程中的每一个模块都是使用三大流程完成的，且不同模块之间的集成也无非就是顺序、分支或者循环执行。因此，从这一小节之后的讲解中，我们将不会再针对于某段代码的具体实现方式来详细地讲解，而是针对于不同模块的调用顺序、调用的逻辑等着重说明。前面一些章节如果没有十分熟练地掌握可以通过后面的代码强化。</p><h3 id="函数入门"><a href="#函数入门" class="headerlink" title="函数入门"></a>函数入门</h3><h4 id="函数引入"><a href="#函数引入" class="headerlink" title="函数引入"></a>函数引入</h4><p>&emsp;&emsp;说起函数，有的读者可能会立刻想起中学时代所学到的三角函数、二次函数等等。在数学中，函数指的是因变量与自变量的变化关系。类比到计算机中，计算机的函数也可以理解为返回值与自变量的对应关系，但是在计算机中，函数的含义会相对广泛得多。函数是从英文function翻译过来的，也可以理解为功能，因此在计算机中，函数往往都是为了完成某个功能而创立的。 </p><p>&emsp;&emsp;函数这个概念也是由来已久了，在很多的语言中函数的作用都是将一些需要实现的大功能分割成为若干个小函数，并且将其有机整合成一个程序。我们在这之前所写的程序往往是把所有的代码都写在了主函数中，然而这种开发方式在针对大型程序的时候就显得捉襟见肘了。当多个人一起开发一个项目的时候，每个人需要开发的部分不同，当然也就不能全部都在主函数中开发了，而是需要在不同的函数中、不同的包中进行开发。 </p><p>&emsp;&emsp;首先我们通过一个案例来引入函数的使用：例如我们通过流程控制来完成找四个整数的最大值（这里整数初始值就给定了，不做交互输入了）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> num3 <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> num4 <span class="keyword">int</span> = <span class="number">15</span></span><br><span class="line"><span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> num1 &gt;= num2 &#123;</span><br><span class="line">    max = num1</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    max = num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> max &gt;= num3 &#123;</span><br><span class="line">    max = max</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    max = num3</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> max &gt;= num4 &#123;</span><br><span class="line">    max = max</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    max = num4</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(max)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的程序可以正确地完成我们所提到的需求，但是我们会发现，在寻找两个数字中比较大的数的过程被进行了三次，而且这三次的操作都十分地相似，只是比较的数据不同而已。假如我们现在对需求进行修改，我们希望求出四个整数中最小的那个，我们就需要对上述程序中的三个程序段都进行修改。一旦某个程序块疏忽忘记了修改，程序就出现了逻辑错误。 </p><p>&emsp;&emsp;因此我们希望将寻找两个数的最大值这个过程提取出来，让它作为一种模板，一旦需要的时候调用这个模板并将想要比较的数填进去。这样在程序中我们只需要调用三次模板就可以了，而且当需求改变的时候，只将这个模板中的代码进行修改，程序中所调用的地方就相当于都自动修改了。这个提取的结果我们就可以称之为函数。</p><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>&emsp;&emsp;经过了上述的需求分析，我们在这个小部分中就开始介绍这个模板的定义方式，首先我们先介绍函数定义方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名称 <span class="params">(输入参数列表)</span> <span class="params">(返回值列表)</span></span> &#123;</span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span> XXX</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们大致介绍一下上述使用方式中各个部分的含义：首先，func作为Go语言中的一个关键字用来声明下述的程序块是一个函数，函数名称就是一个符合标识符规范的一个名称，在后期调用的时候会使用这个名称。参数列表指的就是我们希望向这个模板中注入哪些数据，返回值列表指的是这个函数希望返回给调用者的执行结果。函数体是函数中处理数据书写逻辑的部分，最后return关键字会将希望得到的变量或者值返回出去，如果没有返回值列表可以不出现。 </p><p>&emsp;&emsp;那么针对寻找两个数的最大值这个需求我们一起写一下函数的定义方式：func关键字这个不需要多说，函数名称只需要满足标识符的规则，我们便取名为findMax，输入列表为两个数，且都是整数，输出列表为一个整数，即最大值。函数体为寻找最大值的逻辑，最后return两个数中的最大值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMax</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="params">(max <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num1 &gt;= num2 &#123;</span><br><span class="line">        max = num1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max = num2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在函数的定义过程中还有很多的细节，在这个小节中我们暂时不详细讲解这些细节，只是先写一段函数的入门程序，并且介绍函数对于模块化编程的好处。</p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>&emsp;&emsp;既然我们所说的模板已经存在了，那么剩下的就是如何去使用这个模板了。函数的调用方式十分的简单，我们只需要根据函数名直接调用即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量... = 函数名(参数列表)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果一个函数具备返回值，那么我们需要对应个数的变量进行接收返回值，或者不用变量接收返回值，如果选择接收但是变量个数与返回值个数不同则会报错，函数名必须是已经存在的函数名，参数列表传入真实的变量即可。例如： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> num3 <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> num4 <span class="keyword">int</span> = <span class="number">15</span></span><br><span class="line"><span class="keyword">var</span> max <span class="keyword">int</span></span><br><span class="line">max = findMax(num1, num2)</span><br><span class="line">max = findMax(max, num3)</span><br><span class="line">max = findMax(max, num4)</span><br><span class="line">fmt.Println(max)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这里我们需要简要说明一下形式参数与实际参数的关系与区别：</p><ol><li>形式参数主要出现在函数的定义中，这些参数不代表具体的值，只代表希望进行的运算。我们可以将其理解为一种抽象，例如在找最大值的参数列表中，两个整型变量不代表任何值，我们只知道这两个数是整数而已。具体哪个数更大是传入的数据才能决定的，因此在函数体中所写的是单纯的逻辑关系。</li><li>实际参数是出现在函数的调用中，这次的参数代表调用过程中传入的真实的值。在找最大值的调用过程中（以第一个调用为例）：传入的两个变量分别是num1和num2，在程序中分别对应的是10和20。 </li></ol><p>&emsp;&emsp;我们举一个更为形象的例子：在数学表达式”y = x^2”中，我们可以知道这个函数的作用是求一个值的二次幂，但是求的具体是哪个值目前不得而知，x是个形式参数。现在我们将x=2带入到函数中，我们知道了要得到的是2的二次幂，这个2就是实际参数。在使用过程中，函数定义的参数列表的参数个数、参数顺序、参数类型需要完全一致，否则会报出错误。</p><h3 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h3><p>&emsp;&emsp;在函数的概念部分我们提到了一种多人开发的模式，即多个人开发一个项目，每个人开发不同的部分。即便如此，每个人都有可能会开发很多的函数，而且极为有可能对函数的命名也是相同的。在这种情况下对于不同部分的集成就会出现很大的不利情况：在同一个包中出现同名的函数编译时会报错，一旦某个人对函数名进行了修改，那么在调用的全部位置都需要进行修改，这又会很麻烦。 </p><p>&emsp;&emsp;因此在这里我们引出包的概念，这个概念我们在解决同一个包的两个go文件分别具有main函数的那一小节中出现过，我们也提及过在Go语言中，包其实就是文件夹。在同一个包中不可以出现同名的函数，但是在不同的包中则可以出现。那么在引用其他包所定义的函数时需要采用如下的方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">包名.函数名(...)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种调用方式也同时解决了同一个函数名的问题，我们指定了在哪个包中定义的函数，程序就会进入对应的包中进行寻找。那么现在的这个问题就成为了：编译器将如何寻找到对应的包。我们在使用fmt包的时候似乎没有任何的问题，同理在使用strconv、bufio等包的时候均没有问题，这是因为这些包都在GOROOT中。那么我们自己定义的包以及函数是不会放在GOROOT中的，即便这是个方法但是没有开发者会这样做。</p><p>&emsp;&emsp;我们在环境变量配置的时候，介绍到了另一个环境变量：GOPATH，编译器会在<strong>GOPATH目录中的src目录下开始找</strong>，我的机器配置的GOPATH为E:\GoProject。现在我的文件系统为:E:\GoProject\src下有两个文件夹，分别为demo和test，在demo文件夹中有一个文件是demo.go，test文件夹中有一个文件是test.go，现在我们开始写测试程序:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">demo.<span class="keyword">go</span>中：</span><br><span class="line">    <span class="keyword">package</span> main</span><br><span class="line">    <span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"test"</span></span><br><span class="line">    )      </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> num1 <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">        <span class="keyword">var</span> num2 <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">        fmt.Println(test.FindMax(num1, num2))</span><br><span class="line">    &#125;</span><br><span class="line">test.<span class="keyword">go</span>中：</span><br><span class="line">    <span class="keyword">package</span> test</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">FindMax</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="params">(max <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> num1 &gt;= num2 &#123;</span><br><span class="line">            max = num1</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = num2</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们首先看test.go这个文件，我们在这个文件中定义其属于test包，且定义一个函数叫做FindMax（注意首字母大写）。然后我们再看demo.go文件，在这个文件中我们声明为main包，且具备main函数。在引入包的时候我们不仅引入了fmt包，我们还引入了上面定义的test包，因为test文件夹和demo文件夹在同一级，且都在src下。test包所处于的位置为：E:\GoProject\src\<strong>test</strong>，引入时从src目录下开始寻找，因此我们只需要引test即可。在主函数中我们调用了test包中的FindMax方法，所得到的值也是正确的。 </p><p>&emsp;&emsp;在上述入门案例中，一旦读者出现了无法访问等情况，请首先检查环境变量中GOPATH是否配置错误，或者在其他包中的函数名的首字母是否为大写。函数名首字母大写代表可以被其他包访问，小写则代表只能在本包中访问。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们主要讲述了Go语言中的函数的概念以及如何调用其他包中所定义的函数。函数的相关的讲解目前只停留在入门的情况下，对包的理解可以做到会写、会使用他人的第三方包的函数即可。在下一小节中，我们将针对函数的定义、调用方式作出详细的讲解，并介绍函数的嵌套调用以及递归调用的相关知识。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;21&gt; 流程控制代码举例</title>
      <link href="/2020/02/24/21-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B/"/>
      <url>/2020/02/24/21-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-21-gt-流程控制代码举例"><a href="#Go语言从入门到放弃系列-lt-21-gt-流程控制代码举例" class="headerlink" title="Go语言从入门到放弃系列&lt;21&gt; 流程控制代码举例"></a>Go语言从入门到放弃系列&lt;21&gt; 流程控制代码举例</h2><p>&emsp;&emsp;在这之前的章节中，我们从Go语言入门程序、环境变量配置、乃至于标识符运算符、到三大流程控制进行了讲解。在讲解过程中更多的则是理论上的说明，而缺少一些代码案例。因此在这一小节中，我们针对三大流程控制、结合之前所提及的一些案例做一些代码上的讲解，并且对一些编程方法进行说明，因此这个小节更类似于一个代码篇，如果对流程控制十分自信就可以直接跳过了。</p><h4 id="1-十进制正整数转换成二进制代码程序"><a href="#1-十进制正整数转换成二进制代码程序" class="headerlink" title="1. 十进制正整数转换成二进制代码程序"></a>1. 十进制正整数转换成二进制代码程序</h4><p>&emsp;&emsp;十进制如何转换成二进制这个问题我们很早之前就已经说明过了，同时对于整数乃至于浮点数的存储方式也有了一些说明。可以说在十进制整数转换为二进制原码的过程中主要运用了除法、取模、字符串拼接、以及循环的知识。我们直接用代码实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span></span><br><span class="line">    fmt.Scanln(&amp;num)</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">string</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">0</span> &#123;</span><br><span class="line">        result = <span class="string">"0"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> num != <span class="number">0</span> &#123;</span><br><span class="line">        result = fmt.Sprint(num%<span class="number">2</span>) + result</span><br><span class="line">        num = num / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，我们首先定义了一个整数用来存储十进制的数字，并定义了result字符串为空串。接下来我们先跳过分支结构，直接看循环结构，循环条件是num不等于0，因为在循环体中我们每次都将num除以2，因此这个循环条件最终是一定会被执行的。在循环体中，我们首先对num进行取模运算，所得到的取模结果就是二进制结果中的一位，同时由于取模结果是整数，而result是字符串，因此我们需要将整数转换成字符串，用到Sprint函数。同时，在转换过程中是逆序输出，所以先得到的结果应该在字符串的后面，因此我们每次得到余数的时候都把它加在字符串的前面。做完上述的运算后，我们将num除以2（向下取整）后将其结果重新赋值给num，直到num为0退出循环。现在我们回过头看分支结构，我们判断初始输入的值是否为0，如果为0则令结果为”0”。如果缺少这部分代码，当输入为0的时候，就不会有结果输出了。</p><pre><code>输入：  10输出：  1010输入：  0输出：  0</code></pre><h4 id="2-打印空心三角形"><a href="#2-打印空心三角形" class="headerlink" title="2. 打印空心三角形"></a>2. 打印空心三角形</h4><p> &emsp;&emsp;这个题目在很多的教材以及循环结构的练习中十分的常见，因为这个需求是一个十分基础的多重循环的体现。对于初学者来说不论是C语言还是Java语言，这个题目应该都曾经遇见过。我们说明一下需求：</p><pre><code>输入： 5输出：      *     * *    *   *   *     *  *********</code></pre><p>&emsp;&emsp;即输入一个大于0的整数n，输出一个n行用星号所表示的的空心三角形。在这个题目中，我们可以发现：只有在第一行以及最后一行输出的星号个数为2*n-1，其他行中输出的都只是两个星号，因此我们先这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">fmt.Scanln(&amp;n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span> || i == n &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">2</span>*i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            fmt.Print(<span class="string">"*"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Print(<span class="string">"*"</span>)</span><br><span class="line">        fmt.Println(<span class="string">"*"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在外层循环（i层）中，我们的目的是从第1行输出到第n行。在针对每层进行输出的时候，当行数为1或者行数为n（最后一行）的时候，我们循环输出2*i-1个星号后换行，在其他行中只输出两个星号，目前来说其结果如下：</p><pre><code>输入：  5输出：      *    **    **    **    *********</code></pre><p>&emsp;&emsp;在当前的条件下，我们可以发现想让其成为三角形，在每一行输出星号之前需要输出一定量的空格，才能将星号推到后面，而需要输出的空格个数则是：n-i。（例如第1行需要输出4个空格），我们将输出空格加进去：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">fmt.Scanln(&amp;n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> space := <span class="number">1</span>; space &lt;= n-i; space++ &#123;      <span class="comment">//输出空格循环</span></span><br><span class="line">        fmt.Print(<span class="string">" "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span> || i == n &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">2</span>*i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            fmt.Print(<span class="string">"*"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Print(<span class="string">"*"</span>)</span><br><span class="line">        fmt.Println(<span class="string">"*"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果为：</p><pre><code>输入：5输出：        *       **      **     **    *********  </code></pre><p>&emsp;&emsp;我们会发现已经成功一半了，剩下的那一半的输出是在除去第一行和最后一行之外的行中，第一个星号与第二个星号之间输出空格，而空格的数量为：(i-1)*2-1=i*2-3:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">fmt.Scanln(&amp;n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> space := <span class="number">1</span>; space &lt;= n-i; space++ &#123;</span><br><span class="line">        fmt.Print(<span class="string">" "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span> || i == n &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">2</span>*i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            fmt.Print(<span class="string">"*"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Print(<span class="string">"*"</span>)</span><br><span class="line">        <span class="keyword">for</span> middle := <span class="number">1</span>; middle &lt;= i*<span class="number">2</span><span class="number">-3</span>; middle++ &#123;</span><br><span class="line">            fmt.Print(<span class="string">" "</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"*"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;到了这里，程序就编写完成了，在处理多重循环的时候，我们需要学会将循环剥离开，分析哪里是外层循环，哪里是内层循环，并针对于不同的位置进行循环的编写。做到大事化小，再将小事大化。</p><h4 id="3-数据简单校验问题"><a href="#3-数据简单校验问题" class="headerlink" title="3. 数据简单校验问题"></a>3. 数据简单校验问题</h4><p>&emsp;&emsp;在这里我们提出一个数据校验的简单的问题：要求用户从控制台输入两个字符串作为用户名和密码并比对，当用户名为admin且密码为123456时验证通过，否则验证失败且只有三次机会。程序难度不是很大，针对这个需求直接书写即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> username <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> password <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> chance <span class="keyword">int</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> chance &gt; <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"输入用户名："</span>)</span><br><span class="line">    fmt.Scanln(&amp;username)</span><br><span class="line">    fmt.Println(<span class="string">"输入密码："</span>)</span><br><span class="line">    fmt.Scanln(&amp;password)</span><br><span class="line">    <span class="keyword">if</span> username == <span class="string">"admin"</span> &amp;&amp; password == <span class="string">"123456"</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"验证成功"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        chance--</span><br><span class="line">        <span class="keyword">if</span> chance == <span class="number">0</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"验证失败且没有机会了"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"验证失败请重新输入"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序中需要注意的一点是break的使用，当验证成功后直接跳出循环，否则还会在下一轮循环中重新输入。</p><h4 id="4-斐波那契数列"><a href="#4-斐波那契数列" class="headerlink" title="4. 斐波那契数列"></a>4. 斐波那契数列</h4><p>&emsp;&emsp;意大利著名数学家斐波那契曾提出一个数学问题：如果一对兔子每月可以繁殖一对小兔子，且小兔子在成长一个月之后可繁殖小兔子，假设没有兔子的死亡，问一对兔子在一年后能变成多少对兔子。</p><p>&emsp;&emsp;对这个问题首先进行分析，我们可以知道第一个月只有一对兔子，在第二个月有两对兔子，在第三个的兔子数量就是第一个月和第二个月的兔子之和，同理在大于两个月的前提下，可以得到这样的一个公式：N(month) = N(month-1)+N(month-2)。因此在计算过程中我们只需要定义三个变量即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f1 <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> f2 <span class="keyword">int</span> = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> f <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= <span class="number">12</span>; i++ &#123;</span><br><span class="line">        f = f1 + f2</span><br><span class="line">        f1 = f2</span><br><span class="line">        f2 = f</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(f2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;解决这个题的思路为：首先定义month-2所对应的变量（f1）为1，定义month-1所对应的变量（f2）为2，定义一个中间变量f。从第三个月开始执行循环，且每层循环的内容是：首先让中间变量f接收f1和f2的求和，将f2的值赋给f1，（此时f1原来的值已经丢失），再将中间变量的值赋给f2，此时f1和f2所表示的数字均向前移动了一个月，进而执行下一轮循环。 </p><p>&emsp;&emsp;由于Go语言支持多变量的赋值，因此在循环过程中我们甚至可以不需要使用循环变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1, f2 = f2, f1+f2</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们用这条语句代替循环体的三行代码，且注释掉对f的定义，其结果是相同的。最后说一个小彩蛋：我们利用斐波那契数列中的第i个值除以第i+1个值，所得到的结果是黄金分割比的小数表现形式，且i的值越大，越精确。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们主要针对几个小问题进行了代码的演示与讲解。在计算机中的三大流程控制我们已经讲完了，因此初学者也是具备一些的开发能力了。在面对问题的时候可以首先考虑这个问题是由哪几部分所组成的，针对每一部分是否还具备更为基础的组成部分，每一部分需要通过什么样的流程结构来实现，不同的部分之间是什么关系、如何将其集成在一起。想明白这些问题后，程序的编写就是非常容易的事情了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;20&gt; 嵌套循环结构break和continue</title>
      <link href="/2020/02/23/20-%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84break%E5%92%8Ccontinue/"/>
      <url>/2020/02/23/20-%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84break%E5%92%8Ccontinue/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-20-gt-嵌套循环结构break和continue"><a href="#Go语言从入门到放弃系列-lt-20-gt-嵌套循环结构break和continue" class="headerlink" title="Go语言从入门到放弃系列&lt;20&gt; 嵌套循环结构break和continue"></a>Go语言从入门到放弃系列&lt;20&gt; 嵌套循环结构break和continue</h2><p>&emsp;&emsp;在上一小节中，我们介绍了Go语言中循环结构的定义以及形成循环结构所用的关键字for和goto，在这两个关键字中，由于其他的语言的历史原因，goto这个关键字不是十分受到开发者的青睐，所以更多的人还是选择for来完成循环结构。在这一小节中，我们将讲解循环结构的嵌套和break、continue两个关键字的用法及其注意事项。</p><h3 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h3><p>&emsp;&emsp;根据前几节讲到的分支结构的嵌套，我们可以为循环结构的嵌套进行理解。循环的嵌套简单的说就是一个循环的循环体的内容包含了另一个循环结构。之所以单独将这个话题提取出来是因为这个概念虽说非常好理解，但是在真正使用的过程中还是比较难理解的。尤其在遇到其他的关键字相结合的时候，对于初学者来说可能就会比较费解。</p><p>&emsp;&emsp;在双重循环乃至于多重循环中，内层循环先执行，内层循环执行完之后外层循环才进行了一轮的循环。这个说明方式可能比较抽象，我们可以想象钟表的分针与秒针的关系。分针是外层循环，秒针是内层循环。当秒针走完一圈过后分针才走一格，相对应的是内层循环走完全部的循环，外层循环在走一层。我们用伪代码表示一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> minute := <span class="number">0</span> ; minute &lt; <span class="number">60</span> ; minute ++ &#123;</span><br><span class="line">    <span class="keyword">for</span> second := <span class="number">0</span> ; second &lt; <span class="number">60</span> ; second ++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">"过了一秒钟"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"过了一分钟"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"过了一小时"</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以说，单独的循环嵌套难度还不是十分的大，在介绍了break和continue关键字之后初学者可能会觉得相对有一点吃力了。接下来我们将开始讲述这两个关键字的用法。</p><h3 id="break关键字"><a href="#break关键字" class="headerlink" title="break关键字"></a>break关键字</h3><p>&emsp;&emsp;在一些情况中，我们可能会遇到这种需求：我们并不知道循环体究竟会循环多少次才会结束，或者在循环体中满足一定条件的时候就提前结束，因此在循环条件的表达式中就不太容易定量地写。例如：让程序一直输出0-100的随机数，一直到输出的随机数是50为止。由于一直输出的是随机数，那也就很难在编程的情况下确定循环变量。再或者进行网络编程时，一直通过输入输出流进行消息传输，只有当网络连接断开的时候才退出循环。因此我们引出这个break的关键字。</p><p>&emsp;&emsp;break关键字的作用是跳出当前的程序块，包括switch-case中的代码块和循环结构的代码块。并且只会跳出当前一层的代码块。我们举一个例子来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中我们在循环体中嵌套了一个分支结构，在循环中，我们从0输出到9，在分支结构中，我们判断当i等于5的时候，运行break跳出循环。因此，程序的运行结果是0 1 2 3 4（中间是换行）。出现这个现象的原因是，当循环到i等于5的时候，直接从循环中跳出了，后5次的循环都不执行了。</p><p>&emsp;&emsp;现在我们介绍break在多重循环中的使用，我们先看下一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"i="</span>,i,<span class="string">"j="</span>,j)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的二重循环中，我们在内层循环的循环体中进行了分支判断，当j等于2的时候通过break跳出循环。但是刚刚我们提到了，跳出循环只跳出一层的循环，因此这段程序的结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i= <span class="number">0</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">0</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">1</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">1</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">2</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">2</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">3</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">3</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">4</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">4</span> j= <span class="number">1</span></span><br></pre></td></tr></table></figure><p> &emsp;&emsp;从这个结果中，我们可以看到外层循环所定义的i变量从0执行到了4，而内层循环因为break的原因只执行到1。因此break所能跳出的循环只是当前的这层代码块，一旦超出了这一层就只能正常循环执行了。那么我们可能就会出现这样一种需求：我们从十个字符串中找一个字符，一旦找到了就不找了。换句话说我们要在外层循环中控制要搜索哪个字符串，内层循环中搜索当前字符串中是否具有该字符，一旦找到了，就跳出双重循环。在这里我们采用两种实现方式：借助布尔变量、和运用标签的break。</p><h4 id="运用布尔变量"><a href="#运用布尔变量" class="headerlink" title="运用布尔变量"></a>运用布尔变量</h4><p> &emsp;&emsp;这个方法主要是在外层循环中使用一个布尔变量，在执行内存循环的时候一旦需要跳出了就将该布尔变量的值改变然后使用break跳出。每一次执行外层循环的时候都要判断一下该布尔变量是否发生了变化，一旦发生了变化就跳出。</p><p>&emsp;&emsp;我们将上述的需求转换成在循环中寻找i=2,j=3的情况，因为数组我们还没有学习到，这个demo只是为了演示一下如何退出双重循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">            fmt.Println(<span class="string">"i="</span>, i, <span class="string">"j="</span>, j)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">2</span> &amp;&amp; j == <span class="number">3</span> &#123;</span><br><span class="line">                flag = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> flag == <span class="literal">true</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这一段程序我们就不把结果粘贴上来了，读者可以自行将代码键入并看一下其结果。</p><h4 id="运用带标签的break"><a href="#运用带标签的break" class="headerlink" title="运用带标签的break"></a>运用带标签的break</h4><p>&emsp;&emsp;break所带有的标签和普通的标签不同，在goto结构中所需要的标签可以在任何的位置，但是break所搭配的标签一般只能在某个for之前。一旦不在for关键字前，就会报出错误：invalid break label XXX。我们将这个程序写出来：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"开始"</span>)</span><br><span class="line">    LOOP:</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">            fmt.Println(<span class="string">"i="</span>, i, <span class="string">"j="</span>, j)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">2</span> &amp;&amp; j == <span class="number">3</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> LOOP</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，由于break关键字后面具备标签，所以程序会寻找到对应的标签进行跳出，同时LOOP标签所对应的循环是外层循环，当然就可以直接将双重循环甚至是多重循环一并跳出。</p><h3 id="continue关键字"><a href="#continue关键字" class="headerlink" title="continue关键字"></a>continue关键字</h3><p>&emsp;&emsp;continue与上述提到的break的作用基本相似，不过这两个关键字之间有一些细微的区别：break关键字会直接跳出循环，使得后面剩余的几轮循环都不执行，而continue关键字则是<strong>结束本轮循环，直接进行下一轮循环</strong>，我们举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的这段程序中我们只是将break换成了continue，在这段程序的结果输出中，我们会发现其输出为：0 1 3 4（中间为换行），而唯独不见了2。其原因为当i等于2的时候，执行了continue，使得当前这轮循环不执行了，直接去执行i等于3的那一轮循环。</p><h4 id="带标签的continue"><a href="#带标签的continue" class="headerlink" title="带标签的continue"></a>带标签的continue</h4><p>&emsp;&emsp;就如同break可以使用标签一般，continue也是可以使用标签的，且标签的需求和break也十分相似：只可以存在于for语句上，否则会报错。在多重循环中，continue依旧是结束内层循环的一轮进而进行下一轮的内层循环。如果使用了标签，则直接结束标签所标志的那层循环的当前一轮，直接进行下一轮标记层的循环。这个说明可能比较绕，我们举例说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    LOOP:</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">2</span> &amp;&amp; j == <span class="number">3</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span> LOOP</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(<span class="string">"i="</span>, i, <span class="string">"j="</span>, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，当i等于2且j等于3的时候，执行带标签的continue，且标签标示的是最外层的循环，其结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">i= <span class="number">2</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">2</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">2</span> j= <span class="number">2</span></span><br><span class="line">i= <span class="number">3</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">3</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">3</span> j= <span class="number">2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从结果中我们可以看出当i等于2且j等于3的那层循环过后，直接就从外层循环执行了。在实际应用过程中，continue运用的频率远不及break的使用频率，但是这两个关键字的用法与区别需要记住，在一些初学者的考试之中这两个关键字也经常被列为考点，其难度都不大，记住规则就可以完全答对。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在本小节中，我们主要介绍了循环结构的嵌套使用以及带标签的和不带标签的break关键字、continue关键字的使用方式。在日常开发中，break所用到的地方相对较多，因此这一章节中的介绍一定看懂，尽量做到烂熟于心，在日后的开发过程中对其使用能够达到信手拈来的程度。在下一小节中，我们将针对前面这几节所讲的流程控制集中举一些例子，作为一个练习的章节。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;19&gt; 循环结构goto、for的使用</title>
      <link href="/2020/02/22/19-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84goto%E3%80%81for%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/02/22/19-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84goto%E3%80%81for%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-19-gt-循环结构goto、for的使用"><a href="#Go语言从入门到放弃系列-lt-19-gt-循环结构goto、for的使用" class="headerlink" title="Go语言从入门到放弃系列&lt;19&gt; 循环结构goto、for的使用"></a>Go语言从入门到放弃系列&lt;19&gt; 循环结构goto、for的使用</h2><p>&emsp;&emsp;在上一个小节中，我们讲述了分支结构的两种表示方式，即if系列代码块以及switch-case系列代码块，同时也讲解了这两种表示方式使用过程中的注意事项。我们也讲解了这两种方式的相互的对应关系以及分支结构的嵌套使用。</p><p>&emsp;&emsp;从这一小节开始，我们将进入循环结构部分的讲解，集中讲解for关键字、goto关键字的使用以及break、continue关键字的区别与使用方式。最后我们会单独写一个小节来针对一个例子进行编程过程的讲解。</p><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p>&emsp;&emsp;在讲解循环结构之前，我们首先回忆一下其他的两个流程控制结构。最为初期我们接触到的是顺序结构，函数中代码从上到下，逐条进行执行直到函数结束。然后是前几节所说到的分支结构，代码根据分支结构中的表达式的值选择性执行不同的代码块。如果我们将其使用树型的方式来联想，其过程则是从树根选择树枝再到树叶的执行过程。</p><p>&emsp;&emsp;循环结构作为第三个流程控制也被广泛地应用，在日常生活中也相对常见。在使用计算机的过程中，我们往往需要让计算机重复循环地做一件事，就会用到循环结构。例如：在服务器的开发过程中，每次用户发送了请求，服务器就需要回复一个相应的响应。换句话说服务器所要做的事情就是重复地等待用户的请求，回应用户的请求，并重新等待下一个请求。</p><p>&emsp;&emsp;我们将循环结构利用流程图来表示：</p><p><img src="/2020/02/22/19-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84goto%E3%80%81for%E7%9A%84%E4%BD%BF%E7%94%A8/1.png" alt><br><img src="/2020/02/22/19-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84goto%E3%80%81for%E7%9A%84%E4%BD%BF%E7%94%A8/2.png" alt></p><p>&emsp;&emsp;通过流程图，我们可以看到在循环结构中，当表达式成立的时候有一部分语句块是被循环执行的，当表达式不成立的时候，会跳出循环进而执行后面的代码。接下来我们将会通过代码的方式讲述循环结构。</p><h3 id="goto关键字"><a href="#goto关键字" class="headerlink" title="goto关键字"></a>goto关键字</h3><p>&emsp;&emsp;首先需要明确的是：goto是Go语言中的一个关键字，但是这个关键字的使用频率十分的低，甚至在一些语言中就完全限制了这个关键字的用法。虽说这个关键字在使用过程中不甚受青睐，但是用来介绍循环语句还是十分的方便的。</p><p>&emsp;&emsp;首先我们看一个简单的需求：在程序中输出100句“Hello Devin！”，如果不使用循环结构而是采用之前所讲述的顺序结构的话，这个实现方式就会比较劳神：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"Hello Devin!"</span>)</span><br><span class="line">...此处省略<span class="number">99</span>个</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;而且一旦需求变了，要求输出70个，那我们还要不厌其烦地删掉30个，一旦出了错误多删了几行或少删了几行，程序结果还是错误的。因此我们需要使用循环结构。根据上述的流程图我们可以发现有两个重要的部分，第一个部分为表达式，第二个部分为语句块，我们针对这两个部分分别进行入门开发：  </p><h4 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h4><p>&emsp;&emsp;由于需要循环，所以这里的语句块写的内容是循环一次所需要的语句，针对于上述的需求，我们可以轻而易举地知道，此处的语句块就是输出一句“Hello Devin”：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello Devin"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p>&emsp;&emsp;在流程图中，我们可以发现，表达式是控制循环是否进行的开关，一旦表达式成立则执行循环，表达式不成立则跳出循环执行后面的代码。因此对于上述的需求而言，其表达式的需要反映的内容是是否执行到了100次，我们还需要定义一个整数变量，用来记录输出的次数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">    fmt.Println(<span class="string">"Hello Devin"</span>)</span><br><span class="line">    num++</span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">100</span> &#123;</span><br><span class="line">        <span class="comment">//执行循环</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">（这是个伪代码，不能执行）</span><br></pre></td></tr></table></figure><h4 id="利用goto关键字拼接"><a href="#利用goto关键字拼接" class="headerlink" title="利用goto关键字拼接"></a>利用goto关键字拼接</h4><p>&emsp;&emsp;现在我们对上述的伪代码进行分析，当输出次数小于100的时候，需要执行循环，而这个循环是从输出字符串之前开始，一直到输出次数的自增，最后再判断条件是否成立。换句话说：fmt.Println(“Hello Devin”)语句和num++语句应该处在循环中，而其他的部分应处在循环外。那么我们需要做的就是：当num&lt;100的时候，让程序回到输出字符串前面执行，如果num&gt;=100的时候就放行，让程序正常执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">    LOOP:</span><br><span class="line">    fmt.Println(<span class="string">"Hello Devin"</span>)</span><br><span class="line">    num++</span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">100</span> &#123;</span><br><span class="line">        <span class="comment">//执行循环</span></span><br><span class="line">        <span class="keyword">goto</span> LOOP</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，我们在输出字符串的语句前加了一个标签，并将这个标签取名为LOOP，当程序进入到if判断且num&lt;100的时候，我们让程序跳回到LOOP标签所在的位置继续执行，直到num&gt;=100的情况下不执行跳转了，循环就结束了。</p><p>&emsp;&emsp;所以说，循环的本质其实就是代码在执行的时候出现了向前跳转的情况，使执行的流程出现了环状结构。一旦程序进入了循环且结束循环的条件永远达不到的时候，就出现了<strong>死循环</strong>的现象，这个问题在程序编写过程中需要尤其地注意。</p><p>&emsp;&emsp;goto关键字可以毫无条件地跳转到程序的任何一个地方，还需要定义许多的标签，因此在维护的时候十分不方便，在Go语言中其实不是十分推荐使用，在一些其他语言中甚至根本不允许使用，因此对于goto关键的讲解以及在循环结构中的使用我们就不再过多讲解了。</p><h3 id="for关键字"><a href="#for关键字" class="headerlink" title="for关键字"></a>for关键字</h3><p>&emsp;&emsp;在Go语言中，实现循环所用的方式就是for关键字，而不是采用goto关键字，for结构可以用下述的方法进行使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环变量初始化;表达式;循环变量步长 &#123;</span><br><span class="line">    语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以说，for由四部分构成，分别是循环变量的初始化，条件表达式，变量步长控制，以及相应的语句块。循环变量可以理解为在循环中控制循环次数的一个变量（当然它远不止这一个作用），条件表达式就是上述所说控制循环是否继续执行的开关，满足条件则继续执行循环，不满足条件则跳出循环。步长控制是针对循环变量而言的，在下一轮循环中，循环变量需要做怎样的处理，最后语句块就是循环体中所需要执行的代码。我们针对上述例子用for结构进行改写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> num := <span class="number">0</span>; num &lt; <span class="number">100</span>; num++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Hello Devin"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，for关键字后面用两个分号分割出了三个部分，第一个部分的num:=0相当于goto代码中的LOOP标签前面的那句定义，num&lt;100相对于if num&lt;100，num++代表的是LOOP标签中的num++。因此可以说，for在循环结构中的使用是十分方便的。</p><h3 id="for-range结构"><a href="#for-range结构" class="headerlink" title="for-range结构"></a>for-range结构</h3><p>&emsp;&emsp;在编程中，有时其需求可能会是遍历某个数组、某个集合、乃至于某个字符串中的每一个元素，这时也是需要使用循环的。其使用结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量<span class="number">1</span>,变量<span class="number">2</span> := <span class="keyword">range</span> 变量<span class="number">3</span> &#123;</span><br><span class="line">    语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们针对这个使用方式进行解释说明：首先变量3所对应的是需要被遍历的数据，如集合、数组、字符串等等。变量1所代表的是当前循环中遍历到了数组中的第几个元素（元素从第0个开始），变量2代表的是当前遍历到的数据。我们举一个例子来说明：循环遍历一个字符串，并将字符串中的每个字符输出来</p><h4 id="方法1：使用for结构"><a href="#方法1：使用for结构" class="headerlink" title="方法1：使用for结构"></a>方法1：使用for结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello Devin!"</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%c\n"</span>, str[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法的核心思想是：定义循环变量i为0，计算出字符串的长度，且控制循环的条件为循环变量不超出字符串的长度，每次循环变量自增1，以表示下一个字符，在循环体中输入当前循环变量（位置）所在的字符。</p><p>&emsp;&emsp;现在我们换一个字符串，让字符串中出现中文，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello 墨尔本"</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们再执行上述的程序，我们会发现输出到汉字的部分出现了乱码。其原因是Go语言中的字符串是以字节的形式组成的，而不是以字符的形式组成的（详见数据类型章节），而一个中文汉字在UTF-8编码中是以3个字节的形式所存储的，因此当遍历到字符串中的中文部分的时候，每个中文的编码都被分成了三部分输出，导致结果成为了乱码。</p><p>&emsp;&emsp;其解决方式为：将字符串转换成为rune类型的切片（我们会在后续讲到，此处只是先行体验）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello 墨尔本!"</span></span><br><span class="line"><span class="keyword">var</span> strSlice = []<span class="keyword">rune</span>(str)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(strSlice); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%c\n"</span>, strSlice[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法2：采用for-range结构"><a href="#方法2：采用for-range结构" class="headerlink" title="方法2：采用for-range结构"></a>方法2：采用for-range结构</h4><p>&emsp;&emsp;根据上述的for-range结构的使用方式，我们需要三个变量以及一个代码块：我们定义index作为变量1代表当前循环到的位置，定义value作变量2代表遍历到的值，变量3为需要被遍历的字符串，循环体是输出语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello 墨尔本!"</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> str &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"第%d个字符为：%c\n"</span>, index, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在for-range结构中，range后面可以加数组、切片等其他的复杂数据类型，由于我们暂时没有讲到这些，因此我们将会在后面讲到这些知识的时候再提起如何进行遍历。</p><h3 id="（while和do-while结构）"><a href="#（while和do-while结构）" class="headerlink" title="（while和do-while结构）"></a>（while和do-while结构）</h3><p>&emsp;&emsp;这个我们又通过括号进行括起来，其表示含义与Go语言中的字符类型一样，也代表的是在Go语言中<strong>不存在</strong>，写这个小标题也是为了给有其他语言的编程经验的人来看的，对于没有接触过其他编程语言的可以直接跳过。在这里我们通过break关键字的的配合，用for来完成while和do-while的逻辑的实现：</p><h4 id="（while）结构的逻辑实现"><a href="#（while）结构的逻辑实现" class="headerlink" title="（while）结构的逻辑实现"></a>（while）结构的逻辑实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> 表达式 &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（do-while）结构的逻辑实现"><a href="#（do-while）结构的逻辑实现" class="headerlink" title="（do-while）结构的逻辑实现"></a>（do-while）结构的逻辑实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    语句块</span><br><span class="line">    <span class="keyword">if</span> 表达式 &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因此在以后的编程乃至于聊天面试的过程中，说起Go语言中的循环只有for结构，而没有while结构和do while结构。这个地方需要尤其地强调一下。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们主要介绍了Go语言的循环结构的含义，利用goto关键字和for关键字实现循环的方式，以及对数组等复杂数据类型的遍历的方式（for-range），在下一个小节中，我们依旧针对循环结构进行讲解，介绍循环结构中break，continue两个关键字的用法和作用，以及在多重循环中程序的执行流程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;18&gt; 分支结构-switch case结构</title>
      <link href="/2020/02/21/18-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-switch-case%E7%BB%93%E6%9E%84/"/>
      <url>/2020/02/21/18-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-switch-case%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-18-gt-分支结构-switch-case结构"><a href="#Go语言从入门到放弃系列-lt-18-gt-分支结构-switch-case结构" class="headerlink" title="Go语言从入门到放弃系列&lt;18&gt; 分支结构-switch case结构"></a>Go语言从入门到放弃系列&lt;18&gt; 分支结构-switch case结构</h2><p>&emsp;&emsp;在上一小节中，我们介绍了分支结构的概念以及单分支、双分支、和多分支程序的写法。同时我们也介绍了if-else结构在分支结构中的用法。不仅如此，我们还讲解了在使用分支结构时所需要注意的问题。在这一小节中，我们将依旧对分支结构进行讲解，集中说明switch-case结构的用法，以及分支结构的嵌套使用。</p><h3 id="switch-case结构"><a href="#switch-case结构" class="headerlink" title="switch-case结构"></a>switch-case结构</h3><p>&emsp;&emsp;当我们遇到多分支的程序时候，我们可以采用if-else if-else等方式进行分支分割，但是对于更多条件、更多分支的情况而言，使用if系列的结构就稍显复杂了，取而代之的是，此时我们更多地使用switch-case结构，switch case结构的使用方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> 表达式 &#123;</span><br><span class="line">    <span class="keyword">case</span> 结果<span class="number">1</span>：</span><br><span class="line">    语句块<span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> 结果<span class="number">2</span>：</span><br><span class="line">    语句块<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其使用过程为：switch表示进入条件分支结构，表达式往往是一个具有结果的表达式，比如关系表达式、数学表达式、逻辑表达式、甚至于有返回值的函数都可以。case关键字表示进入当前的分支，当表达式的结果与case后面的结果相匹配时，其语句块得以执行。我们可以将其等价为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式 == 结果<span class="number">1</span> &#123;</span><br><span class="line">    语句块<span class="number">1</span>    </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式 == 结果<span class="number">2</span> &#123;</span><br><span class="line">    语句块<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这里我们需要强调说明的是：相比于一些其他编程语言，Go语言针对switch结构有一个极大的不同点，即执行匹配的语句块后直接跳出switch结构，而不需要break关键字。当然如果希望执行匹配的语句块后再继续向下执行其他的语句块，可以通过另一个关键字fallthrough完成。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">"a=1"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    fmt.Println(<span class="string">"a=2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的程序段输出结果为：a=1，这与C语言和Java等语言完全不同。而对于下面的这段程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">"a=1"</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    fmt.Println(<span class="string">"a=2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个时候的输出结果为a=1换行a=2，也就是说fallthrough的用处就是让程序从当前的分支末尾滑向下面的那个分支，使得两个分支都得以执行。这个关键字其实也可以是有用处的，例如我们输入一个月份，让程序输出该月份的天数。我们知道1、3、5、7、8、10、12月份都是31天，那么当我们输入这几个月份中的某一个时，我们可以让他们一直向下滑，滑到12，并在12所匹配的代码块中输出天数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> month <span class="keyword">int</span></span><br><span class="line">    fmt.Scanln(&amp;month)</span><br><span class="line">    <span class="keyword">switch</span> month &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        fmt.Println(month, <span class="string">"月共31天"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(month, <span class="string">"月共28天"</span>)    <span class="comment">//这里不做闰年判断了</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        fmt.Println(month, <span class="string">"月共30天"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于上述的程序而言，输入的值为1、3、5、7、8、10、12中的一个时，程序会向下滑到12，并输出，当输入的值为2时，直接输出，当输入的是剩下的几个值时，程序会滑到11并输出。</p><h3 id="switch-case-default结构"><a href="#switch-case-default结构" class="headerlink" title="switch-case-default结构"></a>switch-case-default结构</h3><p>&emsp;&emsp;在这个结构中，其实前面与switch-case结构是相同的，只是多了一个default关键字，我将其单独列出来只是想说明default关键字并不是必须的，而是说在大多数的情况下我们将default与switch-case结构相搭配。 </p><p>&emsp;&emsp;我们针对输入月份输出天数的代码进行分析，我们会发现一个问题：一旦用户输入的数字超出了1-12的范围，或者误操作输入错误了，程序就不执行了。default关键字的作用就是弥补这个问题，即当所有的case均不匹配的时候，会执行default中的代码块：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> month &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>： </span><br><span class="line">    fmt.Println(<span class="string">"31天"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>：</span><br><span class="line">    fmt.Println(<span class="string">"28天"</span>)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>：</span><br><span class="line">    fmt.Println(<span class="string">"输入错误"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，一旦用户输入了错误的数字，例如13，程序将会响应为：输入错误。如果将其与if系列相类比，default的作用可以理解为if结构中的最后一个else。</p><h3 id="switch结构中的注意点"><a href="#switch结构中的注意点" class="headerlink" title="switch结构中的注意点"></a>switch结构中的注意点</h3><h4 id="1-case后的表达式可以有多个，用逗号分隔"><a href="#1-case后的表达式可以有多个，用逗号分隔" class="headerlink" title="1. case后的表达式可以有多个，用逗号分隔"></a>1. case后的表达式可以有多个，用逗号分隔</h4><p>&emsp;&emsp;程序的执行流程为判断switch后的表达式的值与哪个case相匹配，如果匹配则执行。那么一个case可以有多个入口，例如上面的例子，当输入月份时，有很多的月份数最终会进入到一个case中，我们其实就不需要那么多的fallthrough了，我们将其列举在case后面就可以了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> month <span class="keyword">int</span></span><br><span class="line">    fmt.Scanln(&amp;month)</span><br><span class="line">    <span class="keyword">switch</span> month &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>:</span><br><span class="line">        fmt.Println(month, <span class="string">"月共31天"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(month, <span class="string">"月共28天"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">11</span>:</span><br><span class="line">        fmt.Println(month, <span class="string">"月共30天"</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        fmt.Print(<span class="string">"输入错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样一来，程序就相比而言简单的多了，在一个case中的不同的条件中，其相互的关系是或关系，相当于是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式 == 结果<span class="number">1</span> || 表达式 == 结果<span class="number">2</span> || 表达式 == 结果<span class="number">3</span> ...</span><br></pre></td></tr></table></figure><h4 id="2-各个case后的数据类型需要与switch后的数据类型相同"><a href="#2-各个case后的数据类型需要与switch后的数据类型相同" class="headerlink" title="2. 各个case后的数据类型需要与switch后的数据类型相同"></a>2. 各个case后的数据类型需要与switch后的数据类型相同</h4><p>&emsp;&emsp;switch后面的表达式的结果是具备数据类型的，当然其相与匹配的case的结果的数据类型需要与其相同，否则在编译过程中就会报错，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int32</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int64</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> b:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序段中，我们定义两个不同的整数类型，我们在switch后的表达式中运用的是int32的数据类型，而case中运用的是int64的数据类型。其程序运行结果并不是因为case匹配不上而不执行语句块，而是因为数据类型不匹配所导致的编译错误，错误类型为：invalid case b in switch on a (mismatched types int64 and int32)。</p><h4 id="3-如果case后是常量（字面量）时，case不可以重复"><a href="#3-如果case后是常量（字面量）时，case不可以重复" class="headerlink" title="3. 如果case后是常量（字面量）时，case不可以重复"></a>3. 如果case后是常量（字面量）时，case不可以重复</h4><p>&emsp;&emsp;在case后面可以是变量、也可以是常量（例如直接写成10），当后面是常量的时候，就不可以重复，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">"结果为1"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">"结果还是1"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中具备两个case结果，但是两个case后面的常量值均为1，这时在程序编译的时候会报错：duplicate case 1 in switch。 </p><p>&emsp;&emsp;那么我们将集中的一个换成变量，同时这个变量依旧为1，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">"结果为1"</span>)</span><br><span class="line">    <span class="keyword">case</span> b:</span><br><span class="line">    fmt.Println(<span class="string">"结果还是1"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个时候程序就不报错了，可以正常执行，那么两个case均满足，程序会选择先出现的那个分支，也就是说会匹配到常量1的那个分支，而不是变量b的分支。</p><h4 id="4-switch后可以不接表达式，此时便类似于if-else结构"><a href="#4-switch后可以不接表达式，此时便类似于if-else结构" class="headerlink" title="4. switch后可以不接表达式，此时便类似于if-else结构"></a>4. switch后可以不接表达式，此时便类似于if-else结构</h4><p>&emsp;&emsp;switch后面不加表达式，也就没有了需要被匹配的表达式，这与传统的switch结构就有了很大的不同，此时则更像是if系列结构，同时，case后面的表达式也基本都成为了关系表达式与逻辑表达式，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score <span class="keyword">int</span></span><br><span class="line">fmt.Scanln(&amp;score)</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> score &gt;= <span class="number">80</span> &amp;&amp; score &lt;= <span class="number">100</span>:</span><br><span class="line">    fmt.Println(<span class="string">"成绩为H1"</span>)</span><br><span class="line">    <span class="keyword">case</span> score &gt;= <span class="number">70</span>:</span><br><span class="line">    fmt.Println(<span class="string">"成绩为H2"</span>)</span><br><span class="line">    <span class="keyword">case</span> score &gt;= <span class="number">50</span>:</span><br><span class="line">    fmt.Println(<span class="string">"成绩为H3"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">"不及格"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，switch的出现相当于是进入了分支结构，但是后面没有表达式直接是大括号，那么程序的执行流程是：逐个判断这些case中的表达式的真假，一旦为真，则进入该语句块。</p><h4 id="5-在switch后以及if后的表达式前，均可以出现数据的定义，但作用域只限于分支结构中（不常用）"><a href="#5-在switch后以及if后的表达式前，均可以出现数据的定义，但作用域只限于分支结构中（不常用）" class="headerlink" title="5. 在switch后以及if后的表达式前，均可以出现数据的定义，但作用域只限于分支结构中（不常用）"></a>5. 在switch后以及if后的表达式前，均可以出现数据的定义，但作用域只限于分支结构中（不常用）</h4><p>&emsp;&emsp;这个特性由于用的相对少一些，我就不过多介绍，只是举个例子说明一下现象而已：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> score := <span class="number">80</span>; &#123; </span><br><span class="line">    <span class="keyword">case</span> score &gt;= <span class="number">80</span> &amp;&amp; score &lt;= <span class="number">100</span> :</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种使用方式是没有问题的，但是上述程序中定义的score只能在switch的大括号中才能使用（定义域的问题后面会说明）。一旦出了这个大括号，score就不能够再次使用了。这个方法不是很常用，因此只需要了解一下，当他人提及时知道这种用法是正确的。</p><h4 id="6-分支结构可以嵌套"><a href="#6-分支结构可以嵌套" class="headerlink" title="6. 分支结构可以嵌套"></a>6. 分支结构可以嵌套</h4><p>&emsp;&emsp;这个特性其实很好理解，在分支结构中，往往会出现一个或多个满足不同条件下的语句块。那么我们在这个语句块中再使用分支结构，就可以称之为分支结构的嵌套，例如当一个人年龄超过18岁可以租房，在这个前提下需要根据性别分配宿舍，其程序实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> gender <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> gender == <span class="literal">true</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"分配男寝"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"分配女寝"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"年龄不够"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的程序中，就是根据年龄出现一个分支结构，在第一个语句块中，又出现了根据性别的分支结构，两个分支结构套在一起，就是分支的嵌套。当然根据这小节所讲述的内容，读者可以自行将上述程序改写为switch-case结构作为练习。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们主要介绍了switch-case乃至于default结构的用法以及变形和注意事项，同时也提及了fallthrough关键字的用法，在最后我们也简述了分支结构的嵌套调用。由于在Go语言中的if结构中，大括号是强制需要写的，因此也不需要讲解像C语言中else与if的匹配问题。在下一章节中，我们将会开始介绍计算机中的第三个流程控制结构：循环结构，并讲解其使用方式和注意事项。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;17&gt; 分支结构-if条件语句</title>
      <link href="/2020/02/20/17-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-if%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>/2020/02/20/17-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-if%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-17-gt-分支结构-if条件语句"><a href="#Go语言从入门到放弃系列-lt-17-gt-分支结构-if条件语句" class="headerlink" title="Go语言从入门到放弃系列&lt;17&gt; 分支结构-if条件语句"></a>Go语言从入门到放弃系列&lt;17&gt; 分支结构-if条件语句</h2><p>&emsp;&emsp;在之前几个章节中，我们所举的例子，讲的知识点基本都是顺序结构的流程。主函数中的所有语句从上到下，每一条语句依次按顺序执行，且在程序不出现运行时异常时，每一条语句都必定会执行。在这一章中，我们将介绍到第二个流程控制：分支结构，在分支结构中将会出现条件性的判断，以确定某些语句的执行与否。</p><h3 id="单分支结构"><a href="#单分支结构" class="headerlink" title="单分支结构"></a>单分支结构</h3><p>&emsp;&emsp;很多时候，普通的顺序结构已经无法满足程序编写的需要了，例如当进行人机交互时候，用户输入的信息不同，程序会根据这个信息执行不同的功能。换句话说，在这种情况下可能会出现一部分代码在某种条件下不执行而另一部分执行的情况，反之当条件变化时，执行的代码块也将变化。</p><p>&emsp;&emsp;在这里我们首先介绍单分支结构，所用到的关键字为：if，我们也可以称其为if语句。其编程格式可用如下的公式来表示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式 &#123;</span><br><span class="line">语句块<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">语句块<span class="number">2</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们分析一下上述的调用方式，首先if代表该语句块是一个分支结构。在if后面的表达式往往是关系表达式亦或是逻辑表达式（<strong>不可以是赋值表达式</strong>），其特点为表达式的值为布尔类型（只能为真或假）。当表达式的值为真（true）时，执行大括号中的语句块，之后再正常向后执行；当表达式为假（false）时，大括号中的代码不执行，直接向大括号外的部分进行执行。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line">fmt.Scanln(&amp;age)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"已经是成年人了。"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"租房成功"</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的代码中，我们从控制台读取一个整数，并判断这个整数是否大于18，如果大于18，则会输出“已经是成年人了”和“租房成功”，如果不大于18，则会直接执行“租房成功”。读者可以自行尝试。</p><p>&emsp;&emsp;我们用一个流程图来表示单分支结构，其表示方式可如下：</p><p><img src="/2020/02/20/17-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-if%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/1.png" alt></p><h2 id="双分支结构"><a href="#双分支结构" class="headerlink" title="双分支结构"></a>双分支结构</h2><p>&emsp;&emsp;有时候，单分支结构可能无法完好地完成某种操作，而是需要双分支乃至于多分支的结构，我们对上述的例子进行扩展：当一个人大于十八岁时，出国可以自行租房，如果小于等于十八岁，则需要找寄宿家庭。对于这个案例，单分支结构就不能合适地完成这个需求，我们就会使用到双分支的结构。</p><p>&emsp;&emsp;如果说单分支的结构用自然语言来表述可以表述为：“如果…就…”,那么双分支结构则可以表述为：“如果…就…，否则就…”。因此我们在这里引出if结构中的下一个关键字：else，其使用方式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式 &#123;</span><br><span class="line">语句块<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">语句块<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们依旧分析一下上述的使用方式，前面和单分支相同：当表达式为真时，执行语句块1，否则（即表达式值为假时），执行语句块2，之后再正常向下执行其他部分。需要说明的是：语句块1和语句块2一次只能执行其中的一个，而无法全部都执行。我们依旧举上述年龄的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line">fmt.Scanln(&amp;age)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"已成年，可自由租房"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"未成年，需要寄宿家庭"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"租房成功"</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中，一个人的年龄区间被划分成两个部分，每个部分对应于一个分支。当输入的值大于等于18时，输出“已成年，可自由租房”以及“租房成功”，当输出的值小于18时，则会输出“未成年，需要寄宿家庭”以及“租房成功”。</p><p>&emsp;&emsp;因此双分支结构可以被看做为单分支结构的一种扩展，当然上述的例子可以使用两个单分支结构来完成，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">18</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果写成这个模式，则相对而言就会浪费一些计算次数，当采用双分支时，无论如何只需要判断一次，但是采用两个双分支结构，无论如何都会判断两次，当判断条件增多以及分支增多时，用多个单分支来完成不是一个合适的做法。</p><p>&emsp;&emsp;我们依旧将双分支的流程图展示在下面：</p><p><img src="/2020/02/20/17-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-if%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/2.png" alt></p><h3 id="多分支结构"><a href="#多分支结构" class="headerlink" title="多分支结构"></a>多分支结构</h3><p>&emsp;&emsp;在某些情况下，双分支结构可能依旧不能满足程序开发的要求，例如在一个列表中，用户输入列表项所对应的编号，计算机根据输入的编号来判断应该执行哪种功能，而这个列表可能具备五个或更多的选项。所以我们有些情况下需要用到多分支的结构。</p><p>&emsp;&emsp;多分支结构是以双分支为基础的结构，其使用方式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span> &#123;</span><br><span class="line">语句块<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式<span class="number">2</span> &#123;</span><br><span class="line">语句块<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//这个else可以没有</span></span><br><span class="line">语句块<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述使用方式的理解与双分支十分类似：当表达式1成立时，执行语句块1，当表达式1不成立且表达式2成立时，执行语句块2，如果都不满足则执行语句块3。当然如果还有更多的条件，我们依旧可以将最后的else换做else if继续向下写，在这里就不写案例了。</p><p>&emsp;&emsp;当然如果分支十分的多的时候，许多的else if的堆叠对于大程序的维护与修改不是十分有利，我们会采取switch case结构来完成更多分支结构的需求，这个结构我们将会在下一个小节中详细说明。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="1-条件表达式的小括号问题"><a href="#1-条件表达式的小括号问题" class="headerlink" title="1. 条件表达式的小括号问题"></a>1. 条件表达式的小括号问题</h4><p>&emsp;&emsp;其实正常来说，这不应该成为一个问题，只是说如果读者之前对C语言、Java语言等有所了解，我们可能会顺手写出 if(age &gt; 18){…}。在Go语言的官方文档中，条件表达式是不需要用小括号所括起来的，当然括起来也不会影响程序的正确执行，只是在使用 go fmt 命令做格式化时，编译器依旧会将小括号去掉，使用liteide保存时，也会将小括号去掉。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt; <span class="number">18</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">if</span> (age &gt;<span class="number">18</span>)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-大括号以及else的位置"><a href="#2-大括号以及else的位置" class="headerlink" title="2. 大括号以及else的位置"></a>2. 大括号以及else的位置</h4><p>&emsp;&emsp;大括号的位置我们在Go语言入门程序中就已然提及了，即左大括号一定要出现在某条语句的结尾，而不可以是单独出现一行。同样的，else所出现的位置只可以在右大括号的后面，而不可以单独一行出现。Go语言对于单独的右大括号的解读为一个程序段的结束，一旦else单独占一行，则会认为if结构已然结束，else不应该出现，将会报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt; <span class="number">18</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//此处会发生错误</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-大括号需要写"><a href="#3-大括号需要写" class="headerlink" title="3. 大括号需要写"></a>3. 大括号需要写</h4><p>&emsp;&emsp;依旧是上述的问题，在某些编程语言中，当语句块只有一条语句时，可以不写大括号。然而在Go语言中，大括号的书写是必须的且是强制的，一旦不写大括号，编译时就会报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt; <span class="number">18</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//编译时会报错，必须要有大括号</span></span><br></pre></td></tr></table></figure><h4 id="4-只会执行一条分支"><a href="#4-只会执行一条分支" class="headerlink" title="4. 只会执行一条分支"></a>4. 只会执行一条分支</h4><p>&emsp;&emsp;在程序开发中，有时候也难免会遇到一个程序满足多个分支的情况，尤其在多个人针对不同层面进行协同开发时会出现这个情况。例如：两个人分别对学习与租房的条件进行限制：大于6岁可以上小学，和大于18岁可以租房。（这个例子举得不好，只是为说明问题而已）就可能会出现这样的程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt; <span class="number">6</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"可以开始义务教育"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> age &gt;<span class="number">18</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"可以租房"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么一个人可能会同时满足这两个分支的条件，此时程序的执行方式是：进入到其满足的第一个分支中，其他分支全部忽略。当然上述说的是指在一个if结构中，各个分支结构是相互独立的，一段程序中可能会出现很多的分支结构。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们对分支结构进行了引出，同时介绍了单分支结构、双分支结构、以及其发展而来的多分支结构。我们也讲解了使用过程中需要注意的几个小点，以避免初学者在分支结构的使用过程中出现一些小错误。</p><p>&emsp;&emsp;在下一个小节中，我们依旧会针对分支结构进行叙述，我们会对另一套的关键字：switch、case、fallthrough进行讲解，同时也会简单提及break关键字的问题，最后我们还会说明分支结构的嵌套使用的场景以及对应的案例。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;16&gt; 输入函数</title>
      <link href="/2020/02/19/16-%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0/"/>
      <url>/2020/02/19/16-%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-16-gt-输入函数"><a href="#Go语言从入门到放弃系列-lt-16-gt-输入函数" class="headerlink" title="Go语言从入门到放弃系列&lt;16&gt; 输入函数"></a>Go语言从入门到放弃系列&lt;16&gt; 输入函数</h2><p>&emsp;&emsp;在上几小节中，我们主要说明了Go语言中的多种操作符，并介绍了各种操作符的用法及注意事项。同时我们也按顺序列举出了各个操作符的优先级，也相当于讲解了在一个复杂的表达式中执行顺序的问题。在这一小节中，我们将介绍Go语言中的输入函数，以及对函数的使用规则以及空格字符读取的问题进行讲解。</p><h3 id="Scanf与Scanln函数"><a href="#Scanf与Scanln函数" class="headerlink" title="Scanf与Scanln函数"></a>Scanf与Scanln函数</h3><p>&emsp;&emsp;在之前的多个小节中，我们所用到的数据都是通过写程序时直接写在程序中的方式进行硬编码，因此就失去了与计算机的交互性。然而在更多的情况中，我们会从控制台（cmd）向程序中进行输入，例如：输入一个人的年龄以及姓名，程序根据输入的不同的值做不同的响应，就用到了从控制台输入的函数。</p><p>&emsp;&emsp;由于向控制台输出和从控制台输出都属于标准输入输出，因此这两个函数也在fmt的包中，在使用的时候依旧需要引入这个包。我们将Scanln与Println相类比，将Scanf与Printf相类比，我们可以大致猜到Scanf函数可以对输入的字符串格式进行编辑，Scanln函数直接进行数据的输入。 </p><h4 id="Scanln函数"><a href="#Scanln函数" class="headerlink" title="Scanln函数"></a>Scanln函数</h4><p>&emsp;&emsp;Scanln函数可以从控制台接收到字符串，并自动地转换成接收的变量的数据类型，我们通过下面的几个案例进行快速入门：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;a)</span><br><span class="line">fmt.Scanln(&amp;b)</span><br><span class="line">fmt.Scanln(&amp;c)</span><br><span class="line">fmt.Scanln(&amp;d)</span><br><span class="line">fmt.Println(a, b, c, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">abc</span><br><span class="line">输出：</span><br><span class="line"><span class="number">100</span> <span class="number">3.14</span> <span class="literal">true</span> abc</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上述的案例，我们可以发现，在Scanln函数中，我们通过键盘所输入的值会根据其参数的数据类型而自动转换。一般来说我们通过控制台输入的值都是字符串，当计算机接收到字符串之后会根据不同的类型做自动的转换。现在我们将输入的形式稍作修改：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">100</span> <span class="number">3.14</span> <span class="literal">true</span> abc（将原来的回车改为空格，最后再敲回车）</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们会发现这个结果非常奇怪且是错误的，输出的结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> <span class="number">.14</span> <span class="literal">false</span> e</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;换句话说，在Scanln函数中，结束Scanln函数的标志为回车符号而不是空格符号，如果采用了空格符号作为结束符号，代码运行时不会报错，但是输出err之后我们可以发现，其读取过程还是发生了错误的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> </span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span></span><br><span class="line">_,err1 := fmt.Scanln(&amp;a)</span><br><span class="line">fmt.Println(<span class="string">"err1 is "</span>,err1)</span><br><span class="line">_,err2 := fmt.Scanln(&amp;b)</span><br><span class="line">fmt.Println(<span class="string">"err2 is "</span>,err2)</span><br><span class="line">fmt.Println(a,b)</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line"><span class="number">100</span> abc</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">err1 is  expected newline</span><br><span class="line">err2 is  &lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="number">100</span> bc</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;即在执行第一个Scanln函数时，读取第一个数字时发生了错误，函数一直在等待一个回车代表输入结束，但一直没有等到，导致其读取发生了错误，并影响到了第二数据的读取。</p><p>&emsp;&emsp;我们再看下一组代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span></span><br><span class="line">_, err := fmt.Scanln(&amp;a,&amp;b)</span><br><span class="line">fmt.Println(err)</span><br><span class="line">fmt.Println(a,b)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这一段代码中，我们依旧采用上述两种方式的输入：输入100空格abc后回车，和输入100回车abc回车。通过结果我们会发现，此时此刻第一种输入方式是奏效的，但是第二种方式会报错，其错误信息为：unexpected newline。出现这个问题的原因是，计算机正在等待一并输入两个值，但是输入完一个值后通过回车就结束了Scanln函数，因此第二个数据没有被读取。</p><p>&emsp;&emsp;所以说Scanln函数的用法还是相对苛刻，在多个Scanln函数执行时需要以回车作为分割，在一个Scanln函数中输入多个数的时候，需要以空格进行分割，不可以发生混淆。</p><h4 id="Scanf函数"><a href="#Scanf函数" class="headerlink" title="Scanf函数"></a>Scanf函数</h4><p>&emsp;&emsp;Scanf函数可以大致参考Printf函数的参数形式，在Printf函数中，我们通过一个含有占位符的字符串将输出格式确定下来，在Scanf函数中我们依旧通过这个含有占位符的字符串将输入格式确定，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">string</span></span><br><span class="line">fmt.Scanf(<span class="string">"%d%f%t%s"</span>, &amp;a, &amp;b, &amp;c, &amp;d)</span><br><span class="line">fmt.Println(a, b, c, d)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时，当我们依旧输入上述的几个数据时，我们会发现在相邻的两个数据输入过程中是以空格的形式进行分割，而不能使用回车。当我们将Scanf函数中的样式做修改时，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt,Scanf(<span class="string">"%d,%f,%t,%s"</span>, &amp;a, &amp;b, &amp;c, &amp;d)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们在利用空格作为输入的间隔符就会产生错误的数据了，因此这个时候我们需要按照输入的格式进行输入，在输入格式中，两个数据之间是以逗号作为分割的，甚至我们可以用任何的不同的字符串分割数据。只要输入的时候按照输入格式进行，就可以正确地读取数据。但是一般来说我们并不会在输入格式上进行限制，如果如此就会输入更多的与数据无关的字符。</p><h3 id="bufio输入"><a href="#bufio输入" class="headerlink" title="bufio输入"></a>bufio输入</h3><p>&emsp;&emsp;在前面的几段程序中，不知读者有没有发现，在输入字符串的过程中是无法出现空格的。一方面空格作为分隔符，当编译器发现空格的时候则默认为上一个数据输入完成了，另一方面，即便是空格不做为分隔符的时候，空格后面的字符串也都不见了。然而在写程序的过程中，我们往往需要让字符串中含有空格，例如外国人输入姓名的时候，或者名字里就是带空格，此时采用fmt输入就会丢失信息。因此一般来说，在做字符串读取的时候还是会使用bufio的方式。</p><p>&emsp;&emsp;使用这种方式需要额外引入两个包，分别是bufio包与os包，其原理是通过bufio中的读取器从标准输入（即键盘等）中直接读取数据，而不是先将数据读入到字符串中，再将其分割后放入变量。程序如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">input, err := inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"读入错误"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先解释一下程序：刚进入主函数的时候，我们通过bufio包新建了一个读取器，并且告诉这个读取器是从系统的标准输入读取的。然后用这个读取器进行读取字符串，直到读入’\n’即换行符为止，在这之前的任何字符都可以被读取到。该函数具备两个返回值，第一个返回值是读取到的内容，第二个返回值为错误类型。当判断没有出现错误（错误为空）时输出该字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：Hello I am Devin!(中间有一个\t)</span><br><span class="line">输出：Hello I amDevin!</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样我们就可以解决空格的问题了，当然这个函数基本都是用来读取字符串的，如果我们想将其转换成为其他数据类型如整数等，可以再参考数据类型转换那小节中的各个方法进行转换。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们主要讲述了Go语言中输入的问题，我们介绍了Scanln、Scanf函数以及通过bufio包中的函数进行字符串读取。在程序中，人机交互一般来说比较常见，因此这三个方法所用之处也十分的广泛，在日后的多次使用过程中，我们自然就会记住这几种方式的用法。</p><p>&emsp;&emsp;在下一小结中，我们将正式进入Go语言的下一章节，分支结构的讲解之中，在下一章节中我们将会介绍计算机中的下一个流程结构，介绍Go语言的if等关键字以及与其他的编程语言（如C语言）的细微的差别。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;15&gt; 运算符-逻辑，位运算，及其他运算符</title>
      <link href="/2020/02/18/15-%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%80%BB%E8%BE%91%EF%BC%8C%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%8C%E5%8F%8A%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2020/02/18/15-%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%80%BB%E8%BE%91%EF%BC%8C%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%8C%E5%8F%8A%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-15-gt-运算符-逻辑，位运算，及其他运算符"><a href="#Go语言从入门到放弃系列-lt-15-gt-运算符-逻辑，位运算，及其他运算符" class="headerlink" title="Go语言从入门到放弃系列&lt;15&gt; 运算符-逻辑，位运算，及其他运算符"></a>Go语言从入门到放弃系列&lt;15&gt; 运算符-逻辑，位运算，及其他运算符</h2><p>&emsp;&emsp;在上一小节中，我们集中说明了Go语言中的运算符中的三种，分别是：算数运算符，赋值运算符，以及关系运算符。在这一小节中，我们将继续介绍另外的几种运算符，并且将列举各个运算符的优先级，使读者当面对一个表达式的时候可以准确地计算出该表达式的值。</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>&emsp;&emsp;在Go语言中，逻辑运算符也相对较少，主要用到的是三个，分别为：&amp;&amp;（逻辑与），||（逻辑或），！（逻辑非）。在数学中乃至于电路中这三种逻辑也十分地常见，这三个运算符是针对于布尔值进行运算的，即其符号左右都需要是布尔值变量或者结果为布尔值的表达式。在一些语言中可以将0代替为false，将1代替为true，使之符号左右可以出现整数，但是在Go语言中，这种使用方式是错误的。</p><p>&emsp;&emsp;既然逻辑运算符是针对于布尔值的，而布尔值只有两种值可以取，因此我们可以很容易列举出不同情况下的返回值，我们也可以称之为真值表，根据我们的理解，也可以相对容易地分析出真值表中的各个值：</p><table><thead><tr><th>序号</th><th>p值</th><th>q值</th><th>p与q</th><th>p或q</th><th align="center">非p</th></tr></thead><tbody><tr><td>1</td><td>true</td><td>true</td><td>true</td><td>true</td><td align="center">false</td></tr><tr><td>2</td><td>true</td><td>false</td><td>false</td><td>true</td><td align="center">false</td></tr><tr><td>3</td><td>false</td><td>true</td><td>false</td><td>true</td><td align="center">true</td></tr><tr><td>4</td><td>false</td><td>false</td><td>false</td><td>false</td><td align="center">true</td></tr></tbody></table><p>&emsp;&emsp;当进行逻辑运算的时候可以完全遵循上述的真值表进行计算。从上述的真值表中我们可以发现，在&amp;&amp;（与）逻辑中，当且仅当左右两个表达式的值均为true的时候其结果才为true，在||（或）逻辑中，当且仅当左右两个表达式均为false的时候其结果才为false，在!（非）逻辑中，其结果仅仅是将后面表达式的结果取反。</p><h4 id="短路现象"><a href="#短路现象" class="headerlink" title="短路现象"></a>短路现象</h4><p>&emsp;&emsp;如果我们将上述的那段话换一种说法：在&amp;&amp;（与）逻辑中，只要左右出现了一个false的表达式，其结果一定就是false，同理，在||（或）逻辑中，只要出现了一个true的表达式，其结果一定就是true。也就是说，在列表中的几种情况中，计算机可以只通过一个表达式的值就可以得到整个表达式的真假，因此计算机可以完全不需要对后半部分的值进行判断，即将后半部分短路了。我们举个例子：（用到了if和函数的知识）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retTrue</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"这个函数返回的是true"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retFalse</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"这个函数返回的是false"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> retFalse() &amp;&amp; retTrue() &#123;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"----------------------------"</span>)</span><br><span class="line"><span class="keyword">if</span> retTrue() || retFalse() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述程序中，我们定义了两个自定义函数，分别是retTrue和retFalse，调用这两个函数的返回值分别是true和false，当调用的时候会输出函数中的字符串。因此，在main函数的调用过程中，我们可以根据输出的字符串来判断函数究竟有没有执行。经过运行，我们可以看到如下的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个函数返回的是<span class="literal">false</span></span><br><span class="line">----------------------------</span><br><span class="line">这个函数返回的是<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在程序中的main函数中的横线上方我们是调用了两个函数的，但是结果中只输出了一句话，从中可以判定在&amp;&amp;符号后方的表达式没有被执行。同理在横线下也调用了两个函数，但是也是只输出了一句话，其||符号后的表达式依旧没有执行。</p><p>&emsp;&emsp;具体的分析过程如下：在第一个运算中，计算机调用了retFalse函数之后，发现其返回值为false，然而在与逻辑中只要出现一个false其结果就一定为false，所以后面的表达式是否执行或执行结果对最终结果完全无影响，因此就不需要执行了。在或逻辑中，计算机先调用了retTrue函数且得到了true的返回值，只要出现了一个true其结果一定为true，所以后面的表达式就不需要执行了。</p><p>&emsp;&emsp;短路与和短路或逻辑在使用中需要注意这一点，在小型的计算中这个特性一般不会被体现出来，但是在逻辑极为复杂且用到很多的逻辑运算符时就会很令人费解。例如我们在函数中对某个全局变量的值进行了修改，但是在不同的情况下，这个函数可能会执行，也可能被短路，这样这个全局变量的值就很难追踪了。</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>&emsp;&emsp;位运算符的原理与数据的二进制表示方法有较大的相关性，所以位运算更贴近于计算机底层操作，因此在日常的开发过程中几乎很少能看到这种运算符。但是对于位运算有较好的掌握对于算法的优化、计算的效率的提升会有较大的帮助，因此我们在这里对位运算进行一些简要的讲解。</p><h4 id="gt-gt-（右移）-lt-lt-（左移）运算"><a href="#gt-gt-（右移）-lt-lt-（左移）运算" class="headerlink" title="&gt;&gt;（右移）&lt;&lt;（左移）运算"></a>&gt;&gt;（右移）&lt;&lt;（左移）运算</h4><p>&emsp;&emsp;根据这两种运算符的名称可以看出，这两种运算都是针对于二进制位的移动的，其格式a&gt;&gt;b的含义为将a数据以二进制表示后向右移动b个位置。那么既然位置在移动就难免会出现移动出可表示的区域的情况和新补充进来的数据位的值的判断。在这里我们介绍一个移位运算溢出时的规律：右移过程中溢出数据舍弃，高位根据符号位的值补充，左移过程中高位溢出舍弃，低位补零。我们先用两个例子进行说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">a = a &gt;&gt; <span class="number">1</span></span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;经过运行后，我们可以得到结果为5。这个结果出现的原因为：首先定义一个变量a为10，用二进制表示为（假设8个二进制位）：00001010，现在我们将其向右移动一位，高位补充为符号位的数据，即得到的结果是：00000101，再换算成10进制为5。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">a = a &lt;&lt; <span class="number">2</span></span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序的输出结果为40，其原因类似于上述的过程，首先将10用二进制表示（假设8个字节）：00001010，将其左移2位后，低位补充进去两个0，得到的结果是：00101000，换算成十进制后结果为40。</p><p>&emsp;&emsp;现在我们再举一个负数且会出现数据溢出的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">-11</span></span><br><span class="line">a = a &gt;&gt; <span class="number">2</span></span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;计算结果为-3，分析这个过程会相对复杂一些，不过依旧和二进制与补码的知识十分相关。首先我们将-11用二进制表示，-11的原码为：10001011，但是在计算机中对负数的存储方式是补码的方式，因此需要对其转换成补码的样式：11110101。现在我们将当前的二进制数向右移两个位，且溢出的位丢弃，补充进来的高位与符号位相同，其结果为：11111101，目前得到的结果是个负数且是补码的形式，因此我们在输出的时候将其转回原码形式进行输出：原码格式为：100000011，再按原码形式解读结果为-3。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int8</span> = <span class="number">-100</span></span><br><span class="line">a = a &lt;&lt; <span class="number">1</span></span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;读者可以自己先分写一下这个结果会是多少然后再看下述的分析。首先对-100进行码制转换，-100的原码是：11100100，转换成补码后得到的结果为：10011100。现在将这个值向左移动1位高位溢出，低位补0，得到的结果为：00111000，这时候符号位已经变成了0，所以其表示的是一个正数，正数的原码与补码相同，转换到十进制后结果就是56。</p><p>&emsp;&emsp;在上述的几个例子中，我们似乎可以发现另一个规律，当数据进行左移n位操作的时候，相当于数据乘以2的n次幂，数据进行右移操作的时候，相当于除以2的n次幂。乘法运算中出现数据溢出，除法操作出现向下取整。可以说，这种左移右移运算是计算数据乘以2或除以2时最好的方法。</p><h4 id="按位与、或、异或、与非、按位取反"><a href="#按位与、或、异或、与非、按位取反" class="headerlink" title="按位与、或、异或、与非、按位取反"></a>按位与、或、异或、与非、按位取反</h4><p>&emsp;&emsp;在理解了上述的真值表之后，我们若将二进制中的1替换成true，二进制中的0替换为false，这个小节就会相对容易理解了。这个小节所介绍到的所有操作依旧是针对于二进制的，因此在进行运算时首先要转换为二进制。</p><h5 id="amp-符号（按位与）"><a href="#amp-符号（按位与）" class="headerlink" title="&amp;符号（按位与）"></a>&amp;符号（按位与）</h5><p>&emsp;&emsp;将两个数据全部转换成二进制后，针对每一位进行与操作，只有两个数据的这个位全为1的时候，结果中的该位才为1，任意一个数据该位为0，结果中该位的值也为0，举例说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="number">86</span> &amp; <span class="number">120</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果为80。其原因为：将172转换成二进制：01010110，将120转换为二进制：01111000，将两个数据按位与运算后结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01010110</span></span><br><span class="line"><span class="number">01111000</span></span><br><span class="line">-----------------</span><br><span class="line"><span class="number">01010000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后将01010000转换为十进制后为80。</p><h5 id="符号-按位或"><a href="#符号-按位或" class="headerlink" title="|符号(按位或)"></a>|符号(按位或)</h5><p>&emsp;&emsp;我们将这个符号与上述进行类比，将两个数据转换成二进制后，数据位全部是0的时候结果为0，否则为1，依旧是上述的数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="number">86</span> | <span class="number">120</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">01010110</span></span><br><span class="line"><span class="number">01111000</span></span><br><span class="line">----------------</span><br><span class="line"><span class="number">01111110</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将01111110转换成十进制后，结果为126。</p><h5 id="符号（按位取反、异或）"><a href="#符号（按位取反、异或）" class="headerlink" title="^符号（按位取反、异或）"></a>^符号（按位取反、异或）</h5><p>&emsp;&emsp;当^符号作为单目运算符号时，即运算符前没有数据（例如正负号），此时这个符号的含义为按位取反，即该数据的某二进制位为1，结果中该位为0，反之亦然（包括符号位）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(^<span class="number">86</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">01010110</span></span><br><span class="line">----------------</span><br><span class="line"><span class="number">10101001</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;得到结果为10101001，转换成原码后为：11010111，按源码方式读取后十进制结果为：-87。</p><p>&emsp;&emsp;当该符号作为双目运算符使用时，其代表的含义为异或，换句话说：当两个数据某位不同的时候，结果中该位为1，当位数据相同时，其结果为0（符号位参与运算）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="number">86</span> ^ <span class="number">-120</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">01010110</span></span><br><span class="line"><span class="number">10001000</span>（补码形式）</span><br><span class="line">----------------</span><br><span class="line"><span class="number">11011110</span>===&gt;<span class="number">10100010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出结果为：-34。</p><h5 id="amp-符号（与非）"><a href="#amp-符号（与非）" class="headerlink" title="&amp;^符号（与非）"></a>&amp;^符号（与非）</h5><p>&emsp;&emsp;这个操作相当于是先将第二个数按位取反，然后将这个结果与第一个数做按位与操作，其特性可以记为：第二个操作数的某位为0的时候，结果为第一个操作数的值，当第二个操作数某位为1的时候，结果该位为0。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="number">86</span> &amp;^ <span class="number">120</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">01010110</span></span><br><span class="line"><span class="number">10000111</span>（取反后）</span><br><span class="line">----------------</span><br><span class="line"><span class="number">00000110</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果为：6。</p><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><p>&emsp;&emsp;Go语言中归纳为其他运算符的可以说只有两个，这两个运算符在我们讲解指针的时候提及过，即：&amp;运算符与*运算符。&amp;运算符表示的含义为返回变量的存储地址，*的含义为取出指针变量中所指向的值。具体就不做过多的讲解了，在指针数据类型的小节中有详细的例子与说明。</p><h3 id="运算符的优先级表"><a href="#运算符的优先级表" class="headerlink" title="运算符的优先级表"></a>运算符的优先级表</h3><table><thead><tr><th>分类</th><th>描述</th><th align="center">关联性</th></tr></thead><tbody><tr><td>后缀</td><td>() [] -&gt; . ++ –</td><td align="center">左到右</td></tr><tr><td>一元</td><td>+ - ! ~ ++ – (type) * &amp;</td><td align="center">右到左</td></tr><tr><td>乘法</td><td>* / %</td><td align="center">左到右</td></tr><tr><td>加法</td><td>+ -</td><td align="center">左到右</td></tr><tr><td>移位</td><td>&lt;&lt; &gt;&gt;</td><td align="center">左到右</td></tr><tr><td>关系</td><td>&lt; &lt;= &gt; &gt;=</td><td align="center">左到右</td></tr><tr><td>相等</td><td>== !=</td><td align="center">左到右</td></tr><tr><td>按位AND</td><td>&amp;</td><td align="center">左到右</td></tr><tr><td>按位XOR</td><td>^</td><td align="center">左到右</td></tr><tr><td>按位OR</td><td>&#124;</td><td align="center">左到右</td></tr><tr><td>逻辑AND</td><td>&amp;&amp;</td><td align="center">左到右</td></tr><tr><td>逻辑OR</td><td>&#124;&#124;</td><td align="center">左到右</td></tr><tr><td>条件</td><td>? :</td><td align="center">右到左</td></tr><tr><td>分配</td><td>= += -= *= /= %= &gt;&gt;= &lt;&lt;= &amp;= ^= &#124;=</td><td align="center">右到左</td></tr><tr><td>逗号</td><td>,</td><td align="center">左到右</td></tr></tbody></table><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们继续说明了Go语言中其他种类的几种运算符，包括逻辑运算及其短路现象，位运算的多个运算符的运算规则，以及提到了指针的两个运算法则。同时，我们也列出了运算符的优先级顺序，优先级越高在表达式中越先执行，反之越低则越后执行。</p><p>&emsp;&emsp;在下一个小节中，我们将对人机交互时向计算机输入信息所用的函数以及其包做出简要的介绍，同时对输入时遇到的分隔符以及字符串问题进行解决。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;14&gt; 运算符-算数、赋值与比较运算符</title>
      <link href="/2020/02/17/14-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%AE%97%E6%95%B0%E3%80%81%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2020/02/17/14-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%AE%97%E6%95%B0%E3%80%81%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-14-gt-运算符-算数、赋值与比较运算符"><a href="#Go语言从入门到放弃系列-lt-14-gt-运算符-算数、赋值与比较运算符" class="headerlink" title="Go语言从入门到放弃系列&lt;14&gt; 运算符-算数、赋值与比较运算符"></a>Go语言从入门到放弃系列&lt;14&gt; 运算符-算数、赋值与比较运算符</h2><p>&emsp;&emsp;在上几节中，我们讲述了Go语言中的多种数据类型，包括整型、浮点型、字符串以及指针类型等。在接下来的几个小节中我们将集中说明Go语言中的运算符的使用。在这一小节中，我们将主要介绍算数运算符、赋值运算符以及比较运算符（关系运算符）。</p><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>&emsp;&emsp;我们最先介绍算数运算符，因为算数运算符在我们日常生活中是最为常用的，在Go语言中算数运算符<br> 主要是进行数学运算的，例如加减乘除取余、正负号、自加自减等等。除此之外，我们将字符串拼接时所用到的加号也算在这个范畴中。我们在下述的表中列出算数运算符、其含义、举例以及案例中的结果：</p><table><thead><tr><th align="left">运算符</th><th align="left">运算</th><th align="left">范例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">正号</td><td align="left">+5</td><td align="center">5</td></tr><tr><td align="left">-</td><td align="left">负号</td><td align="left">-5</td><td align="center">-5</td></tr><tr><td align="left">+</td><td align="left">加法</td><td align="left">5+2</td><td align="center">7</td></tr><tr><td align="left">-</td><td align="left">减法</td><td align="left">5-2</td><td align="center">3</td></tr><tr><td align="left">*</td><td align="left">乘法</td><td align="left">5*2</td><td align="center">10</td></tr><tr><td align="left">/</td><td align="left">除法</td><td align="left">5/2</td><td align="center">2</td></tr><tr><td align="left">%</td><td align="left">取模（求余）</td><td align="left">5%2</td><td align="center">1</td></tr><tr><td align="left">++</td><td align="left">自加</td><td align="left">i=5 i++</td><td align="center">i=6</td></tr><tr><td align="left">–</td><td align="left">自减</td><td align="left">i=5 i–</td><td align="center">i=4</td></tr><tr><td align="left">+</td><td align="left">字符串拼接</td><td align="left">“Hello”+”!”</td><td align="center">“Hello!”</td></tr></tbody></table><p>&emsp;&emsp;在上述表中所列举的数据中，我们将选择几个运算符进行注意事项的讲解。首先表中的前几个运算符：正号、负号、加法、减法、与乘法就不做讲解了，因为这些运算与我们所理解到的数学运算是完全相同的。后面的几个运算符在一定情况下得到的结果与预期值不同，需要做一点讲解。</p><h4 id="除法（-运算）"><a href="#除法（-运算）" class="headerlink" title="除法（/运算）"></a>除法（/运算）</h4><p>&emsp;&emsp;在数学运算中，如果使用不是很小心，除法是最容易出现问题的一个运算法则，我们首先看如下的一段程序，并分析程序的输出结果会是什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">5</span> / <span class="number">2</span></span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在我们的理解中，输出的结果应该是2.5，但是可能令人惊异的是其输出结果是2。其实在上述的代码中出现了两个问题：第一个问题是期望的结果是浮点型但是定义了整型，第二个问题则是整数的运算结果依旧是整数。我们依次对这两个问题进行解决：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">5</span> / <span class="number">2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果只改变了变量a的数据类型，其结果依旧是错误的，也就是说单独地改变结果的数据类型是没有作用的。从中我们可以分析得到，在这一条语句中是存在两个行为的：第一个行为是计算5/2，第二个计算则是将第一个行为的结果赋值给变量a。因此真正出现问题的地方是整数运算结果为整数的规则，所以我们不仅要改变变量a的数据类型，我们还要改变5或者2的数据类型。</p><p>&emsp;&emsp;解决办法有两种：</p><ol><li>对5或者2进行显式类型转换：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="keyword">float32</span>(<span class="number">5</span>) / <span class="number">2</span>or</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">5</span> / <span class="keyword">float32</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>直接将5或2写成浮点型</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">5.0</span> / <span class="number">2</span>or</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">5</span> / <span class="number">2.0</span>or</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">5.0</span> / <span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以说，在Go语言中，整数除以整数得到的结果依旧是整数这个特点可能会使程序运行中出现一定的错误，但是这个特性在很多场景中都得到了很好的应用，因为整数的除法是一种天然的对结果向下取整的运算过程。因此在实际运用中需要注意或利用这个特性。</p><h4 id="取模（-运算）"><a href="#取模（-运算）" class="headerlink" title="取模（%运算）"></a>取模（%运算）</h4><p>&emsp;&emsp;在计算机中也常常会出现取模运算，我们上一次接触到取模运算是在讲解二进制转换的时候。当时十进制转换到二进制的时候各个二进制位都是通过取模运算得到的。在Go语言中取模运算也十分常见，尤其是在出现环路的情况，例如输入任意一个时间数输出它的下一个或几个小时之后的时间。</p><p>&emsp;&emsp;那么我们在最开始学习数学接触到余数的时候往往都是正数的取余运算，其实Go语言中也是支持负数的取模运算的。首先我们看下面一段程序，并考虑其输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">fmt.Println(<span class="number">9</span> % <span class="number">4</span>)</span><br><span class="line">fmt.Println(<span class="number">9</span> % <span class="number">-4</span>)</span><br><span class="line">fmt.Println(<span class="number">-9</span> % <span class="number">4</span>)</span><br><span class="line">fmt.Println(<span class="number">-9</span> % <span class="number">-4</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果为 1、1、-1、-1，从中我们可以看出一个规律：取模结果的符号与被除数的符号相同，且除法得到的商也未必都是正数。在Go语言中做取模运算的时候，遵循着这样的一个公式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = a % b==&gt;  x = a - a / b * b</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将9%（-4）带入到公式中，我们可以计算出：9/（-4）=-2.25，取整数后结果为-2，(-2)*（-4）= 8，最后 9-8=1，同理其他的三个结果也可以通过这个方式得出。</p><h4 id="自加自减（-，–运算）"><a href="#自加自减（-，–运算）" class="headerlink" title="自加自减（++，–运算）"></a>自加自减（++，–运算）</h4><p>&emsp;&emsp;相信在C语言或Java语言的学习过程中，初学者都会对i++,++i,i–,–i以及这四个运算混在一起的运算感到头疼。Go语言开发者为了减少这几种运算带来的迷惑性，对自加自减的运算进行了很多的简化以及限制，接下来我们就针对自加自减的运算做出一些说明。</p><p>&emsp;&emsp;自加自减运算本质上是改变当前的变量值，并且变为其前驱或者后继，例如：i++可以完全等价于i=i+1，同时i–可以完全等价于i=i-1，这个运算在循环结构中用到的非常多。</p><ol><li>Go语言中自加自减都是后缀运算，即运算符只能放在变量的后面：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">i++<span class="comment">//正确i--同理</span></span><br><span class="line">++i<span class="comment">//报错：unexpected ++--i同理</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="2"><li>Go语言中自加自减运算只能作为独立的语句，不能出现在其他赋值等表达式中：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">i++<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">var</span> j <span class="keyword">int</span> = i++<span class="comment">//错误</span></span><br><span class="line">fmt.Println(i++)<span class="comment">//错误</span></span><br><span class="line"><span class="keyword">if</span> i++ &gt; <span class="number">0</span><span class="comment">//错误</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>&emsp;&emsp;赋值运算符根据其名字就可以理解，其作用就是为变量或常量赋值，我们已经接触过的便是’=’符号，也就是我们常用的等于号。除了’=’号之外，还有一些与其他运算符组合的赋值运算符，如’+=’，’-=’，’*=’，’/=’，’%=’，这些符号的用法都十分简单，我们就只针对一个举例并说明。还有一些与位运算相组合的运算符，我们在讲位运算后再提及。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">i += <span class="number">10</span></span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段代码的输出值为20，在Go语言中i+=10所表示的含义为i=i+10，所以这个运算的核心是加法，也就是等号前面的符号。但是这个加号不要受到后面表达式的影响，即便是后面的表达式中出现了比等号前的符号优先级低的符号，也不会受到影响，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">i *= <span class="number">10</span> + <span class="number">2</span></span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这里可能会出现两种答案，一种是120，另一种是102，当我们利用编译器验证后，我们会发现答案其实是120，出现这两种候选的原意是，有人会将其翻译为：i = i * 10 + 2，另一种是i = i *( 10 + 2)，当我们在下一节讲到优先级的时候就会明白为什么结果如第二个表达式，而不是第一个表达式。因为赋值运算符在众多运算符中的优先级是非常低的。</p><p>&emsp;&emsp;还有一个需要注意的地方就依旧是’/=’的使用，在运算法则中，整数的运算结果还是整数，这个点只要注意到，就基本不会出现问题的。</p><h3 id="比较运算符-关系运算符"><a href="#比较运算符-关系运算符" class="headerlink" title="比较运算符/关系运算符"></a>比较运算符/关系运算符</h3><p>&emsp;&emsp;在计算机处理数据中，常常会对数据进行比较，例如，输入的整数是否处在一定的范围之内，从网络接收到的字符串是否是空串，几个数是否相等等等。因此在这种情况下，我们需要一种运算来连接两个数据，并且其表达式的值是一个能够表示真假的量，关系运算符就是如此。</p><p>&emsp;&emsp;在Go语言中，关系运算符有：&gt;，&lt;，==，&gt;=，&lt;=，!=，分别对应于：大于，小于，等于，大于等于，小于等于，不等于。这些运算符都可以通过字面来理解，其含义想必也不必多说，其中需要注意的问题是：在Go语言中，判断两个数据是否相等是要用’==’符号，而不是’=’号。我们刚刚讲，一个等于号代表的是赋值，而两个等于号才代表相等，这个点在初学者的编程过程中非常容易出现。我们依旧举一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">fmt.Println(a &gt; b)</span><br><span class="line">fmt.Println(a &lt; b)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其结果分别是false和true，这与我们心中所认为的是相同的，也就不过多介绍了。其中需要注意的点便是浮点型数据的精度丢失问题，当判断两个多位数的浮点型数据时候，使用’==’符号可能会出现与常理不太相同的结果，因此浮点型数据相等的判断往往是|a-b|&lt;=c的模式，即两个数相减的绝对值小于某个极小值。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们主要介绍了Go语言中的三种运算符，分别为算数运算符，赋值运算符以及关系运算符。在算数运算符中集中需要注意的是除法的运算规则以及取模运算的算式，在赋值运算符中则要注意其优先级，在比较运算符中需要注意的是两个数相等时所用的’==’运算符。</p><p>&emsp;&emsp;在下一小节中，我们将继续讲解其他几种运算符，以及列出诸多运算符的优先级，这样读者可以在面对一个表达式的时候有理有据地得出其最终结果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;13&gt; 指针类型简明讲述</title>
      <link href="/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/"/>
      <url>/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-13-gt-指针类型简明讲述"><a href="#Go语言从入门到放弃系列-lt-13-gt-指针类型简明讲述" class="headerlink" title="Go语言从入门到放弃系列&lt;13&gt; 指针类型简明讲述"></a>Go语言从入门到放弃系列&lt;13&gt; 指针类型简明讲述</h2><p>&emsp;&emsp;在上一节中，我们讲解了Go语言基本数据类型间的相互转化，以及在转化过程中可能遇到的精度丢失，数据溢出等现象。在其他基本数据类型与string类型相互转换的时候，我们讲解了转换所需要的函数方法。在这一节中，我们将介绍一种特殊的数据类型：指针类型。由于Go语言对于指针做出了许多的简化，使之不会出现像C语言一般令初学者谈指针色变。虽说我们在这一节直接介绍指针有些过于提前，不过后续经常会用到它，便在这里做一个简单的解释。</p><h3 id="指针的引入"><a href="#指针的引入" class="headerlink" title="指针的引入"></a>指针的引入</h3><p>&emsp;&emsp;在计算机科学中，指针是编程语言中的一个对象，利用地址的方式进行数据的存取。它的值直接指向存在于电脑内存或硬盘中的另一个地方的值，由于可以通过地址找到所需的变量单元，我们形象地将地址称为指针。简而言之，指针就是指内存中的一个地址。</p><p>&emsp;&emsp;用一个形象一些的例子，依旧是我们在说变量与变量名的那小节的例子。我们定义一个变量，这个变量具备一个变量名，就可以比作有一个人住在房子里且把这个房子取名为txg。其中这个人是变量的值，房子是分配的内存空间，屋子的名字txg是这个变量的名字，然而除了这些可以描述这个房子的人为属性之外，还有一个自然属性，就是这个房子的物理地址，比如说112 A’Beckett Street, Melbourne,VIC。也就是说除了通过访问txg来访问屋子之外，我们依旧可以通过物理地址来访问这个房子。</p><p>&emsp;&emsp;这个物理地址便可以理解为变量在内存中的真实位置，其值就是指针变量的值。我们知道计算机的内存是线性的且是连续的，每一个字节都可以用一个整数来表示，比如说想要访问内存中的第一个字节可以通过地址为0来访问，那么下一个字节就需要通过1来访问了。因此可以讲，指针类型所存储的值就是一个整数。</p><p>&emsp;&emsp;我们通过以下一个例子循序渐进地理解指针的含义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">fmt.Println(<span class="string">"a的值为："</span>,a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么当计算机在执行上述代码时，内存中会发生什么现象呢。首先计算机会分配8个字节给一个整型变量（我的计算机是64位），并且对该段内存赋予一个名字a。当输出的时候通过a的值进行访问该内存空间，并将该空间中的值输出来，可以通过如下的图进行理解：</p><p><img src="/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/1.png" alt></p><p>&emsp;&emsp;那么我们已经得到了名为a的变量，也同时知道的a的值，那么a所处在内存中的位置又是多少，我们可以采用&amp;运算符来获取，我们通过下一段程序进行说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">fmt.Println(<span class="string">"a的值为："</span>,a)</span><br><span class="line">fmt.Println(<span class="string">"a的地址为："</span>,&amp;a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果截屏如下所示：</p><p><img src="/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/2.png" alt></p><p>&emsp;&emsp;从中我们可以看到，不仅a的值可以顺利地打印出来，a所在的地址也被成功输出出来了，即0xc00000a168这个十六进制数的位置。换句话说，系统为a变量所分配的空间处在距离内存的起点处0xc00000a168的地方，且由于系统根据情况自动为变量分配空间，因此我们每个人不同时刻所得到的地址值可能是不尽相同的，此处只是一个案例。将其画在内存的表示图中为：</p><p><img src="/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/3.png" alt></p><h3 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h3><p>&emsp;&emsp;既然我们已经得到了整数a的物理地址，那么我们就相当于知道了指针变量中的变量值。指针变量是一种变量，其中的值为另一个变量的地址，我们在接下来的程序中进行快速入门：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;a</span><br><span class="line">fmt.Println(<span class="string">"p的值为："</span>, p)</span><br><span class="line">fmt.Println(<span class="string">"p指向的值为："</span>, *p)</span><br><span class="line">fmt.Println(<span class="string">"p的地址为："</span>, &amp;p)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将会得到如下的值，依旧需要注意的是内存分配是系统完成，读者得到的数值结果可能与我的不同：</p><p><img src="/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/4.png" alt></p><p>&emsp;&emsp;从上述结果中我们可以看出，我们定义了一个指向整数的指针变量p，且输出的p的值为0xc0000a168，且刚好就是a变量所在的内存地址，p所指向的值是100，也刚好便是a变量的值，同时因为指针变量也是一种变量，需要存在于内存中，因此，指针变量也具备一个物理地址，其当然也可以通过另一个指针来指向。</p><h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><p>&emsp;&emsp;在这里我们逐行对上述代码进行讲解。首先毫无疑问的定义一个整形变量a，并初始化其值为100。然后我们定义一个指向整数的指针变量，在这里定义过程中采用了*的方式进行定义，换句话说星号在定义阶段的出现是表明该变量是一个指针变量。然后我们采用&amp;符号的方式，将a变量的地址赋值给p指针，也就是常说的令p指针指向a。下一步直接输出p的值。再然后输出p所指向的值，在这里*又一次出现了，在变量的使用阶段使用星号，代表取出该指针指向的值。最后一行输出p的地址，我们依旧使用&amp;符号获取p变量的内存地址。将p也加入到内存表示图中为：</p><p><img src="/2020/02/16/13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E6%98%8E%E8%AE%B2%E8%BF%B0/5.png" alt></p><h4 id="amp-符号和-符号"><a href="#amp-符号和-符号" class="headerlink" title="&amp;符号和*符号"></a>&amp;符号和*符号</h4><p>&emsp;&emsp;在这里我们特殊强调一下，我们可以将&amp;符号与*符号看做一组互逆的符号对：&amp;符号可以取出该变量的地址得到指针，*符号可以取出该指针所指向的值，我们通过下面一个小程序来验证这两个符号对的使用关系：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">fmt.Println(*&amp;a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果依旧为100，因为我们先通过&amp;符号得到了a变量的地址，然后立刻通过*符号取出该地址的值，当然结果依旧是100，我们也可以理解为这两个符号同时出现后发生了互相抵消的现象。我们再看下一段程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">fmt.Println(&amp;*a)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们只是把两个符号相互调换了顺序，但是这时，程序是无法编译通过的，虽然是两个符号逻辑上可以互相抵消，但是在实现的时候却是先执行了*符号，然后执行了&amp;符号。然而a变量是一个整型变量，不是一个指针变量，因此对一个整数变量进行取地址中的值的运算时，即*运算时是错误的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;a</span><br><span class="line">fmt.Println(&amp;*p)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将程序修改至上述的样式，就可以正确执行了，因为此时的p就是一个指针，因此就可以执行*取值操作了，然后再取地址可以相互抵消，其输出值就是a变量的地址：0xc00000a168。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;a</span><br><span class="line">fmt.Println(*&amp;p)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以考虑一下上述代码能否正确执行，结果当然是可以执行的。我们最初提到指针变量也是变量，也具备一个地址，那么我们先对指针变量取地址，再对指针变量的地址进行取值，所得到的结果依旧是指针变量，换句话说是可以相互抵消的。其输出值依旧为:0xc00000a168。</p><h4 id="指针也具备数据类型"><a href="#指针也具备数据类型" class="headerlink" title="指针也具备数据类型"></a>指针也具备数据类型</h4><p>&emsp;&emsp;这个标题我其实想说的是，指针类型也是根据其指向的类型不同而不同的，例如*int表示的是指向整数的指针，*float32表示的是指向float32类型的指针。且不同种的指针类型之间是不可以乱赋值的。比如说：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">float32</span> = &amp;a</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码就是错误的，因为我们定义的a是整数变量，但是定义的指针p是指向float32类型的指针，最后我们将a的地址赋给该指针，这个在程序编译的过程中就会报错误。错误信息与之前也十分相似：cannot use &amp;a (type *int) as type *float32 in assignment。</p><p>&emsp;&emsp;我们可能会开始思考，指针的值就是变量的地址，就是内存的地址，换句话说就是一个十六进制的整数而已，既然都是整数，那指向不同数据类型的指针的意义何在。当我们在后面讲到数组的时候，我们会讲解到指针是可以移动的，且移动的长度与其指向的数据类型是相关的。比如指向int8类型的指针向后移动时，只需要移动一个字节就表示下一个int8了，而对于float32类型的指针来说，如果想通过指针移动得到下一个float32的值，则需要移动4个字节。因此写明该指针所指向的数据类型是十分必要的。</p><h4 id="注意空指针（野指针）"><a href="#注意空指针（野指针）" class="headerlink" title="注意空指针（野指针）"></a>注意空指针（野指针）</h4><p>&emsp;&emsp;到目前为止我们所见到的指针一般都是具有指向目标的，在上述的例子中p指针指向的是a变量。那么，如果一个指针变量没有指向任何的值，那么这个指针可以被称为野指针。指针变量和基本数据类型变量相似，也具备一个初始值零值，我们可以通过程序看指针的零值是什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span><span class="comment">//没有指向任何值</span></span><br><span class="line">fmt.Println(p)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们将p的值直接输出来，我们会发现输出结果为：&lt;nil&gt;，而不是像之前一样输出一个十六进制的整数。&lt;nil&gt;的值表示为空，那么从空中妄图取出值，当然就会报错了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">fmt.Println(*p)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其错误信息为：runtime error: invalid memory address or nil pointer dereference.</p><h4 id="指针可以改变数据"><a href="#指针可以改变数据" class="headerlink" title="指针可以改变数据"></a>指针可以改变数据</h4><p>&emsp;&emsp;既然我们可以通过指针的值来访问到变量的值，那么我们也可以通过指针来改变变量的值，例如如下程序:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;a</span><br><span class="line">*p = <span class="number">200</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(*p)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的程序中我们令p指针指向a变量，然后我们通过p指针进行取数据操作，然后将该数据修改为200，最后我们输出了a的值，也输出了p所指向的值，其运算结果为200和200。即通过指针进行修改时，是修改其指向的变量的值。我们再看下面一段程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;a</span><br><span class="line">p = <span class="number">200</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段程序中，我们在为p指针所指向的值赋值时，忘记写了前面的星号，导致了在逻辑上成为了如下的意思：将p的值（即a变量的地址）改变成200，这是绝对不允许的。因为计算机的内存的值从一开始就是设定好的，是无法进行修改的，错误信息为：cannot use 200 (type int) as type *int in assignment</p><h3 id="值类型与引用类型"><a href="#值类型与引用类型" class="headerlink" title="值类型与引用类型"></a>值类型与引用类型</h3><p>&emsp;&emsp;在这里我们只是简要地解释一下值类型与引用类型的概念，这两个概念非常的简单，但是在后续的学习过程中经常出现，我们也会在出现的时候进行强调说明。同时这两个类型涉及到太多的尚未提及的知识，目前只是记住这个概念就好。</p><p>&emsp;&emsp;1. 值类型：一般来说，我们提到的基本数据类型，如int系列，float系列，bool类型，string以及结构体（struct）和数组都是值类型。值类型的特点是：变量直接存储值，内存通常在栈中分配。我们之前举的例子都是值类型的。</p><p>&emsp;&emsp;2. 引用类型：指针是一个最为常见的引用类型，除此之外还有切片（slice），map，管道（chan），接口（interface）等，其特点为：变量存储的是一个地址，这个地址所对应的空间才是真正存储数据的空间，内存通常在堆中分配。当没有任何变量引用到那些真正存储数据的地址时，这个地址所对应的空间就再也无法被调用，且被垃圾回收机制（GC）所回收。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们集中介绍了指针的相关概念，并通过一些例子形象地引出了指针的含义，然后我们对指针的定义、两个符号的关系、以及指针指向的数据类型的含义、野指针的问题进行了讲解。最后又对值类型与引用类型做出了引出，在后续讲解其他知识点的时候会反复提及。</p><p>&emsp;&emsp;在下一小节中，我们将集中地详细地介绍Go语言中的运算符，内容比较散碎，依旧会通过一些例子讲解不同类型的运算符在使用过程中所需要注意的问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;12&gt; 基本数据类型的转换</title>
      <link href="/2020/02/15/12-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
      <url>/2020/02/15/12-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-12-gt-基本数据类型的转换"><a href="#Go语言从入门到放弃系列-lt-12-gt-基本数据类型的转换" class="headerlink" title="Go语言从入门到放弃系列&lt;12&gt; 基本数据类型的转换"></a>Go语言从入门到放弃系列&lt;12&gt; 基本数据类型的转换</h2><p>&emsp;&emsp;在上几个小节中，我们针对Go语言中的基本数据类型进行简要的描述，以及对各个基本数据类型在使用过程中可能出现的问题以及需要注意的点进行了详细的说明。在这一节中，我们将继续集中讲解Go语言中基本数据类型的互相转换方式，以及所用到的相关的函数等。</p><h3 id="不同数据类型的转换"><a href="#不同数据类型的转换" class="headerlink" title="不同数据类型的转换"></a>不同数据类型的转换</h3><p>&emsp;&emsp;我们首先介绍同类型的相互转换方式，例如int8转换为int32、float64转换为float32等。Go语言在这点上与C语言、Java语言等不同，Go语言在不同类型的变量之间赋值时需要进行显式转换，而不能自动转换。例如在Java语言中，我们完全可以将byte类型的数据直接赋值给int类型的数据完成自动转换，因为变量可容纳的空间是由小到大，因此不会出现数据溢出的问题，但是在Go语言中，我们需要明确地显式转换。 </p><p>&emsp;&emsp;大致上来说，Go语言中的类型转换都可以遵循一个语法：T(V)，其含义为将V的数据类型转换成T的数据类型。T是转换后的类型，如int32、float32等等，V是需要转换的变量，我们先写一段程序举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float32</span> = <span class="keyword">float32</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="keyword">uint8</span> = <span class="keyword">uint</span>(i)</span><br><span class="line">fmt.Println(i,f,u)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从以上程序中我们可以看出，我们首先定义了一个int类型的变量，并初始化为10，接着我们希望将这个int变量中的值赋给一个float32和uint8类型的变量，然后再输出，其输出结果为三个10，也就是说在这个类型转换过程中是成功的。接下来我们验证一下Go语言中数据类型不可以自动转换的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int8</span> = <span class="number">127</span></span><br><span class="line"><span class="keyword">var</span> bi <span class="keyword">int64</span> = i</span><br><span class="line">fmt.Println(bi)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在编译这段代码的时候，系统就会报出错误，其错误类型是：cannot use i (type int8) as type int64 in assignment。也就是int8类型的数据不能直接赋值给int64类型的数据，尽管理论上不会出现数据溢出的现象，也不会有任何的数据方面的问题。所以说Go语言对于数据类型的定义以及赋值限制是十分严格的。</p><h3 id="类型转换过程中的数据精度问题"><a href="#类型转换过程中的数据精度问题" class="headerlink" title="类型转换过程中的数据精度问题"></a>类型转换过程中的数据精度问题</h3><p>&emsp;&emsp;既然数据类型可以相互转换，则势必会出现数据精度丢失的问题，以及数据溢出的问题，例如我们将多字节的整数的值赋给一个少字节的整数，则可能会出现数据溢出，将浮点型数据向整数转换时小数的值会丢失。接下来我们写程序验证一下这两种事情发生时的情况。</p><h4 id="整数数据溢出"><a href="#整数数据溢出" class="headerlink" title="整数数据溢出"></a>整数数据溢出</h4><p>&emsp;&emsp;这个问题我们其实在整数精讲的部分时候已经提及过数据溢出的现象以及成因了，在这里我们只是通过程序验证一下这个现象并且通过例子更为深入地了解一下这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i32 <span class="keyword">int32</span> = <span class="number">456</span></span><br><span class="line"><span class="keyword">var</span> i8 <span class="keyword">int8</span> = <span class="keyword">int8</span>(i32)</span><br><span class="line">fmt.Println(i8)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出结果为-56，从程序中，我们可以明显地看出来456这个数值已经超出了int8所能表示的数据范围，如果强行将其赋给int8，我们会发现编译过程中是不报错的，同时也是可以正确输出结果的。下面我们就解释一下-56这个数字的由来，也顺便复习一下二进制与码制的知识点。</p><p>&emsp;&emsp;首先我们看到456是一个正数，因此其补码与原码相同，我们将其转换为二进制后可以得到如下的结果（除模取余，倒序输出）:0111001000，然后由于int8数据类型只分配到了8个二进制位的空间，因此超出8个二进制位的部分被全部舍弃，其结果变为11001000（第一个1溢出舍弃）。现在我们观察一下当前的结果，我们发现符号位为1，因此得到的这个数字是个负数，我们再根据补码规则，将其还原为原码：10111000（符号位不变，从右向左从第一个1以后所有位取反），根据二进制向十进制的转换关系为-56。</p><h4 id="浮点型向整数转换"><a href="#浮点型向整数转换" class="headerlink" title="浮点型向整数转换"></a>浮点型向整数转换</h4><p>&emsp;&emsp;由于整数是无法显示小数的，且整数与浮点型的表示方式也不甚一致，因此我们通过下面的一段程序来探究浮点型向整数转换时的小数问题，以及依旧可能出现的精度丢失问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">float32</span> = <span class="number">456.5</span></span><br><span class="line"><span class="keyword">var</span> i8 <span class="keyword">int8</span> = <span class="keyword">int8</span>(f)</span><br><span class="line">fmt.Println(i8)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据输出结果，我们会发现输出结果依旧是-56，也就是说，在浮点型数据向整型数据转换的时候，其小数位全部丢失，整数位根据整数之间的转换的原则进行数据溢出判断。所以相当于依旧是456向int8进行转换，根据上述的分析过程，我们依旧可以得到结果为-56。</p><h4 id="其他转换细节"><a href="#其他转换细节" class="headerlink" title="其他转换细节"></a>其他转换细节</h4><p>&emsp;&emsp;在大型的程序开发，或者说在多人的合作开发中，每个人完成特定的函数编写，因此可能存在数据类型不一致的情况，因此在计算过程中也可能会出现数据类型的转换，接下来我们举两个例子来完成类型转换的细节讲解。</p><p>&emsp;&emsp;首先我们看如下的一段程序，判断这段程序能否通过编译：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1 <span class="keyword">int32</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> n3 <span class="keyword">int8</span></span><br><span class="line">n2 = n1 + <span class="number">20</span></span><br><span class="line">n3 = n1 + <span class="number">20</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;答案是不能通过编译，因为数据类型不匹配，第一个错误类型依旧为：cannot use n1+20 (type int32) as type int64 in assignment。因此一个数据类型加一个常数，所得到的数据类型依旧是当前的数据类型。所以int32加20之后依旧是int32。接下来我们下面的一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1 <span class="keyword">int32</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="keyword">int64</span> = <span class="number">20</span></span><br><span class="line">n3 := n1 + n2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序中我们分别定义了int32和int64的值，并将两个值相加赋值给n3，我们利用类型推导来完成赋值，现在我们猜n3是什么数据类型。接触过C或者Java的人可能会回答n3的类型为int64，实则不然，因为这段程序根本无法编译，错误类型为：invalid operation: n1 + n2 (mismatched types int32 and int64)。因此不仅仅是赋值过程中不能隐式转换，就是运算过程中也不可以。如果我们将n2显式转换为int32后，编译通过，n3当然也就是int32类型。</p><p>&emsp;&emsp;第二个细节，是程序运算过程中的数据溢出判定，我们先看下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1 <span class="keyword">int32</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="keyword">int8</span></span><br><span class="line"><span class="keyword">var</span> n3 <span class="keyword">int8</span></span><br><span class="line">n2 = <span class="keyword">int8</span>(n1) + <span class="number">127</span></span><br><span class="line">n3 = <span class="keyword">int8</span>(n1) + <span class="number">128</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述程序中，是否能通过编译呢，答案依旧是不能，其错误的语句在于n3 = int8(n1) + 128，报出的错误为128溢出了int8数据类型，因此我们说，即便是’+’号两边的数据类型一致了，编译器也会检查两边的数据是否出现溢出的现象。对于加127那行语句，我们逻辑上可以看出数据溢出了，但是不会报错，程序运行也不受影响，但是128那一行会报错，因此在实际开发中需要注意。</p><h3 id="其他类型与string相互转化"><a href="#其他类型与string相互转化" class="headerlink" title="其他类型与string相互转化"></a>其他类型与string相互转化</h3><p>&emsp;&emsp;在实际开发中，我们常常会将其他基本数据类型与string类型相互转换，例如在网络传输过程中，我们会将实体类的各个属性转换成为一个字符串进行传输，在另一端收到字符串后会将其反序列化为实体类，其中的过程就是类型之间的互相转换。</p><h4 id="其他类型转string"><a href="#其他类型转string" class="headerlink" title="其他类型转string"></a>其他类型转string</h4><p>&emsp;&emsp;总体来说，其他数据类型向string类型转换时有两个常用的方法，分别是fmt包中的Sprintf函数以及strconv包中的几个函数，我们分别举例讲解：</p><ol><li>Sprintf函数，这个函数的签名为：fmt.Sprintf(“%参数”,表达式)，这个类型与fmt包中Printf输出函数十分的类似，如果我们使用Printf函数十分熟练的话，这种方式就非常简单了。无非就是将数据转成字符换和将数据转换成字符串后打印到屏幕上的区别，我们举一个例子：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"Devin"</span></span><br><span class="line"><span class="keyword">var</span> isAdult <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> info <span class="keyword">string</span></span><br><span class="line">info = fmt.Sprintf(<span class="string">"Name is %s age is %d isAdult is %t"</span>, name, age, isAdult)</span><br><span class="line">fmt.Println(info)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的程序的含义为：定义了几种数据类型的变量，并通过Sprintf方式将其格式化形成一个字符串，最后将这个字符串打印到屏幕上。经过运行后，我们会发现屏幕上输出了：Name is Devin age is 25 isAdult is true。也就是说，我们成功地将属性转换成了字符串，格式中的%d之类的表示方法与输出函数相同，可以参考前几节中我们讲到的知识点。</p><ol start="2"><li>strconv包中函数，这个包中的函数在转换过程中主要会用到以下4个函数，分别为：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatBool</span><span class="params">(b <span class="keyword">bool</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="keyword">float64</span>, fmt <span class="keyword">byte</span>, prec,bitSize <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="keyword">int64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatUint</span><span class="params">(i <span class="keyword">uint64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这些函数我们直接就在代码实践中以注释形式解释参数的含义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> num1 <span class="keyword">int32</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="keyword">float64</span> = <span class="number">12.345</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">str1 := strconv.FormatInt(<span class="keyword">int64</span>(num1), <span class="number">8</span>)</span><br><span class="line"><span class="comment">//注意输入参数的数据类型，参数是int64，因此要强转，8为基数，即以8进制形式转换，可选为2,8,10,16</span></span><br><span class="line">str2 := strconv.FormatFloat(num2, <span class="string">'f'</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"><span class="comment">//参数为float64，fmt表示格式: 'f':ddd.dd ,'b':dddp(+-)ddd(二进制科学计数法),'e':ddde(+-)ddd(十进制科学计数法)...</span></span><br><span class="line"><span class="comment">//10为保留10位小数，64指代传入的是float64，可选值为64和32</span></span><br><span class="line">str3 := strconv.FormatBool(b)</span><br><span class="line"><span class="comment">//传入布尔值，将其转换成字符串</span></span><br><span class="line">fmt.Println(str1)</span><br><span class="line">fmt.Println(str2)</span><br><span class="line">fmt.Println(str3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">144</span></span><br><span class="line"><span class="number">12.3450000000</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中FormatInt函数和FormatUint函数参数相同，也不做过多介绍了。</p><h4 id="string转其他基本类型"><a href="#string转其他基本类型" class="headerlink" title="string转其他基本类型"></a>string转其他基本类型</h4><p>&emsp;&emsp;string转向其他基本数据类型依旧使用的是strconv包中的函数，我们将其列出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="keyword">string</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(f <span class="keyword">float64</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(i <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseUint</span><span class="params">()</span><span class="title">s</span> <span class="title">string</span>, <span class="title">base</span> <span class="title">int</span>, <span class="title">bitSize</span> <span class="title">int</span>) <span class="params">(n <span class="keyword">uint64</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述的函数描述中，我们首次看到了两个返回值的函数，即bool值和error值，因此我们在调用的时候需要两个变量进行承接。我们依旧采用程序例子的方式进行说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str1 := <span class="string">"true"</span></span><br><span class="line">str2 := <span class="string">"100"</span></span><br><span class="line">str3 := <span class="string">"12.345"</span></span><br><span class="line">v1, _ := strconv.ParseBool(str1)</span><br><span class="line"><span class="comment">//暂时不关心error，所以采用_标识符进行接收</span></span><br><span class="line">v2, _ := strconv.ParseInt(str2, <span class="number">10</span>, <span class="number">32</span>)</span><br><span class="line"><span class="comment">//10表示以10进制形式转换，如果该值为0则根据字符串判断，出现0x为16进制，以0开头为8进制，否则10进制</span></span><br><span class="line"><span class="comment">//32表示结果可以赋值给int32，该值可选为0,8,16，32,64，分别对应int，int8，int16，int32，int64</span></span><br><span class="line"><span class="comment">//要求该数值指定结果必须能够无溢出地赋值</span></span><br><span class="line">v3, _ := strconv.ParseFloat(str3, <span class="number">32</span>)</span><br><span class="line"><span class="comment">//32表示：结果可以不改变精确值地赋给float32，可选值为32和64</span></span><br><span class="line">fmt.Printf(<span class="string">"v1的类型为%T,v1的值为%t\n"</span>, v1, v1)</span><br><span class="line">fmt.Printf(<span class="string">"v2的类型为%T,v2的值为%d\n"</span>, v2, v2)</span><br><span class="line">fmt.Printf(<span class="string">"v3的类型为%T,v3的值为%f\n"</span>, v3, v3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v1的类型为<span class="keyword">bool</span>,v1的值为<span class="literal">true</span></span><br><span class="line">v2的类型为<span class="keyword">int64</span>,v2的值为<span class="number">100</span></span><br><span class="line">v3的类型为<span class="keyword">float64</span>,v3的值为<span class="number">12.345000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据输出结果，我们可以看出其转换过程是成功的，且返回值分别是bool，int64，以及float64，当我们得到结果并且向转换成其他数据类型如int32时，可以再行显式转换。</p><p>&emsp;&emsp;值得注意的问题是，假如类型转换失败会发生什么现象，例如我们将”true”转换为整数，这时就需要用到error的值了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"true"</span></span><br><span class="line">v1, err := strconv.ParseInt(str, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">fmt.Println(v1)</span><br><span class="line">fmt.Println(err)</span><br><span class="line">v2, err := strconv.ParseBool(str)</span><br><span class="line">fmt.Println(v2)</span><br><span class="line">fmt.Println(err)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">strconv.ParseInt: parsing <span class="string">"true"</span>: invalid syntax</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以发现当数据转换成功的时候，是可以输出正确的值的，并且error的类型为nil，当数据转换不成功的时候，得到的值为该数据类型的<strong>零值</strong>，且error的类型是invalid syntax，因此在做数据类型转换的时候我们往往会根据err是否为nil来判断转换是否成功，所以我们一般会如下去写（使用到分支结构后续会详细讲解）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"Hello"</span></span><br><span class="line">v, err := strconv.ParseInt(str, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"类型转换出错"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在本小结中，我们集中讲解了Go语言的基本数据类型之间的互相转化，讨论了由高精度到低精度，高容量到低容量的转换过程中出现的问题，以及string类型与其他基本类型转换过程中使用到的函数与注意事项。整体来说，本节讲的知识点偏细，且比较杂，但难度不大。读者可以不必现在完全记住这些，当使用的时候，再回来仔细看即可。</p><p>&emsp;&emsp;在下一节中我们将集中介绍另一个数据类型：指针，并对指针数据类型的定义、使用、注意事项等进行详细地说明。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;11&gt; 基本数据类型精讲-字符和字符串</title>
      <link href="/2020/02/14/11-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/02/14/11-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-11-gt-基本数据类型精讲-字符和字符串"><a href="#Go语言从入门到放弃系列-lt-11-gt-基本数据类型精讲-字符和字符串" class="headerlink" title="Go语言从入门到放弃系列&lt;11&gt; 基本数据类型精讲-字符和字符串"></a>Go语言从入门到放弃系列&lt;11&gt; 基本数据类型精讲-字符和字符串</h2><p>&emsp;&emsp;在介绍Go语言的基本数据类型时，我们同时也提及了布尔型变量、复数类型以及字符串，并单独介绍了Go语言中不存在但是一些其他语言存在的字符型变量。复数类型在开发过程中不怎么常用，而布尔型变量我们会在条件结构的章节中详细地介绍，因此在这一节中，我们将集中讲述字符和字符串类型的各个注意事项以及一些细节点。</p><h3 id="（字符型）"><a href="#（字符型）" class="headerlink" title="（字符型）"></a>（字符型）</h3><p>&emsp;&emsp;我们在这里用括号括起来依旧是表示这个类型是不存在的，但是为了介绍方便以及引出字符串的注意点，我们依旧将它作为一种数据类型进行讲解。在前面的介绍中，我们可知Go语言中的字符不仅仅局限于数字、字母等传统ASCII字符集，而是囊括了各个国家的各种语言。因此虽说byte和rune类型均表示字符型类型，但是除非明确运用在英语国家，我们一般还是会运用rune类型。</p><h4 id="ASCII字符集"><a href="#ASCII字符集" class="headerlink" title="ASCII字符集"></a>ASCII字符集</h4><p>&emsp;&emsp;ASCII字符集是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他的西欧类语言。同时也是在西方英语国家中最为常用且通用的单字节编码系统，现在包括UTF-8编码在内的UNICODE编码均向下兼容了ASCII编码模式。一般来说，ASCII码是使用7位或8位二进制位的组合来表示128种或256种可能的字符。在早期ASCII码用于传输的时候是128个，也就是占据了7个二进制位，后来IBM公司根据字节这个最小单位所拥有的位数拓展成了256个字符，但日常编程中常用的是前128个。</p><p><img src="/2020/02/14/11-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/1.png" alt></p><p>&emsp;&emsp;上图即为ASCII码与字符之间的匹配关系（图片来源于网络），从图中看，我们可以找到几点规律：</p><p>&emsp;&emsp;1. 从编号为33的字符开始直到编号为126的字符，均是我们日常开发中在键盘上可以见到的、常用的字符，包括数字、字母、与众多标点等。其余的字符均是控制类与传输类的字符，往往需要转义才能得到。</p><p>&emsp;&emsp;2. 数字从0到9，字母从a到z，字母从A到Z的编码值分别是连续的，但是其之间是不连续的。在字符参与运算过程中，例如’A’+2，其结果为’C’，原理与整数相加是相同的。</p><p>&emsp;&emsp;3. 在编程过程中需要尤其注意0，’0’，与’\0’的关系，在上一节介绍用字符串表示浮点数与整数以消除其误差的时候，过程中的一环便是将字符型的数字转换成内存中的相应的数字，解决办法便是对每一位的值均实行减48的操作，这样计算结果才是正确的，前期练习的时候可能会在这个地方犯错。</p><p>&emsp;&emsp;接下来我们利用循环（后面会讲到）在控制台输出前128个字符，我们会发现还是有许多有趣的字符的：</p><p><img src="/2020/02/14/11-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/2.png" alt></p><p>&emsp;&emsp;从中我们看到了笑脸、看到了心、还看到了许多莫名其妙的字符，这些奇怪的字符代表的均是控制类和传输类的字符，如果仔细听，我们还会听到计算机的蜂鸣器发出了‘嘟’的一声，这个是因为ASCII码为7的字符发出的，其结果就是令蜂鸣器发出声音。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>&emsp;&emsp;在前面的阐述中，我们将字符串阐述成为字符的有序合集，是由一个个字符所构成的，但是这种说法不甚确切，准确地说Go语言的字符串是由字节所构成的。根据UTF-8编码规则可知，每个字符占据三个字节，所以Go语言中的字符串长度与其占据的字节数是不相同的。在Go语言的字符串使用中，我们需要注意以下的几个点：</p><h4 id="字符串是常量"><a href="#字符串是常量" class="headerlink" title="字符串是常量"></a>字符串是常量</h4><p>&emsp;&emsp;这个特性在很多语言中均是如此，字符串在定义过程中就已经分配好了空间，且不能通过类似数组方式进行单个字符的替换，例如如下程序，我们希望将Hallo中的’a’字符替换成’e’字符，这个操作是非法    的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hallo"</span></span><br><span class="line">str[<span class="number">1</span>] = <span class="string">'e'</span></span><br><span class="line">fmt.Println(str)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其报错信息为：cannot assign to str[1]，所以字符串一旦赋值了，字符串就不能更改了。当对字符串进行拼接操作时，例如如下程序，将Hello与World拼接起来，可以采用+号进行拼接:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello"</span></span><br><span class="line">str = str + <span class="string">" World"</span></span><br><span class="line">fmt.Println(str)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;程序输出结果为Hello World，将两个字符串拼在了一起，看起来像是将World单词拼接在了Hello的后面，实则不是。在执行这个操作的时候，内存中生成了两个字符串，分别为Hello和Hello World，只是str由原来的指向Hello变成了指向Hello World字符串。原来的Hello字符串由于没有任何变量指向它了，就被Go的GC机制回收并释放了内存。</p><h4 id="字符串的两种表示方式"><a href="#字符串的两种表示方式" class="headerlink" title="字符串的两种表示方式"></a>字符串的两种表示方式</h4><p>&emsp;&emsp;在前面的举例中，我们都用双引号进行字符串的表达，这个就不再举例了，前面的例子已经足够说明这种方式了，在这里我们介绍的是第二种表示方式，即利用反引号进行表示。反引号是我们键盘上左上角，esc按键下的那个按键，利用反引号可以使字符串以原生的形式进行表示，其中就包含了换行与特殊字符，可以实现防止攻击，输出源代码等效果，例如我们想输出一句Hello “World”，在World的两边输出双引号，如果利用双引号我们将需要写成如下的字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello \"World\""</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也就是说我们需要使用转义字符来手动控制字符串中的格式，否则遇见双引号字符串就提前结束了，因此这点在输出源代码的时候就会非常的困难，取而代之，我们可以利用如下的定义方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">`Hello "World"`</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样就可以将双引号原样输出，我们再举个例子，将程序的源代码输出：</p><p><img src="/2020/02/14/11-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/3.png" alt> </p><p>&emsp;&emsp;从上述代码中，我们可以发现使用反引号时可以将双引号、换行符、乃至于制表符都可以直接输出出来，这个特点在用Go做服务器的时候可以得到很多的使用。</p><h4 id="len函数与Sizeof函数"><a href="#len函数与Sizeof函数" class="headerlink" title="len函数与Sizeof函数"></a>len函数与Sizeof函数</h4><p>&emsp;&emsp;在字符串中我们往往需要知道其长度或占据了多少个字节，我们就因此引入两个函数，len函数的返回值表示了字符串的长度。而unsafe包下的Sizeof函数不太一致，其代表了字符串数据类型在内存中占用的空间，这个问题需要说明一下，否则很容易理解错误。我们首先来看纯英文的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">   <span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"unsafe"</span></span><br><span class="line">   )</span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello"</span></span><br><span class="line">   fmt.Println(<span class="built_in">len</span>(str))</span><br><span class="line">   fmt.Println(unsafe.Sizeof(str))</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过程序编译运行后，我们会发现输出的结果分别为5和16，也就是说，Hello这个字符串的长度为5，在内存中被分配了16个字节。相信字符串长度为5这个很好理解，但是字符串占据16个字节就有些问题了，我们先记下不表，现在我们将视线放在中文字符串上（只写main函数中）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"中国"</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(str))</span><br><span class="line">fmt.Println(unsafe.Sizeof(str))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段程序的输出结果为6和16，这个6也相对好理解，因为每个汉字都占据3个字节，两个汉字占据了6个字节是没问题的，但是通过Sizeof输出的结果依旧是16，而且不论什么字符串，结果都是16。可见通过Sizeof得到的值与字符串本身内容是不相关的。我们接下来解释一下这个问题。</p><p>&emsp;&emsp;有些人最初可能会将它与C语言中的sizeof函数进行类比，但通过分析它与C语言中的是完全不同的。Go语言中的Sizeof总是在编译期就进行求值而不是在运行期间求值。在Go语言中字符串类型其实对应于一个结构体，该结构体中有两个属性，换句话说字符串类型是由两部分构成的。第一部分为指向该字符串的指针（后续会讲到），第二部分为字符串的长度，每个部分都用了8个字节来存储各自的内容，而字符串的值本身则是在另一段连续的内存中储存着。就如同一个遥控器，一台电视一般，字符串数据引用是遥控器，字符串中的值是电视，Sizeof所测量的是遥控器的尺寸，而不是电视的大小。</p><h4 id="字符串拼接时’-’的位置"><a href="#字符串拼接时’-’的位置" class="headerlink" title="字符串拼接时’+’的位置"></a>字符串拼接时’+’的位置</h4><p>&emsp;&emsp;这个问题十分的简单，我们就举两个例子进行说明，这只是一个规定：当字符串过于长而不得不使用多行来赋值时，’+’的位置需要出现在字符串该行的结尾，而不是下一行的开头：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello"</span> +</span><br><span class="line"><span class="string">" World"</span></span><br><span class="line">fmt.Println(str)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码的编译是可以通过的，并且可以得到正确的结果。如果程序写成如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello"</span> </span><br><span class="line">+ <span class="string">" World"</span></span><br><span class="line">fmt.Println(str)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在编译过程中就会出现错误，错误的类型为：invalid operator: + untyped string。这个问题注意一下即可。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小结中，我们集中介绍了字符型数据类型的注意事项，包括ASCII码与字符的对应关系，以及其遵循的规律等。以及字符串在定义、使用过程中所需要注意的几点问题。包括常量的属性、表示方式、字符串长度函数以及拼接过程中+符号所需要处在的位置。在下几节中，我们将继续对基本数据类型进行讲解，集中举例说明数据类型之间的转化方式，例如将整数的值转换为字符串等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;10&gt; 基本数据类型精讲-整型和浮点型</title>
      <link href="/2020/02/13/10-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E6%95%B4%E5%9E%8B%E5%92%8C%E6%B5%AE%E7%82%B9%E5%9E%8B/"/>
      <url>/2020/02/13/10-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2-%E6%95%B4%E5%9E%8B%E5%92%8C%E6%B5%AE%E7%82%B9%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-10-gt-基本数据类型精讲-整型和浮点型"><a href="#Go语言从入门到放弃系列-lt-10-gt-基本数据类型精讲-整型和浮点型" class="headerlink" title="Go语言从入门到放弃系列&lt;10&gt; 基本数据类型精讲-整型和浮点型"></a>Go语言从入门到放弃系列&lt;10&gt; 基本数据类型精讲-整型和浮点型</h2><p>&emsp;&emsp;在前几节中我们详细地讲述了Go语言中二进制的基础，基本数据类型和Go语言中标识符的规定及使用。在接下来的几节中，我们将针对之前提到的几种基本数据类型进行详细地讲解，并对程序开发中可能出现的问题进行讲解和原因的解释。</p><h3 id="整型变量的细节讨论"><a href="#整型变量的细节讨论" class="headerlink" title="整型变量的细节讨论"></a>整型变量的细节讨论</h3><p>&emsp;&emsp;首先，我们先复习一下之前所讲的基本数据类型中的整型变量，整型变量的定义按是否有符号可以分为有符号整数和无符号整数。有符号整数的最高位表示符号位，且0代表正数，1代表负数，无符号整数的最高位参与数字的表示，即只能表示正数。在intN类型中的N代表计算机系统为该类型分配多少个二进制位数，即int8为8位，int16为16位。不同的整数类型对于数值的表示大小是不相同的，我们在接下来的讲解中会以int8为例。</p><p>&emsp;&emsp;既然每种整数类型可以表示的数值范围大小是一定的，那么一旦其中存储的数据超出了其可以表示的最大的范围会发生什么呢，我们将以以下的几个例子进行详细地说明：</p><h4 id="赋值时越界"><a href="#赋值时越界" class="headerlink" title="赋值时越界"></a>赋值时越界</h4><p>&emsp;&emsp;首先我们知道，int8可以表示的范围为-128到127，我们看下面的一段代码（只写main函数中的代码了）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="keyword">int8</span> = <span class="number">128</span></span><br><span class="line">fmt.Println(num)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过对上述程序的分析，我们知道，将128赋值给int8是会出现数值越界的情况的，因为其可表示的最大的数值只为127。在开发阶段出现了这类数值越界的代码时，编译器会帮助我们进行检查，因此这段代码是无法编译通过的，而且其错误类型显示为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constant <span class="number">128</span> overflows <span class="keyword">int8</span></span><br><span class="line">即常量<span class="number">128</span>溢出了<span class="keyword">int8</span>所能表示的范围</span><br></pre></td></tr></table></figure><h4 id="运行时越界"><a href="#运行时越界" class="headerlink" title="运行时越界"></a>运行时越界</h4><p>&emsp;&emsp;既然在变量的赋值过程中是不会出现数据溢出的（否则编译不通过），那么在运行时是否会出现数据越界呢，一旦出现的数据越界程序是否会做出相应的响应，例如程序停止运行等行为。现在我们进行验证一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="keyword">int8</span> = <span class="number">127</span></span><br><span class="line">num = num + <span class="number">1</span></span><br><span class="line">fmt.Println(num)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;程序中出现的num=num+1的意思是，取出num所代表的值，进行加1运算后将结果再赋值给num。在这个过程中，我们会预见在做完加1运算后就又出现了数值溢出现象，经过编译运行后，我们会发现编译过程是不报错误的，同时运行过程中也没有任何的错误消息产生的，当我们看到输出结果时，我们会发现其结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-128</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在我们可以考虑一下为什么会是这个结果，在介绍原码、反码与补码的章节中，我们提到了正0和负0的问题，即00000000和10000000的问题，我们人为地将10000000所代表的数定为-128。首先我们将127转换为2进制表示方法，其结果为01111111，现在我们在此基础上加1，我们会发现通过进位后其结果成为10000000，而这个数字刚好是-128。</p><p>&emsp;&emsp;反过来思考，如果我们首先将num赋值为-128，然后在此基础上减1，其结果会显示为127，也正如当初举的时钟的例子一般，正数最大值和负数最小值是相连的。分析过程是相似的，读者可以自行思考。</p><p>&emsp;&emsp;接下来我们将目光放置在无符号整数上，例如uint8，之前我们曾经介绍过，uint8的表示范围为0到255，那么同样在开发过程中赋越界的值时会编译错误，所以我们依旧关注的是运行过程中数据越界的问题，看如下的程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="keyword">uint8</span> = <span class="number">255</span></span><br><span class="line">num = num + <span class="number">1</span></span><br><span class="line">fmt.Println(num)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以分析得，按照上述最大值和最小值相连的规律，其输出结果为0，由于该整数是一个无符号整数，因此最高位参与了计数，所以255用二进制表示为11111111（8个1），我们在其基础上加1后，经过一系列的进位运算，其结果应该是100000000（1后面有8个0），但是uint8数据类型只得到了8个二进制位的空间，因此最高位（第9位）的数据溢出并舍弃，所以计算结果为： 00000000（8个0）也就是0。逆过程可以自行思考。</p><p>&emsp;&emsp;在应用过程中有一个十分常见的例子，便是字符的表示方式。如果表示ASCII码，byte型就可以完全存储了，但是如果想存储汉字，那么byte就会出现越界，需要用rune类型数据进行存储。当然，用rune类型来存储ASCII字符也是没有问题的，程序验证如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">byte</span> = <span class="string">'中'</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其编译过程中会出现错误，异常信息为：const 20013 overflows byte，由此看出，’中’这个字符在UTF-8编码中的数值为20013，这个数值明显超出了byte所存储的范围，因此会报错。</p><p>&emsp;&emsp;所以，在整数的定义与表示过程中，无论定义了空间多大的整数，都会出现数据溢出的可能，因为每个整数都有确定的数据表示范围。因此针对不同的数据范围需求来选择对应的数据类型是十分重要的，否则在程序运行中会出现意想不到的问题，而这个问题并不涉及任何的逻辑上的错误。比如说我们定义一个变量，令该变量每次都加1，一直加到该变量为500为止，如果我们使用了uint8类型，那么这个程序就永远也停不下来了，因为255后的值又回归到0了。当然我们也可以采用int64来存储，但是针对这个需求而言，int64又有些内存的浪费了（虽说现在基本上不缺这点内存），所以选择适合的数据类型来完成特定的工作是一件需要考虑乃至于优化的事情。</p><h3 id="浮点型变量的细节讨论"><a href="#浮点型变量的细节讨论" class="headerlink" title="浮点型变量的细节讨论"></a>浮点型变量的细节讨论</h3><p>&emsp;&emsp;浮点型的存储过程中精度丢失一直都是一个无法回避的问题，这个问题在大规模的精确计算过程中十分的常见，精度丢失的问题甚至可能会导致逻辑上的问题。根据我们之前对数据类型的介绍，不论是float32还是float64类型的变量，其可表示范围都十分的广阔，同时我们也讲解了浮点型数据在内存中的存储方法，因此一般来说float32所能精确地表示小数位数为6<del>7位，而float64能表示为15</del>16位，超出的精度部分往往就会丢失了，我们来看下面的一段程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">1.00000001</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span> = <span class="number">1.0000001</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(b)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述的一段程序中，我们为a和b两个变量分别赋值，并且在程序的最后输出这两个值。根据我们刚提及的精度丢失问题以及小数保留位数，我们会发现：最终的结果为a=1，b=1.0000001。可以说b的值的输出是正常的，但是a的值却产生了错误。其原因便是超出精度范围的数值被忽略了。如果我们依旧对于精度丢失所产生的问题不甚理解的话，那么我们可以再看一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">3.3333333</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span> = <span class="number">6.6666666</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">float32</span> = a + b</span><br><span class="line">fmt.Println(c)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可能令人大跌眼镜的是，这个运算结果也就是c的值为10，第一个例子中超出精度的部分被舍弃了，而在第二个例子中超出精度的部分就进了1位。这种问题既不可以被归结为编译的错误，也不可以归结为逻辑的错误，而是说这个错误出现的原因是由语言本身和机器本身所导致的。更确切地说是由浮点型数据的存储方法和二进制十进制对应关系所导致的。接下来我们从两个角度简要说明一下精度丢失的成因。</p><p>&emsp;&emsp;第一个成因便是<strong>进制转换时的精度丢失</strong>，在进制转换的那一小节中，我们抛出了一个问题，是否每一个有限的十进制数都有一个有限位数的二进制数相对应，我们对这个问题的解答是否定的。也就是说我们在用十进制数编程时，再用计算机转换成二进制码的时候，精度就已经丢失了一次了，这个丢失是内部原因导致的，也是基本无法避免的。</p><p>&emsp;&emsp;第二个成因便是<strong>浮点数的表示方法</strong>，按常理来说，一个有限位数的浮点型变量居然能表示那么大的范围，其精度必然是不会非常高的。我们在前几节介绍了浮点数的存储方式，即符号位、指数部分、和尾数部分。指数部分代表了科学计数法中的幂次，剩余的部分则表示在尾数部分，由于尾数部分也是有位数限制的，因此也会出现类似于整数一样的数据溢出问题的。因此太多的小数位数将溢出尾数部分，而保留的就是前几位未溢出的部分，因此在浮点数的存储方法中，会出现二次的精度损失。</p><p>&emsp;&emsp;那么一旦真的需要精度十分高的浮点型乃至于数值极为庞大的整数运算时，有一种解决办法便是利用字符串，字符串中的每一个字符值都是一个精确的数字。换句话说，利用字符串，在内存中所保存的是一系列的int8类型，每个int8对应于真值的每一位。同时Go语言开发者也向用户封装了基于字符串所表示的数据的数学运算函数，在需要时可以调用。详细源码可以研读Go语言中的math/big包。</p><p>&emsp;&emsp;利用字符串表示数据虽解决了数据存储与表示的问题，但是这种方式也有其特定的弊端。当我们利用int、float32等提供的数据类型进行运算操作时，系统在计算机底层予以其特殊的优化手段，使之计算速度有极大的提升。而利用字符串进行运算，则会拖慢运行速度，在一些已定义的函数中无法作为参数而不得已只好自行包装、改写函数。</p><p>&emsp;&emsp;不过话说来，浮点数精度丢失的问题一般不会影响到我们程序开发，在应用级的开发中往往不会用到8位小数之后，而且float64所提供的有效精度也足够使用了。但是在科学计算中，或在大规模的银行系统中，精度就会成为一个不得不慎重考虑的问题。曾经有一个生物信息专业的同学给我讲述过一个事情，在做DNA匹配计算过程中需要将各种的变异均考虑进去，并且得到的匹配结果十分的相似。此时问题就是，究竟是这两个DNA相同但是因为计算精度问题而显示成不同，还是说两种DNA真的是不同只是不同点比较少但是比较重要。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们主要讲述了Go语言中整数和浮点数使用注意事项，集中说明了整数中的数据溢出问题和浮点型数据中的精度丢失问题。这两个问题在计算机语言中是普遍存在的问题，不仅仅是Go语言中单独的问题。这两种问题在日常开发中几乎不会遇到，但是在实际工作中一旦出现了某种周期性问题或没有明显逻辑错误的问题时，这两个原因不失为一种考虑方向。</p><p>&emsp;&emsp;在下一节中，我们将针对于剩下的几种基本数据类型进行精讲，同时也将讲解在开发过程中可能出现的问题及原因。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;9&gt; 标识符、输出及转义字符</title>
      <link href="/2020/02/12/9-%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%8C%E8%BE%93%E5%87%BA%E5%8F%8A%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"/>
      <url>/2020/02/12/9-%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%8C%E8%BE%93%E5%87%BA%E5%8F%8A%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-9-gt-标识符、输出及转义字符"><a href="#Go语言从入门到放弃系列-lt-9-gt-标识符、输出及转义字符" class="headerlink" title="Go语言从入门到放弃系列&lt;9&gt; 标识符、输出及转义字符"></a>Go语言从入门到放弃系列&lt;9&gt; 标识符、输出及转义字符</h2><p>&emsp;&emsp;在上一小节中，我们集中介绍了变量的定义、变量的使用过程、初始化过程以及多变量的赋值。同时，我们也验证了每种基本数据类型的初始值的设定。在这一节中，我们将分别介绍Go语言中标识符的概念、合法性以及两个输出函数的使用方式，最后将对（字符型）数据中的转义字符进行介绍。</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>&emsp;&emsp;在上一节中我们介绍变量的时候提到了变量名，严格来说变量名就是一种标识符，标识符不仅仅针对于变量名，而是变量、方法、函数等命名时所使用的字符序列，均称之为标识符。简而言之便是：程序中但凡需要自己取的名字就是标识符。</p><h4 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h4><p>&emsp;&emsp;同其他的编程语言相似，Go语言中的标识符的规则也是可以由三部分构成：字母、数字、下划线，且不能以数字开头。在Go语言中，变量也是大小写敏感的，换句话说就是大写字母构成的标识符和同样字母但是小写所构成的标识符是不同的。既然标识符只能通过这三种字符构成，其他的如空格、回车、美元符号等都是非法的。我们举一些例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello <span class="keyword">int</span><span class="comment">//合法</span></span><br><span class="line"><span class="keyword">var</span> hello123 <span class="keyword">int</span><span class="comment">//合法</span></span><br><span class="line"><span class="keyword">var</span> Hello <span class="keyword">int</span><span class="comment">//合法，且与hello是不同的</span></span><br><span class="line"><span class="keyword">var</span> is_adult <span class="keyword">bool</span><span class="comment">//合法</span></span><br><span class="line"><span class="keyword">var</span> <span class="number">1</span>hello <span class="keyword">int</span><span class="comment">//不合法，数字不可以开头</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中需要说明的是，只由一个下划线所构成的标识符（’_’）是具备特殊含义的，在Go语言中称之为空标识符，其可以代表任何一个标识符，其中的值也是被忽略的。一个经典的例子便是，在Go语言中一些函数的返回值可能有多个，我们在使用的时候可能只希望获得其中的一个或忽略其中的某些，就可以通过下划线标识符来接收，这样程序不会因为返回值数量不匹配而报错，也不会因为定义了变量但没有使用而报错。举例如下（涉及函数知识，可后期再理解）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMaxAndMin</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> num1 &gt;= num2 &#123;</span><br><span class="line"><span class="keyword">return</span> num1, num2</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num2, num1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, b := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">c, _ := getMaxAndMin(a, b)</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;假设getMaxAndMin函数是其他人所实现的函数，我们无法去修改其内容，并且其中会返回最大值和最小值两个数，而我们只希望使用最大值而忽略掉最小值，就可以用’_‘来接收最小值并将其抛弃。那么问题来了，在上述的程序中我们能否输出’_‘以查看其中的值呢，答案是不能，报错的信息就是”不能把_视为一个值”。</p><p>&emsp;&emsp;除此之外，在为标识符取名的时候，还存在一些限制，即不能以系统保留的关键字作为表示符，如break、if、import、func等等。我们将会在下表中列举出系统保留的关键字：</p><table><thead><tr><th align="center">if</th><th align="center">else</th><th align="center">switch</th><th align="center">case</th><th align="center">default</th></tr></thead><tbody><tr><td align="center">break</td><td align="center">continue</td><td align="center">package</td><td align="center">import</td><td align="center">func</td></tr><tr><td align="center">for</td><td align="center">goto</td><td align="center">select</td><td align="center">interface</td><td align="center">defer</td></tr><tr><td align="center">go</td><td align="center">map</td><td align="center">struct</td><td align="center">chan</td><td align="center">const</td></tr><tr><td align="center">fallthrough</td><td align="center">range</td><td align="center">type</td><td align="center">return</td><td align="center">var</td></tr></tbody></table><p>&emsp;&emsp;上述提到的25个系统保留的关键字是绝对不可以使用在标识符里的，这些关键字在我们当使用集成开发工具编程的时候会自动变色，以提醒开发者这些词是不可以使用的。这些关键字中暂时有好多我们都不曾见过，不过我们会在后续的小节中一一接触到。</p><p>&emsp;&emsp;除了25个系统保留的关键字以外，Go语言中还提供了36个预定的标识符，这些标识符包括了期初数据类型和系统内建函数。这个特性是其他编程语言中所没有的特性，这36个标识符如下：</p><table><thead><tr><th align="center">int</th><th align="center">int8</th><th align="center">int16</th><th align="center">int32</th><th align="center">int64</th><th align="center">uint</th></tr></thead><tbody><tr><td align="center">uint8</td><td align="center">uint16</td><td align="center">uint32</td><td align="center">uint64</td><td align="center">byte</td><td align="center">rune</td></tr><tr><td align="center">uintptr</td><td align="center">float32</td><td align="center">float64</td><td align="center">complex64</td><td align="center">complex128</td><td align="center">string</td></tr><tr><td align="center">bool</td><td align="center">complex</td><td align="center">real</td><td align="center">append</td><td align="center">cap</td><td align="center">close</td></tr><tr><td align="center">copy</td><td align="center">false</td><td align="center">true</td><td align="center">imag</td><td align="center">iota</td><td align="center">len</td></tr><tr><td align="center">make</td><td align="center">new</td><td align="center">nil</td><td align="center">panic</td><td align="center">error</td><td align="center">recover</td></tr></tbody></table><p>&emsp;&emsp;在上述的表格中，我们依旧发现有好多我们都见过，并且在变量定义的时候也曾经用过。而且与一般编程语言所不同的是，这些标识符是可以被使用的。例如在Java语言中，int不可以被定义为标识符，但在Go语言中是可以的，换句话说 var int int 这条语句是成立的。但是，对于具备其他语言开发经验的开发者，这个用法是受到绝对抵制的，即便是编译器能正常运行。例如下面的这段程序，会对初学者产生极大的困惑和误导：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">byte</span> <span class="keyword">int</span> = <span class="string">'A'</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">string</span>, <span class="keyword">float32</span> = <span class="keyword">byte</span>, <span class="keyword">byte</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span> + <span class="keyword">float32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出结果是130，看起来各种的变量类型名都出现了一遍，但是其中只有一个数据类型：整型。所以这种用法十分不被推荐，如果哪个开发者以这种形式进行开发，这个人就很，，，不走寻常路。</p><h3 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h3><p>&emsp;&emsp;在这里我们只是简要地讲解几个常用的基本的输出函数，分别为Print()函数、Println()函数、以及Printf()函数。这三个函数都在fmt包中，也就是说如果使用这三个函数，都需要引入fmt包。接下来我们分别对这三个函数进行简要的叙述：</p><ol><li>Print函数和Println函数</li></ol><p>&emsp;&emsp;这两个函数的唯一区别便是输出的时候是否换行，当用Println函数的时候，函数将一个字符串输出之后会换到下一行，而Print函数则会接着当前的输出继续执行。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"Hello "</span>)</span><br><span class="line">fmt.Println(<span class="string">"Devin"</span>)</span><br><span class="line">输出结果为：</span><br><span class="line">Hello</span><br><span class="line">Devin</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;而</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Print(<span class="string">"Hello "</span>)</span><br><span class="line">fmt.Print(<span class="string">"Devin"</span>)</span><br><span class="line">输出结果为：</span><br><span class="line">Hello Devin</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Println函数的括号中（Print函数相同），我们可以传入一些任何类型的变量，而不单单只能传入字符串。例如我们在打印多个信息的时候，我们可以将多个信息通过逗号的形式进行分割，并在输出的时候进行拼接，例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age :=<span class="number">25</span></span><br><span class="line">name := <span class="string">"Devin"</span></span><br><span class="line">fmt.Println(<span class="string">"age is "</span>, age , <span class="string">" name is "</span> , name)</span><br><span class="line">输出结果为：</span><br><span class="line">age is <span class="number">25</span> name is Devin</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也就是说在输出过程中我们将三个字符串类型和一个整数类型的变量传给Println函数，这个函数将所有的参数均转换成了字符串并且按传入的顺序输出。</p><ol start="2"><li>Printf函数</li></ol><p>&emsp;&emsp;Printf函数往往被称之为格式化输出函数，我们可以将希望输出的格式预先规定好，然后向这个格式中填入数据，而不需要像Println函数一样拼接那么多的字符串，那么多的变量。例如：我们希望输出的是age is ‘占位符’ name is ‘占位符’，然后我们再向这个模板中填入25和Devin，就可以输出为age is 25 name is Devin。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"age is %d name is %s"</span>, age , name)</span><br><span class="line">其输出结果为：</span><br><span class="line">age is <span class="number">25</span> name is Devin</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中的%d和%s均为占位符，后面的age和name与这两个占位符分别对应，需要注意的是，后面的变量个数要与占位符的个数相同，且输入的数据类型要与占位符规定的数据类型相同，接触过C语言的开发者对这个应该十分的熟悉。</p><table><thead><tr><th>格式</th><th align="center">含义</th></tr></thead><tbody><tr><td>%%</td><td align="center">输出一个%</td></tr><tr><td>%d</td><td align="center">以十进制形式输出一个整数</td></tr><tr><td>%b</td><td align="center">以二进制形式输出一个整数</td></tr><tr><td>%o</td><td align="center">以八进制形式输出一个整数</td></tr><tr><td>%x(X)</td><td align="center">以十六进制形式输出一个整数且用小写字母（大写字母）表示</td></tr><tr><td>%c</td><td align="center">以字符形式输出一个整数（字符与整数一一对应）</td></tr><tr><td>%f</td><td align="center">输出一个浮点型数据（float32和float64均可使用）</td></tr><tr><td>%t</td><td align="center">以true或者false形式输出一个布尔值</td></tr><tr><td>%T</td><td align="center">输出对应的变量的数据类型</td></tr><tr><td>%v</td><td align="center">自动识别输出类型并输出（会把byte和rune识别成为整数形式）</td></tr></tbody></table><p>&emsp;&emsp;以上的这些就是常用的在输出的过程中使用到的占位符，在Printf函数中会经常使用到。</p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>&emsp;&emsp;这个小知识点我之前在写Java的时候将其写在了字符型数据的讲解中，但是在Go语言中没有这个数据类型，但是放在字符串中又不太合适，就单独写在这里了，转义字符的个数十分地多，我在这里也不一一罗列了，在实际使用的过程中慢慢积累，而且在网络中搜索转义字符也有许多的列表。</p><p>&emsp;&emsp;之前我们说起过计算机中的英文相关的字符可以用一个byte数据类型所存储，我们接触到的也一般都是字母、数字、格式的标点符号等这些能够通过键盘所打出来的字符，然而还有许多的字符是键盘打不出来的，比如说我们希望在一个字符串中存储一个换行的字符（也就是回车），当打印这个字符串时，遇到这个换行字符时自动到下一行输出。而当我们在编程的时候，按下回车键后光标就到了下一行了，字符串中并不能保存这个换行的字符。</p><p>&emsp;&emsp;再举一个例子便是，当我们在输出的时候希望输出的内容具有一些格式，使输出更为规范、有序。其中一个方法就是使用制表符（也就是Tab键），但是当我们编程的时候按下tab键，就直接将源代码向后空出制表间隔了，字符串中依旧没有存下来。因此，我们需要转义字符。</p><p>&emsp;&emsp;转义字符也是一种字符，我们通过键盘可以打出来的字符通过转义的形式，使其代表那些键盘打不出来的字符。转义的方式为’\字符’，例如’\n’，’\t’、’\0’,也就是’\‘这个字符可以将它后面的这个字符合起来共同表示一个其他的含义，比如’\n’代表回车，’\t’代表制表符，’\0’代表字符串的结尾。它们不是两个字符而是一个字符，那么当我们真的就希望输出一个\该如何去做，如果单单输出一个\，它会和后面的字符进行转义，因此，我们想输出\的时候，我们依旧需要将其转义，使用’\\‘（直接复制markdown的话会出现四个\，因为markdown中也要转义），其意思为第一个\表示后面的要转义了，第二个\表示转义后的字符就想输出为\。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info := <span class="string">"Hello World \nI am \t\t Devin"</span></span><br><span class="line">fmt.Println(info)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其输出结果为：</p><p><img src="/2020/02/12/9-%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%8C%E8%BE%93%E5%87%BA%E5%8F%8A%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/1.png" alt></p><p>&emsp;&emsp;Hello World后有回车，am和Devin中间有两个水平制表符。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们集中讲述了Go语言的标识符的概念，以及标识符的命名规则，系统定义的关键字的内容以及保留标识符的内容。同时我们也集中介绍了两种输出的形式，在后续的代码中会经常使用到的两种输出形式。最后我们介绍了转义字符的引出和概念，也提到了几个常用的转义字符，转义字符需要在平时进行慢慢地积累。</p><p>&emsp;&emsp;在之后的几个小节中，我们将针对不同的基本数据类型进行精讲，集中说明在使用这些数据的时候需要注意到的问题，以及出现问题的内部的原因以和解决方案等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;8&gt; 变量的定义及使用</title>
      <link href="/2020/02/11/8-%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/02/11/8-%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-8-gt-变量的定义及使用"><a href="#Go语言从入门到放弃系列-lt-8-gt-变量的定义及使用" class="headerlink" title="Go语言从入门到放弃系列&lt;8&gt; 变量的定义及使用"></a>Go语言从入门到放弃系列&lt;8&gt; 变量的定义及使用</h2><p>&emsp;&emsp;在上一小节中，我们集中说明了数据在内存中的存储形式，以及Go语言的各个基本数据类型、所分配的字节数、以及其可以表示的数据范围的大小。在这一节中，我们将使用之前说到的数据类型，结合变量的概念，讲述程序中的变量以及需要注意的地方。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>&emsp;&emsp;首先我们需要解释一下什么是变量，变量来源于数学，是计算机语言中存储计算结果或能表示值得抽象概念。根据字面的理解为可以变化的量，在生活中也具备许多的常用的例子，比如说人的年龄会随着时间而变化，日期会随着月份周期性变化。在计算机中，一个变量的值也可以发生变化。可以发生变化的值为变量，不能发生变化的值为常量，如圆周率等。</p><p>&emsp;&emsp;一般来说，在计算机语言中，每个变量都存在一个名字，这个名字与这个变量在一定的空间内是一一对应的。也就是说，程序开发者可以通过该名字来访问该变量的值，也可以通过名字来修改该变量的值。我们可以将其比喻为一间屋子，且每间屋子中都只能有一个人，屋子为变量本身，屋子中的人为变量的值，屋子的门牌号为变量的名字。</p><h4 id="变量使用的基本步骤"><a href="#变量使用的基本步骤" class="headerlink" title="变量使用的基本步骤"></a>变量使用的基本步骤</h4><p>&emsp;&emsp;一般来说，变量的使用可以分为三个步骤，分别为：变量的定义、变量的赋值、变量的使用。在这里，我们将通过几个例子分别对着三个过程进行简要的阐述。</p><h5 id="1-变量的定义（变量的声明）"><a href="#1-变量的定义（变量的声明）" class="headerlink" title="1. 变量的定义（变量的声明）"></a>1. 变量的定义（变量的声明）</h5><p>&emsp;&emsp;在这个阶段中，我们需要首先做的是确定这个变量的类型。比如说，如果我们希望存储的是一个人的年龄，我们当然会选择使用整数来存储，如果我们希望存储的是一个人的成绩或工资，那么我们将会采用浮点数的形式来存储。如果我们使用了错误的数据类型，我们可能将会面临因为精度丢失而导致的计算结果错误的风险，乃至于程序编译时发生编译错误。</p><p>&emsp;&emsp;基本数据类型的变量的定义基本满足于一个公式：var 变量名 数据类型，我们举一些例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span><span class="comment">//定义一个字符串用来存姓名</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int32</span><span class="comment">//定义一个整数用来存年龄</span></span><br><span class="line"><span class="keyword">var</span> salary <span class="keyword">float32</span><span class="comment">//定义一个浮点型用来存工资</span></span><br><span class="line"><span class="keyword">var</span> character <span class="keyword">byte</span><span class="comment">//定义一个整型（字符型）用来存字符</span></span><br><span class="line"><span class="keyword">var</span> isAdult <span class="keyword">bool</span><span class="comment">//定义一个布尔值用来存是否成年</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么在数据定义过程中会内存中发生什么变化，在程序执行到定义这一行的时候，内存会分配给这个变量名一段连续的空间，空间的大小根据数据类型而定。在这段内存空间中存在一个初始的值，我们称之为零值，不同的数据类型的零值不同，我们会稍后列出。</p><h5 id="2-变量的赋值"><a href="#2-变量的赋值" class="headerlink" title="2.变量的赋值"></a>2.变量的赋值</h5><p>&emsp;&emsp;在变量定义过后，即内存中已然出现了连续的空间后，我们便可以为之填充新的数值，这个过程可称之为赋值。由于变量中本身存在于一个零值，而赋值过后新的值将会代替原来的零值，因此在变量的多次赋值时，后一次的值将会覆盖掉原来的值，而保留的是最后一次修改后的值。依旧用房间打比方，我们为这个房间分配新的住户时，原来的住户需要搬离。变量的赋值过程如下（采用上述的数据的定义）:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"Devin"</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line">slary = <span class="number">1234.5</span></span><br><span class="line">chracter = <span class="string">'A'</span></span><br><span class="line">isAdult = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里需要注意的一点是，在Go语言中，数据类型的区别是十分严格的，在一些编程语言中存在着数据类型的隐式转换与显式转换，例如，可以利用‘+’将整数转为字符串，而在Go中是不允许的。</p><h5 id="3-变量的使用"><a href="#3-变量的使用" class="headerlink" title="3.变量的使用"></a>3.变量的使用</h5><p>&emsp;&emsp;变量的使用便不需要多做描述了，如何去使用这个变量也很难穷尽，不论是进行再赋值操作还是参与数学运算都是可以的。我们便举一个完整的例子表明变量的使用的全部过程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span><span class="comment">//变量的定义</span></span><br><span class="line">age = <span class="number">25</span><span class="comment">//变量的赋值</span></span><br><span class="line">fmt.Println(age)<span class="comment">//变量的使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-变量的初始化"><a href="#4-变量的初始化" class="headerlink" title="4.变量的初始化"></a>4.变量的初始化</h5><p>&emsp;&emsp;在上述的过程中，我们会发现变量的使用都要通过定义、赋值后才能进行使用，我们可能会觉得这个操作十分的麻烦，因此变量的初始化可以将变量的定义与赋值过程结合在一起，这样就会十分简便了。初始化的定义也是在变量定义时直接给与赋值操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"Devin"</span></span><br><span class="line"><span class="keyword">var</span> isAdult <span class="keyword">bool</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="变量使用中的注意事项及细节"><a href="#变量使用中的注意事项及细节" class="headerlink" title="变量使用中的注意事项及细节"></a>变量使用中的注意事项及细节</h3><h4 id="1-类型自动推导"><a href="#1-类型自动推导" class="headerlink" title="1.类型自动推导"></a>1.类型自动推导</h4><p>&emsp;&emsp;在上述的讲解中，我们提到了：数据定义过程中需要明确这个变量的数据类型，之后再进行其他的操作，但是在变量的初始化过程中其实已经出现了数据类型。因此，Go语言底层有一种机制，即根据用户所输入的值自动推导这个值得数据类型，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Devin"</span></span><br><span class="line"><span class="keyword">var</span> isAdult = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> salary = <span class="number">1000.0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;即相比于初始化过程，略去了数据类型定义的部分。在上述的例子中，Go语言底层会将age的类型自动识别为整数（int类型），name识别为字符串（string类型），isAdult识别为布尔值（bool类型），salary识别为浮点型（float64类型）。在这里需要注意的是浮点型的自动类型推导，我们需要在后面加入小数点，否则将会被推导成为整数。</p><p>&emsp;&emsp;在自动推导的定义过程中，我们会发现，几乎每个定义都有一个var的关键字，因此这个关键字也是可以省略的，不过如果仅仅是这样就会与变量的赋值相混淆了，因此在省略var关键字且初始化数据时，需要采用<strong>:=</strong>的方式进行定义，上述的程序可以改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age := <span class="number">25</span></span><br><span class="line">name := <span class="string">"Devin"</span></span><br><span class="line">isAdult := <span class="literal">true</span></span><br><span class="line">salary := <span class="number">1000.0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用变量的定义时，有一个需要注意的地方，即定义的变量名在相同的作用域中是不应该被定义过的，否则将会出现重定义，导致编译过程的错误（作用域的概念在后期会介绍到）。这一点在使用自动类型推导时容易出现错误。</p><h4 id="2-多变量的声明"><a href="#2-多变量的声明" class="headerlink" title="2.多变量的声明"></a>2.多变量的声明</h4><p>&emsp;&emsp;当我们需要定义多个同类型的数据时，比如说我们需要存储一个人的学号、姓名、住址等几个字符串信息时，我们当然可以分为多行进行定义，每一行定义一个数据，我们也可以在一行中将同样数据类型的变量同时定义，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, id, address <span class="keyword">string</span><span class="comment">//一行中定义三个字符串变量</span></span><br><span class="line">name = <span class="string">"Devin"</span><span class="comment">//分别使用</span></span><br><span class="line">id = <span class="string">"123456"</span></span><br><span class="line">address = <span class="string">"Liaoning Province"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们也可以采用初始化的形式，在一行中定义后直接使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, id, address <span class="keyword">string</span> = <span class="string">"Devin"</span>, <span class="string">"123456"</span>, <span class="string">"Liaoning Province"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;甚至直接类型推导:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, id, address = <span class="string">"Devin"</span>, <span class="string">"123456"</span>, <span class="string">"Liaoning Province"</span></span><br><span class="line">name, id, address := <span class="string">"Devin"</span>, <span class="string">"123456"</span>, <span class="string">"Liaoning Province"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;多个不同的数据类型的定义中，我们也可以采用小括号的形式进行定义以及初始化，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">age <span class="keyword">int</span> = <span class="number">25</span></span><br><span class="line">name <span class="keyword">string</span> = <span class="string">"Devin"</span></span><br><span class="line">isAdult = <span class="literal">true</span></span><br><span class="line">) </span><br><span class="line">或者</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">age = <span class="number">25</span></span><br><span class="line">name = <span class="string">"Devin"</span></span><br><span class="line">isAdult = <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要说明的一点是，在数据类型的自动推导过程中，可以不限制于同样的数据类型，不同的数据类型也是可以在同一行定义推导的，不过这种用法相对来说比较奇怪，习惯于传统语言开发的开发者可能会觉得相对不习惯：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name, age, isAdult := <span class="string">"Devin"</span>, <span class="number">25</span>, <span class="literal">true</span>   <span class="comment">//自动推导name为string，age为int，isAdult为bool</span></span><br></pre></td></tr></table></figure><h4 id="3-基本数据类型的零值"><a href="#3-基本数据类型的零值" class="headerlink" title="3.基本数据类型的零值"></a>3.基本数据类型的零值</h4><p>&emsp;&emsp;在这里我们将介绍Go语言中基本数据类型的零值。在一些编程语言中，为数据定义但不进行赋值是一种危险的行为，其值可以是一个没有意义的值。为了防止这种现象的发生，Go语言中明确定义了各种基本数据类型的零值。在一些开发过程中，有些人可能会利用零值的数值进行部分代码的省略，比如定义一个整数并为这个整数赋值为0。然而整数的零值就是0，所以一些开发者便只定义而不赋值，但是这种做法不是很推荐。</p><p>&emsp;&emsp;为了表明各个基本数据类型的零值，我们便采用下方的程序进行简单的验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">complex64</span></span><br><span class="line">fmt.Println(<span class="string">"a="</span>, a, <span class="string">" b="</span>, b, <span class="string">" c= "</span>, c, <span class="string">" d= "</span>, d, <span class="string">" e = "</span>, e, <span class="string">" f= "</span>, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其结果分别为：</p><p><img src="/2020/02/11/8-%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E4%BD%BF%E7%94%A8/1.png" alt></p><p>&emsp;&emsp;从中可知，整数的零值为0，浮点型的零值也为0，字符串的零值为空串（即””），字符型（整型）为0， 布尔值的零值为false，复数的零值为（0+0i）。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这一小节中，我们集中介绍了变量的定义以及使用的过程，即定义、赋值、使用。同时我们也介绍了变量的初始化、自动推导类型等简便的使用方式。除此之外，我们也讲述了变量定义中的一些细节，如多变量的声明，以及各个基本数据类型的零值。在接下的几节中，我们将针对不同的数据类型进行更为详细的讲解，以及各个基本数据类型的互相转换等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;7&gt; 数据与数据的存储&lt;二&gt;</title>
      <link href="/2020/02/10/7-%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BA%8C/"/>
      <url>/2020/02/10/7-%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-7-gt-数据与数据的存储-lt-二-gt"><a href="#Go语言从入门到放弃系列-lt-7-gt-数据与数据的存储-lt-二-gt" class="headerlink" title="Go语言从入门到放弃系列&lt;7&gt; 数据与数据的存储&lt;二&gt;"></a>Go语言从入门到放弃系列&lt;7&gt; 数据与数据的存储&lt;二&gt;</h2><p>&emsp;&emsp;在上一节集中介绍了二进制的原码，反码和补码之后，我们在这一章简要地介绍一下Go语言中的基本数据类型，简单地列举一下几个基本数据类型所能存储的数字范围，并对数据范围的大小作出讲解。</p><h3 id="Go语言中的基本数据类型"><a href="#Go语言中的基本数据类型" class="headerlink" title="Go语言中的基本数据类型"></a>Go语言中的基本数据类型</h3><h4 id="（计算机内存进制）"><a href="#（计算机内存进制）" class="headerlink" title="（计算机内存进制）"></a>（计算机内存进制）</h4><p>&emsp;&emsp;在介绍数据类型之前，我们首先介绍计算机中的几个表示内存的单位，分别为：bit、byte、kb、mb、gb等等。在bit和byte转换规则中存在一个等式：1byte=8bit，换句话说1个字节的长度等于8个二进制位的长度。而在bit和kb之间、kb和mb之间的进率这个现在很难讲。从我接触到计算机开始，我所学到的进制表示法始终是1kb=1024bit，也就是进制为1024，不过近来我在网上查资料的时候，发现了一种进制表示是1kb=1000bit，而且这两种表示方法均存在，在不同的计算机系统中（如Windows和Mac）也是不同的。此时此刻我依旧为这个问题而感到费解，因此这个进制我不做说明，希望读者自行去查找。 </p><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>&emsp;&emsp;正如我们所理解的一般，整型所代表的就是计算机存储的整数，是不具备小数位的数字。根据不同的定义，整数可以分为有符号整型以及无符号整型。根据上个小节对码制的介绍，有符号整数的最高位代表符号位，并且负数的表示方式为补码方式。而对于无符号整数来说，其最高位表示的是数字中的一部分，不代表符号，是计入数字的计数的，同时因为其无符号的特性，该值永远是正值。下表将列出Go语言中整数的定义方式，以及其分配的bit空间和可表示的范围：</p><table><thead><tr><th>类型名称</th><th align="left">是否有符号</th><th align="left">分配的bit数</th><th align="center">可表示范围</th></tr></thead><tbody><tr><td>int8</td><td align="left">有</td><td align="left">8</td><td align="center">-128到127</td></tr><tr><td>int16</td><td align="left">有</td><td align="left">16</td><td align="center">-32768到32767</td></tr><tr><td>int32</td><td align="left">有</td><td align="left">32</td><td align="center">-2^31到2^31-1</td></tr><tr><td>int64</td><td align="left">有</td><td align="left">64</td><td align="center">-2^63到2^63-1</td></tr><tr><td>uint8</td><td align="left">无</td><td align="left">8</td><td align="center">0到255</td></tr><tr><td>uint16</td><td align="left">无</td><td align="left">16</td><td align="center">0到65535</td></tr><tr><td>uint32</td><td align="left">无</td><td align="left">32</td><td align="center">0到2^32-1</td></tr><tr><td>uint64</td><td align="left">无</td><td align="left">64</td><td align="center">0到2^64-1</td></tr><tr><td>int</td><td align="left">有</td><td align="left">与CPU位数相关</td><td align="center">与CPU位数相关</td></tr><tr><td>uint</td><td align="left">无</td><td align="left">与CPU位数相关</td><td align="center">与CPU位数相关</td></tr><tr><td>rune</td><td align="left">有</td><td align="left">与int32等价</td><td align="center">暂不做介绍</td></tr><tr><td>byte</td><td align="left">无</td><td align="left">与uint8等价</td><td align="center">暂不做介绍</td></tr><tr><td>uintptr</td><td align="left">无</td><td align="left">-</td><td align="center">-</td></tr></tbody></table><p>&emsp;&emsp;其中需要说明的是，int和uint整形变量分配的位数，这个是与CPU位数相关，如果计算机的CPU位数是32位，则为之分配32个bit位，即4个字节的空间。如果计算机CPU位数是64位，则为之分配64个bit位，即8个字节的空间。至于rune以及byte我们会在字符部分为之说明。</p><p>&emsp;&emsp;uintptr是一种无符号的整数，没有指定具体大小，但是足以容纳指针，一般来说是内存地址的哈希值，关于指针我们会在后续介绍到。uintptr类型一般用在底层编程中，在我们入门级别的学习中往往并不常见，在GO语言与C语言函数库的对接以及与操作系统底层硬件交互时才会经常用到。</p><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>&emsp;&emsp;浮点数在计算机中可以被理解为小数，Go语言提供了两种不同精度的小数，分别为float32以及float64，它们的定义符合IEEE754规范的定义，与整数的表示方式不同。这个规范是被现有的所有的各式CPU所支持。根据定义可以看出，float32的浮点数被分配的空间是32个二进制位，float64则分配64个二进制位。</p><p>&emsp;&emsp;那么我们可能会思考，一个整数，即便是64个二进制位，也不过是1.8*10^19（大约）这么大的数字。对于一个小数而言，既有整数部分，也有小数部分，其表示的数字范围岂不是小的可怜。为了防止出现这个结果，浮点数的存储方式与整数的存储方式是截然不同的。</p><p>&emsp;&emsp;一个浮点数可以被分为三个部分，我们以32位浮点数为例，其第一部分为最高位，也就是符号位，同整数相同，0代表正数，1代表负数。第二部分为指数位，被分配8个二进制位并通过移码后专门表示指数。最后剩下23位是第三部分，为尾数部分，这部分将代表这个小数以科学计数法表示后的整数部分。对于float64而言，则是1位的符号位，11位的指数部分，和52位的尾数部分。</p><p>&emsp;&emsp;我们举一个例子，十进制的135.5这个数字用二进制来表示为:1000 0111.1，我们采用二进制的科学计数法为：1.00001111*2^7，首先我们知道，这个数字为正数，因此符号位为0。然后指数部分采用移码的形式，即32位小数用127移，64位小数用1023移，所以7+127=134，将134化成二进制为：10000110，最后是尾数部分，由于科学计数法表示后，整数位一定是1，因此这个位可以被忽略掉，只表示00001111即可，在后面补充0，直到23位，所以结果如下：</p><table><thead><tr><th>符号位</th><th align="left">指数部分</th><th align="center">尾数部分</th></tr></thead><tbody><tr><td>0</td><td align="left">10000110</td><td align="center">00001111000000000000000</td></tr></tbody></table><p>&emsp;&emsp;因此，这个数字在内存中表示为：01000011000001111000000000000000(图片来自于binaryconvert)</p><p><img src="/2020/02/10/7-%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BA%8C/1.png" alt></p><p>&emsp;&emsp;通过这种存储方式，浮点数可以表示的范围就会极大了，粗略来说，float32表示范围可为：-3.4*10^38到3.4*10^38，对于float64而言，其范围可以是：-1.79*10^308到1.79*10^308。</p><h4 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h4><p>&emsp;&emsp;Go语言支持对复数的定义，同样也具备两种精度的复数类型，分别为complex64和complex128，正如我们所了解的，复数一般是由实部和虚部构成，因此这两种复数类型的实部和虚部分别相对应float32和float64。一般来说，复数的使用在应用开发中很少会出现，在数学计算中可能会得到应用。在此不做详细的说明了。</p><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><p>&emsp;&emsp;布尔值一般代表逻辑值，一般来说只有真或假，所对应的值为true或false。在程序中分支控制和循环控制中往往会用到布尔值。布尔值可以通过“与或非”三种逻辑进行运算，但是并不参与数学运算。在有些开发语言中，true可以表示为1，而false可以表示为0，这两种值可以被替换为整数进行数学运算。而在Go语言开发中，这个是不成立的，因此不能参与数学运算。布尔值的具体用法我们将会在分支结构中更为详细地讲述。</p><h4 id="（字符型）"><a href="#（字符型）" class="headerlink" title="（字符型）"></a>（字符型）</h4><p>&emsp;&emsp;这个字符型为什么会打了一个括号，是因为这个数据类型在Go语言中不存在，不过在其他语言中是存在的，对于后面字符串的引出也是即为重要的，因此单独做出介绍。在前面我们介绍编码的时候就提及过，最初的计算机只能应用在英语的环境中，而大小写英文字母的数量加一些转义字符的数量也不超过256个。因此最初字符是可以通过一个8位的整数来表示，这便是我们在介绍整数的时候byte的用法。</p><p>&emsp;&emsp;在后面计算机到了各国之后，不同国家开始应用各个国家的字符集，例如中国汉字，其个数就远超了256个，因此一个byte的空间就没有办法进行存储汉字了，而UTF-8编码格式又融入了所有国家的所有的字符编码，于是就需要寻找容量更大的存储方式，在Go语言中我们采用int32的数据类型来存储汉字，为了区分字符与整数的表示方式，我们采用rune的方式表示。</p><p>&emsp;&emsp;虽说字符一般采用byte和rune的方式进行定义与表示，其核心本质依旧是uint8和int32，所以说Go语言中不存在字符型的变量，传统的字符型都用整数来表示了。</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>&emsp;&emsp;在其他的编程语言中，往往会把字符串作为复杂数据类型来划分，但是字符串同时在编程中应用地十分地普遍，因此Go语言便也把它划分在基础数据类型中。字符串是一个不可改变的字节序列，可以理解为多个字符拼接而成的常量，用双引号所包含（如入门程序中的”Hello World”）。字符串可以包含任何的数据，文本字符串通常会表示为UTF-8编码的rune序列。在这里只是提一句字符串的概念，在后续学习中，我们会针对于字符串及其自带的函数做出详细地讲解。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这两个小节中，我们集中介绍了数据的存储形式，介绍了原码，反码和补码。并通过对这三种码制引出了Go语言的基本数据类型，这几种类型将会在下几小节中详细地叙述。在下一节中，我们将会主要介绍变量与常量的概念，命名规则以及针对基本数据类型定义过程的一些例子。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;6&gt; 数据与数据的存储&lt;一&gt;</title>
      <link href="/2020/02/09/6-%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%80/"/>
      <url>/2020/02/09/6-%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-6-gt-数据与数据的存储-lt-一-gt"><a href="#Go语言从入门到放弃系列-lt-6-gt-数据与数据的存储-lt-一-gt" class="headerlink" title="Go语言从入门到放弃系列&lt;6&gt; 数据与数据的存储&lt;一&gt;"></a>Go语言从入门到放弃系列&lt;6&gt; 数据与数据的存储&lt;一&gt;</h2><p>&emsp;&emsp;在上一个小节中，我们集中说明了一些二进制相关的事，介绍了不同进制之间的转换规律以及该规律的原理，并对二进制有了最基本的认识。那么在这个小节中，我们将基于二进制的知识，引出基本数据类型的存储格式，介绍到原码，反码和补码的知识，进而对Go语言的数据类型进行简要的引出。</p><h3 id="原码，反码，和补码"><a href="#原码，反码，和补码" class="headerlink" title="原码，反码，和补码"></a>原码，反码，和补码</h3><p>&emsp;&emsp;我们回顾一下自己对数字的认识过程，相信大多数人都经历了如下的过程。在很小的时候只知道正数，然后到了初中开始接触负数，之后再考虑到0这个特殊的数字。那么我们就暂时遵循这个过程，对这几种码制作出阐述。可以说，大家对于正数的了解是普遍的，日常生活中也经常会出现与正数打交道的情况。那么对于正数，计算机是如何存储的呢。</p><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>&emsp;&emsp;读过上一个小节的人们可能会直接想到，无非就是把十进制的正数转换成二进制的数而已，这个想法是正确的，只不过是在现有的想法上加上一个符号位，而这个符号位则是最高位，同时我们将符号位的0作为正数的标志，符号位的1就作为负数的标志，因此，对于106这个十进制正数而言，其带符号位的二进制数是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01101010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最高位的0代表了正数。相信大家很容易接受这种表示方式，毕竟改变不是很大。当我们对正数做完阐述之后，我们可能会想到，既然如此，我们将符号位置1，其余的不变，就可以表示对应的负数了。确实这是一种表示方法，也就是我们今天所提及的原码方式。对于-106而言，其二进制数为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11101010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是现在问题就来了，这种方式虽然存储起来很方便，但是对计算而言是极为的不利的。例如，我们每个人都知道的一个等式&nbsp;-1+1=0&nbsp;在计算机用原码表示来计算就会出现错误，我们列举一下计算过程，假设我们依旧用8位来表示每一个数字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000001</span>+<span class="number">10000001</span>=<span class="number">10000010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们会发现结果是-2，而不是0。不仅如此，任何一个正数与一个负数相加，其结果都是负数，因为符号位的0+1=1。很显然，这种数制的表示方法并不能完成计算的任务，因此我们引进了反码。</p><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>&emsp;&emsp;正数的反码与原码是相同的，负数的反码则是符号位不变，其余的位数取反。比如说，对于-106而言，其反码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10010101</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么反码的好处在哪里呢，我们依旧回到-1+1=0的问题上，根据我们上述所说，-1的反码为：11111110，+1的反码为：00000001，那么两个数字相加，我们会得到11111111，对此结果我们再取反码，得到了10000000，换算成十进制为-0，其计算结果是可以接受的，但是现在我们依旧存在一个问题，即+0与-0的问题。</p><p>&emsp;&emsp;不仅如此，即便是在一次计算中真值部分得到了正确的结果，但涉及到中途结果为-0的时候，就又一次出现了问题，我们举一个简单的例子，我们都知道，-1+1+1=1，那么我们采用反码的形式再一次做出计算：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11111110</span>+<span class="number">00000001</span>+<span class="number">00000001</span>=<span class="number">100000000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在计算之前，我们首先假定了由8位构成一个数字，那么计算结果应该也是由8位构成，但是我们的到的结果是9位，因此计算机选择的是忽略掉溢出的位置，因此结果为00000000，也就是我们所说的10进制的0。这个结果显然是不能接受的，而导致这个不可接受的结果的原因则是这个-0的参与运算。因此，单纯地采用补码来运算依旧不是一个很好的方法，接下来，我我们将对补码进行简要地介绍。</p><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>&emsp;&emsp;首先，我们需要对补码有一个相对直观的认识，举一个很常见的例子，就是我们平日生活中的钟表。我们假设时针指向12的时候为0点，时针顺时针为正，逆时针为负，并且以时针指向6为分界，即小于6的时候为正值，大于6点为负值。同时我们采用上一章节所提及的“模”的概念，即在时钟的周期中模为12。</p><p>&emsp;&emsp;现在我们转换一下思想，在上述情况下所说的-1点，就是平时我们称的11点，同时上述情况下所称的1点依旧是平时我们所想的1点，这便是补码的一种直观的思想。即负数可以表示为：<strong>周期的模减去该负数的绝对值</strong>，比如说：-1点即11点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>-abs(<span class="number">-1</span>)=<span class="number">11</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么现在我们回过头来看一下-3用补码是怎样表示的，首先我们依旧假设用8位来表示一个数字，那么8个二进制位所能表示的数字的模是多少。十进制的模是十，是个位为0同时其高位为1，那么8个二进制位的模当然就是八个位都是0，而其高位（借来的第九位）为1：100000000。同时，-3的绝对值是3，其二进制表示方法为：00000011。现在我们将其相减，得到的-3的补码是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11111101</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在我们对-3的补码和-3的原码进行对比，并从中寻找一个转换的规律。我们说，-3的原码为：10000011，-3的补码为：11111101，我们可以发现，补码的转换规则为：<strong>正数的补码是原码本身，负数的补码是，符号位不变，从右向左找到第一个1不变，这个1向左的各位取反。</strong></p><p>&emsp;&emsp;再一次回到-1+1+1的问题上，我们知道-1的表示方法为：模-1，那么-1+1便是：模-1+1=模。根据上述的说明，模的表示方法为：各个位数为0，高位为1，而高位在计算中会溢出而不做计算，因此结果为0，这个+0再加上任何的数字就是正常的数字了。现在我们已然解决了正0的问题，那么原来的-0究竟表示了什么呢。</p><p>&emsp;&emsp;通过上述的描述，我们知道了负数的表示方法，那么我们可以这样来想，模减去某个负数的绝对值等于了“-0”，因此这个“某个负数”的绝对值便是模的大小，取负数之后便是其可以表示的数。因此，原来的-0即表示了-模长。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在本节中，我们集中介绍了计算机存储数据的方法，即原码、反码、和补码的概念，并分别阐述了这三种表示方式的来由。在下一小节中，我们将介绍数据类型的概念，计算机内存中如何表示整数、小数、字符等等，并对其可表示范围作出讲解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;5&gt; 二进制浅谈</title>
      <link href="/2020/02/08/5-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%85%E8%B0%88/"/>
      <url>/2020/02/08/5-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%85%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-5-gt-二进制浅谈"><a href="#Go语言从入门到放弃系列-lt-5-gt-二进制浅谈" class="headerlink" title="Go语言从入门到放弃系列&lt;5&gt; 二进制浅谈"></a>Go语言从入门到放弃系列&lt;5&gt; 二进制浅谈</h2><p>&emsp;&emsp;在上一个小节中，我们集中阐述了Go语言的一些命令，并对其中的几个常用命令进行讲解，在这一小节中，我们将对进制的概念进行阐述，并且对进制之间的相互转换进行详细地说明。</p><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>&emsp;&emsp;说起进制，大家似乎都不陌生，因为我们每天都在以十进制的形式计数，那么什么是十进制呢，便是逢十进一。换句话说，在十进制数中每一个位都可以存放十种不同的数字，分别为0到9，当当前的数字为9的时候，再向上加1，就需要向更高的位进1，而自身的数字归零。在这里，我们也可以称这种计数单位的模为10。</p><p>&emsp;&emsp;如果我们沿用上述的方式，换一种思路，将逢十进一的概念转变为逢二进一，似乎二进制的概念就会比较好理解了。在十进制中，每个位都可以有10种数字，在二进制中，每个位只有两种形式，分别为0和1。在当前位为1的时候再加1，便向更高位进1，自身的数字归零。这便是二进制的计数方式。</p><p>&emsp;&emsp;为什么计算机会采取二进制的形式用来表示数据，是因为二进制是世界上比较常见的一种进制方式，尽管我们我日常生活中并不常用。开关的闭合或开启、逻辑的真与假、电容器是否具有电势等，都是两种状态之间的互相转换。在数字电路中，高电平与低电平也代表两种不同的逻辑态。对于完全由电路构成的计算机而言，主要处理的便是逻辑运算，因此二进制当然也就再合适不过了。</p><h3 id="二进制向十进制的转换"><a href="#二进制向十进制的转换" class="headerlink" title="二进制向十进制的转换"></a>二进制向十进制的转换</h3><p>&emsp;&emsp;虽说计算机非常喜欢二进制的计数方式，但是似乎人们并不喜欢，因为从小到大所接触到的都是十进制的世界，为了更好地理解数字的本质，我们需要了解不同进制之间的转换规则。同样地，我们先从十进制出发，例如我首先写下一个数字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不出意外的话，每个人都能迅速地说出来这个数字是十二万三千四百五十六，那么为什么这个一串的字符就可以表示出这个数字呢，是因为这个结果是可以通过某种计算方式而得到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X=<span class="number">1</span>*<span class="number">10</span>^<span class="number">5</span>+<span class="number">2</span>*<span class="number">10</span>^<span class="number">4</span>+<span class="number">3</span>*<span class="number">10</span>^<span class="number">3</span>+<span class="number">4</span>*<span class="number">10</span>^<span class="number">2</span>+<span class="number">5</span>*<span class="number">10</span>^<span class="number">1</span>+<span class="number">6</span>*<span class="number">10</span>^<span class="number">0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果理解了上述的这个公式，那么对于二进制而言，我们仿照这个计算模式，将其迅速地转换为十进制的表达方式，例如如下的这个二进制数字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11001010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X=<span class="number">1</span>*<span class="number">2</span>^<span class="number">7</span>+<span class="number">1</span>*<span class="number">2</span>^<span class="number">6</span>+<span class="number">0</span>*<span class="number">2</span>^<span class="number">5</span>+<span class="number">0</span>*<span class="number">2</span>^<span class="number">4</span>+<span class="number">1</span>*<span class="number">2</span>^<span class="number">3</span>+<span class="number">0</span>*<span class="number">2</span>^<span class="number">2</span>+<span class="number">1</span>*<span class="number">2</span>^<span class="number">1</span>+<span class="number">0</span>*<span class="number">2</span>^<span class="number">0</span>=<span class="number">202</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果继续向下总结的话，我们可以得到一条规律，从任何进制向十进制的转换规律为：第i位的数字乘以模的i次幂的求和（i从0开始）。根据这个规则，我们就可以自行理解八进制和十六进制，乃至于其他进制向十进制转换的规则了。</p><h3 id="十进制向二进制的转换"><a href="#十进制向二进制的转换" class="headerlink" title="十进制向二进制的转换"></a>十进制向二进制的转换</h3><p>&emsp;&emsp;在这个部分中，我们换一种方法来表示二进制向十进制转换过程，所举的例子依旧是上方提到的两个数字，我们可以分别表示为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123456</span>=(((((<span class="number">1</span>*<span class="number">10</span>)+<span class="number">2</span>)*<span class="number">10</span>+<span class="number">3</span>)*<span class="number">10</span>+<span class="number">4</span>)*<span class="number">10</span>+<span class="number">5</span>)*<span class="number">10</span>+<span class="number">6</span></span><br><span class="line"><span class="number">202</span>=(((((((<span class="number">1</span>*<span class="number">2</span>)+<span class="number">1</span>)*<span class="number">2</span>+<span class="number">0</span>)*<span class="number">2</span>+<span class="number">0</span>)*<span class="number">2</span>+<span class="number">1</span>)*<span class="number">2</span>+<span class="number">0</span>)*<span class="number">2</span>+<span class="number">1</span>)*<span class="number">2</span>+<span class="number">0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们会发现这种表达方式和上述的表达方式的结果是一致的，那么我们为什么采用这种表述方式，是因为在这种表达方式中，我们可以很直观地理解如何从十进制转回到二进制中。如果我们将转回的过程看做上述过程的一个逆过程，答案就会很简单了。我们用两个未知数来表示上述表达式中的两个部分，我们会发现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">202</span>=X*<span class="number">2</span>+Y  （X，Y为整数）</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;虽说这个二元一次方程具备很多的解，但是联合二进制的规定，我们会加一个条件，即Y&lt;2。这样，我们就会轻而易举地得出X为101，Y为0，也就是说，我们得到了二进制的最后一位。接下来，我们针对101进行分析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">101</span>=X*<span class="number">2</span>+Y</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个方程中，我们可以得到X为50，Y为1，这样我们就得到了倒数第二位的数值，如果一直重复上述过程，我们将会得到二进制的最终结果。换句话说，十进制整数向二进制的转换规则为：该数字除以模数向下取整，取余数，最后将余数倒序输出，即为二进制数。这个规则同样也适用于十进制向任何一个进制转换的过程。</p><h3 id="浮点数的进制转换"><a href="#浮点数的进制转换" class="headerlink" title="浮点数的进制转换"></a>浮点数的进制转换</h3><p>&emsp;&emsp;说完整数的数制转换后，我们对浮点数（小数）的进制转换做出简要的说明。在说明之前，我们首先思考一个问题，根据上述的二进制转十进制的规则来看，对于一个<strong>有限位数的整数</strong>而言，是否每一个二进制数都有一个有限位数的十进制数相对应，是否每个十进制数都有一个有限位数的二进制数相对应。两个答案都是肯定的。那么对于小数而言，上述两句话还是否依旧成立？</p><p>&emsp;&emsp;我们以以下的这个二进制数为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1011</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个二进制数转换成十进制数是多少呢，根据刚刚所讲的计算规律，我们将之拓展，就会发现它可以通过这种方式来表示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X=<span class="number">1</span>*<span class="number">2</span>^(<span class="number">-1</span>)+<span class="number">0</span>*<span class="number">2</span>^(<span class="number">-2</span>)+<span class="number">1</span>*<span class="number">2</span>^(<span class="number">-3</span>)+<span class="number">1</span>*<span class="number">2</span>^(<span class="number">-4</span>)=<span class="number">0.6875</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种二进制小数向十进制小数的转换方式是非常容易的，可以说依旧遵循着第i位的值乘以模的i次幂的求和。那么对于小数而言，如何将这个小数转回到二进制的表示方式。现在我们首先假设二进制的每一位为Xi，那么对于上述的小数我们可以表示为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.6875</span>=(X0)*<span class="number">2</span>^(<span class="number">-1</span>)+(X1)*<span class="number">2</span>^(<span class="number">-2</span>)+(X2)*<span class="number">2</span>^(<span class="number">-3</span>)+(X3)*<span class="number">2</span>^(<span class="number">-4</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来，我们在等式两边同时乘以2，我们即可以得到如下的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.375</span>=(X0)+(X1)*<span class="number">2</span>^(<span class="number">-1</span>)+(X2)*<span class="number">2</span>^(<span class="number">-2</span>)+(X3)*<span class="number">2</span>^(<span class="number">-3</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么对于上述这个等式进行分析，以及二进制的限制我们还可以知道X0、X1、X2、X3均小于2，并且只有X0可以代表整数位，我们便可以得到X0的值为1。接下来等式两边再同时减去X0的值，我们可以得到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.375</span>=(X1)*<span class="number">2</span>^(<span class="number">-1</span>)+(X2)*<span class="number">2</span>^(<span class="number">-2</span>)+(X3)*<span class="number">2</span>^(<span class="number">-3</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;重复上述的过程，我们可以得到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.75</span>=(X1)+(X2)*<span class="number">2</span>^(<span class="number">-1</span>)+(X3)*<span class="number">2</span>^(<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因此，只有X1的值可以表示整数位的值，即X1的值为0，以此类推，我们最终是可以得到1011的值的。通过这个过程，我们可以得到这样的一个小数的转换规则：该小数乘以模，取整数位的值，顺序输出。</p><p>&emsp;&emsp;我们回到刚刚提出的那个问题，是否每一个有限位数的二进制小数都有一个有限位数的十进制小数向对应，这个结果是是的，根据本节提到的公式也可以得到这个结果。那么是否每一个有限位数的十进制小数都有一个有限位数的二进制小数相对应，这个结果是否定的，比如十进制中的0.1就无法用有限位数的二进制进行表示，它是一个无限的循环小数。计算机只能无限地去接近这个数，却永远也无法精确地达到这个小数的真值。其具体原因，我目前尚不能明确地说清楚，也希望大家可以考虑一下，相信在考虑的过程中会有一定的收获。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;经过上述的一些讨论过后，我们集中说明了十进制与二进制的互相转化规律，将此推广，其他进制之间的转换规律也如出一辙，简而化之的记忆口诀就为<strong>除模取余，逆序排序，乘模取整，顺序输出</strong>。我们最后再用一张图片演示进制的过程。（图片转自网络）</p><p><img src="/2020/02/08/5-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%85%E8%B0%88/1.jpg" alt></p><p>&emsp;&emsp;在下一个小节中，我们将介绍二进制表示数字的几种形式，原码，反码以及补码，通过对这三种码制的介绍，我们引出基本数据类型的概念，以及变量和常量的问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;4&gt; 常用的Go命令</title>
      <link href="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-4-gt-常用的Go命令"><a href="#Go语言从入门到放弃系列-lt-4-gt-常用的Go命令" class="headerlink" title="Go语言从入门到放弃系列&lt;4&gt; 常用的Go命令"></a>Go语言从入门到放弃系列&lt;4&gt; 常用的Go命令</h2><p>&emsp;&emsp;在上一节中，我们集中对快速入门程序Hello World的编写做出了简要的讲解，同时对包的概念，引入的方式，主函数的执行流程做出基本的介绍。在这一节中，我们将对Go语言的中命令行的常用命令进行介绍。</p><p>&emsp;&emsp;相信许多初学者通过集成开发工具进行入门开发时，将两个go文件写在了同一个文件夹下，同时又都具备main函数，在用ide运行的时候报出了错误，我们从这个错误引入到今天的命令的介绍中。</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/1.png" alt><br><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/2.png" alt></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>&emsp;&emsp;在上一节中，我们提出了包的概念，并且说明了一个项目中只能存在一个main函数，而一般来说，ide的编译运行是以工程为基础。换句话讲，便是以文件夹为基础的编译。因此当开发工具检测到同一个文件夹中含有两个或多个main函数时，会报出主函数重定义的错误。</p><p>&emsp;&emsp;1. 第一个解决办法当然便是将不同的go文件分放在不同的文件夹下，这样使得每个文件夹即每个工程都可以单独地进行编译以及运行，不过对于初学者来说这种做法尚不甚方便，到目前为止乃至于之后一段时间内所写的Demo性质的程序往往都是以单个文件为基础的，因此这个方法对于目前来说不是很适用。</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/3.png" alt></p><p>&emsp;&emsp;2. 第二个解决办法便是通过Go语言的命令行形式进行编译运行，就如同在前几节所提及的那样，通过控制台的cd命令进入到go文件所在的目录，然后运用go run命令进行运行，这种方式是以单个文件的方式进行编译的，因此不会报出重定义的错误。go语言的命令相对来说并不多，常用的也就更少了，我们会在下面着重讲述几个命令。</p><h3 id="常用的Go命令"><a href="#常用的Go命令" class="headerlink" title="常用的Go命令"></a>常用的Go命令</h3><p>&emsp;&emsp;如果在控制台直接输入go help命令，我们会发现系统提示了许多的可用命令，在这里便列一个表格，分别简单解释一下每个命令的含义。在后面我们也会针对其中的几个进行详细地讲解。</p><table><thead><tr><th>Go命令</th><th align="center">含义</th></tr></thead><tbody><tr><td>build</td><td align="center">编译包和依赖</td></tr><tr><td>clean</td><td align="center">移除对象文件</td></tr><tr><td>doc</td><td align="center">显示包或者符号的文档</td></tr><tr><td>env</td><td align="center">打印go的环境信息</td></tr><tr><td>bug</td><td align="center">启动错误报告</td></tr><tr><td>fix</td><td align="center">运行go tool fix</td></tr><tr><td>fmt</td><td align="center">运行gofmt进行格式化</td></tr><tr><td>generate</td><td align="center">从processing source生成go文件</td></tr><tr><td>get</td><td align="center">下载并安装包和依赖</td></tr><tr><td>install</td><td align="center">编译并安装包和依赖</td></tr><tr><td>list</td><td align="center">列出包</td></tr><tr><td>run</td><td align="center">编译并运行go程序</td></tr><tr><td>test</td><td align="center">运行测试</td></tr><tr><td>tool</td><td align="center">运行go提供的工具</td></tr><tr><td>version</td><td align="center">显示go的版本</td></tr><tr><td>vet</td><td align="center">运行go tool vet</td></tr></tbody></table><h4 id="build和run命令"><a href="#build和run命令" class="headerlink" title="build和run命令"></a>build和run命令</h4><p>&emsp;&emsp;正如同其他的静态语言一般，Go语言也是需要先编译再运行的。编译过程产生可执行文件，如Windows中的exe文件，之后再运行该可执行文件。而go build命令就是用来编译的，并不是所有的go程序都会编译出可执行文件，其条件即为：go程序属于main包、main包中包含main函数。现在假如在test文件夹中只有一个TestDemo.go文件，我们通过命令行定位到该位置后，键入go build TestDemo.go后，结果将如下图所示：</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/4.png" alt></p><p>&emsp;&emsp;从上图我们可以发现，build命令会生成一个与go文件相同名的可执行文件，进而执行该文件可以得到输出结果。可是往往我们在实际开发中，并不希望生成的可执行文件与go文件是同名的，在另一些情况下多个go程序生成的名字是相同的时候，会覆盖旧版本的exe文件（在大工程中很容易出现）。因此我们希望在编译过程中将生成的结果修改名字，其命令为： go build -o 新名字 go文件。</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/5.png" alt></p><p>&emsp;&emsp;而go run的方法则是将编译和运行两个步骤合并为一个步骤，因此我们在使用go run命令时，在当前的文件夹中或其他的位置是找不到可执行文件的生成的，这很适用于程序开发中的调试阶段，具体便不做演示了。</p><h4 id="fmt以及doc命令"><a href="#fmt以及doc命令" class="headerlink" title="fmt以及doc命令"></a>fmt以及doc命令</h4><p>&emsp;&emsp;在上一节中我们演示到一个问题，就是大括号的位置问题。同时，Go语言有一个特性，便是对格式的要求十分的严格。不同的开发者对这个特性的看法不一，不过也是需要遵守这个格式的。各个开发者的格式是统一的，便利于组合开发以及代码的清晰。go fmt命令便是格式化代码，将代码根据规定的格式进行调整。其格式为：go fmt xxx.go，这个也不做演示了，而且一般情况下也不要手动去调用，一般的集成开发工具都会自动帮助我们去调整。</p><p>&emsp;&emsp;doc命令是查看文档的命令，例如我们在使用fmt包的时候忘记了某个函数如何去写，或希望查到某个函数的具体含义，可能就会用到这个命令，其格式为:go doc package，在终端上就会显示这个包的文档。由于控制台的大小有限，一般来说直接go doc一个包会显示不全。不过我们可以使用go doc package.function来查具体的功能。</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/6.png" alt></p><p>&emsp;&emsp;还有一个比较好的一点是，这个命令可以启动我们自己的文档服务器，比如说我们使用godoc -http=:10000(数字可以随意，不过需要大于1024)，之后打开一个浏览器，在网址栏中输入localhost:10000我们会发现出现了图形界面的帮助文档，可以离线地、更方便地查询信息。</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/7.png" alt></p><h4 id="get和install命令"><a href="#get和install命令" class="headerlink" title="get和install命令"></a>get和install命令</h4><p>&emsp;&emsp;get命令也是十分常用的命令，我们可以通过这个命令来直接从网上下载第三方的包，调用方式为go get source。如果本地已经存有该文件，便会更新指定的代码和依赖，如果使用go语言操作redis数据库，下载并使用beego的web框架时等，会通过这个命令进行下载。</p><p>&emsp;&emsp;install命令与build命令十分的相像，其结果都是生成一个可执行程序，不同点便是生成的可执行文件的路径、名字、以及依赖包。这时我们需要在环境变量中配置GOBIN变量，这个变量的值便是GOPATH下的bin目录，在这里我们简要地演示一下。</p><p><img src="/2020/02/07/4-%E5%B8%B8%E7%94%A8%E7%9A%84Go%E5%91%BD%E4%BB%A4/8.png" alt></p><p>&emsp;&emsp;那么install和build的区别具体可用如下的表格来表示:</p><table><thead><tr><th>区别</th><th align="left">install</th><th align="center">build</th></tr></thead><tbody><tr><td>生成可执行文件路径</td><td align="left">在工作目录的bin目录下，或GOBIN下</td><td align="center">当前目录下</td></tr><tr><td>可执行文件名</td><td align="left">和源码所在的目录同名</td><td align="center">与go文件同名，或-o设定</td></tr><tr><td>依赖包</td><td align="left">在工作目录的pkg文件夹中</td><td align="center">-</td></tr></tbody></table><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小结中，我们初步解决了在Demo演示过程中出现的主函数重定义问题，以及介绍了一些Go语言中相对常用的几个命令。在下一小节中，我们将集中讲解进制相关的一些问题，进而在后续的文章中引出数据类型的概念以及其可以表示的大小的限制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;3&gt; 基于Hello World的几点讨论</title>
      <link href="/2020/02/06/3-%E5%9F%BA%E4%BA%8EHelloWorld%E7%9A%84%E5%87%A0%E7%82%B9%E8%AE%A8%E8%AE%BA/"/>
      <url>/2020/02/06/3-%E5%9F%BA%E4%BA%8EHelloWorld%E7%9A%84%E5%87%A0%E7%82%B9%E8%AE%A8%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-3-gt-基于Hello-World的几点讨论"><a href="#Go语言从入门到放弃系列-lt-3-gt-基于Hello-World的几点讨论" class="headerlink" title="Go语言从入门到放弃系列&lt;3&gt; 基于Hello World的几点讨论"></a>Go语言从入门到放弃系列&lt;3&gt; 基于Hello World的几点讨论</h2><p>&emsp;&emsp;在第一个小节中，我们阐述了Go语言环境的安装与配置，同时也写了一小段的程序来验证开发环境是否正确配置。那么在这一节中，我们集中针对于这段代码自上而下进行几点简要的讲解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hello World的编写</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go语言代码注释"><a href="#Go语言代码注释" class="headerlink" title="Go语言代码注释"></a>Go语言代码注释</h3><p>&emsp;&emsp;Go语言的注释风格依旧遵循了C语言的注释风格，即采用两个斜杠（//）对单行注释，同时也支持/*…*/的方式对代码块进行注释。一般来说，行注释更为通用，块注释主要是针对包的详细说明或者屏蔽更大的代码块而使用的。 </p><p>&emsp;&emsp;注释的作用往往是为了标注某个变量、代码块、或者函数等的具体功能，以备后续维护时能够快速地理解代码的含义。因此在实际开发中，强烈建议每个包都具备一个注解，即package前的注解，这个注解会详细介绍此包、提供相应的包信息、注明作者引用等等。</p><p>&emsp;&emsp;处在注释中的语句是不执行的，同样地，在编译的过程中也不会参与编译的过程。因此，不必担心写太多的注释会令可执行文件增大。注释出现的位置也是十分地灵活，可以出现在某行中，也可以出现在某条语句的结尾，但不可以出现在某条语句的中间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//注释可以出现在某行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;<span class="comment">//也可以出现在某语句的结尾</span></span><br><span class="line">fmt.Println(<span class="string">"您好世界"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go语言的包"><a href="#Go语言的包" class="headerlink" title="Go语言的包"></a>Go语言的包</h3><p>&emsp;&emsp;同一些其他的语言一样，Go语言是以包package作为管理单位，如果针对于文件系统可以理解为以文件夹为管理单位。因此，每个Go文件都需要声明包，并且只能存在于一个包内。不仅如此，每个程序中都必须要有一个main包，如果没有main包是无法编译通过的。</p><p><img src="/2020/02/06/3-%E5%9F%BA%E4%BA%8EHelloWorld%E7%9A%84%E5%87%A0%E7%82%B9%E8%AE%A8%E8%AE%BA/2.png" alt></p><p>&emsp;&emsp;在日后的开发过程中，package的名字当然可以不是main，但是具备main函数的go文件必须是main包，因此在开发中，尤其指多人的开发中，每个程序员负责自己的部分，便会以包的名字建立一个文件夹，只是不在其中写main函数，这个问题我们在后面的一些章节会再次提及。由于我们目前的开发均在一个文件中，不需要跨越文件编程，因此在习惯上暂且先都写package main即可。</p><h3 id="包的引入"><a href="#包的引入" class="headerlink" title="包的引入"></a>包的引入</h3><p>&emsp;&emsp;在开发的过程中往往需要使用开发者所提供的函数，或者其他人的代码，这时就需要将这个包进行引入操作，所用的关键字为import。fmt包是我们接触到的第一个引用的包，这个包的作用是提供了许多的格式化输出的函数。当我们希望在屏幕上打印出某行汉字的时候，我们不需要了解其内部的过程，如何让屏幕的像素点亮起来，我们只需要知道调用该包的特定函数可以完成需求。当然，fmt包中不仅仅具备格式化输出的函数，随着学习的深入，我们将会接触到更多的包和相应的函数。</p><p>&emsp;&emsp;有时候在程序开发的过程中，我们可能不仅仅需要引用一个包，而是需要引入多个包。比如说，我希望生成一个随机数，并且采用当前时间为种子进行随机生成，最后将这个随机数打印在屏幕上（这个案例我们后续会讲到）。那么，我们可能需要多个包，生成随机数需要一个包，获取时间需要一个包，打印在屏幕上需要一个包，因此需要多个包的引入。引入的方式有两种，分别为：多个import关键字，一个import后加一个小括号，将包写于括号中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"math/rand"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="主函数及大括号"><a href="#主函数及大括号" class="headerlink" title="主函数及大括号"></a>主函数及大括号</h3><p>&emsp;&emsp;每一个项目中都需要有一个主函数，注意这不是指每一个Go文件都有一个主函数。主函数作为程序的入口，往往会最先被执行（这个说法不好，后面会对这句话进行更正，初期可以先这样理解）。声明函数的关键字func即function的前四个字母，main为函数名，后面的括号为函数参数，大括号所包裹的代码即为函数体（在函数的章节中会详细讲）。程序便从大括号后的第一行开始执行，直到函数的结束。</p><p>&emsp;&emsp;与一些传统的编程语言相不同的是，Go语言语句后不需要以分号为结尾。同时，大括号的位置也不如C语言等那样灵活。Go语言的规定是：左大括号的位置一定需要是某个块定义的结尾，而不能单独另取一行，否则在编译时是无法通过的。</p><p><img src="/2020/02/06/3-%E5%9F%BA%E4%BA%8EHelloWorld%E7%9A%84%E5%87%A0%E7%82%B9%E8%AE%A8%E8%AE%BA/5.png" alt></p><h3 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h3><p>&emsp;&emsp;在日后的计算机的学习中，我们将会接触到计算机程序的三大流程控制，分别为：顺序结构、分支结构、和循环结构。我们今天所接触到的便是其中的第一个：顺序结构。</p><p>&emsp;&emsp;顺序结构的核心思想是，程序从上至下逐条依次执行，每一条都会被执行，而且每条都会被执行一次。例如我们在程序中令其多次输出几个字符串，我们会发现结果的输出与程序中的输出顺序是相一致的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"您好世界 1"</span>)</span><br><span class="line">fmt.Println(<span class="string">"您好世界 2"</span>)</span><br><span class="line">fmt.Println(<span class="string">"您好世界 3"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段代码的输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">您好世界 <span class="number">1</span></span><br><span class="line">您好世界 <span class="number">2</span></span><br><span class="line">您好世界 <span class="number">3</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在我们后续讲到函数，并且提及defer关键字时，会对现有的理解的顺序结构产生冲击，这个问题我们在日后会详细地进行讲解。</p><p>&emsp;&emsp;在程序中，我们可以看到的是，函数的调用往往是需要包的存在的，也就是说Println函数是属于fmt包的，即便是自己定义的函数，也是属于当前的package的。如果不通过fmt包，就无法直接使用Println函数，也就无法通过这个函数向屏幕中输出了。还有一个需要注意的点是：当引入了某个包，但是这个包并没有在程序中被使用，也是不允许的。在编译过程中会报如下的错误： </p><p><img src="/2020/02/06/3-%E5%9F%BA%E4%BA%8EHelloWorld%E7%9A%84%E5%87%A0%E7%82%B9%E8%AE%A8%E8%AE%BA/7.png" alt></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们针对快速入门程序，Hello World的输出程序，进行了几点简要的讨论，分别讲解了注释的用法，包的概念的入门，主函数的作用，以及函数体中的顺序结构。同时，也对开发中的几点小细节做出了说明，如大括号位置，包的使用等等。</p><p>&emsp;&emsp;在下一小节中，我们将讲解一些cmd命令行中与Go相关的一些命令，并集中讲解几个常用的命令以及实际过程中的运用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;2&gt; 编码及几种ide的介绍</title>
      <link href="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-2-gt-编码及几种ide的介绍"><a href="#Go语言从入门到放弃系列-lt-2-gt-编码及几种ide的介绍" class="headerlink" title="Go语言从入门到放弃系列&lt;2&gt; 编码及几种ide的介绍"></a>Go语言从入门到放弃系列&lt;2&gt; 编码及几种ide的介绍</h2><p>&emsp;&emsp;在这个小节中，我们首先介绍几个实用的常用的Go语言的集成开发工具，并对几种工具做一个简要的比较，集成开发工具的选择会方便程序员对程序的编写，但对于语言本身来说是基本没有关系的。因此，不必过于纠结于集成开发工具的选择，做到能用、方便、正确即可以。同时，对于初学者来说，建议使用功能不是十分强大的开发工具，这样能相对强制性地记住更多的基本的语法与应用。</p><h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p>&emsp;&emsp;在这一小节中，我们首先介绍计算机中的编码格式，通过对编码格式的叙述引入对ide的介绍。编码是用预先规定的方法将文字、数字或其它对象编成数码，或将信息、数据转换成规定的电脉冲信号（引用自百度百科）。通俗一点解释便是，将每个字符（汉字、字母等）与计算机中的数字相关联。字符是有限的，而数字是无限的，因此，每一个字符必定能对应于一个数字，这个对应关系便是编码。 </p><p>&emsp;&emsp;目前来说，对于中国的用户而言，常见的编码格式有ASCII、ANSI、GBK、GB2312、UTF-8等等。不同的编码格式有不同的对应关系，因此在网络传输时，或者在打开文件时，如若对应的编码格式是不一致的，内容就会显示为乱码。</p><p>&emsp;&emsp;从计算机对多国语言的支持程度上来分，编码可以分为三个阶段。第一个阶段是计算机的初期，只在美国国内通用时，是只支持英文显示的，而其他国家的语言是无法显示的。在这个阶段的代表性编码规则为ASCII码。随着计算机的国际通用，各国均开始研发适应于本国的编码规则，也为第二阶段，不同的国家制定了不同的标准，出现了采用两个字节代表一个字符的汉字延伸编码方式，称为ANSI编码，如GB2312等。然而不同国家的ANSI编码依旧不兼容。所以便进入了第三个阶段，UNICODE编码，这种编码为每一个国家、每一种语言、每一个字符均设定了统一的且是唯一的数字编号，以满足跨语言，跨平台的特性，代表字符集为UTF-8编码。</p><p> &emsp;&emsp;对于Go语言来说，为了出现字符集的冲突与乱码的形成，官方规定：所有的字符编码均为<strong>UTF-8</strong>编码，如果采用了其他的编码样式，程序是无法编译通过的。采用上一个小节所举的例子，将编码改为ANSI后并输入对应的中文，运行时会出现如下的效果：</p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/1.png" alt></p><p>&emsp;&emsp;在将字符集恢复成UTF-8编码之后，就恢复了正常的显示。所以在各个集成开发工具中，默认的字符编码均为UTF-8编码，所以在使用工具时，可以不需要担心这个问题。</p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/2.png" alt></p><h3 id="几种集成开发工具的介绍"><a href="#几种集成开发工具的介绍" class="headerlink" title="几种集成开发工具的介绍"></a>几种集成开发工具的介绍</h3><h4 id="1-LiteIDE"><a href="#1-LiteIDE" class="headerlink" title="1. LiteIDE"></a>1. LiteIDE</h4><p>&emsp;&emsp;LiteIDE是一款开源的简单的IDE，同时也是Go语言的首个发布的正式版的IDE，通过QT开发，是专门为了Go语言而设计的。在LiteIDE中，可以直接配置构建命令，高级代码编辑，代码管理，自动完成格式化等多个功能。是一个十分轻量级且功能强大的小开发工具。</p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/3.png" alt></p><h4 id="2-VSCode"><a href="#2-VSCode" class="headerlink" title="2. VSCode"></a>2. VSCode</h4><p>&emsp;&emsp;VSCode是微软开发的一个开源IDE，单独这款IDE本身不支持Go语言开发，需要在IDE中进行Go语言的扩展，也是十分方便的。同样地，VSCode的诸多插件也为开发者提供了许多的功能。不仅如此，它也提供了多种语言的支持，使之成为广受欢迎的集成开发工具。</p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/4.png" alt></p><h4 id="3-GoClipse插件"><a href="#3-GoClipse插件" class="headerlink" title="3. GoClipse插件"></a>3. GoClipse插件</h4><p>&emsp;&emsp;看到这个名字可能会比较熟悉，会想起一款名为eclipse的开发工具，GoClipse正是eclipse的插件，通过使用这个插件，开发者可以通过流行的eclipse开发工具进行go语言的开发，其优点是高度的可扩展性，包括源代码编辑器，项目向导，以及GDB项目调试器等等。eclipse和GoClipse插件均为开源的，因此也是免费的。 </p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/5.png" alt></p><h4 id="4-VIM编辑器"><a href="#4-VIM编辑器" class="headerlink" title="4. VIM编辑器"></a>4. VIM编辑器</h4><p>&emsp;&emsp;这个想必也不需要多说，经常使用Linux和MacOS操作系统的对于这个简直不能更熟悉，通过VIM-Go插件使得该编辑器具备了编译器，增强的语法高亮、代码折叠等等功能。除此之外，也可以集成一些高级的源分析工具。可以讲，VIM编辑器的强大之处完全不仅仅在于对Go语言的支持上。</p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/6.png" alt></p><h4 id="5-Goland"><a href="#5-Goland" class="headerlink" title="5. Goland"></a>5. Goland</h4><p>&emsp;&emsp;Goland是由JetBrains公司开发的，旨在为Go语言开发者提供一个更为简便、快速的开发环境。这个商业的IDE整合了IntelliJ平台的Go相关的辅助编码功能和其他的工具。Goland是一个极为强大的开发工具，具备智能补全，检查和快速修复，格式化程序，以及调试器，版本控制器等功能。当然商业工具是需要付费的，对于个人使用可以采用破解<strong>（划掉，改为购买~）</strong>的方式。</p><p><img src="/2020/02/05/2-%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%A0%E7%A7%8Dide%E7%9A%84%E4%BB%8B%E7%BB%8D/7.png" alt></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;在这个小节中，我们首先介绍了编码的含义以及Go语言对编码的要求，同时也介绍了几款相对好用的集成开发工具可供选择，在下一个小节中，我们将集中对第一个Go语言程序，Hello World的输出程序，进行简要的讲解以及对初期开发过程中所需要注意的问题和要求进行说明。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言从入门到放弃系列&lt;1&gt; 环境安装及设置</title>
      <link href="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/"/>
      <url>/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言从入门到放弃系列-lt-1-gt-环境安装及设置"><a href="#Go语言从入门到放弃系列-lt-1-gt-环境安装及设置" class="headerlink" title="Go语言从入门到放弃系列&lt;1&gt; 环境安装及设置"></a>Go语言从入门到放弃系列&lt;1&gt; 环境安装及设置</h2><p>&emsp;&emsp;首先第一节，今天便说一说Go语言开发环境的搭建。所谓工欲善其事，必先利其器，没有开发环境对于Go语言的开发简直如同空谈。因此在本章节中，我们会集中阐述开发环境的安装，环境变量的配置，以及对环境变量配置的结果进行验证。</p><h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><p>&emsp;&emsp;最先说明，在写这篇文章的时候，我采用的是windows环境，因此我的各项操作均是基于windows操作系统的，如果读者希望采用其他的系统进行开发，可以在网络上找到配置的方式。此处只介绍windows相关配置，其他系统暂不再赘述。</p><p>&emsp;&emsp;首先，作为最初的，便是在网络中下载Go的安装包，本文给出安装包的下载地址：<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a> </p><p>&emsp;&emsp;需要说明的是，这个网站可能需要翻墙才能进入，因此如果打不开可以尝试这个地址：<a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a> 因为本人是在国内开始写的这个连载，因此采用的是第二个网址。进入下载页面后如下图（图片将来可能会根据网站版本不同而改变）：</p><p><img src="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/1.png" alt></p><p>&emsp;&emsp;从图中可以看出，Go官方提供了基于不同系统的不同的安装包，只需要下载相应系统的安装包，再根据不同系统的命令进行安装即可，我们以下依旧采用windows为例。安装过程便不作具体描述了，一般来说不需要修改其中的设置，只需要下一步直到完成。值得说明的是，当选择Go语言开发环境的安装位置时如果不作修改便是C:\Go这个文件夹，修改的话需要记住修改后的位置，在后续配置中是需要的。同时，在安装过程中，尽量不要出现中文路径，以防止后续出现问题。</p><p>&emsp;&emsp;在安装过后，我们打开cmd命令控台，键入go version命令（中间有空格）</p><p><img src="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/2.png" alt></p><p>&emsp;&emsp;从上图我们可以看到的是，我的机器的Go开发环境版本为1.11.2，如果安装不同的版本，这个版本号会不同。在安装过后，我们进入环境变量中会发现，系统自动为我们设置了GOROOT环境变量，并且该值为 <strong>刚刚安装的目录</strong> ，如果发现该值与安装目录不同，需要进行修改。本人在安装的时候没有对安装目录进行修改，所以均为默认值。</p><p>&emsp;&emsp;除此之外，还需要检查Path变量是否进行了更新，对Path的配置便是在后面加入 <strong>安装目录下的bin\目录</strong> 的全路径，建议用分号将其与前后的其他设置分开。</p><p><img src="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/3.png" alt></p><p> &emsp;&emsp;到目前为止，可以说环境变量已经配置完了，可以进行初级的开发，不过为了后续的开发方便，我们继续配置GOPATH环境变量，在Go语言的包引入过程中，是采用%GoPath%\src为起始的目录引入的，因此建议单独生成一个文件夹，并将所有的源代码均写在这个文件夹的src目录中，而GOPATH的配置便是这个文件夹，本人在E盘下新建了GoProject，并且所有的源代码均写于E:\GoProject\src\xxx\yyy.go下，因此我的GOPATH为： <strong>E:\GoProject</strong></p><p>&emsp;&emsp;此时我们在cmd控制台中键入： go env，将显示出当前GO的所有环境配置，如下图所示。</p><p><img src="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/4.png" alt></p><h3 id="环境测试"><a href="#环境测试" class="headerlink" title="环境测试"></a>环境测试</h3><p>&emsp;&emsp;安装环境已经结束，接下来我们需要对环境的配置进行检测，便写一段简单的代码进行验证。代码也是众所周知的Hello World的输出。首先，我们在任意一个文件夹下建立一个.txt文件并将扩展名改为.go，本人便于桌面上建立一个test.go文件。请注意，在修改文件时一并修改的文件格式，也就是将隐藏已知文件名的选项去掉，否则会成为一个test.go.txt的文件。（windows各版本设置方式不同，windows7为例）</p><p><img src="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/5.png" alt></p><p>&emsp;&emsp;采用记事本的方式打开，并在其中输入如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hello World的编写</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后，打开cmd控制台，进入到桌面上，键入go run test.go后会立刻出现程序的执行结果，也就是在控制台输出了Hello World字样，如果成功输出则代表Go环境在本机配置正确，可以进行代码的编写了。</p><p><img src="/2020/02/04/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E7%BD%AE/6.png" alt></p><p>&emsp;&emsp;环境配置工作是相对简单的，本人也暂时没有发现在这个过程中出现什么问题，因此也不知如何去写问题的解答。不过一定要注意将环境配好，这可能会影响后续一些小节的内容的讲解。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;这个小节集中阐述了Go语言开发环境的安装，环境变量的配置，以及入门程序Hello World的编写。其版本号以及其他图片实例均与个人的配置相关，或在版本升级后将有其他的样式。在下一章，我们将集中介绍几款GO开发的集成开发环境，并选择其中一个进行安装。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
